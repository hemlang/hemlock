// Test cases where precision may be lost
// i64/u64 + f32 should promote to f64 to preserve precision

// Large integers that can't be represented exactly in f32
let big64: i64 = 9007199254740993;  // 2^53 + 1, beyond f64 exact range

// f32 has only 24 bits of mantissa (about 7 decimal digits precision)
let f32_val: f32 = 16777217;  // 2^24 + 1, beyond f32 exact range
print("f32(16777217): " + f32_val);  // May show rounding

// f64 has 53 bits of mantissa (about 15-16 decimal digits precision)
let f64_val: f64 = 16777217;
print("f64(16777217): " + f64_val);  // Should be exact

// Type promotion preserves precision where possible
let i64_val: i64 = 1000000000000;  // 10^12
let f32_small: f32 = 1.5;

// i64 + f32 should promote to f64 (not f32) to preserve precision
let result = i64_val + f32_small;
print("i64(10^12) + f32(1.5) = " + result);
print("Result type: " + typeof(result));

// Verify with different operations
let u64_val: u64 = 1000000000000;
let mixed = u64_val * f32_small;
print("u64(10^12) * f32(1.5) = " + mixed);
print("Result type: " + typeof(mixed));

// Integer division vs float division
let a = 7;
let b = 3;
print("7 / 3 (float): " + (a / b));        // Float division
print("div(7, 3): " + div(a, b));           // Integer division

// Modulo with negative numbers
print("-7 % 3 = " + (-7 % 3));
print("7 % -3 = " + (7 % -3));
print("-7 % -3 = " + (-7 % -3));

print("All precision tests completed");
