// Test typed variable unboxing optimization
// Variables with explicit type annotations that don't escape should be unboxed

// Test 1: i32 typed variable
fn test_i32(): i32 {
    let x: i32 = 10;
    let y: i32 = 20;
    let z: i32 = x + y;
    return z;
}
print(test_i32());

// Test 2: i64 typed variable
fn test_i64(): i64 {
    let big: i64 = 10000000000;
    let result: i64 = big + 1;
    return result;
}
print(test_i64());

// Test 3: Accumulator pattern (loop with typed accumulator)
fn sum_to_n(n: i32): i32 {
    let total: i32 = 0;
    for (let i = 0; i < n; i = i + 1) {
        total = total + i;
    }
    return total;
}
print(sum_to_n(100));

// Test 4: Nested typed variables
fn nested_types(): i32 {
    let a: i32 = 1;
    let b: i32 = 2;
    let c: i32 = 3;
    let result: i32 = a + b * c;
    return result;
}
print(nested_types());

// Test 5: Typed variables with conditionals
fn conditional_types(x: i32): i32 {
    let result: i32 = 0;
    if (x > 0) {
        result = x * 2;
    } else {
        result = x * -1;
    }
    return result;
}
print(conditional_types(5));
print(conditional_types(-3));

// Test 6: Typed variables in while loop
fn while_loop_test(): i32 {
    let counter: i32 = 0;
    let sum: i32 = 0;
    while (counter < 5) {
        sum = sum + counter;
        counter = counter + 1;
    }
    return sum;
}
print(while_loop_test());

// Test 7: Mixed typed and untyped
fn mixed_types(): i32 {
    let typed: i32 = 100;
    let untyped = 50;
    return typed + untyped;
}
print(mixed_types());
