// Test: detach() cleanup verification
// Tests that detached tasks properly clean up their memory when they complete

// Create channel for thread-safe communication
let ch = channel(100);

async fn increment_task(id: i32, ch) {
    // Simulate some work
    let i = 0;
    let sum = 0;
    while (i < 100) {
        sum = sum + i;
        i = i + 1;
    }

    // Signal completion via channel (thread-safe)
    ch.send(1);

    return null;
}

// Detach many tasks to exercise cleanup mechanism
let num_tasks = 50;
let i = 0;
while (i < num_tasks) {
    detach(increment_task, i, ch);
    i = i + 1;
}

print("Detached tasks:");
print(num_tasks);

// Wait for all tasks to complete by receiving from channel
// Use timeout to prevent test hang if a task fails to complete
let completed = 0;
let j = 0;
let timeout_ms = 5000;  // 5 second timeout per task
while (j < num_tasks) {
    let val = ch.recv_timeout(timeout_ms);
    if (val == null) {
        print("Timeout waiting for task");
        break;
    }
    completed = completed + val;
    j = j + 1;
}

print("Tasks completed:");
print(completed);
print("Test completed without crashes");
