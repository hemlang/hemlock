// Conway's Game of Life - Cellular Automaton
// Demonstrates: 2D grid simulation, array manipulation, nested loops

import { GREEN, RESET, BOLD } from "@stdlib/terminal";

// Grid dimensions (small for performance)
let WIDTH = 25;
let HEIGHT = 8;

// Create an empty grid
fn create_grid(): array {
    let grid = [];
    for (let y = 0; y < HEIGHT; y = y + 1) {
        let row = [];
        for (let x = 0; x < WIDTH; x = x + 1) {
            row.push(0);
        }
        grid.push(row);
    }
    return grid;
}

// Count live neighbors for a cell (wrapping at edges)
fn count_neighbors(grid, x: i32, y: i32): i32 {
    let count = 0;
    for (let dy = -1; dy <= 1; dy = dy + 1) {
        for (let dx = -1; dx <= 1; dx = dx + 1) {
            if (dx == 0 && dy == 0) {
                // skip self
            } else {
                let nx = (x + dx + WIDTH) % WIDTH;
                let ny = (y + dy + HEIGHT) % HEIGHT;
                if (grid[ny][nx] == 1) {
                    count = count + 1;
                }
            }
        }
    }
    return count;
}

// Compute next generation
fn next_generation(grid): array {
    let new_grid = create_grid();
    for (let y = 0; y < HEIGHT; y = y + 1) {
        for (let x = 0; x < WIDTH; x = x + 1) {
            let neighbors = count_neighbors(grid, x, y);
            let cell = grid[y][x];
            // Conway's rules
            if (cell == 1) {
                if (neighbors == 2 || neighbors == 3) {
                    new_grid[y][x] = 1;
                }
            } else {
                if (neighbors == 3) {
                    new_grid[y][x] = 1;
                }
            }
        }
    }
    return new_grid;
}

// Print the grid
fn print_grid(grid, generation: i32) {
    print(BOLD + "Generation " + generation + RESET);
    let border = "+-------------------------+";
    print(border);
    for (let y = 0; y < HEIGHT; y = y + 1) {
        let line = "|";
        for (let x = 0; x < WIDTH; x = x + 1) {
            if (grid[y][x] == 1) {
                line = line + GREEN + "#" + RESET;
            } else {
                line = line + " ";
            }
        }
        line = line + "|";
        print(line);
    }
    print(border);
}

// Count total live cells
fn count_population(grid): i32 {
    let count = 0;
    for (let y = 0; y < HEIGHT; y = y + 1) {
        for (let x = 0; x < WIDTH; x = x + 1) {
            if (grid[y][x] == 1) {
                count = count + 1;
            }
        }
    }
    return count;
}

// Add a glider pattern at position
fn add_glider(grid, sx: i32, sy: i32) {
    grid[(sy + 0) % HEIGHT][(sx + 1) % WIDTH] = 1;
    grid[(sy + 1) % HEIGHT][(sx + 2) % WIDTH] = 1;
    grid[(sy + 2) % HEIGHT][(sx + 0) % WIDTH] = 1;
    grid[(sy + 2) % HEIGHT][(sx + 1) % WIDTH] = 1;
    grid[(sy + 2) % HEIGHT][(sx + 2) % WIDTH] = 1;
}

// Add a blinker pattern at position (oscillates)
fn add_blinker(grid, sx: i32, sy: i32) {
    grid[sy % HEIGHT][(sx + 0) % WIDTH] = 1;
    grid[sy % HEIGHT][(sx + 1) % WIDTH] = 1;
    grid[sy % HEIGHT][(sx + 2) % WIDTH] = 1;
}

// Main simulation
fn main() {
    print("");
    print(BOLD + "======================================" + RESET);
    print(BOLD + "    CONWAY'S GAME OF LIFE" + RESET);
    print(BOLD + "======================================" + RESET);
    print("");
    print("Rules: 2-3 neighbors survive, 3 neighbors birth");
    print("");

    let grid = create_grid();
    add_glider(grid, 2, 1);
    add_blinker(grid, 15, 3);

    print("Patterns: glider + blinker");
    print("");

    // Show 4 generations
    print_grid(grid, 0);
    print("Population: " + count_population(grid));
    print("");

    grid = next_generation(grid);
    print_grid(grid, 1);
    print("Population: " + count_population(grid));
    print("");

    grid = next_generation(grid);
    print_grid(grid, 2);
    print("Population: " + count_population(grid));
    print("");

    grid = next_generation(grid);
    print_grid(grid, 3);
    print("Population: " + count_population(grid));
    print("");

    print(GREEN + "Simulation complete!" + RESET);
}

main();
