// Dining Philosophers Problem - A classic concurrency demonstration
// Demonstrates: simulation of concurrent resource contention, objects, arrays, switch

import { rand } from "@stdlib/math";
import { RED, GREEN, YELLOW, CYAN, MAGENTA, RESET, BOLD } from "@stdlib/terminal";

// Philosopher states
let STATE_THINKING = 0;
let STATE_HUNGRY = 1;
let STATE_EATING = 2;

// State colors
fn state_color(state: i32): string {
    if (state == STATE_THINKING) { return CYAN; }
    if (state == STATE_HUNGRY) { return YELLOW; }
    if (state == STATE_EATING) { return GREEN; }
    return RESET;
}

// State names (short)
fn state_short(state: i32): string {
    if (state == STATE_THINKING) { return "think"; }
    if (state == STATE_HUNGRY) { return "hungr"; }
    if (state == STATE_EATING) { return "eat  "; }
    return "?????";
}

// Get random integer in [0, max)
fn randint(max: i32): i32 {
    let f = rand() * max;
    let result: i32 = f;
    return result;
}

// Main simulation
fn main() {
    print("");
    print(MAGENTA + BOLD + "============================================" + RESET);
    print(MAGENTA + BOLD + "    THE DINING PHILOSOPHERS PROBLEM" + RESET);
    print(MAGENTA + BOLD + "    A Classic Concurrency Demonstration" + RESET);
    print(MAGENTA + BOLD + "============================================" + RESET);
    print("");

    // The philosophers
    let names = ["Plato", "Aristotle", "Socrates", "Descartes", "Kant"];

    // Their states: 0=thinking, 1=hungry, 2=eating
    let states = [STATE_THINKING, STATE_THINKING, STATE_THINKING, STATE_THINKING, STATE_THINKING];

    // Fork availability: true = available, false = in use
    // Each fork is between philosopher[i] and philosopher[(i+1)%5]
    let forks = [true, true, true, true, true];

    // Track eating counts
    let eat_counts = [0, 0, 0, 0, 0];

    // Show initial state
    print(CYAN + "Five philosophers sit around a circular table." + RESET);
    print(CYAN + "Between each pair is a single fork (5 total)." + RESET);
    print(CYAN + "To eat, a philosopher needs BOTH adjacent forks." + RESET);
    print("");

    // Print table layout
    print("        " + names[0]);
    print("      /       \\");
    print("   [F0]       [F4]");
    print("    |           |");
    print(names[1] + "         " + names[4]);
    print("    |           |");
    print("   [F1]       [F3]");
    print("      \\       /");
    print("    " + names[2] + "   " + names[3]);
    print("        [F2]");
    print("");

    // Simulate several rounds
    let rounds = 10;
    print(BOLD + "=== Beginning Simulation (" + rounds + " rounds) ===" + RESET);
    print("");

    for (let round = 1; round <= rounds; round = round + 1) {
        print(BOLD + "--- Round " + round + " ---" + RESET);

        // Each philosopher takes an action
        for (let p = 0; p < 5; p = p + 1) {
            let left_fork = p;
            let right_fork = (p + 1) % 5;

            if (states[p] == STATE_THINKING) {
                // Might get hungry
                if (randint(3) == 0) {
                    states[p] = STATE_HUNGRY;
                    print(YELLOW + names[p] + " is now hungry" + RESET);
                }
            } else if (states[p] == STATE_HUNGRY) {
                // Try to pick up both forks
                if (forks[left_fork] && forks[right_fork]) {
                    // Got both forks!
                    forks[left_fork] = false;
                    forks[right_fork] = false;
                    states[p] = STATE_EATING;
                    eat_counts[p] = eat_counts[p] + 1;
                    print(GREEN + names[p] + " picks up forks [" + left_fork + "] and [" + right_fork + "] and eats!" + RESET);
                } else {
                    // Can't get both forks - potential deadlock scenario
                    let waiting_for = "";
                    if (!forks[left_fork]) { waiting_for = "[" + left_fork + "]"; }
                    if (!forks[right_fork]) {
                        if (waiting_for != "") { waiting_for = waiting_for + " and "; }
                        waiting_for = waiting_for + "[" + right_fork + "]";
                    }
                    print(YELLOW + names[p] + " waits for fork " + waiting_for + RESET);
                }
            } else if (states[p] == STATE_EATING) {
                // Might finish eating
                if (randint(2) == 0) {
                    forks[left_fork] = true;
                    forks[right_fork] = true;
                    states[p] = STATE_THINKING;
                    print(CYAN + names[p] + " puts down forks, thinks" + RESET);
                }
            }
        }

        // Build status line
        let status = "Status: ";
        for (let p = 0; p < 5; p = p + 1) {
            let color = state_color(states[p]);
            let sname = state_short(states[p]);
            status = status + color + names[p].substr(0, 3) + ":" + sname + RESET + " ";
        }
        print(status);

        // Build fork status line
        let fork_status = "Forks:  ";
        for (let f = 0; f < 5; f = f + 1) {
            if (forks[f]) {
                fork_status = fork_status + GREEN + "[" + f + ":ok] " + RESET;
            } else {
                fork_status = fork_status + RED + "[" + f + ":--] " + RESET;
            }
        }
        print(fork_status);
        print("");
    }

    // Final summary
    print(MAGENTA + BOLD + "============================================" + RESET);
    print(MAGENTA + BOLD + "            SIMULATION COMPLETE" + RESET);
    print(MAGENTA + BOLD + "============================================" + RESET);
    print("");

    print(BOLD + "Eating counts:" + RESET);
    for (let p = 0; p < 5; p = p + 1) {
        print("  " + names[p] + ": " + eat_counts[p] + " meals");
    }
    print("");

    // Check for starvation
    let starved = false;
    for (let p = 0; p < 5; p = p + 1) {
        if (eat_counts[p] == 0) {
            print(RED + "Warning: " + names[p] + " never got to eat! (Starvation)" + RESET);
            starved = true;
        }
    }

    if (!starved) {
        print(GREEN + "All philosophers got at least one meal!" + RESET);
    }

    print("");
    print(CYAN + "Note: In a real concurrent system, philosophers would" + RESET);
    print(CYAN + "run in parallel and could deadlock if all grab their" + RESET);
    print(CYAN + "left fork simultaneously (circular wait condition)." + RESET);
}

main();
