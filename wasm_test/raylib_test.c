/*
 * Generated by Hemlock Compiler
 */

#include "hemlock_runtime.h"
#include <setjmp.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <poll.h>

// Signal constants
#define SIGINT_VAL 2
#define SIGTERM_VAL 15
#define SIGHUP_VAL 1
#define SIGQUIT_VAL 3
#define SIGABRT_VAL 6
#define SIGUSR1_VAL 10
#define SIGUSR2_VAL 12
#define SIGALRM_VAL 14
#define SIGCHLD_VAL 17
#define SIGPIPE_VAL 13
#define SIGCONT_VAL 18
#define SIGSTOP_VAL 19
#define SIGTSTP_VAL 20

// FFI globals
static HmlValue _ffi_lib = {0};
static void *_ffi_ptr_InitWindow = NULL;
static void *_ffi_ptr_CloseWindow = NULL;
static void *_ffi_ptr_WindowShouldClose = NULL;
static void *_ffi_ptr_IsWindowReady = NULL;
static void *_ffi_ptr_IsWindowFullscreen = NULL;
static void *_ffi_ptr_IsWindowHidden = NULL;
static void *_ffi_ptr_IsWindowMinimized = NULL;
static void *_ffi_ptr_IsWindowMaximized = NULL;
static void *_ffi_ptr_IsWindowFocused = NULL;
static void *_ffi_ptr_IsWindowResized = NULL;
static void *_ffi_ptr_IsWindowState = NULL;
static void *_ffi_ptr_SetWindowState = NULL;
static void *_ffi_ptr_ClearWindowState = NULL;
static void *_ffi_ptr_SetWindowTitle = NULL;
static void *_ffi_ptr_SetWindowPosition = NULL;
static void *_ffi_ptr_SetWindowSize = NULL;
static void *_ffi_ptr_SetWindowMinSize = NULL;
static void *_ffi_ptr_SetWindowMaxSize = NULL;
static void *_ffi_ptr_GetScreenWidth = NULL;
static void *_ffi_ptr_GetScreenHeight = NULL;
static void *_ffi_ptr_GetRenderWidth = NULL;
static void *_ffi_ptr_GetRenderHeight = NULL;
static void *_ffi_ptr_GetMonitorCount = NULL;
static void *_ffi_ptr_GetCurrentMonitor = NULL;
static void *_ffi_ptr_GetMonitorWidth = NULL;
static void *_ffi_ptr_GetMonitorHeight = NULL;
static void *_ffi_ptr_GetMonitorRefreshRate = NULL;
static void *_ffi_ptr_GetMonitorPhysicalWidth = NULL;
static void *_ffi_ptr_GetMonitorPhysicalHeight = NULL;
static void *_ffi_ptr_GetMonitorName = NULL;
static void *_ffi_ptr_ToggleFullscreen = NULL;
static void *_ffi_ptr_ToggleBorderlessWindowed = NULL;
static void *_ffi_ptr_MaximizeWindow = NULL;
static void *_ffi_ptr_MinimizeWindow = NULL;
static void *_ffi_ptr_RestoreWindow = NULL;
static void *_ffi_ptr_SetWindowOpacity = NULL;
static void *_ffi_ptr_SetWindowFocused = NULL;
static void *_ffi_ptr_SetWindowIcon = NULL;
static void *_ffi_ptr_SetTargetFPS = NULL;
static void *_ffi_ptr_GetFPS = NULL;
static void *_ffi_ptr_GetFrameTime = NULL;
static void *_ffi_ptr_GetTime = NULL;
static void *_ffi_ptr_ClearBackground = NULL;
static void *_ffi_ptr_BeginDrawing = NULL;
static void *_ffi_ptr_EndDrawing = NULL;
static void *_ffi_ptr_BeginBlendMode = NULL;
static void *_ffi_ptr_EndBlendMode = NULL;
static void *_ffi_ptr_BeginScissorMode = NULL;
static void *_ffi_ptr_EndScissorMode = NULL;
static void *_ffi_ptr_rlBegin = NULL;
static void *_ffi_ptr_rlEnd = NULL;
static void *_ffi_ptr_rlVertex2f = NULL;
static void *_ffi_ptr_rlVertex2i = NULL;
static void *_ffi_ptr_rlColor4ub = NULL;
static void *_ffi_ptr_IsKeyPressed = NULL;
static void *_ffi_ptr_IsKeyPressedRepeat = NULL;
static void *_ffi_ptr_IsKeyDown = NULL;
static void *_ffi_ptr_IsKeyReleased = NULL;
static void *_ffi_ptr_IsKeyUp = NULL;
static void *_ffi_ptr_GetKeyPressed = NULL;
static void *_ffi_ptr_GetCharPressed = NULL;
static void *_ffi_ptr_GetKeyName = NULL;
static void *_ffi_ptr_SetExitKey = NULL;
static void *_ffi_ptr_IsMouseButtonPressed = NULL;
static void *_ffi_ptr_IsMouseButtonDown = NULL;
static void *_ffi_ptr_IsMouseButtonReleased = NULL;
static void *_ffi_ptr_IsMouseButtonUp = NULL;
static void *_ffi_ptr_GetMouseX = NULL;
static void *_ffi_ptr_GetMouseY = NULL;
static void *_ffi_ptr_GetMousePosition = NULL;
static void *_ffi_ptr_GetMouseDelta = NULL;
static void *_ffi_ptr_GetMouseWheelMove = NULL;
static void *_ffi_ptr_GetMouseWheelMoveV = NULL;
static void *_ffi_ptr_SetMousePosition = NULL;
static void *_ffi_ptr_SetMouseOffset = NULL;
static void *_ffi_ptr_SetMouseScale = NULL;
static void *_ffi_ptr_SetMouseCursor = NULL;
static void *_ffi_ptr_ShowCursor = NULL;
static void *_ffi_ptr_HideCursor = NULL;
static void *_ffi_ptr_IsCursorHidden = NULL;
static void *_ffi_ptr_EnableCursor = NULL;
static void *_ffi_ptr_DisableCursor = NULL;
static void *_ffi_ptr_IsCursorOnScreen = NULL;
static void *_ffi_ptr_IsGamepadAvailable = NULL;
static void *_ffi_ptr_GetGamepadName = NULL;
static void *_ffi_ptr_IsGamepadButtonPressed = NULL;
static void *_ffi_ptr_IsGamepadButtonDown = NULL;
static void *_ffi_ptr_IsGamepadButtonReleased = NULL;
static void *_ffi_ptr_IsGamepadButtonUp = NULL;
static void *_ffi_ptr_GetGamepadButtonPressed = NULL;
static void *_ffi_ptr_GetGamepadAxisCount = NULL;
static void *_ffi_ptr_GetGamepadAxisMovement = NULL;
static void *_ffi_ptr_SetGamepadMappings = NULL;
static void *_ffi_ptr_SetGamepadVibration = NULL;
static void *_ffi_ptr_GetTouchX = NULL;
static void *_ffi_ptr_GetTouchY = NULL;
static void *_ffi_ptr_GetTouchPosition = NULL;
static void *_ffi_ptr_GetTouchPointId = NULL;
static void *_ffi_ptr_GetTouchPointCount = NULL;
static void *_ffi_ptr_SetGesturesEnabled = NULL;
static void *_ffi_ptr_IsGestureDetected = NULL;
static void *_ffi_ptr_GetGestureDetected = NULL;
static void *_ffi_ptr_GetGestureHoldDuration = NULL;
static void *_ffi_ptr_GetGestureDragAngle = NULL;
static void *_ffi_ptr_GetGesturePinchAngle = NULL;
static void *_ffi_ptr_TraceLog = NULL;
static void *_ffi_ptr_SetTraceLogLevel = NULL;
static void *_ffi_ptr_DrawPixel = NULL;
static void *_ffi_ptr_DrawPixelV = NULL;
static void *_ffi_ptr_DrawLine = NULL;
static void *_ffi_ptr_DrawLineV = NULL;
static void *_ffi_ptr_DrawLineEx = NULL;
static void *_ffi_ptr_DrawLineStrip = NULL;
static void *_ffi_ptr_DrawLineBezier = NULL;
static void *_ffi_ptr_DrawCircle = NULL;
static void *_ffi_ptr_DrawCircleV = NULL;
static void *_ffi_ptr_DrawCircleGradient = NULL;
static void *_ffi_ptr_DrawCircleLines = NULL;
static void *_ffi_ptr_DrawCircleLinesV = NULL;
static void *_ffi_ptr_DrawCircleSector = NULL;
static void *_ffi_ptr_DrawCircleSectorLines = NULL;
static void *_ffi_ptr_DrawRing = NULL;
static void *_ffi_ptr_DrawRingLines = NULL;
static void *_ffi_ptr_DrawEllipse = NULL;
static void *_ffi_ptr_DrawEllipseLines = NULL;
static void *_ffi_ptr_DrawRectangle = NULL;
static void *_ffi_ptr_DrawRectangleV = NULL;
static void *_ffi_ptr_DrawRectangleRec = NULL;
static void *_ffi_ptr_DrawRectanglePro = NULL;
static void *_ffi_ptr_DrawRectangleGradientV = NULL;
static void *_ffi_ptr_DrawRectangleGradientH = NULL;
static void *_ffi_ptr_DrawRectangleGradientEx = NULL;
static void *_ffi_ptr_DrawRectangleLines = NULL;
static void *_ffi_ptr_DrawRectangleLinesEx = NULL;
static void *_ffi_ptr_DrawRectangleRounded = NULL;
static void *_ffi_ptr_DrawRectangleRoundedLines = NULL;
static void *_ffi_ptr_DrawRectangleRoundedLinesEx = NULL;
static void *_ffi_ptr_DrawTriangle = NULL;
static void *_ffi_ptr_DrawTriangleLines = NULL;
static void *_ffi_ptr_DrawTriangleFan = NULL;
static void *_ffi_ptr_DrawTriangleStrip = NULL;
static void *_ffi_ptr_DrawPoly = NULL;
static void *_ffi_ptr_DrawPolyLines = NULL;
static void *_ffi_ptr_DrawPolyLinesEx = NULL;
static void *_ffi_ptr_DrawText = NULL;
static void *_ffi_ptr_MeasureText = NULL;
static void *_ffi_ptr_WaitTime = NULL;
static void *_ffi_ptr_GetRandomValue = NULL;
static void *_ffi_ptr_SetRandomSeed = NULL;
static void *_ffi_ptr_TakeScreenshot = NULL;
static void *_ffi_ptr_SetConfigFlags = NULL;
static void *_ffi_ptr_OpenURL = NULL;
static void *_ffi_ptr_SetClipboardText = NULL;
static void *_ffi_ptr_GetClipboardText = NULL;
static void *_ffi_ptr_CheckCollisionRecs = NULL;
static void *_ffi_ptr_CheckCollisionCircles = NULL;
static void *_ffi_ptr_CheckCollisionCircleRec = NULL;
static void *_ffi_ptr_CheckCollisionPointRec = NULL;
static void *_ffi_ptr_CheckCollisionPointCircle = NULL;
static void *_ffi_ptr_CheckCollisionPointTriangle = NULL;
static void *_ffi_ptr_CheckCollisionPointLine = NULL;
static void *_ffi_ptr_CheckCollisionLines = NULL;
static void *_ffi_ptr_GetCollisionRec = NULL;
static void *_ffi_ptr_DrawFPS = NULL;
static void *_ffi_ptr_InitAudioDevice = NULL;
static void *_ffi_ptr_CloseAudioDevice = NULL;
static void *_ffi_ptr_IsAudioDeviceReady = NULL;
static void *_ffi_ptr_SetMasterVolume = NULL;
static void *_ffi_ptr_GetMasterVolume = NULL;
static void *_ffi_ptr_LoadTexture = NULL;
static void *_ffi_ptr_LoadTextureFromImage = NULL;
static void *_ffi_ptr_UnloadTexture = NULL;
static void *_ffi_ptr_IsTextureValid = NULL;
static void *_ffi_ptr_UpdateTexture = NULL;
static void *_ffi_ptr_DrawTexture = NULL;
static void *_ffi_ptr_DrawTextureV = NULL;
static void *_ffi_ptr_DrawTextureEx = NULL;
static void *_ffi_ptr_DrawTextureRec = NULL;
static void *_ffi_ptr_DrawTexturePro = NULL;
static void *_ffi_ptr_SetTextureFilter = NULL;
static void *_ffi_ptr_SetTextureWrap = NULL;
static void *_ffi_ptr_LoadRenderTexture = NULL;
static void *_ffi_ptr_UnloadRenderTexture = NULL;
static void *_ffi_ptr_IsRenderTextureValid = NULL;
static void *_ffi_ptr_BeginTextureMode = NULL;
static void *_ffi_ptr_EndTextureMode = NULL;
static void *_ffi_ptr_LoadSound = NULL;
static void *_ffi_ptr_UnloadSound = NULL;
static void *_ffi_ptr_IsSoundValid = NULL;
static void *_ffi_ptr_PlaySound = NULL;
static void *_ffi_ptr_StopSound = NULL;
static void *_ffi_ptr_PauseSound = NULL;
static void *_ffi_ptr_ResumeSound = NULL;
static void *_ffi_ptr_IsSoundPlaying = NULL;
static void *_ffi_ptr_SetSoundVolume = NULL;
static void *_ffi_ptr_SetSoundPitch = NULL;
static void *_ffi_ptr_SetSoundPan = NULL;
static void *_ffi_ptr_LoadMusicStream = NULL;
static void *_ffi_ptr_UnloadMusicStream = NULL;
static void *_ffi_ptr_IsMusicValid = NULL;
static void *_ffi_ptr_PlayMusicStream = NULL;
static void *_ffi_ptr_StopMusicStream = NULL;
static void *_ffi_ptr_PauseMusicStream = NULL;
static void *_ffi_ptr_ResumeMusicStream = NULL;
static void *_ffi_ptr_UpdateMusicStream = NULL;
static void *_ffi_ptr_IsMusicStreamPlaying = NULL;
static void *_ffi_ptr_SetMusicVolume = NULL;
static void *_ffi_ptr_SetMusicPitch = NULL;
static void *_ffi_ptr_SetMusicPan = NULL;
static void *_ffi_ptr_GetMusicTimeLength = NULL;
static void *_ffi_ptr_GetMusicTimePlayed = NULL;
static void *_ffi_ptr_SeekMusicStream = NULL;
static void *_ffi_ptr_SetMusicLooping = NULL;
static void *_ffi_ptr_LoadFont = NULL;
static void *_ffi_ptr_LoadFontEx = NULL;
static void *_ffi_ptr_UnloadFont = NULL;
static void *_ffi_ptr_IsFontValid = NULL;
static void *_ffi_ptr_GetFontDefault = NULL;
static void *_ffi_ptr_DrawTextEx = NULL;
static void *_ffi_ptr_DrawTextPro = NULL;
static void *_ffi_ptr_MeasureTextEx = NULL;
static void *_ffi_ptr_LoadImage = NULL;
static void *_ffi_ptr_LoadImageRaw = NULL;
static void *_ffi_ptr_LoadImageFromMemory = NULL;
static void *_ffi_ptr_UnloadImage = NULL;
static void *_ffi_ptr_IsImageValid = NULL;
static void *_ffi_ptr_ExportImage = NULL;
static void *_ffi_ptr_GenImageColor = NULL;
static void *_ffi_ptr_GenImageGradientLinear = NULL;
static void *_ffi_ptr_GenImageGradientRadial = NULL;
static void *_ffi_ptr_GenImageChecked = NULL;
static void *_ffi_ptr_GenImageWhiteNoise = NULL;
static void *_ffi_ptr_GenImagePerlinNoise = NULL;
static void *_ffi_ptr_ImageCopy = NULL;
static void *_ffi_ptr_ImageFromImage = NULL;
static void *_ffi_ptr_ImageResize = NULL;
static void *_ffi_ptr_ImageResizeNN = NULL;
static void *_ffi_ptr_ImageCrop = NULL;
static void *_ffi_ptr_ImageFlipVertical = NULL;
static void *_ffi_ptr_ImageFlipHorizontal = NULL;
static void *_ffi_ptr_ImageRotate = NULL;
static void *_ffi_ptr_ImageRotateCW = NULL;
static void *_ffi_ptr_ImageRotateCCW = NULL;
static void *_ffi_ptr_ImageColorTint = NULL;
static void *_ffi_ptr_ImageColorInvert = NULL;
static void *_ffi_ptr_ImageColorGrayscale = NULL;
static void *_ffi_ptr_ImageColorContrast = NULL;
static void *_ffi_ptr_ImageColorBrightness = NULL;
static void *_ffi_ptr_ImageClearBackground = NULL;
static void *_ffi_ptr_ImageDrawPixel = NULL;
static void *_ffi_ptr_ImageDrawPixelV = NULL;
static void *_ffi_ptr_ImageDrawLine = NULL;
static void *_ffi_ptr_ImageDrawLineV = NULL;
static void *_ffi_ptr_ImageDrawCircle = NULL;
static void *_ffi_ptr_ImageDrawCircleV = NULL;
static void *_ffi_ptr_ImageDrawRectangle = NULL;
static void *_ffi_ptr_ImageDrawRectangleV = NULL;
static void *_ffi_ptr_ImageDrawRectangleRec = NULL;
static void *_ffi_ptr_ImageDrawText = NULL;
static void *_ffi_ptr_ImageDrawTextEx = NULL;
static void *_ffi_ptr_FileExists = NULL;
static void *_ffi_ptr_DirectoryExists = NULL;
static void *_ffi_ptr_IsFileExtension = NULL;
static void *_ffi_ptr_GetFileExtension = NULL;
static void *_ffi_ptr_GetFileName = NULL;
static void *_ffi_ptr_GetFileNameWithoutExt = NULL;
static void *_ffi_ptr_GetDirectoryPath = NULL;
static void *_ffi_ptr_GetPrevDirectoryPath = NULL;
static void *_ffi_ptr_GetWorkingDirectory = NULL;
static void *_ffi_ptr_ChangeDirectory = NULL;
static void *_ffi_ptr_GetFileLength = NULL;
static void *_ffi_ptr_GetFileModTime = NULL;
static void *_ffi_ptr_IsPathFile = NULL;
static void *_ffi_ptr_GetApplicationDirectory = NULL;
static void *_ffi_ptr_LoadFileText = NULL;
static void *_ffi_ptr_UnloadFileText = NULL;
static void *_ffi_ptr_SaveFileText = NULL;

// Built-in globals
static HmlValue _main_args = {0};

// Top-level variables (static for function access)
static HmlValue _main_screenWidth = {0};
static HmlValue _main_screenHeight = {0};

// Module global variables
static HmlValue _mod1_RAYLIB_LOADED = {0};
static HmlValue _mod1__platform = {0};
static HmlValue _mod0_InitWindow = {0};
static HmlValue _mod0_CloseWindow = {0};
static HmlValue _mod0_WindowShouldClose = {0};
static HmlValue _mod0_IsWindowReady = {0};
static HmlValue _mod0_IsWindowFullscreen = {0};
static HmlValue _mod0_IsWindowHidden = {0};
static HmlValue _mod0_IsWindowMinimized = {0};
static HmlValue _mod0_IsWindowMaximized = {0};
static HmlValue _mod0_IsWindowFocused = {0};
static HmlValue _mod0_IsWindowResized = {0};
static HmlValue _mod0_IsWindowState = {0};
static HmlValue _mod0_SetWindowState = {0};
static HmlValue _mod0_ClearWindowState = {0};
static HmlValue _mod0_SetWindowTitle = {0};
static HmlValue _mod0_SetWindowPosition = {0};
static HmlValue _mod0_SetWindowSize = {0};
static HmlValue _mod0_SetWindowMinSize = {0};
static HmlValue _mod0_SetWindowMaxSize = {0};
static HmlValue _mod0_GetScreenWidth = {0};
static HmlValue _mod0_GetScreenHeight = {0};
static HmlValue _mod0_GetRenderWidth = {0};
static HmlValue _mod0_GetRenderHeight = {0};
static HmlValue _mod0_GetMonitorCount = {0};
static HmlValue _mod0_GetCurrentMonitor = {0};
static HmlValue _mod0_GetMonitorWidth = {0};
static HmlValue _mod0_GetMonitorHeight = {0};
static HmlValue _mod0_GetMonitorRefreshRate = {0};
static HmlValue _mod0_GetMonitorPhysicalWidth = {0};
static HmlValue _mod0_GetMonitorPhysicalHeight = {0};
static HmlValue _mod0_GetMonitorName = {0};
static HmlValue _mod0_ToggleFullscreen = {0};
static HmlValue _mod0_ToggleBorderlessWindowed = {0};
static HmlValue _mod0_MaximizeWindow = {0};
static HmlValue _mod0_MinimizeWindow = {0};
static HmlValue _mod0_RestoreWindow = {0};
static HmlValue _mod0_SetWindowOpacity = {0};
static HmlValue _mod0_SetWindowFocused = {0};
static HmlValue _mod0_SetWindowIcon = {0};
static HmlValue _mod0_SetTargetFPS = {0};
static HmlValue _mod0_GetFPS = {0};
static HmlValue _mod0_GetFrameTime = {0};
static HmlValue _mod0_GetTime = {0};
static HmlValue _mod0_ClearBackground = {0};
static HmlValue _mod0_BeginDrawing = {0};
static HmlValue _mod0_EndDrawing = {0};
static HmlValue _mod0_BeginBlendMode = {0};
static HmlValue _mod0_EndBlendMode = {0};
static HmlValue _mod0_BeginScissorMode = {0};
static HmlValue _mod0_EndScissorMode = {0};
static HmlValue _mod0_rlBegin = {0};
static HmlValue _mod0_rlEnd = {0};
static HmlValue _mod0_rlVertex2f = {0};
static HmlValue _mod0_rlVertex2i = {0};
static HmlValue _mod0_rlColor4ub = {0};
static HmlValue _mod0_RL_LINES = {0};
static HmlValue _mod0_RL_TRIANGLES = {0};
static HmlValue _mod0_RL_QUADS = {0};
static HmlValue _mod0_IsKeyPressed = {0};
static HmlValue _mod0_IsKeyPressedRepeat = {0};
static HmlValue _mod0_IsKeyDown = {0};
static HmlValue _mod0_IsKeyReleased = {0};
static HmlValue _mod0_IsKeyUp = {0};
static HmlValue _mod0_GetKeyPressed = {0};
static HmlValue _mod0_GetCharPressed = {0};
static HmlValue _mod0_GetKeyName = {0};
static HmlValue _mod0_SetExitKey = {0};
static HmlValue _mod0_IsMouseButtonPressed = {0};
static HmlValue _mod0_IsMouseButtonDown = {0};
static HmlValue _mod0_IsMouseButtonReleased = {0};
static HmlValue _mod0_IsMouseButtonUp = {0};
static HmlValue _mod0_GetMouseX = {0};
static HmlValue _mod0_GetMouseY = {0};
static HmlValue _mod0_GetMousePosition = {0};
static HmlValue _mod0_GetMouseDelta = {0};
static HmlValue _mod0_GetMouseWheelMove = {0};
static HmlValue _mod0_GetMouseWheelMoveV = {0};
static HmlValue _mod0_SetMousePosition = {0};
static HmlValue _mod0_SetMouseOffset = {0};
static HmlValue _mod0_SetMouseScale = {0};
static HmlValue _mod0_SetMouseCursor = {0};
static HmlValue _mod0_ShowCursor = {0};
static HmlValue _mod0_HideCursor = {0};
static HmlValue _mod0_IsCursorHidden = {0};
static HmlValue _mod0_EnableCursor = {0};
static HmlValue _mod0_DisableCursor = {0};
static HmlValue _mod0_IsCursorOnScreen = {0};
static HmlValue _mod0_IsGamepadAvailable = {0};
static HmlValue _mod0_GetGamepadName = {0};
static HmlValue _mod0_IsGamepadButtonPressed = {0};
static HmlValue _mod0_IsGamepadButtonDown = {0};
static HmlValue _mod0_IsGamepadButtonReleased = {0};
static HmlValue _mod0_IsGamepadButtonUp = {0};
static HmlValue _mod0_GetGamepadButtonPressed = {0};
static HmlValue _mod0_GetGamepadAxisCount = {0};
static HmlValue _mod0_GetGamepadAxisMovement = {0};
static HmlValue _mod0_SetGamepadMappings = {0};
static HmlValue _mod0_SetGamepadVibration = {0};
static HmlValue _mod0_GetTouchX = {0};
static HmlValue _mod0_GetTouchY = {0};
static HmlValue _mod0_GetTouchPosition = {0};
static HmlValue _mod0_GetTouchPointId = {0};
static HmlValue _mod0_GetTouchPointCount = {0};
static HmlValue _mod0_SetGesturesEnabled = {0};
static HmlValue _mod0_IsGestureDetected = {0};
static HmlValue _mod0_GetGestureDetected = {0};
static HmlValue _mod0_GetGestureHoldDuration = {0};
static HmlValue _mod0_GetGestureDragAngle = {0};
static HmlValue _mod0_GetGesturePinchAngle = {0};
static HmlValue _mod0_TraceLog = {0};
static HmlValue _mod0_SetTraceLogLevel = {0};
static HmlValue _mod0_DrawPixel = {0};
static HmlValue _mod0_DrawPixelV = {0};
static HmlValue _mod0_DrawLine = {0};
static HmlValue _mod0_DrawLineV = {0};
static HmlValue _mod0_DrawLineEx = {0};
static HmlValue _mod0_DrawLineStrip = {0};
static HmlValue _mod0_DrawLineBezier = {0};
static HmlValue _mod0_DrawCircle = {0};
static HmlValue _mod0_DrawCircleV = {0};
static HmlValue _mod0_DrawCircleGradient = {0};
static HmlValue _mod0_DrawCircleLines = {0};
static HmlValue _mod0_DrawCircleLinesV = {0};
static HmlValue _mod0_DrawCircleSector = {0};
static HmlValue _mod0_DrawCircleSectorLines = {0};
static HmlValue _mod0_DrawRing = {0};
static HmlValue _mod0_DrawRingLines = {0};
static HmlValue _mod0_DrawEllipse = {0};
static HmlValue _mod0_DrawEllipseLines = {0};
static HmlValue _mod0_DrawRectangle = {0};
static HmlValue _mod0_DrawRectangleV = {0};
static HmlValue _mod0_DrawRectangleRec = {0};
static HmlValue _mod0_DrawRectanglePro = {0};
static HmlValue _mod0_DrawRectangleGradientV = {0};
static HmlValue _mod0_DrawRectangleGradientH = {0};
static HmlValue _mod0_DrawRectangleGradientEx = {0};
static HmlValue _mod0_DrawRectangleLines = {0};
static HmlValue _mod0_DrawRectangleLinesEx = {0};
static HmlValue _mod0_DrawRectangleRounded = {0};
static HmlValue _mod0_DrawRectangleRoundedLines = {0};
static HmlValue _mod0_DrawRectangleRoundedLinesEx = {0};
static HmlValue _mod0_DrawTriangle = {0};
static HmlValue _mod0_DrawTriangleLines = {0};
static HmlValue _mod0_DrawTriangleFan = {0};
static HmlValue _mod0_DrawTriangleStrip = {0};
static HmlValue _mod0_DrawPoly = {0};
static HmlValue _mod0_DrawPolyLines = {0};
static HmlValue _mod0_DrawPolyLinesEx = {0};
static HmlValue _mod0_DrawText = {0};
static HmlValue _mod0_MeasureText = {0};
static HmlValue _mod0_WaitTime = {0};
static HmlValue _mod0_GetRandomValue = {0};
static HmlValue _mod0_SetRandomSeed = {0};
static HmlValue _mod0_TakeScreenshot = {0};
static HmlValue _mod0_SetConfigFlags = {0};
static HmlValue _mod0_OpenURL = {0};
static HmlValue _mod0_SetClipboardText = {0};
static HmlValue _mod0_GetClipboardText = {0};
static HmlValue _mod0_CheckCollisionRecs = {0};
static HmlValue _mod0_CheckCollisionCircles = {0};
static HmlValue _mod0_CheckCollisionCircleRec = {0};
static HmlValue _mod0_CheckCollisionPointRec = {0};
static HmlValue _mod0_CheckCollisionPointCircle = {0};
static HmlValue _mod0_CheckCollisionPointTriangle = {0};
static HmlValue _mod0_CheckCollisionPointLine = {0};
static HmlValue _mod0_CheckCollisionLines = {0};
static HmlValue _mod0_GetCollisionRec = {0};
static HmlValue _mod0_DrawFPS = {0};
static HmlValue _mod0_InitAudioDevice = {0};
static HmlValue _mod0_CloseAudioDevice = {0};
static HmlValue _mod0_IsAudioDeviceReady = {0};
static HmlValue _mod0_SetMasterVolume = {0};
static HmlValue _mod0_GetMasterVolume = {0};
static HmlValue _mod0_LoadTexture = {0};
static HmlValue _mod0_LoadTextureFromImage = {0};
static HmlValue _mod0_UnloadTexture = {0};
static HmlValue _mod0_IsTextureValid = {0};
static HmlValue _mod0_UpdateTexture = {0};
static HmlValue _mod0_DrawTexture = {0};
static HmlValue _mod0_DrawTextureV = {0};
static HmlValue _mod0_DrawTextureEx = {0};
static HmlValue _mod0_DrawTextureRec = {0};
static HmlValue _mod0_DrawTexturePro = {0};
static HmlValue _mod0_SetTextureFilter = {0};
static HmlValue _mod0_SetTextureWrap = {0};
static HmlValue _mod0_LoadRenderTexture = {0};
static HmlValue _mod0_UnloadRenderTexture = {0};
static HmlValue _mod0_IsRenderTextureValid = {0};
static HmlValue _mod0_BeginTextureMode = {0};
static HmlValue _mod0_EndTextureMode = {0};
static HmlValue _mod0_LoadSound = {0};
static HmlValue _mod0_UnloadSound = {0};
static HmlValue _mod0_IsSoundValid = {0};
static HmlValue _mod0_PlaySound = {0};
static HmlValue _mod0_StopSound = {0};
static HmlValue _mod0_PauseSound = {0};
static HmlValue _mod0_ResumeSound = {0};
static HmlValue _mod0_IsSoundPlaying = {0};
static HmlValue _mod0_SetSoundVolume = {0};
static HmlValue _mod0_SetSoundPitch = {0};
static HmlValue _mod0_SetSoundPan = {0};
static HmlValue _mod0_LoadMusicStream = {0};
static HmlValue _mod0_UnloadMusicStream = {0};
static HmlValue _mod0_IsMusicValid = {0};
static HmlValue _mod0_PlayMusicStream = {0};
static HmlValue _mod0_StopMusicStream = {0};
static HmlValue _mod0_PauseMusicStream = {0};
static HmlValue _mod0_ResumeMusicStream = {0};
static HmlValue _mod0_UpdateMusicStream = {0};
static HmlValue _mod0_IsMusicStreamPlaying = {0};
static HmlValue _mod0_SetMusicVolume = {0};
static HmlValue _mod0_SetMusicPitch = {0};
static HmlValue _mod0_SetMusicPan = {0};
static HmlValue _mod0_GetMusicTimeLength = {0};
static HmlValue _mod0_GetMusicTimePlayed = {0};
static HmlValue _mod0_SeekMusicStream = {0};
static HmlValue _mod0_SetMusicLooping = {0};
static HmlValue _mod0_LoadFont = {0};
static HmlValue _mod0_LoadFontEx = {0};
static HmlValue _mod0_UnloadFont = {0};
static HmlValue _mod0_IsFontValid = {0};
static HmlValue _mod0_GetFontDefault = {0};
static HmlValue _mod0_DrawTextEx = {0};
static HmlValue _mod0_DrawTextPro = {0};
static HmlValue _mod0_MeasureTextEx = {0};
static HmlValue _mod0_LoadImage = {0};
static HmlValue _mod0_LoadImageRaw = {0};
static HmlValue _mod0_LoadImageFromMemory = {0};
static HmlValue _mod0_UnloadImage = {0};
static HmlValue _mod0_IsImageValid = {0};
static HmlValue _mod0_ExportImage = {0};
static HmlValue _mod0_GenImageColor = {0};
static HmlValue _mod0_GenImageGradientLinear = {0};
static HmlValue _mod0_GenImageGradientRadial = {0};
static HmlValue _mod0_GenImageChecked = {0};
static HmlValue _mod0_GenImageWhiteNoise = {0};
static HmlValue _mod0_GenImagePerlinNoise = {0};
static HmlValue _mod0_ImageCopy = {0};
static HmlValue _mod0_ImageFromImage = {0};
static HmlValue _mod0_ImageResize = {0};
static HmlValue _mod0_ImageResizeNN = {0};
static HmlValue _mod0_ImageCrop = {0};
static HmlValue _mod0_ImageFlipVertical = {0};
static HmlValue _mod0_ImageFlipHorizontal = {0};
static HmlValue _mod0_ImageRotate = {0};
static HmlValue _mod0_ImageRotateCW = {0};
static HmlValue _mod0_ImageRotateCCW = {0};
static HmlValue _mod0_ImageColorTint = {0};
static HmlValue _mod0_ImageColorInvert = {0};
static HmlValue _mod0_ImageColorGrayscale = {0};
static HmlValue _mod0_ImageColorContrast = {0};
static HmlValue _mod0_ImageColorBrightness = {0};
static HmlValue _mod0_ImageClearBackground = {0};
static HmlValue _mod0_ImageDrawPixel = {0};
static HmlValue _mod0_ImageDrawPixelV = {0};
static HmlValue _mod0_ImageDrawLine = {0};
static HmlValue _mod0_ImageDrawLineV = {0};
static HmlValue _mod0_ImageDrawCircle = {0};
static HmlValue _mod0_ImageDrawCircleV = {0};
static HmlValue _mod0_ImageDrawRectangle = {0};
static HmlValue _mod0_ImageDrawRectangleV = {0};
static HmlValue _mod0_ImageDrawRectangleRec = {0};
static HmlValue _mod0_ImageDrawText = {0};
static HmlValue _mod0_ImageDrawTextEx = {0};
static HmlValue _mod0_FileExists = {0};
static HmlValue _mod0_DirectoryExists = {0};
static HmlValue _mod0_IsFileExtension = {0};
static HmlValue _mod0_GetFileExtension = {0};
static HmlValue _mod0_GetFileName = {0};
static HmlValue _mod0_GetFileNameWithoutExt = {0};
static HmlValue _mod0_GetDirectoryPath = {0};
static HmlValue _mod0_GetPrevDirectoryPath = {0};
static HmlValue _mod0_GetWorkingDirectory = {0};
static HmlValue _mod0_ChangeDirectory = {0};
static HmlValue _mod0_GetFileLength = {0};
static HmlValue _mod0_GetFileModTime = {0};
static HmlValue _mod0_IsPathFile = {0};
static HmlValue _mod0_GetApplicationDirectory = {0};
static HmlValue _mod0_LoadFileText = {0};
static HmlValue _mod0_UnloadFileText = {0};
static HmlValue _mod0_SaveFileText = {0};
static HmlValue _mod0_TEXTURE_FILTER_POINT = {0};
static HmlValue _mod0_TEXTURE_FILTER_BILINEAR = {0};
static HmlValue _mod0_TEXTURE_FILTER_TRILINEAR = {0};
static HmlValue _mod0_TEXTURE_FILTER_ANISOTROPIC_4X = {0};
static HmlValue _mod0_TEXTURE_FILTER_ANISOTROPIC_8X = {0};
static HmlValue _mod0_TEXTURE_FILTER_ANISOTROPIC_16X = {0};
static HmlValue _mod0_TEXTURE_WRAP_REPEAT = {0};
static HmlValue _mod0_TEXTURE_WRAP_CLAMP = {0};
static HmlValue _mod0_TEXTURE_WRAP_MIRROR_REPEAT = {0};
static HmlValue _mod0_TEXTURE_WRAP_MIRROR_CLAMP = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R32 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R16 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = {0};
static HmlValue _mod0_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = {0};
static HmlValue _mod0_Color = {0};
static HmlValue _mod0_ColorAlpha = {0};
static HmlValue _mod0_ColorBrightness = {0};
static HmlValue _mod0_ColorGetR = {0};
static HmlValue _mod0_ColorGetG = {0};
static HmlValue _mod0_ColorGetB = {0};
static HmlValue _mod0_ColorGetA = {0};
static HmlValue _mod0_DrawCircleFill = {0};
static HmlValue _mod0_DrawCircleOutline = {0};
static HmlValue _mod0_DrawTriangleFill = {0};
static HmlValue _mod0_DrawTriangleOutline = {0};
static HmlValue _mod0_LIGHTGRAY = {0};
static HmlValue _mod0_GRAY = {0};
static HmlValue _mod0_DARKGRAY = {0};
static HmlValue _mod0_YELLOW = {0};
static HmlValue _mod0_GOLD = {0};
static HmlValue _mod0_ORANGE = {0};
static HmlValue _mod0_PINK = {0};
static HmlValue _mod0_RED = {0};
static HmlValue _mod0_MAROON = {0};
static HmlValue _mod0_GREEN = {0};
static HmlValue _mod0_LIME = {0};
static HmlValue _mod0_DARKGREEN = {0};
static HmlValue _mod0_SKYBLUE = {0};
static HmlValue _mod0_BLUE = {0};
static HmlValue _mod0_DARKBLUE = {0};
static HmlValue _mod0_PURPLE = {0};
static HmlValue _mod0_VIOLET = {0};
static HmlValue _mod0_DARKPURPLE = {0};
static HmlValue _mod0_BEIGE = {0};
static HmlValue _mod0_BROWN = {0};
static HmlValue _mod0_DARKBROWN = {0};
static HmlValue _mod0_WHITE = {0};
static HmlValue _mod0_BLACK = {0};
static HmlValue _mod0_BLANK = {0};
static HmlValue _mod0_MAGENTA = {0};
static HmlValue _mod0_RAYWHITE = {0};
static HmlValue _mod0_KEY_NULL = {0};
static HmlValue _mod0_KEY_APOSTROPHE = {0};
static HmlValue _mod0_KEY_COMMA = {0};
static HmlValue _mod0_KEY_MINUS = {0};
static HmlValue _mod0_KEY_PERIOD = {0};
static HmlValue _mod0_KEY_SLASH = {0};
static HmlValue _mod0_KEY_ZERO = {0};
static HmlValue _mod0_KEY_ONE = {0};
static HmlValue _mod0_KEY_TWO = {0};
static HmlValue _mod0_KEY_THREE = {0};
static HmlValue _mod0_KEY_FOUR = {0};
static HmlValue _mod0_KEY_FIVE = {0};
static HmlValue _mod0_KEY_SIX = {0};
static HmlValue _mod0_KEY_SEVEN = {0};
static HmlValue _mod0_KEY_EIGHT = {0};
static HmlValue _mod0_KEY_NINE = {0};
static HmlValue _mod0_KEY_SEMICOLON = {0};
static HmlValue _mod0_KEY_EQUAL = {0};
static HmlValue _mod0_KEY_A = {0};
static HmlValue _mod0_KEY_B = {0};
static HmlValue _mod0_KEY_C = {0};
static HmlValue _mod0_KEY_D = {0};
static HmlValue _mod0_KEY_E = {0};
static HmlValue _mod0_KEY_F = {0};
static HmlValue _mod0_KEY_G = {0};
static HmlValue _mod0_KEY_H = {0};
static HmlValue _mod0_KEY_I = {0};
static HmlValue _mod0_KEY_J = {0};
static HmlValue _mod0_KEY_K = {0};
static HmlValue _mod0_KEY_L = {0};
static HmlValue _mod0_KEY_M = {0};
static HmlValue _mod0_KEY_N = {0};
static HmlValue _mod0_KEY_O = {0};
static HmlValue _mod0_KEY_P = {0};
static HmlValue _mod0_KEY_Q = {0};
static HmlValue _mod0_KEY_R = {0};
static HmlValue _mod0_KEY_S = {0};
static HmlValue _mod0_KEY_T = {0};
static HmlValue _mod0_KEY_U = {0};
static HmlValue _mod0_KEY_V = {0};
static HmlValue _mod0_KEY_W = {0};
static HmlValue _mod0_KEY_X = {0};
static HmlValue _mod0_KEY_Y = {0};
static HmlValue _mod0_KEY_Z = {0};
static HmlValue _mod0_KEY_LEFT_BRACKET = {0};
static HmlValue _mod0_KEY_BACKSLASH = {0};
static HmlValue _mod0_KEY_RIGHT_BRACKET = {0};
static HmlValue _mod0_KEY_GRAVE = {0};
static HmlValue _mod0_KEY_SPACE = {0};
static HmlValue _mod0_KEY_ESCAPE = {0};
static HmlValue _mod0_KEY_ENTER = {0};
static HmlValue _mod0_KEY_TAB = {0};
static HmlValue _mod0_KEY_BACKSPACE = {0};
static HmlValue _mod0_KEY_INSERT = {0};
static HmlValue _mod0_KEY_DELETE = {0};
static HmlValue _mod0_KEY_RIGHT = {0};
static HmlValue _mod0_KEY_LEFT = {0};
static HmlValue _mod0_KEY_DOWN = {0};
static HmlValue _mod0_KEY_UP = {0};
static HmlValue _mod0_KEY_PAGE_UP = {0};
static HmlValue _mod0_KEY_PAGE_DOWN = {0};
static HmlValue _mod0_KEY_HOME = {0};
static HmlValue _mod0_KEY_END = {0};
static HmlValue _mod0_KEY_CAPS_LOCK = {0};
static HmlValue _mod0_KEY_SCROLL_LOCK = {0};
static HmlValue _mod0_KEY_NUM_LOCK = {0};
static HmlValue _mod0_KEY_PRINT_SCREEN = {0};
static HmlValue _mod0_KEY_PAUSE = {0};
static HmlValue _mod0_KEY_F1 = {0};
static HmlValue _mod0_KEY_F2 = {0};
static HmlValue _mod0_KEY_F3 = {0};
static HmlValue _mod0_KEY_F4 = {0};
static HmlValue _mod0_KEY_F5 = {0};
static HmlValue _mod0_KEY_F6 = {0};
static HmlValue _mod0_KEY_F7 = {0};
static HmlValue _mod0_KEY_F8 = {0};
static HmlValue _mod0_KEY_F9 = {0};
static HmlValue _mod0_KEY_F10 = {0};
static HmlValue _mod0_KEY_F11 = {0};
static HmlValue _mod0_KEY_F12 = {0};
static HmlValue _mod0_KEY_LEFT_SHIFT = {0};
static HmlValue _mod0_KEY_LEFT_CONTROL = {0};
static HmlValue _mod0_KEY_LEFT_ALT = {0};
static HmlValue _mod0_KEY_LEFT_SUPER = {0};
static HmlValue _mod0_KEY_RIGHT_SHIFT = {0};
static HmlValue _mod0_KEY_RIGHT_CONTROL = {0};
static HmlValue _mod0_KEY_RIGHT_ALT = {0};
static HmlValue _mod0_KEY_RIGHT_SUPER = {0};
static HmlValue _mod0_KEY_KB_MENU = {0};
static HmlValue _mod0_KEY_KP_0 = {0};
static HmlValue _mod0_KEY_KP_1 = {0};
static HmlValue _mod0_KEY_KP_2 = {0};
static HmlValue _mod0_KEY_KP_3 = {0};
static HmlValue _mod0_KEY_KP_4 = {0};
static HmlValue _mod0_KEY_KP_5 = {0};
static HmlValue _mod0_KEY_KP_6 = {0};
static HmlValue _mod0_KEY_KP_7 = {0};
static HmlValue _mod0_KEY_KP_8 = {0};
static HmlValue _mod0_KEY_KP_9 = {0};
static HmlValue _mod0_KEY_KP_DECIMAL = {0};
static HmlValue _mod0_KEY_KP_DIVIDE = {0};
static HmlValue _mod0_KEY_KP_MULTIPLY = {0};
static HmlValue _mod0_KEY_KP_SUBTRACT = {0};
static HmlValue _mod0_KEY_KP_ADD = {0};
static HmlValue _mod0_KEY_KP_ENTER = {0};
static HmlValue _mod0_KEY_KP_EQUAL = {0};
static HmlValue _mod0_MOUSE_BUTTON_LEFT = {0};
static HmlValue _mod0_MOUSE_BUTTON_RIGHT = {0};
static HmlValue _mod0_MOUSE_BUTTON_MIDDLE = {0};
static HmlValue _mod0_MOUSE_BUTTON_SIDE = {0};
static HmlValue _mod0_MOUSE_BUTTON_EXTRA = {0};
static HmlValue _mod0_MOUSE_BUTTON_FORWARD = {0};
static HmlValue _mod0_MOUSE_BUTTON_BACK = {0};
static HmlValue _mod0_MOUSE_CURSOR_DEFAULT = {0};
static HmlValue _mod0_MOUSE_CURSOR_ARROW = {0};
static HmlValue _mod0_MOUSE_CURSOR_IBEAM = {0};
static HmlValue _mod0_MOUSE_CURSOR_CROSSHAIR = {0};
static HmlValue _mod0_MOUSE_CURSOR_POINTING_HAND = {0};
static HmlValue _mod0_MOUSE_CURSOR_RESIZE_EW = {0};
static HmlValue _mod0_MOUSE_CURSOR_RESIZE_NS = {0};
static HmlValue _mod0_MOUSE_CURSOR_RESIZE_NWSE = {0};
static HmlValue _mod0_MOUSE_CURSOR_RESIZE_NESW = {0};
static HmlValue _mod0_MOUSE_CURSOR_RESIZE_ALL = {0};
static HmlValue _mod0_MOUSE_CURSOR_NOT_ALLOWED = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_UNKNOWN = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_LEFT_FACE_UP = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_LEFT_FACE_RIGHT = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_LEFT_FACE_DOWN = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_LEFT_FACE_LEFT = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_RIGHT_FACE_UP = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_RIGHT_FACE_DOWN = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_RIGHT_FACE_LEFT = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_LEFT_TRIGGER_1 = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_LEFT_TRIGGER_2 = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_MIDDLE_LEFT = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_MIDDLE = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_MIDDLE_RIGHT = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_LEFT_THUMB = {0};
static HmlValue _mod0_GAMEPAD_BUTTON_RIGHT_THUMB = {0};
static HmlValue _mod0_GAMEPAD_AXIS_LEFT_X = {0};
static HmlValue _mod0_GAMEPAD_AXIS_LEFT_Y = {0};
static HmlValue _mod0_GAMEPAD_AXIS_RIGHT_X = {0};
static HmlValue _mod0_GAMEPAD_AXIS_RIGHT_Y = {0};
static HmlValue _mod0_GAMEPAD_AXIS_LEFT_TRIGGER = {0};
static HmlValue _mod0_GAMEPAD_AXIS_RIGHT_TRIGGER = {0};
static HmlValue _mod0_GESTURE_NONE = {0};
static HmlValue _mod0_GESTURE_TAP = {0};
static HmlValue _mod0_GESTURE_DOUBLETAP = {0};
static HmlValue _mod0_GESTURE_HOLD = {0};
static HmlValue _mod0_GESTURE_DRAG = {0};
static HmlValue _mod0_GESTURE_SWIPE_RIGHT = {0};
static HmlValue _mod0_GESTURE_SWIPE_LEFT = {0};
static HmlValue _mod0_GESTURE_SWIPE_UP = {0};
static HmlValue _mod0_GESTURE_SWIPE_DOWN = {0};
static HmlValue _mod0_GESTURE_PINCH_IN = {0};
static HmlValue _mod0_GESTURE_PINCH_OUT = {0};
static HmlValue _mod0_BLEND_ALPHA = {0};
static HmlValue _mod0_BLEND_ADDITIVE = {0};
static HmlValue _mod0_BLEND_MULTIPLIED = {0};
static HmlValue _mod0_BLEND_ADD_COLORS = {0};
static HmlValue _mod0_BLEND_SUBTRACT_COLORS = {0};
static HmlValue _mod0_BLEND_ALPHA_PREMULTIPLY = {0};
static HmlValue _mod0_BLEND_CUSTOM = {0};
static HmlValue _mod0_BLEND_CUSTOM_SEPARATE = {0};
static HmlValue _mod0_FLAG_VSYNC_HINT = {0};
static HmlValue _mod0_FLAG_FULLSCREEN_MODE = {0};
static HmlValue _mod0_FLAG_WINDOW_RESIZABLE = {0};
static HmlValue _mod0_FLAG_WINDOW_UNDECORATED = {0};
static HmlValue _mod0_FLAG_WINDOW_HIDDEN = {0};
static HmlValue _mod0_FLAG_WINDOW_MINIMIZED = {0};
static HmlValue _mod0_FLAG_WINDOW_MAXIMIZED = {0};
static HmlValue _mod0_FLAG_WINDOW_UNFOCUSED = {0};
static HmlValue _mod0_FLAG_WINDOW_TOPMOST = {0};
static HmlValue _mod0_FLAG_WINDOW_ALWAYS_RUN = {0};
static HmlValue _mod0_FLAG_WINDOW_TRANSPARENT = {0};
static HmlValue _mod0_FLAG_WINDOW_HIGHDPI = {0};
static HmlValue _mod0_FLAG_WINDOW_MOUSE_PASSTHROUGH = {0};
static HmlValue _mod0_FLAG_BORDERLESS_WINDOWED_MODE = {0};
static HmlValue _mod0_FLAG_MSAA_4X_HINT = {0};
static HmlValue _mod0_FLAG_INTERLACED_HINT = {0};
static HmlValue _mod0_LOG_ALL = {0};
static HmlValue _mod0_LOG_TRACE = {0};
static HmlValue _mod0_LOG_DEBUG = {0};
static HmlValue _mod0_LOG_INFO = {0};
static HmlValue _mod0_LOG_WARNING = {0};
static HmlValue _mod0_LOG_ERROR = {0};
static HmlValue _mod0_LOG_FATAL = {0};
static HmlValue _mod0_LOG_NONE = {0};
static HmlValue _mod0_CheckCollisionCirclesXY = {0};
static HmlValue _mod0_CheckCollisionRectsXY = {0};
static HmlValue _mod0_CheckCollisionPointRectXY = {0};
static HmlValue _mod0_CheckCollisionPointCircleXY = {0};
static HmlValue _mod0_CheckCollisionCircleRecXY = {0};
static HmlValue _mod0_Vector2Distance = {0};
static HmlValue _mod0_Vector2Length = {0};
static HmlValue _mod0_Vector2Dot = {0};
static HmlValue _mod0_Lerp = {0};
static HmlValue _mod0_Clamp = {0};
static HmlValue _mod0_ClampInt = {0};
static HmlValue _mod0_Remap = {0};
static HmlValue _mod0_Wrap = {0};
static HmlValue _mod0_NormalizeAngle = {0};
static HmlValue _mod0_Deg2Rad = {0};
static HmlValue _mod0_Rad2Deg = {0};
static HmlValue _mod0_Sign = {0};
static HmlValue _mod0_SignInt = {0};
static HmlValue _mod0_Abs = {0};
static HmlValue _mod0_AbsInt = {0};
static HmlValue _mod0_Min = {0};
static HmlValue _mod0_Max = {0};
static HmlValue _mod0_MinInt = {0};
static HmlValue _mod0_MaxInt = {0};
static HmlValue _mod0_FloorInt = {0};
static HmlValue _mod0_CeilInt = {0};
static HmlValue _mod0_RoundInt = {0};
static HmlValue _mod0_SmoothStep = {0};
static HmlValue _mod0_InverseLerp = {0};
static HmlValue _mod0_MoveTowards = {0};
static HmlValue _mod0_MoveTowardsInt = {0};
static HmlValue _mod0_Approximately = {0};
static HmlValue _mod0_InRange = {0};
static HmlValue _mod0_InRangeInt = {0};
static HmlValue _mod0_WrapInt = {0};
static HmlValue _mod0_Vector2LengthSq = {0};
static HmlValue _mod0_Vector2NormalizeGetLength = {0};
static HmlValue _mod0_Vector2ScaleX = {0};
static HmlValue _mod0_Vector2ScaleY = {0};
static HmlValue _mod0_Vector2AddX = {0};
static HmlValue _mod0_Vector2AddY = {0};
static HmlValue _mod0_Vector2SubtractX = {0};
static HmlValue _mod0_Vector2SubtractY = {0};
static HmlValue _mod0_Vector2NegateX = {0};
static HmlValue _mod0_Vector2NegateY = {0};
static HmlValue _mod0_Vector2RotateX = {0};
static HmlValue _mod0_Vector2RotateY = {0};
static HmlValue _mod0_Vector2LerpX = {0};
static HmlValue _mod0_Vector2LerpY = {0};
static HmlValue _mod0_Vector2ReflectX = {0};
static HmlValue _mod0_Vector2ReflectY = {0};
static HmlValue _mod0_Vector2Angle = {0};
static HmlValue _mod0_Vector2AngleFromX = {0};
static HmlValue _mod0_Vector2MoveTowardsX = {0};
static HmlValue _mod0_Vector2MoveTowardsY = {0};
static HmlValue _mod0_CheckCollisionLinesXY = {0};
static HmlValue _mod0_CheckCollisionPointTriangleXY = {0};
static HmlValue _mod0_CheckCollisionPointLineXY = {0};
static HmlValue _mod0_EaseLinear = {0};
static HmlValue _mod0_EaseInQuad = {0};
static HmlValue _mod0_EaseOutQuad = {0};
static HmlValue _mod0_EaseInOutQuad = {0};
static HmlValue _mod0_EaseInCubic = {0};
static HmlValue _mod0_EaseOutCubic = {0};
static HmlValue _mod0_EaseInOutCubic = {0};
static HmlValue _mod0_EaseInQuart = {0};
static HmlValue _mod0_EaseOutQuart = {0};
static HmlValue _mod0_EaseInOutQuart = {0};
static HmlValue _mod0_EaseInQuint = {0};
static HmlValue _mod0_EaseOutQuint = {0};
static HmlValue _mod0_EaseInOutQuint = {0};
static HmlValue _mod0_EaseInSine = {0};
static HmlValue _mod0_EaseOutSine = {0};
static HmlValue _mod0_EaseInOutSine = {0};
static HmlValue _mod0_EaseInExpo = {0};
static HmlValue _mod0_EaseOutExpo = {0};
static HmlValue _mod0_EaseInOutExpo = {0};
static HmlValue _mod0_EaseInCirc = {0};
static HmlValue _mod0_EaseOutCirc = {0};
static HmlValue _mod0_EaseInOutCirc = {0};
static HmlValue _mod0_EaseInBack = {0};
static HmlValue _mod0_EaseOutBack = {0};
static HmlValue _mod0_EaseInOutBack = {0};
static HmlValue _mod0_EaseOutBounce = {0};
static HmlValue _mod0_EaseInBounce = {0};
static HmlValue _mod0_EaseInOutBounce = {0};
static HmlValue _mod0_EaseInElastic = {0};
static HmlValue _mod0_EaseOutElastic = {0};
static HmlValue _mod0_EaseInOutElastic = {0};
static HmlValue _mod0_ColorBlend = {0};
static HmlValue _mod0_ColorInvert = {0};
static HmlValue _mod0_ColorToGrayscale = {0};
static HmlValue _mod0_ColorTint = {0};
static HmlValue _mod0_ColorContrast = {0};

// Module function forward declarations
HmlValue _mod0_fn_Color(HmlClosureEnv *_closure_env, HmlValue r, HmlValue g, HmlValue b, HmlValue a);
HmlValue _mod0_fn_ColorAlpha(HmlClosureEnv *_closure_env, HmlValue color, HmlValue alpha);
HmlValue _mod0_fn_ColorBrightness(HmlClosureEnv *_closure_env, HmlValue color, HmlValue factor);
HmlValue _mod0_fn_ColorGetR(HmlClosureEnv *_closure_env, HmlValue color);
HmlValue _mod0_fn_ColorGetG(HmlClosureEnv *_closure_env, HmlValue color);
HmlValue _mod0_fn_ColorGetB(HmlClosureEnv *_closure_env, HmlValue color);
HmlValue _mod0_fn_ColorGetA(HmlClosureEnv *_closure_env, HmlValue color);
HmlValue _mod0_fn_DrawCircleFill(HmlClosureEnv *_closure_env, HmlValue centerX, HmlValue centerY, HmlValue radius, HmlValue color);
HmlValue _mod0_fn_DrawCircleOutline(HmlClosureEnv *_closure_env, HmlValue centerX, HmlValue centerY, HmlValue radius, HmlValue color);
HmlValue _mod0_fn_DrawTriangleFill(HmlClosureEnv *_closure_env, HmlValue v1x, HmlValue v1y, HmlValue v2x, HmlValue v2y, HmlValue v3x, HmlValue v3y, HmlValue color);
HmlValue _mod0_fn_DrawTriangleOutline(HmlClosureEnv *_closure_env, HmlValue v1x, HmlValue v1y, HmlValue v2x, HmlValue v2y, HmlValue v3x, HmlValue v3y, HmlValue color);
HmlValue _mod0_fn_CheckCollisionCirclesXY(HmlClosureEnv *_closure_env, HmlValue c1x, HmlValue c1y, HmlValue r1, HmlValue c2x, HmlValue c2y, HmlValue r2);
HmlValue _mod0_fn_CheckCollisionRectsXY(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue y1, HmlValue w1, HmlValue h1, HmlValue x2, HmlValue y2, HmlValue w2, HmlValue h2);
HmlValue _mod0_fn_CheckCollisionPointRectXY(HmlClosureEnv *_closure_env, HmlValue px, HmlValue py, HmlValue rx, HmlValue ry, HmlValue rw, HmlValue rh);
HmlValue _mod0_fn_CheckCollisionPointCircleXY(HmlClosureEnv *_closure_env, HmlValue px, HmlValue py, HmlValue cx, HmlValue cy, HmlValue r);
HmlValue _mod0_fn_CheckCollisionCircleRecXY(HmlClosureEnv *_closure_env, HmlValue cx, HmlValue cy, HmlValue r, HmlValue rx, HmlValue ry, HmlValue rw, HmlValue rh);
HmlValue _mod0_fn_Vector2Distance(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue y1, HmlValue x2, HmlValue y2);
HmlValue _mod0_fn_Vector2Length(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y);
HmlValue _mod0_fn_Vector2Dot(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue y1, HmlValue x2, HmlValue y2);
HmlValue _mod0_fn_Lerp(HmlClosureEnv *_closure_env, HmlValue start, HmlValue end, HmlValue amount);
HmlValue _mod0_fn_Clamp(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max);
HmlValue _mod0_fn_ClampInt(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max);
HmlValue _mod0_fn_Remap(HmlClosureEnv *_closure_env, HmlValue value, HmlValue inputStart, HmlValue inputEnd, HmlValue outputStart, HmlValue outputEnd);
HmlValue _mod0_fn_Wrap(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max);
HmlValue _mod0_fn_NormalizeAngle(HmlClosureEnv *_closure_env, HmlValue angle);
HmlValue _mod0_fn_Deg2Rad(HmlClosureEnv *_closure_env, HmlValue degrees);
HmlValue _mod0_fn_Rad2Deg(HmlClosureEnv *_closure_env, HmlValue radians);
HmlValue _mod0_fn_Sign(HmlClosureEnv *_closure_env, HmlValue value);
HmlValue _mod0_fn_SignInt(HmlClosureEnv *_closure_env, HmlValue value);
HmlValue _mod0_fn_Abs(HmlClosureEnv *_closure_env, HmlValue value);
HmlValue _mod0_fn_AbsInt(HmlClosureEnv *_closure_env, HmlValue value);
HmlValue _mod0_fn_Min(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b);
HmlValue _mod0_fn_Max(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b);
HmlValue _mod0_fn_MinInt(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b);
HmlValue _mod0_fn_MaxInt(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b);
HmlValue _mod0_fn_FloorInt(HmlClosureEnv *_closure_env, HmlValue value);
HmlValue _mod0_fn_CeilInt(HmlClosureEnv *_closure_env, HmlValue value);
HmlValue _mod0_fn_RoundInt(HmlClosureEnv *_closure_env, HmlValue value);
HmlValue _mod0_fn_SmoothStep(HmlClosureEnv *_closure_env, HmlValue edge0, HmlValue edge1, HmlValue x);
HmlValue _mod0_fn_InverseLerp(HmlClosureEnv *_closure_env, HmlValue start, HmlValue end, HmlValue value);
HmlValue _mod0_fn_MoveTowards(HmlClosureEnv *_closure_env, HmlValue current, HmlValue target, HmlValue maxDelta);
HmlValue _mod0_fn_MoveTowardsInt(HmlClosureEnv *_closure_env, HmlValue current, HmlValue target, HmlValue maxDelta);
HmlValue _mod0_fn_Approximately(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b, HmlValue epsilon);
HmlValue _mod0_fn_InRange(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max);
HmlValue _mod0_fn_InRangeInt(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max);
HmlValue _mod0_fn_WrapInt(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max);
HmlValue _mod0_fn_Vector2LengthSq(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y);
HmlValue _mod0_fn_Vector2NormalizeGetLength(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y);
HmlValue _mod0_fn_Vector2ScaleX(HmlClosureEnv *_closure_env, HmlValue x, HmlValue scale);
HmlValue _mod0_fn_Vector2ScaleY(HmlClosureEnv *_closure_env, HmlValue y, HmlValue scale);
HmlValue _mod0_fn_Vector2AddX(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue x2);
HmlValue _mod0_fn_Vector2AddY(HmlClosureEnv *_closure_env, HmlValue y1, HmlValue y2);
HmlValue _mod0_fn_Vector2SubtractX(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue x2);
HmlValue _mod0_fn_Vector2SubtractY(HmlClosureEnv *_closure_env, HmlValue y1, HmlValue y2);
HmlValue _mod0_fn_Vector2NegateX(HmlClosureEnv *_closure_env, HmlValue x);
HmlValue _mod0_fn_Vector2NegateY(HmlClosureEnv *_closure_env, HmlValue y);
HmlValue _mod0_fn_Vector2RotateX(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y, HmlValue angle);
HmlValue _mod0_fn_Vector2RotateY(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y, HmlValue angle);
HmlValue _mod0_fn_Vector2LerpX(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue x2, HmlValue amount);
HmlValue _mod0_fn_Vector2LerpY(HmlClosureEnv *_closure_env, HmlValue y1, HmlValue y2, HmlValue amount);
HmlValue _mod0_fn_Vector2ReflectX(HmlClosureEnv *_closure_env, HmlValue vx, HmlValue vy, HmlValue nx, HmlValue ny);
HmlValue _mod0_fn_Vector2ReflectY(HmlClosureEnv *_closure_env, HmlValue vx, HmlValue vy, HmlValue nx, HmlValue ny);
HmlValue _mod0_fn_Vector2Angle(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue y1, HmlValue x2, HmlValue y2);
HmlValue _mod0_fn_Vector2AngleFromX(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y);
HmlValue _mod0_fn_Vector2MoveTowardsX(HmlClosureEnv *_closure_env, HmlValue currentX, HmlValue currentY, HmlValue targetX, HmlValue targetY, HmlValue maxDistance);
HmlValue _mod0_fn_Vector2MoveTowardsY(HmlClosureEnv *_closure_env, HmlValue currentX, HmlValue currentY, HmlValue targetX, HmlValue targetY, HmlValue maxDistance);
HmlValue _mod0_fn_CheckCollisionLinesXY(HmlClosureEnv *_closure_env, HmlValue p1x, HmlValue p1y, HmlValue p2x, HmlValue p2y, HmlValue p3x, HmlValue p3y, HmlValue p4x, HmlValue p4y);
HmlValue _mod0_fn_CheckCollisionPointTriangleXY(HmlClosureEnv *_closure_env, HmlValue px, HmlValue py, HmlValue ax, HmlValue ay, HmlValue bx, HmlValue by, HmlValue cx, HmlValue cy);
HmlValue _mod0_fn_CheckCollisionPointLineXY(HmlClosureEnv *_closure_env, HmlValue px, HmlValue py, HmlValue p1x, HmlValue p1y, HmlValue p2x, HmlValue p2y, HmlValue threshold);
HmlValue _mod0_fn_EaseLinear(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInQuad(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutQuad(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutQuad(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInCubic(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutCubic(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutCubic(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInQuart(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutQuart(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutQuart(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInQuint(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutQuint(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutQuint(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInSine(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutSine(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutSine(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInExpo(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutExpo(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutExpo(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInCirc(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutCirc(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutCirc(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInBack(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutBack(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutBack(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutBounce(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInBounce(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutBounce(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInElastic(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseOutElastic(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_EaseInOutElastic(HmlClosureEnv *_closure_env, HmlValue t);
HmlValue _mod0_fn_ColorBlend(HmlClosureEnv *_closure_env, HmlValue color1, HmlValue color2, HmlValue factor);
HmlValue _mod0_fn_ColorInvert(HmlClosureEnv *_closure_env, HmlValue color);
HmlValue _mod0_fn_ColorToGrayscale(HmlClosureEnv *_closure_env, HmlValue color);
HmlValue _mod0_fn_ColorTint(HmlClosureEnv *_closure_env, HmlValue color, HmlValue tint);
HmlValue _mod0_fn_ColorContrast(HmlClosureEnv *_closure_env, HmlValue color, HmlValue contrast);

// Module init function declarations
static void _mod1_init(void);
static void _mod0_init(void);

// Named function forward declarations
HmlValue hml_fn_InitWindow(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_CloseWindow(HmlClosureEnv *_closure_env);
HmlValue hml_fn_WindowShouldClose(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsWindowReady(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsWindowFullscreen(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsWindowHidden(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsWindowMinimized(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsWindowMaximized(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsWindowFocused(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsWindowResized(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsWindowState(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetWindowState(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ClearWindowState(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetWindowTitle(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetWindowPosition(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetWindowSize(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetWindowMinSize(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetWindowMaxSize(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_GetScreenWidth(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetScreenHeight(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetRenderWidth(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetRenderHeight(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetMonitorCount(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetCurrentMonitor(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetMonitorWidth(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetMonitorHeight(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetMonitorRefreshRate(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetMonitorPhysicalWidth(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetMonitorPhysicalHeight(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetMonitorName(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ToggleFullscreen(HmlClosureEnv *_closure_env);
HmlValue hml_fn_ToggleBorderlessWindowed(HmlClosureEnv *_closure_env);
HmlValue hml_fn_MaximizeWindow(HmlClosureEnv *_closure_env);
HmlValue hml_fn_MinimizeWindow(HmlClosureEnv *_closure_env);
HmlValue hml_fn_RestoreWindow(HmlClosureEnv *_closure_env);
HmlValue hml_fn_SetWindowOpacity(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetWindowFocused(HmlClosureEnv *_closure_env);
HmlValue hml_fn_SetWindowIcon(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetTargetFPS(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetFPS(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetFrameTime(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetTime(HmlClosureEnv *_closure_env);
HmlValue hml_fn_ClearBackground(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_BeginDrawing(HmlClosureEnv *_closure_env);
HmlValue hml_fn_EndDrawing(HmlClosureEnv *_closure_env);
HmlValue hml_fn_BeginBlendMode(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_EndBlendMode(HmlClosureEnv *_closure_env);
HmlValue hml_fn_BeginScissorMode(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_EndScissorMode(HmlClosureEnv *_closure_env);
HmlValue hml_fn_rlBegin(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_rlEnd(HmlClosureEnv *_closure_env);
HmlValue hml_fn_rlVertex2f(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_rlVertex2i(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_rlColor4ub(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_IsKeyPressed(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsKeyPressedRepeat(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsKeyDown(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsKeyReleased(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsKeyUp(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetKeyPressed(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetCharPressed(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetKeyName(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetExitKey(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsMouseButtonPressed(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsMouseButtonDown(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsMouseButtonReleased(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsMouseButtonUp(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetMouseX(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetMouseY(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetMousePosition(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetMouseDelta(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetMouseWheelMove(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetMouseWheelMoveV(HmlClosureEnv *_closure_env);
HmlValue hml_fn_SetMousePosition(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetMouseOffset(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetMouseScale(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetMouseCursor(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ShowCursor(HmlClosureEnv *_closure_env);
HmlValue hml_fn_HideCursor(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsCursorHidden(HmlClosureEnv *_closure_env);
HmlValue hml_fn_EnableCursor(HmlClosureEnv *_closure_env);
HmlValue hml_fn_DisableCursor(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsCursorOnScreen(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsGamepadAvailable(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetGamepadName(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsGamepadButtonPressed(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_IsGamepadButtonDown(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_IsGamepadButtonReleased(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_IsGamepadButtonUp(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_GetGamepadButtonPressed(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetGamepadAxisCount(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetGamepadAxisMovement(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetGamepadMappings(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetGamepadVibration(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_GetTouchX(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetTouchY(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetTouchPosition(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetTouchPointId(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetTouchPointCount(HmlClosureEnv *_closure_env);
HmlValue hml_fn_SetGesturesEnabled(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsGestureDetected(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetGestureDetected(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetGestureHoldDuration(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetGestureDragAngle(HmlClosureEnv *_closure_env);
HmlValue hml_fn_GetGesturePinchAngle(HmlClosureEnv *_closure_env);
HmlValue hml_fn_TraceLog(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetTraceLogLevel(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_DrawPixel(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawPixelV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_DrawLine(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawLineV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawLineEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawLineStrip(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawLineBezier(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawCircle(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawCircleV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawCircleGradient(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawCircleLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawCircleLinesV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawCircleSector(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_DrawCircleSectorLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_DrawRing(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5, HmlValue _arg6);
HmlValue hml_fn_DrawRingLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5, HmlValue _arg6);
HmlValue hml_fn_DrawEllipse(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawEllipseLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawRectangle(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawRectangleV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawRectangleRec(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_DrawRectanglePro(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawRectangleGradientV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_DrawRectangleGradientH(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_DrawRectangleGradientEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawRectangleLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawRectangleLinesEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawRectangleRounded(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawRectangleRoundedLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawRectangleRoundedLinesEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawTriangle(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawTriangleLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawTriangleFan(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawTriangleStrip(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawPoly(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawPolyLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawPolyLinesEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_DrawText(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_MeasureText(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_WaitTime(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetRandomValue(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetRandomSeed(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_TakeScreenshot(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetConfigFlags(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_OpenURL(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetClipboardText(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetClipboardText(HmlClosureEnv *_closure_env);
HmlValue hml_fn_CheckCollisionRecs(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_CheckCollisionCircles(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_CheckCollisionCircleRec(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_CheckCollisionPointRec(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_CheckCollisionPointCircle(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_CheckCollisionPointTriangle(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_CheckCollisionPointLine(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_CheckCollisionLines(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_GetCollisionRec(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_DrawFPS(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_InitAudioDevice(HmlClosureEnv *_closure_env);
HmlValue hml_fn_CloseAudioDevice(HmlClosureEnv *_closure_env);
HmlValue hml_fn_IsAudioDeviceReady(HmlClosureEnv *_closure_env);
HmlValue hml_fn_SetMasterVolume(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetMasterVolume(HmlClosureEnv *_closure_env);
HmlValue hml_fn_LoadTexture(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_LoadTextureFromImage(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_UnloadTexture(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsTextureValid(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_UpdateTexture(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_DrawTexture(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawTextureV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_DrawTextureEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_DrawTextureRec(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_DrawTexturePro(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_SetTextureFilter(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetTextureWrap(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_LoadRenderTexture(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_UnloadRenderTexture(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsRenderTextureValid(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_BeginTextureMode(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_EndTextureMode(HmlClosureEnv *_closure_env);
HmlValue hml_fn_LoadSound(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_UnloadSound(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsSoundValid(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_PlaySound(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_StopSound(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_PauseSound(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ResumeSound(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsSoundPlaying(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetSoundVolume(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetSoundPitch(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetSoundPan(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_LoadMusicStream(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_UnloadMusicStream(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsMusicValid(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_PlayMusicStream(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_StopMusicStream(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_PauseMusicStream(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ResumeMusicStream(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_UpdateMusicStream(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsMusicStreamPlaying(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SetMusicVolume(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetMusicPitch(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetMusicPan(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_GetMusicTimeLength(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetMusicTimePlayed(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SeekMusicStream(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_SetMusicLooping(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_LoadFont(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_LoadFontEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_UnloadFont(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsFontValid(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetFontDefault(HmlClosureEnv *_closure_env);
HmlValue hml_fn_DrawTextEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_DrawTextPro(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5, HmlValue _arg6, HmlValue _arg7);
HmlValue hml_fn_MeasureTextEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_LoadImage(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_LoadImageRaw(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_LoadImageFromMemory(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_UnloadImage(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsImageValid(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ExportImage(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_GenImageColor(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_GenImageGradientLinear(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_GenImageGradientRadial(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_GenImageChecked(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_GenImageWhiteNoise(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_GenImagePerlinNoise(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_ImageCopy(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ImageFromImage(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_ImageResize(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_ImageResizeNN(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_ImageCrop(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_ImageFlipVertical(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ImageFlipHorizontal(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ImageRotate(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_ImageRotateCW(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ImageRotateCCW(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ImageColorTint(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_ImageColorInvert(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ImageColorGrayscale(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_ImageColorContrast(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_ImageColorBrightness(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_ImageClearBackground(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_ImageDrawPixel(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_ImageDrawPixelV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_ImageDrawLine(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_ImageDrawLineV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_ImageDrawCircle(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4);
HmlValue hml_fn_ImageDrawCircleV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_ImageDrawRectangle(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_ImageDrawRectangleV(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3);
HmlValue hml_fn_ImageDrawRectangleRec(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2);
HmlValue hml_fn_ImageDrawText(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5);
HmlValue hml_fn_ImageDrawTextEx(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5, HmlValue _arg6);
HmlValue hml_fn_FileExists(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_DirectoryExists(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsFileExtension(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);
HmlValue hml_fn_GetFileExtension(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetFileName(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetFileNameWithoutExt(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetDirectoryPath(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetPrevDirectoryPath(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetWorkingDirectory(HmlClosureEnv *_closure_env);
HmlValue hml_fn_ChangeDirectory(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetFileLength(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetFileModTime(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_IsPathFile(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_GetApplicationDirectory(HmlClosureEnv *_closure_env);
HmlValue hml_fn_LoadFileText(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_UnloadFileText(HmlClosureEnv *_closure_env, HmlValue _arg0);
HmlValue hml_fn_SaveFileText(HmlClosureEnv *_closure_env, HmlValue _arg0, HmlValue _arg1);

// FFI wrapper for InitWindow
HmlValue hml_fn_InitWindow(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_InitWindow) {
        _ffi_ptr_InitWindow = hml_ffi_sym(_ffi_lib, "InitWindow");
        if (!_ffi_ptr_InitWindow) {
            hml_runtime_error("FFI function '%s' not found in library", "InitWindow");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_STRING;
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call(_ffi_ptr_InitWindow, _args, 3, _types);
}

// FFI wrapper for CloseWindow
HmlValue hml_fn_CloseWindow(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_CloseWindow) {
        _ffi_ptr_CloseWindow = hml_ffi_sym(_ffi_lib, "CloseWindow");
        if (!_ffi_ptr_CloseWindow) {
            hml_runtime_error("FFI function '%s' not found in library", "CloseWindow");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_CloseWindow, NULL, 0, _types);
}

// FFI wrapper for WindowShouldClose
HmlValue hml_fn_WindowShouldClose(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_WindowShouldClose) {
        _ffi_ptr_WindowShouldClose = hml_ffi_sym(_ffi_lib, "WindowShouldClose");
        if (!_ffi_ptr_WindowShouldClose) {
            hml_runtime_error("FFI function '%s' not found in library", "WindowShouldClose");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_WindowShouldClose, NULL, 0, _types);
}

// FFI wrapper for IsWindowReady
HmlValue hml_fn_IsWindowReady(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsWindowReady) {
        _ffi_ptr_IsWindowReady = hml_ffi_sym(_ffi_lib, "IsWindowReady");
        if (!_ffi_ptr_IsWindowReady) {
            hml_runtime_error("FFI function '%s' not found in library", "IsWindowReady");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsWindowReady, NULL, 0, _types);
}

// FFI wrapper for IsWindowFullscreen
HmlValue hml_fn_IsWindowFullscreen(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsWindowFullscreen) {
        _ffi_ptr_IsWindowFullscreen = hml_ffi_sym(_ffi_lib, "IsWindowFullscreen");
        if (!_ffi_ptr_IsWindowFullscreen) {
            hml_runtime_error("FFI function '%s' not found in library", "IsWindowFullscreen");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsWindowFullscreen, NULL, 0, _types);
}

// FFI wrapper for IsWindowHidden
HmlValue hml_fn_IsWindowHidden(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsWindowHidden) {
        _ffi_ptr_IsWindowHidden = hml_ffi_sym(_ffi_lib, "IsWindowHidden");
        if (!_ffi_ptr_IsWindowHidden) {
            hml_runtime_error("FFI function '%s' not found in library", "IsWindowHidden");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsWindowHidden, NULL, 0, _types);
}

// FFI wrapper for IsWindowMinimized
HmlValue hml_fn_IsWindowMinimized(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsWindowMinimized) {
        _ffi_ptr_IsWindowMinimized = hml_ffi_sym(_ffi_lib, "IsWindowMinimized");
        if (!_ffi_ptr_IsWindowMinimized) {
            hml_runtime_error("FFI function '%s' not found in library", "IsWindowMinimized");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsWindowMinimized, NULL, 0, _types);
}

// FFI wrapper for IsWindowMaximized
HmlValue hml_fn_IsWindowMaximized(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsWindowMaximized) {
        _ffi_ptr_IsWindowMaximized = hml_ffi_sym(_ffi_lib, "IsWindowMaximized");
        if (!_ffi_ptr_IsWindowMaximized) {
            hml_runtime_error("FFI function '%s' not found in library", "IsWindowMaximized");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsWindowMaximized, NULL, 0, _types);
}

// FFI wrapper for IsWindowFocused
HmlValue hml_fn_IsWindowFocused(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsWindowFocused) {
        _ffi_ptr_IsWindowFocused = hml_ffi_sym(_ffi_lib, "IsWindowFocused");
        if (!_ffi_ptr_IsWindowFocused) {
            hml_runtime_error("FFI function '%s' not found in library", "IsWindowFocused");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsWindowFocused, NULL, 0, _types);
}

// FFI wrapper for IsWindowResized
HmlValue hml_fn_IsWindowResized(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsWindowResized) {
        _ffi_ptr_IsWindowResized = hml_ffi_sym(_ffi_lib, "IsWindowResized");
        if (!_ffi_ptr_IsWindowResized) {
            hml_runtime_error("FFI function '%s' not found in library", "IsWindowResized");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsWindowResized, NULL, 0, _types);
}

// FFI wrapper for IsWindowState
HmlValue hml_fn_IsWindowState(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsWindowState) {
        _ffi_ptr_IsWindowState = hml_ffi_sym(_ffi_lib, "IsWindowState");
        if (!_ffi_ptr_IsWindowState) {
            hml_runtime_error("FFI function '%s' not found in library", "IsWindowState");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_U32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsWindowState, _args, 1, _types);
}

// FFI wrapper for SetWindowState
HmlValue hml_fn_SetWindowState(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetWindowState) {
        _ffi_ptr_SetWindowState = hml_ffi_sym(_ffi_lib, "SetWindowState");
        if (!_ffi_ptr_SetWindowState) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowState");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_U32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetWindowState, _args, 1, _types);
}

// FFI wrapper for ClearWindowState
HmlValue hml_fn_ClearWindowState(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ClearWindowState) {
        _ffi_ptr_ClearWindowState = hml_ffi_sym(_ffi_lib, "ClearWindowState");
        if (!_ffi_ptr_ClearWindowState) {
            hml_runtime_error("FFI function '%s' not found in library", "ClearWindowState");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_U32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ClearWindowState, _args, 1, _types);
}

// FFI wrapper for SetWindowTitle
HmlValue hml_fn_SetWindowTitle(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetWindowTitle) {
        _ffi_ptr_SetWindowTitle = hml_ffi_sym(_ffi_lib, "SetWindowTitle");
        if (!_ffi_ptr_SetWindowTitle) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowTitle");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetWindowTitle, _args, 1, _types);
}

// FFI wrapper for SetWindowPosition
HmlValue hml_fn_SetWindowPosition(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetWindowPosition) {
        _ffi_ptr_SetWindowPosition = hml_ffi_sym(_ffi_lib, "SetWindowPosition");
        if (!_ffi_ptr_SetWindowPosition) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowPosition");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_SetWindowPosition, _args, 2, _types);
}

// FFI wrapper for SetWindowSize
HmlValue hml_fn_SetWindowSize(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetWindowSize) {
        _ffi_ptr_SetWindowSize = hml_ffi_sym(_ffi_lib, "SetWindowSize");
        if (!_ffi_ptr_SetWindowSize) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowSize");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_SetWindowSize, _args, 2, _types);
}

// FFI wrapper for SetWindowMinSize
HmlValue hml_fn_SetWindowMinSize(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetWindowMinSize) {
        _ffi_ptr_SetWindowMinSize = hml_ffi_sym(_ffi_lib, "SetWindowMinSize");
        if (!_ffi_ptr_SetWindowMinSize) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowMinSize");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_SetWindowMinSize, _args, 2, _types);
}

// FFI wrapper for SetWindowMaxSize
HmlValue hml_fn_SetWindowMaxSize(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetWindowMaxSize) {
        _ffi_ptr_SetWindowMaxSize = hml_ffi_sym(_ffi_lib, "SetWindowMaxSize");
        if (!_ffi_ptr_SetWindowMaxSize) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowMaxSize");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_SetWindowMaxSize, _args, 2, _types);
}

// FFI wrapper for GetScreenWidth
HmlValue hml_fn_GetScreenWidth(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetScreenWidth) {
        _ffi_ptr_GetScreenWidth = hml_ffi_sym(_ffi_lib, "GetScreenWidth");
        if (!_ffi_ptr_GetScreenWidth) {
            hml_runtime_error("FFI function '%s' not found in library", "GetScreenWidth");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetScreenWidth, NULL, 0, _types);
}

// FFI wrapper for GetScreenHeight
HmlValue hml_fn_GetScreenHeight(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetScreenHeight) {
        _ffi_ptr_GetScreenHeight = hml_ffi_sym(_ffi_lib, "GetScreenHeight");
        if (!_ffi_ptr_GetScreenHeight) {
            hml_runtime_error("FFI function '%s' not found in library", "GetScreenHeight");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetScreenHeight, NULL, 0, _types);
}

// FFI wrapper for GetRenderWidth
HmlValue hml_fn_GetRenderWidth(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetRenderWidth) {
        _ffi_ptr_GetRenderWidth = hml_ffi_sym(_ffi_lib, "GetRenderWidth");
        if (!_ffi_ptr_GetRenderWidth) {
            hml_runtime_error("FFI function '%s' not found in library", "GetRenderWidth");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetRenderWidth, NULL, 0, _types);
}

// FFI wrapper for GetRenderHeight
HmlValue hml_fn_GetRenderHeight(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetRenderHeight) {
        _ffi_ptr_GetRenderHeight = hml_ffi_sym(_ffi_lib, "GetRenderHeight");
        if (!_ffi_ptr_GetRenderHeight) {
            hml_runtime_error("FFI function '%s' not found in library", "GetRenderHeight");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetRenderHeight, NULL, 0, _types);
}

// FFI wrapper for GetMonitorCount
HmlValue hml_fn_GetMonitorCount(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetMonitorCount) {
        _ffi_ptr_GetMonitorCount = hml_ffi_sym(_ffi_lib, "GetMonitorCount");
        if (!_ffi_ptr_GetMonitorCount) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMonitorCount");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetMonitorCount, NULL, 0, _types);
}

// FFI wrapper for GetCurrentMonitor
HmlValue hml_fn_GetCurrentMonitor(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetCurrentMonitor) {
        _ffi_ptr_GetCurrentMonitor = hml_ffi_sym(_ffi_lib, "GetCurrentMonitor");
        if (!_ffi_ptr_GetCurrentMonitor) {
            hml_runtime_error("FFI function '%s' not found in library", "GetCurrentMonitor");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetCurrentMonitor, NULL, 0, _types);
}

// FFI wrapper for GetMonitorWidth
HmlValue hml_fn_GetMonitorWidth(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetMonitorWidth) {
        _ffi_ptr_GetMonitorWidth = hml_ffi_sym(_ffi_lib, "GetMonitorWidth");
        if (!_ffi_ptr_GetMonitorWidth) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMonitorWidth");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetMonitorWidth, _args, 1, _types);
}

// FFI wrapper for GetMonitorHeight
HmlValue hml_fn_GetMonitorHeight(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetMonitorHeight) {
        _ffi_ptr_GetMonitorHeight = hml_ffi_sym(_ffi_lib, "GetMonitorHeight");
        if (!_ffi_ptr_GetMonitorHeight) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMonitorHeight");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetMonitorHeight, _args, 1, _types);
}

// FFI wrapper for GetMonitorRefreshRate
HmlValue hml_fn_GetMonitorRefreshRate(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetMonitorRefreshRate) {
        _ffi_ptr_GetMonitorRefreshRate = hml_ffi_sym(_ffi_lib, "GetMonitorRefreshRate");
        if (!_ffi_ptr_GetMonitorRefreshRate) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMonitorRefreshRate");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetMonitorRefreshRate, _args, 1, _types);
}

// FFI wrapper for GetMonitorPhysicalWidth
HmlValue hml_fn_GetMonitorPhysicalWidth(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetMonitorPhysicalWidth) {
        _ffi_ptr_GetMonitorPhysicalWidth = hml_ffi_sym(_ffi_lib, "GetMonitorPhysicalWidth");
        if (!_ffi_ptr_GetMonitorPhysicalWidth) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMonitorPhysicalWidth");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetMonitorPhysicalWidth, _args, 1, _types);
}

// FFI wrapper for GetMonitorPhysicalHeight
HmlValue hml_fn_GetMonitorPhysicalHeight(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetMonitorPhysicalHeight) {
        _ffi_ptr_GetMonitorPhysicalHeight = hml_ffi_sym(_ffi_lib, "GetMonitorPhysicalHeight");
        if (!_ffi_ptr_GetMonitorPhysicalHeight) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMonitorPhysicalHeight");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetMonitorPhysicalHeight, _args, 1, _types);
}

// FFI wrapper for GetMonitorName
HmlValue hml_fn_GetMonitorName(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetMonitorName) {
        _ffi_ptr_GetMonitorName = hml_ffi_sym(_ffi_lib, "GetMonitorName");
        if (!_ffi_ptr_GetMonitorName) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMonitorName");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetMonitorName, _args, 1, _types);
}

// FFI wrapper for ToggleFullscreen
HmlValue hml_fn_ToggleFullscreen(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_ToggleFullscreen) {
        _ffi_ptr_ToggleFullscreen = hml_ffi_sym(_ffi_lib, "ToggleFullscreen");
        if (!_ffi_ptr_ToggleFullscreen) {
            hml_runtime_error("FFI function '%s' not found in library", "ToggleFullscreen");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_ToggleFullscreen, NULL, 0, _types);
}

// FFI wrapper for ToggleBorderlessWindowed
HmlValue hml_fn_ToggleBorderlessWindowed(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_ToggleBorderlessWindowed) {
        _ffi_ptr_ToggleBorderlessWindowed = hml_ffi_sym(_ffi_lib, "ToggleBorderlessWindowed");
        if (!_ffi_ptr_ToggleBorderlessWindowed) {
            hml_runtime_error("FFI function '%s' not found in library", "ToggleBorderlessWindowed");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_ToggleBorderlessWindowed, NULL, 0, _types);
}

// FFI wrapper for MaximizeWindow
HmlValue hml_fn_MaximizeWindow(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_MaximizeWindow) {
        _ffi_ptr_MaximizeWindow = hml_ffi_sym(_ffi_lib, "MaximizeWindow");
        if (!_ffi_ptr_MaximizeWindow) {
            hml_runtime_error("FFI function '%s' not found in library", "MaximizeWindow");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_MaximizeWindow, NULL, 0, _types);
}

// FFI wrapper for MinimizeWindow
HmlValue hml_fn_MinimizeWindow(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_MinimizeWindow) {
        _ffi_ptr_MinimizeWindow = hml_ffi_sym(_ffi_lib, "MinimizeWindow");
        if (!_ffi_ptr_MinimizeWindow) {
            hml_runtime_error("FFI function '%s' not found in library", "MinimizeWindow");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_MinimizeWindow, NULL, 0, _types);
}

// FFI wrapper for RestoreWindow
HmlValue hml_fn_RestoreWindow(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_RestoreWindow) {
        _ffi_ptr_RestoreWindow = hml_ffi_sym(_ffi_lib, "RestoreWindow");
        if (!_ffi_ptr_RestoreWindow) {
            hml_runtime_error("FFI function '%s' not found in library", "RestoreWindow");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_RestoreWindow, NULL, 0, _types);
}

// FFI wrapper for SetWindowOpacity
HmlValue hml_fn_SetWindowOpacity(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetWindowOpacity) {
        _ffi_ptr_SetWindowOpacity = hml_ffi_sym(_ffi_lib, "SetWindowOpacity");
        if (!_ffi_ptr_SetWindowOpacity) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowOpacity");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_F32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetWindowOpacity, _args, 1, _types);
}

// FFI wrapper for SetWindowFocused
HmlValue hml_fn_SetWindowFocused(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_SetWindowFocused) {
        _ffi_ptr_SetWindowFocused = hml_ffi_sym(_ffi_lib, "SetWindowFocused");
        if (!_ffi_ptr_SetWindowFocused) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowFocused");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_SetWindowFocused, NULL, 0, _types);
}

// FFI wrapper for SetWindowIcon
HmlValue hml_fn_SetWindowIcon(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetWindowIcon) {
        _ffi_ptr_SetWindowIcon = hml_ffi_sym(_ffi_lib, "SetWindowIcon");
        if (!_ffi_ptr_SetWindowIcon) {
            hml_runtime_error("FFI function '%s' not found in library", "SetWindowIcon");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetWindowIcon, _args, 1, _types);
}

// FFI wrapper for SetTargetFPS
HmlValue hml_fn_SetTargetFPS(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetTargetFPS) {
        _ffi_ptr_SetTargetFPS = hml_ffi_sym(_ffi_lib, "SetTargetFPS");
        if (!_ffi_ptr_SetTargetFPS) {
            hml_runtime_error("FFI function '%s' not found in library", "SetTargetFPS");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetTargetFPS, _args, 1, _types);
}

// FFI wrapper for GetFPS
HmlValue hml_fn_GetFPS(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetFPS) {
        _ffi_ptr_GetFPS = hml_ffi_sym(_ffi_lib, "GetFPS");
        if (!_ffi_ptr_GetFPS) {
            hml_runtime_error("FFI function '%s' not found in library", "GetFPS");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetFPS, NULL, 0, _types);
}

// FFI wrapper for GetFrameTime
HmlValue hml_fn_GetFrameTime(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetFrameTime) {
        _ffi_ptr_GetFrameTime = hml_ffi_sym(_ffi_lib, "GetFrameTime");
        if (!_ffi_ptr_GetFrameTime) {
            hml_runtime_error("FFI function '%s' not found in library", "GetFrameTime");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_F32;
    return hml_ffi_call(_ffi_ptr_GetFrameTime, NULL, 0, _types);
}

// FFI wrapper for GetTime
HmlValue hml_fn_GetTime(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetTime) {
        _ffi_ptr_GetTime = hml_ffi_sym(_ffi_lib, "GetTime");
        if (!_ffi_ptr_GetTime) {
            hml_runtime_error("FFI function '%s' not found in library", "GetTime");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_F64;
    return hml_ffi_call(_ffi_ptr_GetTime, NULL, 0, _types);
}

// FFI wrapper for ClearBackground
HmlValue hml_fn_ClearBackground(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ClearBackground) {
        _ffi_ptr_ClearBackground = hml_ffi_sym(_ffi_lib, "ClearBackground");
        if (!_ffi_ptr_ClearBackground) {
            hml_runtime_error("FFI function '%s' not found in library", "ClearBackground");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_U32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ClearBackground, _args, 1, _types);
}

// FFI wrapper for BeginDrawing
HmlValue hml_fn_BeginDrawing(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_BeginDrawing) {
        _ffi_ptr_BeginDrawing = hml_ffi_sym(_ffi_lib, "BeginDrawing");
        if (!_ffi_ptr_BeginDrawing) {
            hml_runtime_error("FFI function '%s' not found in library", "BeginDrawing");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_BeginDrawing, NULL, 0, _types);
}

// FFI wrapper for EndDrawing
HmlValue hml_fn_EndDrawing(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_EndDrawing) {
        _ffi_ptr_EndDrawing = hml_ffi_sym(_ffi_lib, "EndDrawing");
        if (!_ffi_ptr_EndDrawing) {
            hml_runtime_error("FFI function '%s' not found in library", "EndDrawing");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_EndDrawing, NULL, 0, _types);
}

// FFI wrapper for BeginBlendMode
HmlValue hml_fn_BeginBlendMode(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_BeginBlendMode) {
        _ffi_ptr_BeginBlendMode = hml_ffi_sym(_ffi_lib, "BeginBlendMode");
        if (!_ffi_ptr_BeginBlendMode) {
            hml_runtime_error("FFI function '%s' not found in library", "BeginBlendMode");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_BeginBlendMode, _args, 1, _types);
}

// FFI wrapper for EndBlendMode
HmlValue hml_fn_EndBlendMode(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_EndBlendMode) {
        _ffi_ptr_EndBlendMode = hml_ffi_sym(_ffi_lib, "EndBlendMode");
        if (!_ffi_ptr_EndBlendMode) {
            hml_runtime_error("FFI function '%s' not found in library", "EndBlendMode");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_EndBlendMode, NULL, 0, _types);
}

// FFI wrapper for BeginScissorMode
HmlValue hml_fn_BeginScissorMode(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_BeginScissorMode) {
        _ffi_ptr_BeginScissorMode = hml_ffi_sym(_ffi_lib, "BeginScissorMode");
        if (!_ffi_ptr_BeginScissorMode) {
            hml_runtime_error("FFI function '%s' not found in library", "BeginScissorMode");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call(_ffi_ptr_BeginScissorMode, _args, 4, _types);
}

// FFI wrapper for EndScissorMode
HmlValue hml_fn_EndScissorMode(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_EndScissorMode) {
        _ffi_ptr_EndScissorMode = hml_ffi_sym(_ffi_lib, "EndScissorMode");
        if (!_ffi_ptr_EndScissorMode) {
            hml_runtime_error("FFI function '%s' not found in library", "EndScissorMode");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_EndScissorMode, NULL, 0, _types);
}

// FFI wrapper for rlBegin
HmlValue hml_fn_rlBegin(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_rlBegin) {
        _ffi_ptr_rlBegin = hml_ffi_sym(_ffi_lib, "rlBegin");
        if (!_ffi_ptr_rlBegin) {
            hml_runtime_error("FFI function '%s' not found in library", "rlBegin");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_rlBegin, _args, 1, _types);
}

// FFI wrapper for rlEnd
HmlValue hml_fn_rlEnd(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_rlEnd) {
        _ffi_ptr_rlEnd = hml_ffi_sym(_ffi_lib, "rlEnd");
        if (!_ffi_ptr_rlEnd) {
            hml_runtime_error("FFI function '%s' not found in library", "rlEnd");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_rlEnd, NULL, 0, _types);
}

// FFI wrapper for rlVertex2f
HmlValue hml_fn_rlVertex2f(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_rlVertex2f) {
        _ffi_ptr_rlVertex2f = hml_ffi_sym(_ffi_lib, "rlVertex2f");
        if (!_ffi_ptr_rlVertex2f) {
            hml_runtime_error("FFI function '%s' not found in library", "rlVertex2f");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_F32;
    _types[2] = HML_FFI_F32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_rlVertex2f, _args, 2, _types);
}

// FFI wrapper for rlVertex2i
HmlValue hml_fn_rlVertex2i(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_rlVertex2i) {
        _ffi_ptr_rlVertex2i = hml_ffi_sym(_ffi_lib, "rlVertex2i");
        if (!_ffi_ptr_rlVertex2i) {
            hml_runtime_error("FFI function '%s' not found in library", "rlVertex2i");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_rlVertex2i, _args, 2, _types);
}

// FFI wrapper for rlColor4ub
HmlValue hml_fn_rlColor4ub(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_rlColor4ub) {
        _ffi_ptr_rlColor4ub = hml_ffi_sym(_ffi_lib, "rlColor4ub");
        if (!_ffi_ptr_rlColor4ub) {
            hml_runtime_error("FFI function '%s' not found in library", "rlColor4ub");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_U8;
    _types[2] = HML_FFI_U8;
    _types[3] = HML_FFI_U8;
    _types[4] = HML_FFI_U8;
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call(_ffi_ptr_rlColor4ub, _args, 4, _types);
}

// FFI wrapper for IsKeyPressed
HmlValue hml_fn_IsKeyPressed(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsKeyPressed) {
        _ffi_ptr_IsKeyPressed = hml_ffi_sym(_ffi_lib, "IsKeyPressed");
        if (!_ffi_ptr_IsKeyPressed) {
            hml_runtime_error("FFI function '%s' not found in library", "IsKeyPressed");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsKeyPressed, _args, 1, _types);
}

// FFI wrapper for IsKeyPressedRepeat
HmlValue hml_fn_IsKeyPressedRepeat(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsKeyPressedRepeat) {
        _ffi_ptr_IsKeyPressedRepeat = hml_ffi_sym(_ffi_lib, "IsKeyPressedRepeat");
        if (!_ffi_ptr_IsKeyPressedRepeat) {
            hml_runtime_error("FFI function '%s' not found in library", "IsKeyPressedRepeat");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsKeyPressedRepeat, _args, 1, _types);
}

// FFI wrapper for IsKeyDown
HmlValue hml_fn_IsKeyDown(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsKeyDown) {
        _ffi_ptr_IsKeyDown = hml_ffi_sym(_ffi_lib, "IsKeyDown");
        if (!_ffi_ptr_IsKeyDown) {
            hml_runtime_error("FFI function '%s' not found in library", "IsKeyDown");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsKeyDown, _args, 1, _types);
}

// FFI wrapper for IsKeyReleased
HmlValue hml_fn_IsKeyReleased(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsKeyReleased) {
        _ffi_ptr_IsKeyReleased = hml_ffi_sym(_ffi_lib, "IsKeyReleased");
        if (!_ffi_ptr_IsKeyReleased) {
            hml_runtime_error("FFI function '%s' not found in library", "IsKeyReleased");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsKeyReleased, _args, 1, _types);
}

// FFI wrapper for IsKeyUp
HmlValue hml_fn_IsKeyUp(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsKeyUp) {
        _ffi_ptr_IsKeyUp = hml_ffi_sym(_ffi_lib, "IsKeyUp");
        if (!_ffi_ptr_IsKeyUp) {
            hml_runtime_error("FFI function '%s' not found in library", "IsKeyUp");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsKeyUp, _args, 1, _types);
}

// FFI wrapper for GetKeyPressed
HmlValue hml_fn_GetKeyPressed(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetKeyPressed) {
        _ffi_ptr_GetKeyPressed = hml_ffi_sym(_ffi_lib, "GetKeyPressed");
        if (!_ffi_ptr_GetKeyPressed) {
            hml_runtime_error("FFI function '%s' not found in library", "GetKeyPressed");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetKeyPressed, NULL, 0, _types);
}

// FFI wrapper for GetCharPressed
HmlValue hml_fn_GetCharPressed(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetCharPressed) {
        _ffi_ptr_GetCharPressed = hml_ffi_sym(_ffi_lib, "GetCharPressed");
        if (!_ffi_ptr_GetCharPressed) {
            hml_runtime_error("FFI function '%s' not found in library", "GetCharPressed");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetCharPressed, NULL, 0, _types);
}

// FFI wrapper for GetKeyName
HmlValue hml_fn_GetKeyName(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetKeyName) {
        _ffi_ptr_GetKeyName = hml_ffi_sym(_ffi_lib, "GetKeyName");
        if (!_ffi_ptr_GetKeyName) {
            hml_runtime_error("FFI function '%s' not found in library", "GetKeyName");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetKeyName, _args, 1, _types);
}

// FFI wrapper for SetExitKey
HmlValue hml_fn_SetExitKey(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetExitKey) {
        _ffi_ptr_SetExitKey = hml_ffi_sym(_ffi_lib, "SetExitKey");
        if (!_ffi_ptr_SetExitKey) {
            hml_runtime_error("FFI function '%s' not found in library", "SetExitKey");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetExitKey, _args, 1, _types);
}

// FFI wrapper for IsMouseButtonPressed
HmlValue hml_fn_IsMouseButtonPressed(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsMouseButtonPressed) {
        _ffi_ptr_IsMouseButtonPressed = hml_ffi_sym(_ffi_lib, "IsMouseButtonPressed");
        if (!_ffi_ptr_IsMouseButtonPressed) {
            hml_runtime_error("FFI function '%s' not found in library", "IsMouseButtonPressed");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsMouseButtonPressed, _args, 1, _types);
}

// FFI wrapper for IsMouseButtonDown
HmlValue hml_fn_IsMouseButtonDown(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsMouseButtonDown) {
        _ffi_ptr_IsMouseButtonDown = hml_ffi_sym(_ffi_lib, "IsMouseButtonDown");
        if (!_ffi_ptr_IsMouseButtonDown) {
            hml_runtime_error("FFI function '%s' not found in library", "IsMouseButtonDown");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsMouseButtonDown, _args, 1, _types);
}

// FFI wrapper for IsMouseButtonReleased
HmlValue hml_fn_IsMouseButtonReleased(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsMouseButtonReleased) {
        _ffi_ptr_IsMouseButtonReleased = hml_ffi_sym(_ffi_lib, "IsMouseButtonReleased");
        if (!_ffi_ptr_IsMouseButtonReleased) {
            hml_runtime_error("FFI function '%s' not found in library", "IsMouseButtonReleased");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsMouseButtonReleased, _args, 1, _types);
}

// FFI wrapper for IsMouseButtonUp
HmlValue hml_fn_IsMouseButtonUp(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsMouseButtonUp) {
        _ffi_ptr_IsMouseButtonUp = hml_ffi_sym(_ffi_lib, "IsMouseButtonUp");
        if (!_ffi_ptr_IsMouseButtonUp) {
            hml_runtime_error("FFI function '%s' not found in library", "IsMouseButtonUp");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsMouseButtonUp, _args, 1, _types);
}

// FFI wrapper for GetMouseX
HmlValue hml_fn_GetMouseX(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetMouseX) {
        _ffi_ptr_GetMouseX = hml_ffi_sym(_ffi_lib, "GetMouseX");
        if (!_ffi_ptr_GetMouseX) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMouseX");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetMouseX, NULL, 0, _types);
}

// FFI wrapper for GetMouseY
HmlValue hml_fn_GetMouseY(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetMouseY) {
        _ffi_ptr_GetMouseY = hml_ffi_sym(_ffi_lib, "GetMouseY");
        if (!_ffi_ptr_GetMouseY) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMouseY");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetMouseY, NULL, 0, _types);
}

// FFI wrapper for GetMousePosition
HmlValue hml_fn_GetMousePosition(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetMousePosition) {
        _ffi_ptr_GetMousePosition = hml_ffi_sym(_ffi_lib, "GetMousePosition");
        if (!_ffi_ptr_GetMousePosition) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMousePosition");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_STRUCT;
    static const char *_struct_names[1] = {
        "Vector2"
    };
    return hml_ffi_call_with_structs(_ffi_ptr_GetMousePosition, NULL, 0, _types, _struct_names);
}

// FFI wrapper for GetMouseDelta
HmlValue hml_fn_GetMouseDelta(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetMouseDelta) {
        _ffi_ptr_GetMouseDelta = hml_ffi_sym(_ffi_lib, "GetMouseDelta");
        if (!_ffi_ptr_GetMouseDelta) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMouseDelta");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_STRUCT;
    static const char *_struct_names[1] = {
        "Vector2"
    };
    return hml_ffi_call_with_structs(_ffi_ptr_GetMouseDelta, NULL, 0, _types, _struct_names);
}

// FFI wrapper for GetMouseWheelMove
HmlValue hml_fn_GetMouseWheelMove(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetMouseWheelMove) {
        _ffi_ptr_GetMouseWheelMove = hml_ffi_sym(_ffi_lib, "GetMouseWheelMove");
        if (!_ffi_ptr_GetMouseWheelMove) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMouseWheelMove");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_F32;
    return hml_ffi_call(_ffi_ptr_GetMouseWheelMove, NULL, 0, _types);
}

// FFI wrapper for GetMouseWheelMoveV
HmlValue hml_fn_GetMouseWheelMoveV(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetMouseWheelMoveV) {
        _ffi_ptr_GetMouseWheelMoveV = hml_ffi_sym(_ffi_lib, "GetMouseWheelMoveV");
        if (!_ffi_ptr_GetMouseWheelMoveV) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMouseWheelMoveV");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_STRUCT;
    static const char *_struct_names[1] = {
        "Vector2"
    };
    return hml_ffi_call_with_structs(_ffi_ptr_GetMouseWheelMoveV, NULL, 0, _types, _struct_names);
}

// FFI wrapper for SetMousePosition
HmlValue hml_fn_SetMousePosition(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetMousePosition) {
        _ffi_ptr_SetMousePosition = hml_ffi_sym(_ffi_lib, "SetMousePosition");
        if (!_ffi_ptr_SetMousePosition) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMousePosition");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_SetMousePosition, _args, 2, _types);
}

// FFI wrapper for SetMouseOffset
HmlValue hml_fn_SetMouseOffset(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetMouseOffset) {
        _ffi_ptr_SetMouseOffset = hml_ffi_sym(_ffi_lib, "SetMouseOffset");
        if (!_ffi_ptr_SetMouseOffset) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMouseOffset");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_SetMouseOffset, _args, 2, _types);
}

// FFI wrapper for SetMouseScale
HmlValue hml_fn_SetMouseScale(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetMouseScale) {
        _ffi_ptr_SetMouseScale = hml_ffi_sym(_ffi_lib, "SetMouseScale");
        if (!_ffi_ptr_SetMouseScale) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMouseScale");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_F32;
    _types[2] = HML_FFI_F32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_SetMouseScale, _args, 2, _types);
}

// FFI wrapper for SetMouseCursor
HmlValue hml_fn_SetMouseCursor(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetMouseCursor) {
        _ffi_ptr_SetMouseCursor = hml_ffi_sym(_ffi_lib, "SetMouseCursor");
        if (!_ffi_ptr_SetMouseCursor) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMouseCursor");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetMouseCursor, _args, 1, _types);
}

// FFI wrapper for ShowCursor
HmlValue hml_fn_ShowCursor(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_ShowCursor) {
        _ffi_ptr_ShowCursor = hml_ffi_sym(_ffi_lib, "ShowCursor");
        if (!_ffi_ptr_ShowCursor) {
            hml_runtime_error("FFI function '%s' not found in library", "ShowCursor");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_ShowCursor, NULL, 0, _types);
}

// FFI wrapper for HideCursor
HmlValue hml_fn_HideCursor(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_HideCursor) {
        _ffi_ptr_HideCursor = hml_ffi_sym(_ffi_lib, "HideCursor");
        if (!_ffi_ptr_HideCursor) {
            hml_runtime_error("FFI function '%s' not found in library", "HideCursor");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_HideCursor, NULL, 0, _types);
}

// FFI wrapper for IsCursorHidden
HmlValue hml_fn_IsCursorHidden(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsCursorHidden) {
        _ffi_ptr_IsCursorHidden = hml_ffi_sym(_ffi_lib, "IsCursorHidden");
        if (!_ffi_ptr_IsCursorHidden) {
            hml_runtime_error("FFI function '%s' not found in library", "IsCursorHidden");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsCursorHidden, NULL, 0, _types);
}

// FFI wrapper for EnableCursor
HmlValue hml_fn_EnableCursor(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_EnableCursor) {
        _ffi_ptr_EnableCursor = hml_ffi_sym(_ffi_lib, "EnableCursor");
        if (!_ffi_ptr_EnableCursor) {
            hml_runtime_error("FFI function '%s' not found in library", "EnableCursor");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_EnableCursor, NULL, 0, _types);
}

// FFI wrapper for DisableCursor
HmlValue hml_fn_DisableCursor(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_DisableCursor) {
        _ffi_ptr_DisableCursor = hml_ffi_sym(_ffi_lib, "DisableCursor");
        if (!_ffi_ptr_DisableCursor) {
            hml_runtime_error("FFI function '%s' not found in library", "DisableCursor");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_DisableCursor, NULL, 0, _types);
}

// FFI wrapper for IsCursorOnScreen
HmlValue hml_fn_IsCursorOnScreen(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsCursorOnScreen) {
        _ffi_ptr_IsCursorOnScreen = hml_ffi_sym(_ffi_lib, "IsCursorOnScreen");
        if (!_ffi_ptr_IsCursorOnScreen) {
            hml_runtime_error("FFI function '%s' not found in library", "IsCursorOnScreen");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsCursorOnScreen, NULL, 0, _types);
}

// FFI wrapper for IsGamepadAvailable
HmlValue hml_fn_IsGamepadAvailable(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsGamepadAvailable) {
        _ffi_ptr_IsGamepadAvailable = hml_ffi_sym(_ffi_lib, "IsGamepadAvailable");
        if (!_ffi_ptr_IsGamepadAvailable) {
            hml_runtime_error("FFI function '%s' not found in library", "IsGamepadAvailable");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsGamepadAvailable, _args, 1, _types);
}

// FFI wrapper for GetGamepadName
HmlValue hml_fn_GetGamepadName(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetGamepadName) {
        _ffi_ptr_GetGamepadName = hml_ffi_sym(_ffi_lib, "GetGamepadName");
        if (!_ffi_ptr_GetGamepadName) {
            hml_runtime_error("FFI function '%s' not found in library", "GetGamepadName");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetGamepadName, _args, 1, _types);
}

// FFI wrapper for IsGamepadButtonPressed
HmlValue hml_fn_IsGamepadButtonPressed(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_IsGamepadButtonPressed) {
        _ffi_ptr_IsGamepadButtonPressed = hml_ffi_sym(_ffi_lib, "IsGamepadButtonPressed");
        if (!_ffi_ptr_IsGamepadButtonPressed) {
            hml_runtime_error("FFI function '%s' not found in library", "IsGamepadButtonPressed");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_IsGamepadButtonPressed, _args, 2, _types);
}

// FFI wrapper for IsGamepadButtonDown
HmlValue hml_fn_IsGamepadButtonDown(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_IsGamepadButtonDown) {
        _ffi_ptr_IsGamepadButtonDown = hml_ffi_sym(_ffi_lib, "IsGamepadButtonDown");
        if (!_ffi_ptr_IsGamepadButtonDown) {
            hml_runtime_error("FFI function '%s' not found in library", "IsGamepadButtonDown");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_IsGamepadButtonDown, _args, 2, _types);
}

// FFI wrapper for IsGamepadButtonReleased
HmlValue hml_fn_IsGamepadButtonReleased(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_IsGamepadButtonReleased) {
        _ffi_ptr_IsGamepadButtonReleased = hml_ffi_sym(_ffi_lib, "IsGamepadButtonReleased");
        if (!_ffi_ptr_IsGamepadButtonReleased) {
            hml_runtime_error("FFI function '%s' not found in library", "IsGamepadButtonReleased");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_IsGamepadButtonReleased, _args, 2, _types);
}

// FFI wrapper for IsGamepadButtonUp
HmlValue hml_fn_IsGamepadButtonUp(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_IsGamepadButtonUp) {
        _ffi_ptr_IsGamepadButtonUp = hml_ffi_sym(_ffi_lib, "IsGamepadButtonUp");
        if (!_ffi_ptr_IsGamepadButtonUp) {
            hml_runtime_error("FFI function '%s' not found in library", "IsGamepadButtonUp");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_IsGamepadButtonUp, _args, 2, _types);
}

// FFI wrapper for GetGamepadButtonPressed
HmlValue hml_fn_GetGamepadButtonPressed(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetGamepadButtonPressed) {
        _ffi_ptr_GetGamepadButtonPressed = hml_ffi_sym(_ffi_lib, "GetGamepadButtonPressed");
        if (!_ffi_ptr_GetGamepadButtonPressed) {
            hml_runtime_error("FFI function '%s' not found in library", "GetGamepadButtonPressed");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetGamepadButtonPressed, NULL, 0, _types);
}

// FFI wrapper for GetGamepadAxisCount
HmlValue hml_fn_GetGamepadAxisCount(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetGamepadAxisCount) {
        _ffi_ptr_GetGamepadAxisCount = hml_ffi_sym(_ffi_lib, "GetGamepadAxisCount");
        if (!_ffi_ptr_GetGamepadAxisCount) {
            hml_runtime_error("FFI function '%s' not found in library", "GetGamepadAxisCount");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetGamepadAxisCount, _args, 1, _types);
}

// FFI wrapper for GetGamepadAxisMovement
HmlValue hml_fn_GetGamepadAxisMovement(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_GetGamepadAxisMovement) {
        _ffi_ptr_GetGamepadAxisMovement = hml_ffi_sym(_ffi_lib, "GetGamepadAxisMovement");
        if (!_ffi_ptr_GetGamepadAxisMovement) {
            hml_runtime_error("FFI function '%s' not found in library", "GetGamepadAxisMovement");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_F32;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_GetGamepadAxisMovement, _args, 2, _types);
}

// FFI wrapper for SetGamepadMappings
HmlValue hml_fn_SetGamepadMappings(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetGamepadMappings) {
        _ffi_ptr_SetGamepadMappings = hml_ffi_sym(_ffi_lib, "SetGamepadMappings");
        if (!_ffi_ptr_SetGamepadMappings) {
            hml_runtime_error("FFI function '%s' not found in library", "SetGamepadMappings");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetGamepadMappings, _args, 1, _types);
}

// FFI wrapper for SetGamepadVibration
HmlValue hml_fn_SetGamepadVibration(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_SetGamepadVibration) {
        _ffi_ptr_SetGamepadVibration = hml_ffi_sym(_ffi_lib, "SetGamepadVibration");
        if (!_ffi_ptr_SetGamepadVibration) {
            hml_runtime_error("FFI function '%s' not found in library", "SetGamepadVibration");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call(_ffi_ptr_SetGamepadVibration, _args, 4, _types);
}

// FFI wrapper for GetTouchX
HmlValue hml_fn_GetTouchX(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetTouchX) {
        _ffi_ptr_GetTouchX = hml_ffi_sym(_ffi_lib, "GetTouchX");
        if (!_ffi_ptr_GetTouchX) {
            hml_runtime_error("FFI function '%s' not found in library", "GetTouchX");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetTouchX, NULL, 0, _types);
}

// FFI wrapper for GetTouchY
HmlValue hml_fn_GetTouchY(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetTouchY) {
        _ffi_ptr_GetTouchY = hml_ffi_sym(_ffi_lib, "GetTouchY");
        if (!_ffi_ptr_GetTouchY) {
            hml_runtime_error("FFI function '%s' not found in library", "GetTouchY");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetTouchY, NULL, 0, _types);
}

// FFI wrapper for GetTouchPosition
HmlValue hml_fn_GetTouchPosition(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetTouchPosition) {
        _ffi_ptr_GetTouchPosition = hml_ffi_sym(_ffi_lib, "GetTouchPosition");
        if (!_ffi_ptr_GetTouchPosition) {
            hml_runtime_error("FFI function '%s' not found in library", "GetTouchPosition");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_I32;
    static const char *_struct_names[2] = {
        "Vector2",
        NULL
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_GetTouchPosition, _args, 1, _types, _struct_names);
}

// FFI wrapper for GetTouchPointId
HmlValue hml_fn_GetTouchPointId(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetTouchPointId) {
        _ffi_ptr_GetTouchPointId = hml_ffi_sym(_ffi_lib, "GetTouchPointId");
        if (!_ffi_ptr_GetTouchPointId) {
            hml_runtime_error("FFI function '%s' not found in library", "GetTouchPointId");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetTouchPointId, _args, 1, _types);
}

// FFI wrapper for GetTouchPointCount
HmlValue hml_fn_GetTouchPointCount(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetTouchPointCount) {
        _ffi_ptr_GetTouchPointCount = hml_ffi_sym(_ffi_lib, "GetTouchPointCount");
        if (!_ffi_ptr_GetTouchPointCount) {
            hml_runtime_error("FFI function '%s' not found in library", "GetTouchPointCount");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetTouchPointCount, NULL, 0, _types);
}

// FFI wrapper for SetGesturesEnabled
HmlValue hml_fn_SetGesturesEnabled(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetGesturesEnabled) {
        _ffi_ptr_SetGesturesEnabled = hml_ffi_sym(_ffi_lib, "SetGesturesEnabled");
        if (!_ffi_ptr_SetGesturesEnabled) {
            hml_runtime_error("FFI function '%s' not found in library", "SetGesturesEnabled");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_U32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetGesturesEnabled, _args, 1, _types);
}

// FFI wrapper for IsGestureDetected
HmlValue hml_fn_IsGestureDetected(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsGestureDetected) {
        _ffi_ptr_IsGestureDetected = hml_ffi_sym(_ffi_lib, "IsGestureDetected");
        if (!_ffi_ptr_IsGestureDetected) {
            hml_runtime_error("FFI function '%s' not found in library", "IsGestureDetected");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_U32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsGestureDetected, _args, 1, _types);
}

// FFI wrapper for GetGestureDetected
HmlValue hml_fn_GetGestureDetected(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetGestureDetected) {
        _ffi_ptr_GetGestureDetected = hml_ffi_sym(_ffi_lib, "GetGestureDetected");
        if (!_ffi_ptr_GetGestureDetected) {
            hml_runtime_error("FFI function '%s' not found in library", "GetGestureDetected");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_GetGestureDetected, NULL, 0, _types);
}

// FFI wrapper for GetGestureHoldDuration
HmlValue hml_fn_GetGestureHoldDuration(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetGestureHoldDuration) {
        _ffi_ptr_GetGestureHoldDuration = hml_ffi_sym(_ffi_lib, "GetGestureHoldDuration");
        if (!_ffi_ptr_GetGestureHoldDuration) {
            hml_runtime_error("FFI function '%s' not found in library", "GetGestureHoldDuration");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_F32;
    return hml_ffi_call(_ffi_ptr_GetGestureHoldDuration, NULL, 0, _types);
}

// FFI wrapper for GetGestureDragAngle
HmlValue hml_fn_GetGestureDragAngle(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetGestureDragAngle) {
        _ffi_ptr_GetGestureDragAngle = hml_ffi_sym(_ffi_lib, "GetGestureDragAngle");
        if (!_ffi_ptr_GetGestureDragAngle) {
            hml_runtime_error("FFI function '%s' not found in library", "GetGestureDragAngle");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_F32;
    return hml_ffi_call(_ffi_ptr_GetGestureDragAngle, NULL, 0, _types);
}

// FFI wrapper for GetGesturePinchAngle
HmlValue hml_fn_GetGesturePinchAngle(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetGesturePinchAngle) {
        _ffi_ptr_GetGesturePinchAngle = hml_ffi_sym(_ffi_lib, "GetGesturePinchAngle");
        if (!_ffi_ptr_GetGesturePinchAngle) {
            hml_runtime_error("FFI function '%s' not found in library", "GetGesturePinchAngle");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_F32;
    return hml_ffi_call(_ffi_ptr_GetGesturePinchAngle, NULL, 0, _types);
}

// FFI wrapper for TraceLog
HmlValue hml_fn_TraceLog(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_TraceLog) {
        _ffi_ptr_TraceLog = hml_ffi_sym(_ffi_lib, "TraceLog");
        if (!_ffi_ptr_TraceLog) {
            hml_runtime_error("FFI function '%s' not found in library", "TraceLog");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_STRING;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_TraceLog, _args, 2, _types);
}

// FFI wrapper for SetTraceLogLevel
HmlValue hml_fn_SetTraceLogLevel(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetTraceLogLevel) {
        _ffi_ptr_SetTraceLogLevel = hml_ffi_sym(_ffi_lib, "SetTraceLogLevel");
        if (!_ffi_ptr_SetTraceLogLevel) {
            hml_runtime_error("FFI function '%s' not found in library", "SetTraceLogLevel");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetTraceLogLevel, _args, 1, _types);
}

// FFI wrapper for DrawPixel
HmlValue hml_fn_DrawPixel(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawPixel) {
        _ffi_ptr_DrawPixel = hml_ffi_sym(_ffi_lib, "DrawPixel");
        if (!_ffi_ptr_DrawPixel) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawPixel");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_U32;
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call(_ffi_ptr_DrawPixel, _args, 3, _types);
}

// FFI wrapper for DrawPixelV
HmlValue hml_fn_DrawPixelV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_DrawPixelV) {
        _ffi_ptr_DrawPixelV = hml_ffi_sym(_ffi_lib, "DrawPixelV");
        if (!_ffi_ptr_DrawPixelV) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawPixelV");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_U32;
    static const char *_struct_names[3] = {
        NULL,
        "Vector2",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawPixelV, _args, 2, _types, _struct_names);
}

// FFI wrapper for DrawLine
HmlValue hml_fn_DrawLine(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawLine) {
        _ffi_ptr_DrawLine = hml_ffi_sym(_ffi_lib, "DrawLine");
        if (!_ffi_ptr_DrawLine) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawLine");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_U32;
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call(_ffi_ptr_DrawLine, _args, 5, _types);
}

// FFI wrapper for DrawLineV
HmlValue hml_fn_DrawLineV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawLineV) {
        _ffi_ptr_DrawLineV = hml_ffi_sym(_ffi_lib, "DrawLineV");
        if (!_ffi_ptr_DrawLineV) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawLineV");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        NULL,
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawLineV, _args, 3, _types, _struct_names);
}

// FFI wrapper for DrawLineEx
HmlValue hml_fn_DrawLineEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawLineEx) {
        _ffi_ptr_DrawLineEx = hml_ffi_sym(_ffi_lib, "DrawLineEx");
        if (!_ffi_ptr_DrawLineEx) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawLineEx");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Vector2",
        "Vector2",
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawLineEx, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawLineStrip
HmlValue hml_fn_DrawLineStrip(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawLineStrip) {
        _ffi_ptr_DrawLineStrip = hml_ffi_sym(_ffi_lib, "DrawLineStrip");
        if (!_ffi_ptr_DrawLineStrip) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawLineStrip");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_U32;
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call(_ffi_ptr_DrawLineStrip, _args, 3, _types);
}

// FFI wrapper for DrawLineBezier
HmlValue hml_fn_DrawLineBezier(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawLineBezier) {
        _ffi_ptr_DrawLineBezier = hml_ffi_sym(_ffi_lib, "DrawLineBezier");
        if (!_ffi_ptr_DrawLineBezier) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawLineBezier");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Vector2",
        "Vector2",
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawLineBezier, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawCircle
HmlValue hml_fn_DrawCircle(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawCircle) {
        _ffi_ptr_DrawCircle = hml_ffi_sym(_ffi_lib, "DrawCircle");
        if (!_ffi_ptr_DrawCircle) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawCircle");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_U32;
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call(_ffi_ptr_DrawCircle, _args, 4, _types);
}

// FFI wrapper for DrawCircleV
HmlValue hml_fn_DrawCircleV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawCircleV) {
        _ffi_ptr_DrawCircleV = hml_ffi_sym(_ffi_lib, "DrawCircleV");
        if (!_ffi_ptr_DrawCircleV) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawCircleV");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        NULL,
        "Vector2",
        NULL,
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawCircleV, _args, 3, _types, _struct_names);
}

// FFI wrapper for DrawCircleGradient
HmlValue hml_fn_DrawCircleGradient(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawCircleGradient) {
        _ffi_ptr_DrawCircleGradient = hml_ffi_sym(_ffi_lib, "DrawCircleGradient");
        if (!_ffi_ptr_DrawCircleGradient) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawCircleGradient");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_U32;
    _types[5] = HML_FFI_U32;
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call(_ffi_ptr_DrawCircleGradient, _args, 5, _types);
}

// FFI wrapper for DrawCircleLines
HmlValue hml_fn_DrawCircleLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawCircleLines) {
        _ffi_ptr_DrawCircleLines = hml_ffi_sym(_ffi_lib, "DrawCircleLines");
        if (!_ffi_ptr_DrawCircleLines) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawCircleLines");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_U32;
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call(_ffi_ptr_DrawCircleLines, _args, 4, _types);
}

// FFI wrapper for DrawCircleLinesV
HmlValue hml_fn_DrawCircleLinesV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawCircleLinesV) {
        _ffi_ptr_DrawCircleLinesV = hml_ffi_sym(_ffi_lib, "DrawCircleLinesV");
        if (!_ffi_ptr_DrawCircleLinesV) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawCircleLinesV");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        NULL,
        "Vector2",
        NULL,
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawCircleLinesV, _args, 3, _types, _struct_names);
}

// FFI wrapper for DrawCircleSector
HmlValue hml_fn_DrawCircleSector(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_DrawCircleSector) {
        _ffi_ptr_DrawCircleSector = hml_ffi_sym(_ffi_lib, "DrawCircleSector");
        if (!_ffi_ptr_DrawCircleSector) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawCircleSector");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_I32;
    _types[6] = HML_FFI_U32;
    static const char *_struct_names[7] = {
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawCircleSector, _args, 6, _types, _struct_names);
}

// FFI wrapper for DrawCircleSectorLines
HmlValue hml_fn_DrawCircleSectorLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_DrawCircleSectorLines) {
        _ffi_ptr_DrawCircleSectorLines = hml_ffi_sym(_ffi_lib, "DrawCircleSectorLines");
        if (!_ffi_ptr_DrawCircleSectorLines) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawCircleSectorLines");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_I32;
    _types[6] = HML_FFI_U32;
    static const char *_struct_names[7] = {
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawCircleSectorLines, _args, 6, _types, _struct_names);
}

// FFI wrapper for DrawRing
HmlValue hml_fn_DrawRing(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5, HmlValue _arg6) {
    (void)_env;
    if (!_ffi_ptr_DrawRing) {
        _ffi_ptr_DrawRing = hml_ffi_sym(_ffi_lib, "DrawRing");
        if (!_ffi_ptr_DrawRing) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRing");
        }
    }
    HmlFFIType _types[8];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_F32;
    _types[6] = HML_FFI_I32;
    _types[7] = HML_FFI_U32;
    static const char *_struct_names[8] = {
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[7];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    _args[6] = _arg6;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRing, _args, 7, _types, _struct_names);
}

// FFI wrapper for DrawRingLines
HmlValue hml_fn_DrawRingLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5, HmlValue _arg6) {
    (void)_env;
    if (!_ffi_ptr_DrawRingLines) {
        _ffi_ptr_DrawRingLines = hml_ffi_sym(_ffi_lib, "DrawRingLines");
        if (!_ffi_ptr_DrawRingLines) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRingLines");
        }
    }
    HmlFFIType _types[8];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_F32;
    _types[6] = HML_FFI_I32;
    _types[7] = HML_FFI_U32;
    static const char *_struct_names[8] = {
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[7];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    _args[6] = _arg6;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRingLines, _args, 7, _types, _struct_names);
}

// FFI wrapper for DrawEllipse
HmlValue hml_fn_DrawEllipse(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawEllipse) {
        _ffi_ptr_DrawEllipse = hml_ffi_sym(_ffi_lib, "DrawEllipse");
        if (!_ffi_ptr_DrawEllipse) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawEllipse");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_U32;
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call(_ffi_ptr_DrawEllipse, _args, 5, _types);
}

// FFI wrapper for DrawEllipseLines
HmlValue hml_fn_DrawEllipseLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawEllipseLines) {
        _ffi_ptr_DrawEllipseLines = hml_ffi_sym(_ffi_lib, "DrawEllipseLines");
        if (!_ffi_ptr_DrawEllipseLines) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawEllipseLines");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_U32;
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call(_ffi_ptr_DrawEllipseLines, _args, 5, _types);
}

// FFI wrapper for DrawRectangle
HmlValue hml_fn_DrawRectangle(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangle) {
        _ffi_ptr_DrawRectangle = hml_ffi_sym(_ffi_lib, "DrawRectangle");
        if (!_ffi_ptr_DrawRectangle) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangle");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_U32;
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call(_ffi_ptr_DrawRectangle, _args, 5, _types);
}

// FFI wrapper for DrawRectangleV
HmlValue hml_fn_DrawRectangleV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleV) {
        _ffi_ptr_DrawRectangleV = hml_ffi_sym(_ffi_lib, "DrawRectangleV");
        if (!_ffi_ptr_DrawRectangleV) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleV");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        NULL,
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRectangleV, _args, 3, _types, _struct_names);
}

// FFI wrapper for DrawRectangleRec
HmlValue hml_fn_DrawRectangleRec(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleRec) {
        _ffi_ptr_DrawRectangleRec = hml_ffi_sym(_ffi_lib, "DrawRectangleRec");
        if (!_ffi_ptr_DrawRectangleRec) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleRec");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_U32;
    static const char *_struct_names[3] = {
        NULL,
        "Rectangle",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRectangleRec, _args, 2, _types, _struct_names);
}

// FFI wrapper for DrawRectanglePro
HmlValue hml_fn_DrawRectanglePro(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawRectanglePro) {
        _ffi_ptr_DrawRectanglePro = hml_ffi_sym(_ffi_lib, "DrawRectanglePro");
        if (!_ffi_ptr_DrawRectanglePro) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectanglePro");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Rectangle",
        "Vector2",
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRectanglePro, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawRectangleGradientV
HmlValue hml_fn_DrawRectangleGradientV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleGradientV) {
        _ffi_ptr_DrawRectangleGradientV = hml_ffi_sym(_ffi_lib, "DrawRectangleGradientV");
        if (!_ffi_ptr_DrawRectangleGradientV) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleGradientV");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_U32;
    _types[6] = HML_FFI_U32;
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call(_ffi_ptr_DrawRectangleGradientV, _args, 6, _types);
}

// FFI wrapper for DrawRectangleGradientH
HmlValue hml_fn_DrawRectangleGradientH(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleGradientH) {
        _ffi_ptr_DrawRectangleGradientH = hml_ffi_sym(_ffi_lib, "DrawRectangleGradientH");
        if (!_ffi_ptr_DrawRectangleGradientH) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleGradientH");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_U32;
    _types[6] = HML_FFI_U32;
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call(_ffi_ptr_DrawRectangleGradientH, _args, 6, _types);
}

// FFI wrapper for DrawRectangleGradientEx
HmlValue hml_fn_DrawRectangleGradientEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleGradientEx) {
        _ffi_ptr_DrawRectangleGradientEx = hml_ffi_sym(_ffi_lib, "DrawRectangleGradientEx");
        if (!_ffi_ptr_DrawRectangleGradientEx) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleGradientEx");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_U32;
    _types[3] = HML_FFI_U32;
    _types[4] = HML_FFI_U32;
    _types[5] = HML_FFI_U32;
    static const char *_struct_names[6] = {
        NULL,
        "Rectangle",
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRectangleGradientEx, _args, 5, _types, _struct_names);
}

// FFI wrapper for DrawRectangleLines
HmlValue hml_fn_DrawRectangleLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleLines) {
        _ffi_ptr_DrawRectangleLines = hml_ffi_sym(_ffi_lib, "DrawRectangleLines");
        if (!_ffi_ptr_DrawRectangleLines) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleLines");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_U32;
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call(_ffi_ptr_DrawRectangleLines, _args, 5, _types);
}

// FFI wrapper for DrawRectangleLinesEx
HmlValue hml_fn_DrawRectangleLinesEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleLinesEx) {
        _ffi_ptr_DrawRectangleLinesEx = hml_ffi_sym(_ffi_lib, "DrawRectangleLinesEx");
        if (!_ffi_ptr_DrawRectangleLinesEx) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleLinesEx");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        NULL,
        "Rectangle",
        NULL,
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRectangleLinesEx, _args, 3, _types, _struct_names);
}

// FFI wrapper for DrawRectangleRounded
HmlValue hml_fn_DrawRectangleRounded(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleRounded) {
        _ffi_ptr_DrawRectangleRounded = hml_ffi_sym(_ffi_lib, "DrawRectangleRounded");
        if (!_ffi_ptr_DrawRectangleRounded) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleRounded");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Rectangle",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRectangleRounded, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawRectangleRoundedLines
HmlValue hml_fn_DrawRectangleRoundedLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleRoundedLines) {
        _ffi_ptr_DrawRectangleRoundedLines = hml_ffi_sym(_ffi_lib, "DrawRectangleRoundedLines");
        if (!_ffi_ptr_DrawRectangleRoundedLines) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleRoundedLines");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Rectangle",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRectangleRoundedLines, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawRectangleRoundedLinesEx
HmlValue hml_fn_DrawRectangleRoundedLinesEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawRectangleRoundedLinesEx) {
        _ffi_ptr_DrawRectangleRoundedLinesEx = hml_ffi_sym(_ffi_lib, "DrawRectangleRoundedLinesEx");
        if (!_ffi_ptr_DrawRectangleRoundedLinesEx) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawRectangleRoundedLinesEx");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_U32;
    static const char *_struct_names[6] = {
        NULL,
        "Rectangle",
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawRectangleRoundedLinesEx, _args, 5, _types, _struct_names);
}

// FFI wrapper for DrawTriangle
HmlValue hml_fn_DrawTriangle(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawTriangle) {
        _ffi_ptr_DrawTriangle = hml_ffi_sym(_ffi_lib, "DrawTriangle");
        if (!_ffi_ptr_DrawTriangle) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTriangle");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Vector2",
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTriangle, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawTriangleLines
HmlValue hml_fn_DrawTriangleLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawTriangleLines) {
        _ffi_ptr_DrawTriangleLines = hml_ffi_sym(_ffi_lib, "DrawTriangleLines");
        if (!_ffi_ptr_DrawTriangleLines) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTriangleLines");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Vector2",
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTriangleLines, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawTriangleFan
HmlValue hml_fn_DrawTriangleFan(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawTriangleFan) {
        _ffi_ptr_DrawTriangleFan = hml_ffi_sym(_ffi_lib, "DrawTriangleFan");
        if (!_ffi_ptr_DrawTriangleFan) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTriangleFan");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_U32;
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call(_ffi_ptr_DrawTriangleFan, _args, 3, _types);
}

// FFI wrapper for DrawTriangleStrip
HmlValue hml_fn_DrawTriangleStrip(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawTriangleStrip) {
        _ffi_ptr_DrawTriangleStrip = hml_ffi_sym(_ffi_lib, "DrawTriangleStrip");
        if (!_ffi_ptr_DrawTriangleStrip) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTriangleStrip");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_U32;
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call(_ffi_ptr_DrawTriangleStrip, _args, 3, _types);
}

// FFI wrapper for DrawPoly
HmlValue hml_fn_DrawPoly(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawPoly) {
        _ffi_ptr_DrawPoly = hml_ffi_sym(_ffi_lib, "DrawPoly");
        if (!_ffi_ptr_DrawPoly) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawPoly");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_U32;
    static const char *_struct_names[6] = {
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawPoly, _args, 5, _types, _struct_names);
}

// FFI wrapper for DrawPolyLines
HmlValue hml_fn_DrawPolyLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawPolyLines) {
        _ffi_ptr_DrawPolyLines = hml_ffi_sym(_ffi_lib, "DrawPolyLines");
        if (!_ffi_ptr_DrawPolyLines) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawPolyLines");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_U32;
    static const char *_struct_names[6] = {
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawPolyLines, _args, 5, _types, _struct_names);
}

// FFI wrapper for DrawPolyLinesEx
HmlValue hml_fn_DrawPolyLinesEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_DrawPolyLinesEx) {
        _ffi_ptr_DrawPolyLinesEx = hml_ffi_sym(_ffi_lib, "DrawPolyLinesEx");
        if (!_ffi_ptr_DrawPolyLinesEx) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawPolyLinesEx");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_F32;
    _types[6] = HML_FFI_U32;
    static const char *_struct_names[7] = {
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawPolyLinesEx, _args, 6, _types, _struct_names);
}

// FFI wrapper for DrawText
HmlValue hml_fn_DrawText(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawText) {
        _ffi_ptr_DrawText = hml_ffi_sym(_ffi_lib, "DrawText");
        if (!_ffi_ptr_DrawText) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawText");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRING;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_U32;
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call(_ffi_ptr_DrawText, _args, 5, _types);
}

// FFI wrapper for MeasureText
HmlValue hml_fn_MeasureText(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_MeasureText) {
        _ffi_ptr_MeasureText = hml_ffi_sym(_ffi_lib, "MeasureText");
        if (!_ffi_ptr_MeasureText) {
            hml_runtime_error("FFI function '%s' not found in library", "MeasureText");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_MeasureText, _args, 2, _types);
}

// FFI wrapper for WaitTime
HmlValue hml_fn_WaitTime(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_WaitTime) {
        _ffi_ptr_WaitTime = hml_ffi_sym(_ffi_lib, "WaitTime");
        if (!_ffi_ptr_WaitTime) {
            hml_runtime_error("FFI function '%s' not found in library", "WaitTime");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_F64;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_WaitTime, _args, 1, _types);
}

// FFI wrapper for GetRandomValue
HmlValue hml_fn_GetRandomValue(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_GetRandomValue) {
        _ffi_ptr_GetRandomValue = hml_ffi_sym(_ffi_lib, "GetRandomValue");
        if (!_ffi_ptr_GetRandomValue) {
            hml_runtime_error("FFI function '%s' not found in library", "GetRandomValue");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_GetRandomValue, _args, 2, _types);
}

// FFI wrapper for SetRandomSeed
HmlValue hml_fn_SetRandomSeed(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetRandomSeed) {
        _ffi_ptr_SetRandomSeed = hml_ffi_sym(_ffi_lib, "SetRandomSeed");
        if (!_ffi_ptr_SetRandomSeed) {
            hml_runtime_error("FFI function '%s' not found in library", "SetRandomSeed");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_U32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetRandomSeed, _args, 1, _types);
}

// FFI wrapper for TakeScreenshot
HmlValue hml_fn_TakeScreenshot(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_TakeScreenshot) {
        _ffi_ptr_TakeScreenshot = hml_ffi_sym(_ffi_lib, "TakeScreenshot");
        if (!_ffi_ptr_TakeScreenshot) {
            hml_runtime_error("FFI function '%s' not found in library", "TakeScreenshot");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_TakeScreenshot, _args, 1, _types);
}

// FFI wrapper for SetConfigFlags
HmlValue hml_fn_SetConfigFlags(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetConfigFlags) {
        _ffi_ptr_SetConfigFlags = hml_ffi_sym(_ffi_lib, "SetConfigFlags");
        if (!_ffi_ptr_SetConfigFlags) {
            hml_runtime_error("FFI function '%s' not found in library", "SetConfigFlags");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_U32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetConfigFlags, _args, 1, _types);
}

// FFI wrapper for OpenURL
HmlValue hml_fn_OpenURL(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_OpenURL) {
        _ffi_ptr_OpenURL = hml_ffi_sym(_ffi_lib, "OpenURL");
        if (!_ffi_ptr_OpenURL) {
            hml_runtime_error("FFI function '%s' not found in library", "OpenURL");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_OpenURL, _args, 1, _types);
}

// FFI wrapper for SetClipboardText
HmlValue hml_fn_SetClipboardText(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetClipboardText) {
        _ffi_ptr_SetClipboardText = hml_ffi_sym(_ffi_lib, "SetClipboardText");
        if (!_ffi_ptr_SetClipboardText) {
            hml_runtime_error("FFI function '%s' not found in library", "SetClipboardText");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetClipboardText, _args, 1, _types);
}

// FFI wrapper for GetClipboardText
HmlValue hml_fn_GetClipboardText(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetClipboardText) {
        _ffi_ptr_GetClipboardText = hml_ffi_sym(_ffi_lib, "GetClipboardText");
        if (!_ffi_ptr_GetClipboardText) {
            hml_runtime_error("FFI function '%s' not found in library", "GetClipboardText");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_STRING;
    return hml_ffi_call(_ffi_ptr_GetClipboardText, NULL, 0, _types);
}

// FFI wrapper for CheckCollisionRecs
HmlValue hml_fn_CheckCollisionRecs(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_CheckCollisionRecs) {
        _ffi_ptr_CheckCollisionRecs = hml_ffi_sym(_ffi_lib, "CheckCollisionRecs");
        if (!_ffi_ptr_CheckCollisionRecs) {
            hml_runtime_error("FFI function '%s' not found in library", "CheckCollisionRecs");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    static const char *_struct_names[3] = {
        NULL,
        "Rectangle",
        "Rectangle"
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_CheckCollisionRecs, _args, 2, _types, _struct_names);
}

// FFI wrapper for CheckCollisionCircles
HmlValue hml_fn_CheckCollisionCircles(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_CheckCollisionCircles) {
        _ffi_ptr_CheckCollisionCircles = hml_ffi_sym(_ffi_lib, "CheckCollisionCircles");
        if (!_ffi_ptr_CheckCollisionCircles) {
            hml_runtime_error("FFI function '%s' not found in library", "CheckCollisionCircles");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_F32;
    static const char *_struct_names[5] = {
        NULL,
        "Vector2",
        NULL,
        "Vector2",
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_CheckCollisionCircles, _args, 4, _types, _struct_names);
}

// FFI wrapper for CheckCollisionCircleRec
HmlValue hml_fn_CheckCollisionCircleRec(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_CheckCollisionCircleRec) {
        _ffi_ptr_CheckCollisionCircleRec = hml_ffi_sym(_ffi_lib, "CheckCollisionCircleRec");
        if (!_ffi_ptr_CheckCollisionCircleRec) {
            hml_runtime_error("FFI function '%s' not found in library", "CheckCollisionCircleRec");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    _types[3] = HML_FFI_STRUCT;
    static const char *_struct_names[4] = {
        NULL,
        "Vector2",
        NULL,
        "Rectangle"
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_CheckCollisionCircleRec, _args, 3, _types, _struct_names);
}

// FFI wrapper for CheckCollisionPointRec
HmlValue hml_fn_CheckCollisionPointRec(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_CheckCollisionPointRec) {
        _ffi_ptr_CheckCollisionPointRec = hml_ffi_sym(_ffi_lib, "CheckCollisionPointRec");
        if (!_ffi_ptr_CheckCollisionPointRec) {
            hml_runtime_error("FFI function '%s' not found in library", "CheckCollisionPointRec");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    static const char *_struct_names[3] = {
        NULL,
        "Vector2",
        "Rectangle"
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_CheckCollisionPointRec, _args, 2, _types, _struct_names);
}

// FFI wrapper for CheckCollisionPointCircle
HmlValue hml_fn_CheckCollisionPointCircle(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_CheckCollisionPointCircle) {
        _ffi_ptr_CheckCollisionPointCircle = hml_ffi_sym(_ffi_lib, "CheckCollisionPointCircle");
        if (!_ffi_ptr_CheckCollisionPointCircle) {
            hml_runtime_error("FFI function '%s' not found in library", "CheckCollisionPointCircle");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_F32;
    static const char *_struct_names[4] = {
        NULL,
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_CheckCollisionPointCircle, _args, 3, _types, _struct_names);
}

// FFI wrapper for CheckCollisionPointTriangle
HmlValue hml_fn_CheckCollisionPointTriangle(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_CheckCollisionPointTriangle) {
        _ffi_ptr_CheckCollisionPointTriangle = hml_ffi_sym(_ffi_lib, "CheckCollisionPointTriangle");
        if (!_ffi_ptr_CheckCollisionPointTriangle) {
            hml_runtime_error("FFI function '%s' not found in library", "CheckCollisionPointTriangle");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_STRUCT;
    static const char *_struct_names[5] = {
        NULL,
        "Vector2",
        "Vector2",
        "Vector2",
        "Vector2"
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_CheckCollisionPointTriangle, _args, 4, _types, _struct_names);
}

// FFI wrapper for CheckCollisionPointLine
HmlValue hml_fn_CheckCollisionPointLine(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_CheckCollisionPointLine) {
        _ffi_ptr_CheckCollisionPointLine = hml_ffi_sym(_ffi_lib, "CheckCollisionPointLine");
        if (!_ffi_ptr_CheckCollisionPointLine) {
            hml_runtime_error("FFI function '%s' not found in library", "CheckCollisionPointLine");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_I32;
    static const char *_struct_names[5] = {
        NULL,
        "Vector2",
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_CheckCollisionPointLine, _args, 4, _types, _struct_names);
}

// FFI wrapper for CheckCollisionLines
HmlValue hml_fn_CheckCollisionLines(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_CheckCollisionLines) {
        _ffi_ptr_CheckCollisionLines = hml_ffi_sym(_ffi_lib, "CheckCollisionLines");
        if (!_ffi_ptr_CheckCollisionLines) {
            hml_runtime_error("FFI function '%s' not found in library", "CheckCollisionLines");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_STRUCT;
    _types[5] = HML_FFI_PTR;
    static const char *_struct_names[6] = {
        NULL,
        "Vector2",
        "Vector2",
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_CheckCollisionLines, _args, 5, _types, _struct_names);
}

// FFI wrapper for GetCollisionRec
HmlValue hml_fn_GetCollisionRec(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_GetCollisionRec) {
        _ffi_ptr_GetCollisionRec = hml_ffi_sym(_ffi_lib, "GetCollisionRec");
        if (!_ffi_ptr_GetCollisionRec) {
            hml_runtime_error("FFI function '%s' not found in library", "GetCollisionRec");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    static const char *_struct_names[3] = {
        "Rectangle",
        "Rectangle",
        "Rectangle"
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_GetCollisionRec, _args, 2, _types, _struct_names);
}

// FFI wrapper for DrawFPS
HmlValue hml_fn_DrawFPS(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_DrawFPS) {
        _ffi_ptr_DrawFPS = hml_ffi_sym(_ffi_lib, "DrawFPS");
        if (!_ffi_ptr_DrawFPS) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawFPS");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_DrawFPS, _args, 2, _types);
}

// FFI wrapper for InitAudioDevice
HmlValue hml_fn_InitAudioDevice(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_InitAudioDevice) {
        _ffi_ptr_InitAudioDevice = hml_ffi_sym(_ffi_lib, "InitAudioDevice");
        if (!_ffi_ptr_InitAudioDevice) {
            hml_runtime_error("FFI function '%s' not found in library", "InitAudioDevice");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_InitAudioDevice, NULL, 0, _types);
}

// FFI wrapper for CloseAudioDevice
HmlValue hml_fn_CloseAudioDevice(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_CloseAudioDevice) {
        _ffi_ptr_CloseAudioDevice = hml_ffi_sym(_ffi_lib, "CloseAudioDevice");
        if (!_ffi_ptr_CloseAudioDevice) {
            hml_runtime_error("FFI function '%s' not found in library", "CloseAudioDevice");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_CloseAudioDevice, NULL, 0, _types);
}

// FFI wrapper for IsAudioDeviceReady
HmlValue hml_fn_IsAudioDeviceReady(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_IsAudioDeviceReady) {
        _ffi_ptr_IsAudioDeviceReady = hml_ffi_sym(_ffi_lib, "IsAudioDeviceReady");
        if (!_ffi_ptr_IsAudioDeviceReady) {
            hml_runtime_error("FFI function '%s' not found in library", "IsAudioDeviceReady");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_I32;
    return hml_ffi_call(_ffi_ptr_IsAudioDeviceReady, NULL, 0, _types);
}

// FFI wrapper for SetMasterVolume
HmlValue hml_fn_SetMasterVolume(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_SetMasterVolume) {
        _ffi_ptr_SetMasterVolume = hml_ffi_sym(_ffi_lib, "SetMasterVolume");
        if (!_ffi_ptr_SetMasterVolume) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMasterVolume");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_F32;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_SetMasterVolume, _args, 1, _types);
}

// FFI wrapper for GetMasterVolume
HmlValue hml_fn_GetMasterVolume(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetMasterVolume) {
        _ffi_ptr_GetMasterVolume = hml_ffi_sym(_ffi_lib, "GetMasterVolume");
        if (!_ffi_ptr_GetMasterVolume) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMasterVolume");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_F32;
    return hml_ffi_call(_ffi_ptr_GetMasterVolume, NULL, 0, _types);
}

// FFI wrapper for LoadTexture
HmlValue hml_fn_LoadTexture(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_LoadTexture) {
        _ffi_ptr_LoadTexture = hml_ffi_sym(_ffi_lib, "LoadTexture");
        if (!_ffi_ptr_LoadTexture) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadTexture");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRING;
    static const char *_struct_names[2] = {
        "Texture2D",
        NULL
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadTexture, _args, 1, _types, _struct_names);
}

// FFI wrapper for LoadTextureFromImage
HmlValue hml_fn_LoadTextureFromImage(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_LoadTextureFromImage) {
        _ffi_ptr_LoadTextureFromImage = hml_ffi_sym(_ffi_lib, "LoadTextureFromImage");
        if (!_ffi_ptr_LoadTextureFromImage) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadTextureFromImage");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        "Texture2D",
        "Image"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadTextureFromImage, _args, 1, _types, _struct_names);
}

// FFI wrapper for UnloadTexture
HmlValue hml_fn_UnloadTexture(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_UnloadTexture) {
        _ffi_ptr_UnloadTexture = hml_ffi_sym(_ffi_lib, "UnloadTexture");
        if (!_ffi_ptr_UnloadTexture) {
            hml_runtime_error("FFI function '%s' not found in library", "UnloadTexture");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Texture2D"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_UnloadTexture, _args, 1, _types, _struct_names);
}

// FFI wrapper for IsTextureValid
HmlValue hml_fn_IsTextureValid(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsTextureValid) {
        _ffi_ptr_IsTextureValid = hml_ffi_sym(_ffi_lib, "IsTextureValid");
        if (!_ffi_ptr_IsTextureValid) {
            hml_runtime_error("FFI function '%s' not found in library", "IsTextureValid");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Texture2D"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_IsTextureValid, _args, 1, _types, _struct_names);
}

// FFI wrapper for UpdateTexture
HmlValue hml_fn_UpdateTexture(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_UpdateTexture) {
        _ffi_ptr_UpdateTexture = hml_ffi_sym(_ffi_lib, "UpdateTexture");
        if (!_ffi_ptr_UpdateTexture) {
            hml_runtime_error("FFI function '%s' not found in library", "UpdateTexture");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_PTR;
    static const char *_struct_names[3] = {
        NULL,
        "Texture2D",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_UpdateTexture, _args, 2, _types, _struct_names);
}

// FFI wrapper for DrawTexture
HmlValue hml_fn_DrawTexture(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawTexture) {
        _ffi_ptr_DrawTexture = hml_ffi_sym(_ffi_lib, "DrawTexture");
        if (!_ffi_ptr_DrawTexture) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTexture");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Texture2D",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTexture, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawTextureV
HmlValue hml_fn_DrawTextureV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_DrawTextureV) {
        _ffi_ptr_DrawTextureV = hml_ffi_sym(_ffi_lib, "DrawTextureV");
        if (!_ffi_ptr_DrawTextureV) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTextureV");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        NULL,
        "Texture2D",
        "Vector2",
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTextureV, _args, 3, _types, _struct_names);
}

// FFI wrapper for DrawTextureEx
HmlValue hml_fn_DrawTextureEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_DrawTextureEx) {
        _ffi_ptr_DrawTextureEx = hml_ffi_sym(_ffi_lib, "DrawTextureEx");
        if (!_ffi_ptr_DrawTextureEx) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTextureEx");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_U32;
    static const char *_struct_names[6] = {
        NULL,
        "Texture2D",
        "Vector2",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTextureEx, _args, 5, _types, _struct_names);
}

// FFI wrapper for DrawTextureRec
HmlValue hml_fn_DrawTextureRec(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_DrawTextureRec) {
        _ffi_ptr_DrawTextureRec = hml_ffi_sym(_ffi_lib, "DrawTextureRec");
        if (!_ffi_ptr_DrawTextureRec) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTextureRec");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        "Texture2D",
        "Rectangle",
        "Vector2",
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTextureRec, _args, 4, _types, _struct_names);
}

// FFI wrapper for DrawTexturePro
HmlValue hml_fn_DrawTexturePro(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_DrawTexturePro) {
        _ffi_ptr_DrawTexturePro = hml_ffi_sym(_ffi_lib, "DrawTexturePro");
        if (!_ffi_ptr_DrawTexturePro) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTexturePro");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_STRUCT;
    _types[5] = HML_FFI_F32;
    _types[6] = HML_FFI_U32;
    static const char *_struct_names[7] = {
        NULL,
        "Texture2D",
        "Rectangle",
        "Rectangle",
        "Vector2",
        NULL,
        NULL
    };
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTexturePro, _args, 6, _types, _struct_names);
}

// FFI wrapper for SetTextureFilter
HmlValue hml_fn_SetTextureFilter(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetTextureFilter) {
        _ffi_ptr_SetTextureFilter = hml_ffi_sym(_ffi_lib, "SetTextureFilter");
        if (!_ffi_ptr_SetTextureFilter) {
            hml_runtime_error("FFI function '%s' not found in library", "SetTextureFilter");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_I32;
    static const char *_struct_names[3] = {
        NULL,
        "Texture2D",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetTextureFilter, _args, 2, _types, _struct_names);
}

// FFI wrapper for SetTextureWrap
HmlValue hml_fn_SetTextureWrap(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetTextureWrap) {
        _ffi_ptr_SetTextureWrap = hml_ffi_sym(_ffi_lib, "SetTextureWrap");
        if (!_ffi_ptr_SetTextureWrap) {
            hml_runtime_error("FFI function '%s' not found in library", "SetTextureWrap");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_I32;
    static const char *_struct_names[3] = {
        NULL,
        "Texture2D",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetTextureWrap, _args, 2, _types, _struct_names);
}

// FFI wrapper for LoadRenderTexture
HmlValue hml_fn_LoadRenderTexture(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_LoadRenderTexture) {
        _ffi_ptr_LoadRenderTexture = hml_ffi_sym(_ffi_lib, "LoadRenderTexture");
        if (!_ffi_ptr_LoadRenderTexture) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadRenderTexture");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    static const char *_struct_names[3] = {
        "RenderTexture2D",
        NULL,
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadRenderTexture, _args, 2, _types, _struct_names);
}

// FFI wrapper for UnloadRenderTexture
HmlValue hml_fn_UnloadRenderTexture(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_UnloadRenderTexture) {
        _ffi_ptr_UnloadRenderTexture = hml_ffi_sym(_ffi_lib, "UnloadRenderTexture");
        if (!_ffi_ptr_UnloadRenderTexture) {
            hml_runtime_error("FFI function '%s' not found in library", "UnloadRenderTexture");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "RenderTexture2D"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_UnloadRenderTexture, _args, 1, _types, _struct_names);
}

// FFI wrapper for IsRenderTextureValid
HmlValue hml_fn_IsRenderTextureValid(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsRenderTextureValid) {
        _ffi_ptr_IsRenderTextureValid = hml_ffi_sym(_ffi_lib, "IsRenderTextureValid");
        if (!_ffi_ptr_IsRenderTextureValid) {
            hml_runtime_error("FFI function '%s' not found in library", "IsRenderTextureValid");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "RenderTexture2D"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_IsRenderTextureValid, _args, 1, _types, _struct_names);
}

// FFI wrapper for BeginTextureMode
HmlValue hml_fn_BeginTextureMode(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_BeginTextureMode) {
        _ffi_ptr_BeginTextureMode = hml_ffi_sym(_ffi_lib, "BeginTextureMode");
        if (!_ffi_ptr_BeginTextureMode) {
            hml_runtime_error("FFI function '%s' not found in library", "BeginTextureMode");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "RenderTexture2D"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_BeginTextureMode, _args, 1, _types, _struct_names);
}

// FFI wrapper for EndTextureMode
HmlValue hml_fn_EndTextureMode(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_EndTextureMode) {
        _ffi_ptr_EndTextureMode = hml_ffi_sym(_ffi_lib, "EndTextureMode");
        if (!_ffi_ptr_EndTextureMode) {
            hml_runtime_error("FFI function '%s' not found in library", "EndTextureMode");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_VOID;
    return hml_ffi_call(_ffi_ptr_EndTextureMode, NULL, 0, _types);
}

// FFI wrapper for LoadSound
HmlValue hml_fn_LoadSound(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_LoadSound) {
        _ffi_ptr_LoadSound = hml_ffi_sym(_ffi_lib, "LoadSound");
        if (!_ffi_ptr_LoadSound) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadSound");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRING;
    static const char *_struct_names[2] = {
        "Sound",
        NULL
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadSound, _args, 1, _types, _struct_names);
}

// FFI wrapper for UnloadSound
HmlValue hml_fn_UnloadSound(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_UnloadSound) {
        _ffi_ptr_UnloadSound = hml_ffi_sym(_ffi_lib, "UnloadSound");
        if (!_ffi_ptr_UnloadSound) {
            hml_runtime_error("FFI function '%s' not found in library", "UnloadSound");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Sound"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_UnloadSound, _args, 1, _types, _struct_names);
}

// FFI wrapper for IsSoundValid
HmlValue hml_fn_IsSoundValid(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsSoundValid) {
        _ffi_ptr_IsSoundValid = hml_ffi_sym(_ffi_lib, "IsSoundValid");
        if (!_ffi_ptr_IsSoundValid) {
            hml_runtime_error("FFI function '%s' not found in library", "IsSoundValid");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Sound"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_IsSoundValid, _args, 1, _types, _struct_names);
}

// FFI wrapper for PlaySound
HmlValue hml_fn_PlaySound(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_PlaySound) {
        _ffi_ptr_PlaySound = hml_ffi_sym(_ffi_lib, "PlaySound");
        if (!_ffi_ptr_PlaySound) {
            hml_runtime_error("FFI function '%s' not found in library", "PlaySound");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Sound"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_PlaySound, _args, 1, _types, _struct_names);
}

// FFI wrapper for StopSound
HmlValue hml_fn_StopSound(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_StopSound) {
        _ffi_ptr_StopSound = hml_ffi_sym(_ffi_lib, "StopSound");
        if (!_ffi_ptr_StopSound) {
            hml_runtime_error("FFI function '%s' not found in library", "StopSound");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Sound"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_StopSound, _args, 1, _types, _struct_names);
}

// FFI wrapper for PauseSound
HmlValue hml_fn_PauseSound(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_PauseSound) {
        _ffi_ptr_PauseSound = hml_ffi_sym(_ffi_lib, "PauseSound");
        if (!_ffi_ptr_PauseSound) {
            hml_runtime_error("FFI function '%s' not found in library", "PauseSound");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Sound"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_PauseSound, _args, 1, _types, _struct_names);
}

// FFI wrapper for ResumeSound
HmlValue hml_fn_ResumeSound(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ResumeSound) {
        _ffi_ptr_ResumeSound = hml_ffi_sym(_ffi_lib, "ResumeSound");
        if (!_ffi_ptr_ResumeSound) {
            hml_runtime_error("FFI function '%s' not found in library", "ResumeSound");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Sound"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_ResumeSound, _args, 1, _types, _struct_names);
}

// FFI wrapper for IsSoundPlaying
HmlValue hml_fn_IsSoundPlaying(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsSoundPlaying) {
        _ffi_ptr_IsSoundPlaying = hml_ffi_sym(_ffi_lib, "IsSoundPlaying");
        if (!_ffi_ptr_IsSoundPlaying) {
            hml_runtime_error("FFI function '%s' not found in library", "IsSoundPlaying");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Sound"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_IsSoundPlaying, _args, 1, _types, _struct_names);
}

// FFI wrapper for SetSoundVolume
HmlValue hml_fn_SetSoundVolume(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetSoundVolume) {
        _ffi_ptr_SetSoundVolume = hml_ffi_sym(_ffi_lib, "SetSoundVolume");
        if (!_ffi_ptr_SetSoundVolume) {
            hml_runtime_error("FFI function '%s' not found in library", "SetSoundVolume");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    static const char *_struct_names[3] = {
        NULL,
        "Sound",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetSoundVolume, _args, 2, _types, _struct_names);
}

// FFI wrapper for SetSoundPitch
HmlValue hml_fn_SetSoundPitch(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetSoundPitch) {
        _ffi_ptr_SetSoundPitch = hml_ffi_sym(_ffi_lib, "SetSoundPitch");
        if (!_ffi_ptr_SetSoundPitch) {
            hml_runtime_error("FFI function '%s' not found in library", "SetSoundPitch");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    static const char *_struct_names[3] = {
        NULL,
        "Sound",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetSoundPitch, _args, 2, _types, _struct_names);
}

// FFI wrapper for SetSoundPan
HmlValue hml_fn_SetSoundPan(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetSoundPan) {
        _ffi_ptr_SetSoundPan = hml_ffi_sym(_ffi_lib, "SetSoundPan");
        if (!_ffi_ptr_SetSoundPan) {
            hml_runtime_error("FFI function '%s' not found in library", "SetSoundPan");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    static const char *_struct_names[3] = {
        NULL,
        "Sound",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetSoundPan, _args, 2, _types, _struct_names);
}

// FFI wrapper for LoadMusicStream
HmlValue hml_fn_LoadMusicStream(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_LoadMusicStream) {
        _ffi_ptr_LoadMusicStream = hml_ffi_sym(_ffi_lib, "LoadMusicStream");
        if (!_ffi_ptr_LoadMusicStream) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadMusicStream");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRING;
    static const char *_struct_names[2] = {
        "Music",
        NULL
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadMusicStream, _args, 1, _types, _struct_names);
}

// FFI wrapper for UnloadMusicStream
HmlValue hml_fn_UnloadMusicStream(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_UnloadMusicStream) {
        _ffi_ptr_UnloadMusicStream = hml_ffi_sym(_ffi_lib, "UnloadMusicStream");
        if (!_ffi_ptr_UnloadMusicStream) {
            hml_runtime_error("FFI function '%s' not found in library", "UnloadMusicStream");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_UnloadMusicStream, _args, 1, _types, _struct_names);
}

// FFI wrapper for IsMusicValid
HmlValue hml_fn_IsMusicValid(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsMusicValid) {
        _ffi_ptr_IsMusicValid = hml_ffi_sym(_ffi_lib, "IsMusicValid");
        if (!_ffi_ptr_IsMusicValid) {
            hml_runtime_error("FFI function '%s' not found in library", "IsMusicValid");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_IsMusicValid, _args, 1, _types, _struct_names);
}

// FFI wrapper for PlayMusicStream
HmlValue hml_fn_PlayMusicStream(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_PlayMusicStream) {
        _ffi_ptr_PlayMusicStream = hml_ffi_sym(_ffi_lib, "PlayMusicStream");
        if (!_ffi_ptr_PlayMusicStream) {
            hml_runtime_error("FFI function '%s' not found in library", "PlayMusicStream");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_PlayMusicStream, _args, 1, _types, _struct_names);
}

// FFI wrapper for StopMusicStream
HmlValue hml_fn_StopMusicStream(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_StopMusicStream) {
        _ffi_ptr_StopMusicStream = hml_ffi_sym(_ffi_lib, "StopMusicStream");
        if (!_ffi_ptr_StopMusicStream) {
            hml_runtime_error("FFI function '%s' not found in library", "StopMusicStream");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_StopMusicStream, _args, 1, _types, _struct_names);
}

// FFI wrapper for PauseMusicStream
HmlValue hml_fn_PauseMusicStream(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_PauseMusicStream) {
        _ffi_ptr_PauseMusicStream = hml_ffi_sym(_ffi_lib, "PauseMusicStream");
        if (!_ffi_ptr_PauseMusicStream) {
            hml_runtime_error("FFI function '%s' not found in library", "PauseMusicStream");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_PauseMusicStream, _args, 1, _types, _struct_names);
}

// FFI wrapper for ResumeMusicStream
HmlValue hml_fn_ResumeMusicStream(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ResumeMusicStream) {
        _ffi_ptr_ResumeMusicStream = hml_ffi_sym(_ffi_lib, "ResumeMusicStream");
        if (!_ffi_ptr_ResumeMusicStream) {
            hml_runtime_error("FFI function '%s' not found in library", "ResumeMusicStream");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_ResumeMusicStream, _args, 1, _types, _struct_names);
}

// FFI wrapper for UpdateMusicStream
HmlValue hml_fn_UpdateMusicStream(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_UpdateMusicStream) {
        _ffi_ptr_UpdateMusicStream = hml_ffi_sym(_ffi_lib, "UpdateMusicStream");
        if (!_ffi_ptr_UpdateMusicStream) {
            hml_runtime_error("FFI function '%s' not found in library", "UpdateMusicStream");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_UpdateMusicStream, _args, 1, _types, _struct_names);
}

// FFI wrapper for IsMusicStreamPlaying
HmlValue hml_fn_IsMusicStreamPlaying(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsMusicStreamPlaying) {
        _ffi_ptr_IsMusicStreamPlaying = hml_ffi_sym(_ffi_lib, "IsMusicStreamPlaying");
        if (!_ffi_ptr_IsMusicStreamPlaying) {
            hml_runtime_error("FFI function '%s' not found in library", "IsMusicStreamPlaying");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_IsMusicStreamPlaying, _args, 1, _types, _struct_names);
}

// FFI wrapper for SetMusicVolume
HmlValue hml_fn_SetMusicVolume(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetMusicVolume) {
        _ffi_ptr_SetMusicVolume = hml_ffi_sym(_ffi_lib, "SetMusicVolume");
        if (!_ffi_ptr_SetMusicVolume) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMusicVolume");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    static const char *_struct_names[3] = {
        NULL,
        "Music",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetMusicVolume, _args, 2, _types, _struct_names);
}

// FFI wrapper for SetMusicPitch
HmlValue hml_fn_SetMusicPitch(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetMusicPitch) {
        _ffi_ptr_SetMusicPitch = hml_ffi_sym(_ffi_lib, "SetMusicPitch");
        if (!_ffi_ptr_SetMusicPitch) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMusicPitch");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    static const char *_struct_names[3] = {
        NULL,
        "Music",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetMusicPitch, _args, 2, _types, _struct_names);
}

// FFI wrapper for SetMusicPan
HmlValue hml_fn_SetMusicPan(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetMusicPan) {
        _ffi_ptr_SetMusicPan = hml_ffi_sym(_ffi_lib, "SetMusicPan");
        if (!_ffi_ptr_SetMusicPan) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMusicPan");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    static const char *_struct_names[3] = {
        NULL,
        "Music",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetMusicPan, _args, 2, _types, _struct_names);
}

// FFI wrapper for GetMusicTimeLength
HmlValue hml_fn_GetMusicTimeLength(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetMusicTimeLength) {
        _ffi_ptr_GetMusicTimeLength = hml_ffi_sym(_ffi_lib, "GetMusicTimeLength");
        if (!_ffi_ptr_GetMusicTimeLength) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMusicTimeLength");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_F32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_GetMusicTimeLength, _args, 1, _types, _struct_names);
}

// FFI wrapper for GetMusicTimePlayed
HmlValue hml_fn_GetMusicTimePlayed(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetMusicTimePlayed) {
        _ffi_ptr_GetMusicTimePlayed = hml_ffi_sym(_ffi_lib, "GetMusicTimePlayed");
        if (!_ffi_ptr_GetMusicTimePlayed) {
            hml_runtime_error("FFI function '%s' not found in library", "GetMusicTimePlayed");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_F32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Music"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_GetMusicTimePlayed, _args, 1, _types, _struct_names);
}

// FFI wrapper for SeekMusicStream
HmlValue hml_fn_SeekMusicStream(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SeekMusicStream) {
        _ffi_ptr_SeekMusicStream = hml_ffi_sym(_ffi_lib, "SeekMusicStream");
        if (!_ffi_ptr_SeekMusicStream) {
            hml_runtime_error("FFI function '%s' not found in library", "SeekMusicStream");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_F32;
    static const char *_struct_names[3] = {
        NULL,
        "Music",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SeekMusicStream, _args, 2, _types, _struct_names);
}

// FFI wrapper for SetMusicLooping
HmlValue hml_fn_SetMusicLooping(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SetMusicLooping) {
        _ffi_ptr_SetMusicLooping = hml_ffi_sym(_ffi_lib, "SetMusicLooping");
        if (!_ffi_ptr_SetMusicLooping) {
            hml_runtime_error("FFI function '%s' not found in library", "SetMusicLooping");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_I32;
    static const char *_struct_names[3] = {
        NULL,
        "Music",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_SetMusicLooping, _args, 2, _types, _struct_names);
}

// FFI wrapper for LoadFont
HmlValue hml_fn_LoadFont(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_LoadFont) {
        _ffi_ptr_LoadFont = hml_ffi_sym(_ffi_lib, "LoadFont");
        if (!_ffi_ptr_LoadFont) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadFont");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRING;
    static const char *_struct_names[2] = {
        "Font",
        NULL
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadFont, _args, 1, _types, _struct_names);
}

// FFI wrapper for LoadFontEx
HmlValue hml_fn_LoadFontEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_LoadFontEx) {
        _ffi_ptr_LoadFontEx = hml_ffi_sym(_ffi_lib, "LoadFontEx");
        if (!_ffi_ptr_LoadFontEx) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadFontEx");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRING;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_PTR;
    _types[4] = HML_FFI_I32;
    static const char *_struct_names[5] = {
        "Font",
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadFontEx, _args, 4, _types, _struct_names);
}

// FFI wrapper for UnloadFont
HmlValue hml_fn_UnloadFont(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_UnloadFont) {
        _ffi_ptr_UnloadFont = hml_ffi_sym(_ffi_lib, "UnloadFont");
        if (!_ffi_ptr_UnloadFont) {
            hml_runtime_error("FFI function '%s' not found in library", "UnloadFont");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Font"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_UnloadFont, _args, 1, _types, _struct_names);
}

// FFI wrapper for IsFontValid
HmlValue hml_fn_IsFontValid(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsFontValid) {
        _ffi_ptr_IsFontValid = hml_ffi_sym(_ffi_lib, "IsFontValid");
        if (!_ffi_ptr_IsFontValid) {
            hml_runtime_error("FFI function '%s' not found in library", "IsFontValid");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Font"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_IsFontValid, _args, 1, _types, _struct_names);
}

// FFI wrapper for GetFontDefault
HmlValue hml_fn_GetFontDefault(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetFontDefault) {
        _ffi_ptr_GetFontDefault = hml_ffi_sym(_ffi_lib, "GetFontDefault");
        if (!_ffi_ptr_GetFontDefault) {
            hml_runtime_error("FFI function '%s' not found in library", "GetFontDefault");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_STRUCT;
    static const char *_struct_names[1] = {
        "Font"
    };
    return hml_ffi_call_with_structs(_ffi_ptr_GetFontDefault, NULL, 0, _types, _struct_names);
}

// FFI wrapper for DrawTextEx
HmlValue hml_fn_DrawTextEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_DrawTextEx) {
        _ffi_ptr_DrawTextEx = hml_ffi_sym(_ffi_lib, "DrawTextEx");
        if (!_ffi_ptr_DrawTextEx) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTextEx");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRING;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_F32;
    _types[5] = HML_FFI_F32;
    _types[6] = HML_FFI_U32;
    static const char *_struct_names[7] = {
        NULL,
        "Font",
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTextEx, _args, 6, _types, _struct_names);
}

// FFI wrapper for DrawTextPro
HmlValue hml_fn_DrawTextPro(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5, HmlValue _arg6, HmlValue _arg7) {
    (void)_env;
    if (!_ffi_ptr_DrawTextPro) {
        _ffi_ptr_DrawTextPro = hml_ffi_sym(_ffi_lib, "DrawTextPro");
        if (!_ffi_ptr_DrawTextPro) {
            hml_runtime_error("FFI function '%s' not found in library", "DrawTextPro");
        }
    }
    HmlFFIType _types[9];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRING;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_STRUCT;
    _types[5] = HML_FFI_F32;
    _types[6] = HML_FFI_F32;
    _types[7] = HML_FFI_F32;
    _types[8] = HML_FFI_U32;
    static const char *_struct_names[9] = {
        NULL,
        "Font",
        NULL,
        "Vector2",
        "Vector2",
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[8];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    _args[6] = _arg6;
    _args[7] = _arg7;
    return hml_ffi_call_with_structs(_ffi_ptr_DrawTextPro, _args, 8, _types, _struct_names);
}

// FFI wrapper for MeasureTextEx
HmlValue hml_fn_MeasureTextEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_MeasureTextEx) {
        _ffi_ptr_MeasureTextEx = hml_ffi_sym(_ffi_lib, "MeasureTextEx");
        if (!_ffi_ptr_MeasureTextEx) {
            hml_runtime_error("FFI function '%s' not found in library", "MeasureTextEx");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRING;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_F32;
    static const char *_struct_names[5] = {
        "Vector2",
        "Font",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_MeasureTextEx, _args, 4, _types, _struct_names);
}

// FFI wrapper for LoadImage
HmlValue hml_fn_LoadImage(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_LoadImage) {
        _ffi_ptr_LoadImage = hml_ffi_sym(_ffi_lib, "LoadImage");
        if (!_ffi_ptr_LoadImage) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadImage");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRING;
    static const char *_struct_names[2] = {
        "Image",
        NULL
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadImage, _args, 1, _types, _struct_names);
}

// FFI wrapper for LoadImageRaw
HmlValue hml_fn_LoadImageRaw(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_LoadImageRaw) {
        _ffi_ptr_LoadImageRaw = hml_ffi_sym(_ffi_lib, "LoadImageRaw");
        if (!_ffi_ptr_LoadImageRaw) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadImageRaw");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRING;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_I32;
    static const char *_struct_names[6] = {
        "Image",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadImageRaw, _args, 5, _types, _struct_names);
}

// FFI wrapper for LoadImageFromMemory
HmlValue hml_fn_LoadImageFromMemory(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_LoadImageFromMemory) {
        _ffi_ptr_LoadImageFromMemory = hml_ffi_sym(_ffi_lib, "LoadImageFromMemory");
        if (!_ffi_ptr_LoadImageFromMemory) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadImageFromMemory");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRING;
    _types[2] = HML_FFI_PTR;
    _types[3] = HML_FFI_I32;
    static const char *_struct_names[4] = {
        "Image",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_LoadImageFromMemory, _args, 3, _types, _struct_names);
}

// FFI wrapper for UnloadImage
HmlValue hml_fn_UnloadImage(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_UnloadImage) {
        _ffi_ptr_UnloadImage = hml_ffi_sym(_ffi_lib, "UnloadImage");
        if (!_ffi_ptr_UnloadImage) {
            hml_runtime_error("FFI function '%s' not found in library", "UnloadImage");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Image"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_UnloadImage, _args, 1, _types, _struct_names);
}

// FFI wrapper for IsImageValid
HmlValue hml_fn_IsImageValid(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsImageValid) {
        _ffi_ptr_IsImageValid = hml_ffi_sym(_ffi_lib, "IsImageValid");
        if (!_ffi_ptr_IsImageValid) {
            hml_runtime_error("FFI function '%s' not found in library", "IsImageValid");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        NULL,
        "Image"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_IsImageValid, _args, 1, _types, _struct_names);
}

// FFI wrapper for ExportImage
HmlValue hml_fn_ExportImage(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_ExportImage) {
        _ffi_ptr_ExportImage = hml_ffi_sym(_ffi_lib, "ExportImage");
        if (!_ffi_ptr_ExportImage) {
            hml_runtime_error("FFI function '%s' not found in library", "ExportImage");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRING;
    static const char *_struct_names[3] = {
        NULL,
        "Image",
        NULL
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_ExportImage, _args, 2, _types, _struct_names);
}

// FFI wrapper for GenImageColor
HmlValue hml_fn_GenImageColor(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_GenImageColor) {
        _ffi_ptr_GenImageColor = hml_ffi_sym(_ffi_lib, "GenImageColor");
        if (!_ffi_ptr_GenImageColor) {
            hml_runtime_error("FFI function '%s' not found in library", "GenImageColor");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        "Image",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_GenImageColor, _args, 3, _types, _struct_names);
}

// FFI wrapper for GenImageGradientLinear
HmlValue hml_fn_GenImageGradientLinear(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_GenImageGradientLinear) {
        _ffi_ptr_GenImageGradientLinear = hml_ffi_sym(_ffi_lib, "GenImageGradientLinear");
        if (!_ffi_ptr_GenImageGradientLinear) {
            hml_runtime_error("FFI function '%s' not found in library", "GenImageGradientLinear");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_U32;
    _types[5] = HML_FFI_U32;
    static const char *_struct_names[6] = {
        "Image",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_GenImageGradientLinear, _args, 5, _types, _struct_names);
}

// FFI wrapper for GenImageGradientRadial
HmlValue hml_fn_GenImageGradientRadial(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_GenImageGradientRadial) {
        _ffi_ptr_GenImageGradientRadial = hml_ffi_sym(_ffi_lib, "GenImageGradientRadial");
        if (!_ffi_ptr_GenImageGradientRadial) {
            hml_runtime_error("FFI function '%s' not found in library", "GenImageGradientRadial");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    _types[4] = HML_FFI_U32;
    _types[5] = HML_FFI_U32;
    static const char *_struct_names[6] = {
        "Image",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_GenImageGradientRadial, _args, 5, _types, _struct_names);
}

// FFI wrapper for GenImageChecked
HmlValue hml_fn_GenImageChecked(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_GenImageChecked) {
        _ffi_ptr_GenImageChecked = hml_ffi_sym(_ffi_lib, "GenImageChecked");
        if (!_ffi_ptr_GenImageChecked) {
            hml_runtime_error("FFI function '%s' not found in library", "GenImageChecked");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_U32;
    _types[6] = HML_FFI_U32;
    static const char *_struct_names[7] = {
        "Image",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call_with_structs(_ffi_ptr_GenImageChecked, _args, 6, _types, _struct_names);
}

// FFI wrapper for GenImageWhiteNoise
HmlValue hml_fn_GenImageWhiteNoise(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_GenImageWhiteNoise) {
        _ffi_ptr_GenImageWhiteNoise = hml_ffi_sym(_ffi_lib, "GenImageWhiteNoise");
        if (!_ffi_ptr_GenImageWhiteNoise) {
            hml_runtime_error("FFI function '%s' not found in library", "GenImageWhiteNoise");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_F32;
    static const char *_struct_names[4] = {
        "Image",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_GenImageWhiteNoise, _args, 3, _types, _struct_names);
}

// FFI wrapper for GenImagePerlinNoise
HmlValue hml_fn_GenImagePerlinNoise(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_GenImagePerlinNoise) {
        _ffi_ptr_GenImagePerlinNoise = hml_ffi_sym(_ffi_lib, "GenImagePerlinNoise");
        if (!_ffi_ptr_GenImagePerlinNoise) {
            hml_runtime_error("FFI function '%s' not found in library", "GenImagePerlinNoise");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_I32;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_F32;
    static const char *_struct_names[6] = {
        "Image",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call_with_structs(_ffi_ptr_GenImagePerlinNoise, _args, 5, _types, _struct_names);
}

// FFI wrapper for ImageCopy
HmlValue hml_fn_ImageCopy(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ImageCopy) {
        _ffi_ptr_ImageCopy = hml_ffi_sym(_ffi_lib, "ImageCopy");
        if (!_ffi_ptr_ImageCopy) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageCopy");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRUCT;
    static const char *_struct_names[2] = {
        "Image",
        "Image"
    };
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageCopy, _args, 1, _types, _struct_names);
}

// FFI wrapper for ImageFromImage
HmlValue hml_fn_ImageFromImage(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_ImageFromImage) {
        _ffi_ptr_ImageFromImage = hml_ffi_sym(_ffi_lib, "ImageFromImage");
        if (!_ffi_ptr_ImageFromImage) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageFromImage");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_STRUCT;
    _types[1] = HML_FFI_STRUCT;
    _types[2] = HML_FFI_STRUCT;
    static const char *_struct_names[3] = {
        "Image",
        "Image",
        "Rectangle"
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageFromImage, _args, 2, _types, _struct_names);
}

// FFI wrapper for ImageResize
HmlValue hml_fn_ImageResize(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_ImageResize) {
        _ffi_ptr_ImageResize = hml_ffi_sym(_ffi_lib, "ImageResize");
        if (!_ffi_ptr_ImageResize) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageResize");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call(_ffi_ptr_ImageResize, _args, 3, _types);
}

// FFI wrapper for ImageResizeNN
HmlValue hml_fn_ImageResizeNN(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_ImageResizeNN) {
        _ffi_ptr_ImageResizeNN = hml_ffi_sym(_ffi_lib, "ImageResizeNN");
        if (!_ffi_ptr_ImageResizeNN) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageResizeNN");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call(_ffi_ptr_ImageResizeNN, _args, 3, _types);
}

// FFI wrapper for ImageCrop
HmlValue hml_fn_ImageCrop(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_ImageCrop) {
        _ffi_ptr_ImageCrop = hml_ffi_sym(_ffi_lib, "ImageCrop");
        if (!_ffi_ptr_ImageCrop) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageCrop");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_STRUCT;
    static const char *_struct_names[3] = {
        NULL,
        NULL,
        "Rectangle"
    };
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageCrop, _args, 2, _types, _struct_names);
}

// FFI wrapper for ImageFlipVertical
HmlValue hml_fn_ImageFlipVertical(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ImageFlipVertical) {
        _ffi_ptr_ImageFlipVertical = hml_ffi_sym(_ffi_lib, "ImageFlipVertical");
        if (!_ffi_ptr_ImageFlipVertical) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageFlipVertical");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ImageFlipVertical, _args, 1, _types);
}

// FFI wrapper for ImageFlipHorizontal
HmlValue hml_fn_ImageFlipHorizontal(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ImageFlipHorizontal) {
        _ffi_ptr_ImageFlipHorizontal = hml_ffi_sym(_ffi_lib, "ImageFlipHorizontal");
        if (!_ffi_ptr_ImageFlipHorizontal) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageFlipHorizontal");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ImageFlipHorizontal, _args, 1, _types);
}

// FFI wrapper for ImageRotate
HmlValue hml_fn_ImageRotate(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_ImageRotate) {
        _ffi_ptr_ImageRotate = hml_ffi_sym(_ffi_lib, "ImageRotate");
        if (!_ffi_ptr_ImageRotate) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageRotate");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_ImageRotate, _args, 2, _types);
}

// FFI wrapper for ImageRotateCW
HmlValue hml_fn_ImageRotateCW(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ImageRotateCW) {
        _ffi_ptr_ImageRotateCW = hml_ffi_sym(_ffi_lib, "ImageRotateCW");
        if (!_ffi_ptr_ImageRotateCW) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageRotateCW");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ImageRotateCW, _args, 1, _types);
}

// FFI wrapper for ImageRotateCCW
HmlValue hml_fn_ImageRotateCCW(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ImageRotateCCW) {
        _ffi_ptr_ImageRotateCCW = hml_ffi_sym(_ffi_lib, "ImageRotateCCW");
        if (!_ffi_ptr_ImageRotateCCW) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageRotateCCW");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ImageRotateCCW, _args, 1, _types);
}

// FFI wrapper for ImageColorTint
HmlValue hml_fn_ImageColorTint(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_ImageColorTint) {
        _ffi_ptr_ImageColorTint = hml_ffi_sym(_ffi_lib, "ImageColorTint");
        if (!_ffi_ptr_ImageColorTint) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageColorTint");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_U32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_ImageColorTint, _args, 2, _types);
}

// FFI wrapper for ImageColorInvert
HmlValue hml_fn_ImageColorInvert(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ImageColorInvert) {
        _ffi_ptr_ImageColorInvert = hml_ffi_sym(_ffi_lib, "ImageColorInvert");
        if (!_ffi_ptr_ImageColorInvert) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageColorInvert");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ImageColorInvert, _args, 1, _types);
}

// FFI wrapper for ImageColorGrayscale
HmlValue hml_fn_ImageColorGrayscale(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ImageColorGrayscale) {
        _ffi_ptr_ImageColorGrayscale = hml_ffi_sym(_ffi_lib, "ImageColorGrayscale");
        if (!_ffi_ptr_ImageColorGrayscale) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageColorGrayscale");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ImageColorGrayscale, _args, 1, _types);
}

// FFI wrapper for ImageColorContrast
HmlValue hml_fn_ImageColorContrast(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_ImageColorContrast) {
        _ffi_ptr_ImageColorContrast = hml_ffi_sym(_ffi_lib, "ImageColorContrast");
        if (!_ffi_ptr_ImageColorContrast) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageColorContrast");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_F32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_ImageColorContrast, _args, 2, _types);
}

// FFI wrapper for ImageColorBrightness
HmlValue hml_fn_ImageColorBrightness(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_ImageColorBrightness) {
        _ffi_ptr_ImageColorBrightness = hml_ffi_sym(_ffi_lib, "ImageColorBrightness");
        if (!_ffi_ptr_ImageColorBrightness) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageColorBrightness");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_ImageColorBrightness, _args, 2, _types);
}

// FFI wrapper for ImageClearBackground
HmlValue hml_fn_ImageClearBackground(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_ImageClearBackground) {
        _ffi_ptr_ImageClearBackground = hml_ffi_sym(_ffi_lib, "ImageClearBackground");
        if (!_ffi_ptr_ImageClearBackground) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageClearBackground");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_U32;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_ImageClearBackground, _args, 2, _types);
}

// FFI wrapper for ImageDrawPixel
HmlValue hml_fn_ImageDrawPixel(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawPixel) {
        _ffi_ptr_ImageDrawPixel = hml_ffi_sym(_ffi_lib, "ImageDrawPixel");
        if (!_ffi_ptr_ImageDrawPixel) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawPixel");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_U32;
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call(_ffi_ptr_ImageDrawPixel, _args, 4, _types);
}

// FFI wrapper for ImageDrawPixelV
HmlValue hml_fn_ImageDrawPixelV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawPixelV) {
        _ffi_ptr_ImageDrawPixelV = hml_ffi_sym(_ffi_lib, "ImageDrawPixelV");
        if (!_ffi_ptr_ImageDrawPixelV) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawPixelV");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        NULL,
        NULL,
        "Vector2",
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageDrawPixelV, _args, 3, _types, _struct_names);
}

// FFI wrapper for ImageDrawLine
HmlValue hml_fn_ImageDrawLine(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawLine) {
        _ffi_ptr_ImageDrawLine = hml_ffi_sym(_ffi_lib, "ImageDrawLine");
        if (!_ffi_ptr_ImageDrawLine) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawLine");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_I32;
    _types[6] = HML_FFI_U32;
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call(_ffi_ptr_ImageDrawLine, _args, 6, _types);
}

// FFI wrapper for ImageDrawLineV
HmlValue hml_fn_ImageDrawLineV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawLineV) {
        _ffi_ptr_ImageDrawLineV = hml_ffi_sym(_ffi_lib, "ImageDrawLineV");
        if (!_ffi_ptr_ImageDrawLineV) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawLineV");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        NULL,
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageDrawLineV, _args, 4, _types, _struct_names);
}

// FFI wrapper for ImageDrawCircle
HmlValue hml_fn_ImageDrawCircle(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawCircle) {
        _ffi_ptr_ImageDrawCircle = hml_ffi_sym(_ffi_lib, "ImageDrawCircle");
        if (!_ffi_ptr_ImageDrawCircle) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawCircle");
        }
    }
    HmlFFIType _types[6];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_U32;
    HmlValue _args[5];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    return hml_ffi_call(_ffi_ptr_ImageDrawCircle, _args, 5, _types);
}

// FFI wrapper for ImageDrawCircleV
HmlValue hml_fn_ImageDrawCircleV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawCircleV) {
        _ffi_ptr_ImageDrawCircleV = hml_ffi_sym(_ffi_lib, "ImageDrawCircleV");
        if (!_ffi_ptr_ImageDrawCircleV) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawCircleV");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        NULL,
        "Vector2",
        NULL,
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageDrawCircleV, _args, 4, _types, _struct_names);
}

// FFI wrapper for ImageDrawRectangle
HmlValue hml_fn_ImageDrawRectangle(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawRectangle) {
        _ffi_ptr_ImageDrawRectangle = hml_ffi_sym(_ffi_lib, "ImageDrawRectangle");
        if (!_ffi_ptr_ImageDrawRectangle) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawRectangle");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_I32;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_I32;
    _types[6] = HML_FFI_U32;
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call(_ffi_ptr_ImageDrawRectangle, _args, 6, _types);
}

// FFI wrapper for ImageDrawRectangleV
HmlValue hml_fn_ImageDrawRectangleV(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawRectangleV) {
        _ffi_ptr_ImageDrawRectangleV = hml_ffi_sym(_ffi_lib, "ImageDrawRectangleV");
        if (!_ffi_ptr_ImageDrawRectangleV) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawRectangleV");
        }
    }
    HmlFFIType _types[5];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRUCT;
    _types[4] = HML_FFI_U32;
    static const char *_struct_names[5] = {
        NULL,
        NULL,
        "Vector2",
        "Vector2",
        NULL
    };
    HmlValue _args[4];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageDrawRectangleV, _args, 4, _types, _struct_names);
}

// FFI wrapper for ImageDrawRectangleRec
HmlValue hml_fn_ImageDrawRectangleRec(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawRectangleRec) {
        _ffi_ptr_ImageDrawRectangleRec = hml_ffi_sym(_ffi_lib, "ImageDrawRectangleRec");
        if (!_ffi_ptr_ImageDrawRectangleRec) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawRectangleRec");
        }
    }
    HmlFFIType _types[4];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_U32;
    static const char *_struct_names[4] = {
        NULL,
        NULL,
        "Rectangle",
        NULL
    };
    HmlValue _args[3];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageDrawRectangleRec, _args, 3, _types, _struct_names);
}

// FFI wrapper for ImageDrawText
HmlValue hml_fn_ImageDrawText(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawText) {
        _ffi_ptr_ImageDrawText = hml_ffi_sym(_ffi_lib, "ImageDrawText");
        if (!_ffi_ptr_ImageDrawText) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawText");
        }
    }
    HmlFFIType _types[7];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_STRING;
    _types[3] = HML_FFI_I32;
    _types[4] = HML_FFI_I32;
    _types[5] = HML_FFI_I32;
    _types[6] = HML_FFI_U32;
    HmlValue _args[6];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    return hml_ffi_call(_ffi_ptr_ImageDrawText, _args, 6, _types);
}

// FFI wrapper for ImageDrawTextEx
HmlValue hml_fn_ImageDrawTextEx(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1, HmlValue _arg2, HmlValue _arg3, HmlValue _arg4, HmlValue _arg5, HmlValue _arg6) {
    (void)_env;
    if (!_ffi_ptr_ImageDrawTextEx) {
        _ffi_ptr_ImageDrawTextEx = hml_ffi_sym(_ffi_lib, "ImageDrawTextEx");
        if (!_ffi_ptr_ImageDrawTextEx) {
            hml_runtime_error("FFI function '%s' not found in library", "ImageDrawTextEx");
        }
    }
    HmlFFIType _types[8];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_PTR;
    _types[2] = HML_FFI_STRUCT;
    _types[3] = HML_FFI_STRING;
    _types[4] = HML_FFI_STRUCT;
    _types[5] = HML_FFI_F32;
    _types[6] = HML_FFI_F32;
    _types[7] = HML_FFI_U32;
    static const char *_struct_names[8] = {
        NULL,
        NULL,
        "Font",
        NULL,
        "Vector2",
        NULL,
        NULL,
        NULL
    };
    HmlValue _args[7];
    _args[0] = _arg0;
    _args[1] = _arg1;
    _args[2] = _arg2;
    _args[3] = _arg3;
    _args[4] = _arg4;
    _args[5] = _arg5;
    _args[6] = _arg6;
    return hml_ffi_call_with_structs(_ffi_ptr_ImageDrawTextEx, _args, 7, _types, _struct_names);
}

// FFI wrapper for FileExists
HmlValue hml_fn_FileExists(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_FileExists) {
        _ffi_ptr_FileExists = hml_ffi_sym(_ffi_lib, "FileExists");
        if (!_ffi_ptr_FileExists) {
            hml_runtime_error("FFI function '%s' not found in library", "FileExists");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_FileExists, _args, 1, _types);
}

// FFI wrapper for DirectoryExists
HmlValue hml_fn_DirectoryExists(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_DirectoryExists) {
        _ffi_ptr_DirectoryExists = hml_ffi_sym(_ffi_lib, "DirectoryExists");
        if (!_ffi_ptr_DirectoryExists) {
            hml_runtime_error("FFI function '%s' not found in library", "DirectoryExists");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_DirectoryExists, _args, 1, _types);
}

// FFI wrapper for IsFileExtension
HmlValue hml_fn_IsFileExtension(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_IsFileExtension) {
        _ffi_ptr_IsFileExtension = hml_ffi_sym(_ffi_lib, "IsFileExtension");
        if (!_ffi_ptr_IsFileExtension) {
            hml_runtime_error("FFI function '%s' not found in library", "IsFileExtension");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    _types[2] = HML_FFI_STRING;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_IsFileExtension, _args, 2, _types);
}

// FFI wrapper for GetFileExtension
HmlValue hml_fn_GetFileExtension(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetFileExtension) {
        _ffi_ptr_GetFileExtension = hml_ffi_sym(_ffi_lib, "GetFileExtension");
        if (!_ffi_ptr_GetFileExtension) {
            hml_runtime_error("FFI function '%s' not found in library", "GetFileExtension");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetFileExtension, _args, 1, _types);
}

// FFI wrapper for GetFileName
HmlValue hml_fn_GetFileName(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetFileName) {
        _ffi_ptr_GetFileName = hml_ffi_sym(_ffi_lib, "GetFileName");
        if (!_ffi_ptr_GetFileName) {
            hml_runtime_error("FFI function '%s' not found in library", "GetFileName");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetFileName, _args, 1, _types);
}

// FFI wrapper for GetFileNameWithoutExt
HmlValue hml_fn_GetFileNameWithoutExt(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetFileNameWithoutExt) {
        _ffi_ptr_GetFileNameWithoutExt = hml_ffi_sym(_ffi_lib, "GetFileNameWithoutExt");
        if (!_ffi_ptr_GetFileNameWithoutExt) {
            hml_runtime_error("FFI function '%s' not found in library", "GetFileNameWithoutExt");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetFileNameWithoutExt, _args, 1, _types);
}

// FFI wrapper for GetDirectoryPath
HmlValue hml_fn_GetDirectoryPath(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetDirectoryPath) {
        _ffi_ptr_GetDirectoryPath = hml_ffi_sym(_ffi_lib, "GetDirectoryPath");
        if (!_ffi_ptr_GetDirectoryPath) {
            hml_runtime_error("FFI function '%s' not found in library", "GetDirectoryPath");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetDirectoryPath, _args, 1, _types);
}

// FFI wrapper for GetPrevDirectoryPath
HmlValue hml_fn_GetPrevDirectoryPath(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetPrevDirectoryPath) {
        _ffi_ptr_GetPrevDirectoryPath = hml_ffi_sym(_ffi_lib, "GetPrevDirectoryPath");
        if (!_ffi_ptr_GetPrevDirectoryPath) {
            hml_runtime_error("FFI function '%s' not found in library", "GetPrevDirectoryPath");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetPrevDirectoryPath, _args, 1, _types);
}

// FFI wrapper for GetWorkingDirectory
HmlValue hml_fn_GetWorkingDirectory(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetWorkingDirectory) {
        _ffi_ptr_GetWorkingDirectory = hml_ffi_sym(_ffi_lib, "GetWorkingDirectory");
        if (!_ffi_ptr_GetWorkingDirectory) {
            hml_runtime_error("FFI function '%s' not found in library", "GetWorkingDirectory");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_STRING;
    return hml_ffi_call(_ffi_ptr_GetWorkingDirectory, NULL, 0, _types);
}

// FFI wrapper for ChangeDirectory
HmlValue hml_fn_ChangeDirectory(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_ChangeDirectory) {
        _ffi_ptr_ChangeDirectory = hml_ffi_sym(_ffi_lib, "ChangeDirectory");
        if (!_ffi_ptr_ChangeDirectory) {
            hml_runtime_error("FFI function '%s' not found in library", "ChangeDirectory");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_ChangeDirectory, _args, 1, _types);
}

// FFI wrapper for GetFileLength
HmlValue hml_fn_GetFileLength(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetFileLength) {
        _ffi_ptr_GetFileLength = hml_ffi_sym(_ffi_lib, "GetFileLength");
        if (!_ffi_ptr_GetFileLength) {
            hml_runtime_error("FFI function '%s' not found in library", "GetFileLength");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetFileLength, _args, 1, _types);
}

// FFI wrapper for GetFileModTime
HmlValue hml_fn_GetFileModTime(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_GetFileModTime) {
        _ffi_ptr_GetFileModTime = hml_ffi_sym(_ffi_lib, "GetFileModTime");
        if (!_ffi_ptr_GetFileModTime) {
            hml_runtime_error("FFI function '%s' not found in library", "GetFileModTime");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I64;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_GetFileModTime, _args, 1, _types);
}

// FFI wrapper for IsPathFile
HmlValue hml_fn_IsPathFile(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_IsPathFile) {
        _ffi_ptr_IsPathFile = hml_ffi_sym(_ffi_lib, "IsPathFile");
        if (!_ffi_ptr_IsPathFile) {
            hml_runtime_error("FFI function '%s' not found in library", "IsPathFile");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_IsPathFile, _args, 1, _types);
}

// FFI wrapper for GetApplicationDirectory
HmlValue hml_fn_GetApplicationDirectory(HmlClosureEnv *_env) {
    (void)_env;
    if (!_ffi_ptr_GetApplicationDirectory) {
        _ffi_ptr_GetApplicationDirectory = hml_ffi_sym(_ffi_lib, "GetApplicationDirectory");
        if (!_ffi_ptr_GetApplicationDirectory) {
            hml_runtime_error("FFI function '%s' not found in library", "GetApplicationDirectory");
        }
    }
    HmlFFIType _types[1];
    _types[0] = HML_FFI_STRING;
    return hml_ffi_call(_ffi_ptr_GetApplicationDirectory, NULL, 0, _types);
}

// FFI wrapper for LoadFileText
HmlValue hml_fn_LoadFileText(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_LoadFileText) {
        _ffi_ptr_LoadFileText = hml_ffi_sym(_ffi_lib, "LoadFileText");
        if (!_ffi_ptr_LoadFileText) {
            hml_runtime_error("FFI function '%s' not found in library", "LoadFileText");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_STRING;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_LoadFileText, _args, 1, _types);
}

// FFI wrapper for UnloadFileText
HmlValue hml_fn_UnloadFileText(HmlClosureEnv *_env, HmlValue _arg0) {
    (void)_env;
    if (!_ffi_ptr_UnloadFileText) {
        _ffi_ptr_UnloadFileText = hml_ffi_sym(_ffi_lib, "UnloadFileText");
        if (!_ffi_ptr_UnloadFileText) {
            hml_runtime_error("FFI function '%s' not found in library", "UnloadFileText");
        }
    }
    HmlFFIType _types[2];
    _types[0] = HML_FFI_VOID;
    _types[1] = HML_FFI_STRING;
    HmlValue _args[1];
    _args[0] = _arg0;
    return hml_ffi_call(_ffi_ptr_UnloadFileText, _args, 1, _types);
}

// FFI wrapper for SaveFileText
HmlValue hml_fn_SaveFileText(HmlClosureEnv *_env, HmlValue _arg0, HmlValue _arg1) {
    (void)_env;
    if (!_ffi_ptr_SaveFileText) {
        _ffi_ptr_SaveFileText = hml_ffi_sym(_ffi_lib, "SaveFileText");
        if (!_ffi_ptr_SaveFileText) {
            hml_runtime_error("FFI function '%s' not found in library", "SaveFileText");
        }
    }
    HmlFFIType _types[3];
    _types[0] = HML_FFI_I32;
    _types[1] = HML_FFI_STRING;
    _types[2] = HML_FFI_STRING;
    HmlValue _args[2];
    _args[0] = _arg0;
    _args[1] = _arg1;
    return hml_ffi_call(_ffi_ptr_SaveFileText, _args, 2, _types);
}

// Module function implementations
HmlValue _mod0_fn_Color(HmlClosureEnv *_closure_env, HmlValue r, HmlValue g, HmlValue b, HmlValue a) {
    (void)_closure_env;
    HmlValue _tmp0 = r;
    hml_retain_if_needed(&_tmp0);
    HmlValue r32 = hml_convert_to_type(_tmp0, HML_VAL_U32);
    HmlValue _tmp1 = g;
    hml_retain_if_needed(&_tmp1);
    HmlValue g32 = hml_convert_to_type(_tmp1, HML_VAL_U32);
    HmlValue _tmp2 = b;
    hml_retain_if_needed(&_tmp2);
    HmlValue b32 = hml_convert_to_type(_tmp2, HML_VAL_U32);
    HmlValue _tmp3 = a;
    hml_retain_if_needed(&_tmp3);
    HmlValue a32 = hml_convert_to_type(_tmp3, HML_VAL_U32);
    HmlValue _tmp8 = a32;
    hml_retain_if_needed(&_tmp8);
    HmlValue _tmp9 = hml_val_i32(24);
    HmlValue _tmp7 = hml_both_i32(_tmp8, _tmp9) ? hml_i32_lshift(_tmp8, _tmp9) : (hml_both_i64(_tmp8, _tmp9) ? hml_i64_lshift(_tmp8, _tmp9) : hml_binary_op(HML_OP_LSHIFT, _tmp8, _tmp9));
    hml_release_if_needed(&_tmp8);
    hml_release_if_needed(&_tmp9);
    HmlValue _tmp11 = b32;
    hml_retain_if_needed(&_tmp11);
    HmlValue _tmp12 = hml_val_i32(16);
    HmlValue _tmp10 = hml_both_i32(_tmp11, _tmp12) ? hml_i32_lshift(_tmp11, _tmp12) : (hml_both_i64(_tmp11, _tmp12) ? hml_i64_lshift(_tmp11, _tmp12) : hml_binary_op(HML_OP_LSHIFT, _tmp11, _tmp12));
    hml_release_if_needed(&_tmp11);
    hml_release_if_needed(&_tmp12);
    HmlValue _tmp6 = hml_both_i32(_tmp7, _tmp10) ? hml_i32_bit_or(_tmp7, _tmp10) : (hml_both_i64(_tmp7, _tmp10) ? hml_i64_bit_or(_tmp7, _tmp10) : hml_binary_op(HML_OP_BIT_OR, _tmp7, _tmp10));
    hml_release_if_needed(&_tmp7);
    hml_release_if_needed(&_tmp10);
    HmlValue _tmp14 = g32;
    hml_retain_if_needed(&_tmp14);
    HmlValue _tmp15 = hml_val_i32(8);
    HmlValue _tmp13 = hml_both_i32(_tmp14, _tmp15) ? hml_i32_lshift(_tmp14, _tmp15) : (hml_both_i64(_tmp14, _tmp15) ? hml_i64_lshift(_tmp14, _tmp15) : hml_binary_op(HML_OP_LSHIFT, _tmp14, _tmp15));
    hml_release_if_needed(&_tmp14);
    hml_release_if_needed(&_tmp15);
    HmlValue _tmp5 = hml_both_i32(_tmp6, _tmp13) ? hml_i32_bit_or(_tmp6, _tmp13) : (hml_both_i64(_tmp6, _tmp13) ? hml_i64_bit_or(_tmp6, _tmp13) : hml_binary_op(HML_OP_BIT_OR, _tmp6, _tmp13));
    hml_release_if_needed(&_tmp6);
    hml_release_if_needed(&_tmp13);
    HmlValue _tmp16 = r32;
    hml_retain_if_needed(&_tmp16);
    HmlValue _tmp4 = hml_both_i32(_tmp5, _tmp16) ? hml_i32_bit_or(_tmp5, _tmp16) : (hml_both_i64(_tmp5, _tmp16) ? hml_i64_bit_or(_tmp5, _tmp16) : hml_binary_op(HML_OP_BIT_OR, _tmp5, _tmp16));
    hml_release_if_needed(&_tmp5);
    hml_release_if_needed(&_tmp16);
    HML_CALL_EXIT();
    return _tmp4;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorAlpha(HmlClosureEnv *_closure_env, HmlValue color, HmlValue alpha) {
    (void)_closure_env;
    HmlValue _tmp18 = alpha;
    hml_retain_if_needed(&_tmp18);
    HmlValue _tmp19 = hml_val_f64(255);
    HmlValue _tmp17 = hml_both_i32(_tmp18, _tmp19) ? hml_i32_mul(_tmp18, _tmp19) : (hml_both_i64(_tmp18, _tmp19) ? hml_i64_mul(_tmp18, _tmp19) : hml_binary_op(HML_OP_MUL, _tmp18, _tmp19));
    hml_release_if_needed(&_tmp18);
    hml_release_if_needed(&_tmp19);
    HmlValue a = hml_convert_to_type(_tmp17, HML_VAL_U32);
    HmlValue _tmp21 = a;
    hml_retain_if_needed(&_tmp21);
    HmlValue _tmp22 = hml_val_i32(255);
    HmlValue _tmp20 = hml_both_i32(_tmp21, _tmp22) ? hml_i32_gt(_tmp21, _tmp22) : (hml_both_i64(_tmp21, _tmp22) ? hml_i64_gt(_tmp21, _tmp22) : hml_binary_op(HML_OP_GREATER, _tmp21, _tmp22));
    hml_release_if_needed(&_tmp21);
    hml_release_if_needed(&_tmp22);
    if (hml_to_bool(_tmp20)) {
        {
            HmlValue _tmp24 = hml_val_i32(255);
            hml_release(&a);
            a = _tmp24;
            hml_retain(&a);
            HmlValue _tmp23 = a;
            hml_retain(&_tmp23);
            hml_release(&_tmp23);
        }
    }
    hml_release(&_tmp20);
    HmlValue _tmp27 = color;
    hml_retain_if_needed(&_tmp27);
    HmlValue _tmp28 = hml_val_i32(16777215);
    HmlValue _tmp26 = hml_both_i32(_tmp27, _tmp28) ? hml_i32_bit_and(_tmp27, _tmp28) : (hml_both_i64(_tmp27, _tmp28) ? hml_i64_bit_and(_tmp27, _tmp28) : hml_binary_op(HML_OP_BIT_AND, _tmp27, _tmp28));
    hml_release_if_needed(&_tmp27);
    hml_release_if_needed(&_tmp28);
    HmlValue _tmp30 = a;
    hml_retain_if_needed(&_tmp30);
    HmlValue _tmp31 = hml_val_i32(24);
    HmlValue _tmp29 = hml_both_i32(_tmp30, _tmp31) ? hml_i32_lshift(_tmp30, _tmp31) : (hml_both_i64(_tmp30, _tmp31) ? hml_i64_lshift(_tmp30, _tmp31) : hml_binary_op(HML_OP_LSHIFT, _tmp30, _tmp31));
    hml_release_if_needed(&_tmp30);
    hml_release_if_needed(&_tmp31);
    HmlValue _tmp25 = hml_both_i32(_tmp26, _tmp29) ? hml_i32_bit_or(_tmp26, _tmp29) : (hml_both_i64(_tmp26, _tmp29) ? hml_i64_bit_or(_tmp26, _tmp29) : hml_binary_op(HML_OP_BIT_OR, _tmp26, _tmp29));
    hml_release_if_needed(&_tmp26);
    hml_release_if_needed(&_tmp29);
    HML_CALL_EXIT();
    return _tmp25;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorBrightness(HmlClosureEnv *_closure_env, HmlValue color, HmlValue factor) {
    (void)_closure_env;
    HmlValue _tmp33 = color;
    hml_retain_if_needed(&_tmp33);
    HmlValue _tmp34 = hml_val_i32(255);
    HmlValue _tmp32 = hml_both_i32(_tmp33, _tmp34) ? hml_i32_bit_and(_tmp33, _tmp34) : (hml_both_i64(_tmp33, _tmp34) ? hml_i64_bit_and(_tmp33, _tmp34) : hml_binary_op(HML_OP_BIT_AND, _tmp33, _tmp34));
    hml_release_if_needed(&_tmp33);
    hml_release_if_needed(&_tmp34);
    HmlValue r = hml_convert_to_type(_tmp32, HML_VAL_U32);
    HmlValue _tmp37 = color;
    hml_retain_if_needed(&_tmp37);
    HmlValue _tmp38 = hml_val_i32(8);
    HmlValue _tmp36 = hml_both_i32(_tmp37, _tmp38) ? hml_i32_rshift(_tmp37, _tmp38) : (hml_both_i64(_tmp37, _tmp38) ? hml_i64_rshift(_tmp37, _tmp38) : hml_binary_op(HML_OP_RSHIFT, _tmp37, _tmp38));
    hml_release_if_needed(&_tmp37);
    hml_release_if_needed(&_tmp38);
    HmlValue _tmp39 = hml_val_i32(255);
    HmlValue _tmp35 = hml_both_i32(_tmp36, _tmp39) ? hml_i32_bit_and(_tmp36, _tmp39) : (hml_both_i64(_tmp36, _tmp39) ? hml_i64_bit_and(_tmp36, _tmp39) : hml_binary_op(HML_OP_BIT_AND, _tmp36, _tmp39));
    hml_release_if_needed(&_tmp36);
    hml_release_if_needed(&_tmp39);
    HmlValue g = hml_convert_to_type(_tmp35, HML_VAL_U32);
    HmlValue _tmp42 = color;
    hml_retain_if_needed(&_tmp42);
    HmlValue _tmp43 = hml_val_i32(16);
    HmlValue _tmp41 = hml_both_i32(_tmp42, _tmp43) ? hml_i32_rshift(_tmp42, _tmp43) : (hml_both_i64(_tmp42, _tmp43) ? hml_i64_rshift(_tmp42, _tmp43) : hml_binary_op(HML_OP_RSHIFT, _tmp42, _tmp43));
    hml_release_if_needed(&_tmp42);
    hml_release_if_needed(&_tmp43);
    HmlValue _tmp44 = hml_val_i32(255);
    HmlValue _tmp40 = hml_both_i32(_tmp41, _tmp44) ? hml_i32_bit_and(_tmp41, _tmp44) : (hml_both_i64(_tmp41, _tmp44) ? hml_i64_bit_and(_tmp41, _tmp44) : hml_binary_op(HML_OP_BIT_AND, _tmp41, _tmp44));
    hml_release_if_needed(&_tmp41);
    hml_release_if_needed(&_tmp44);
    HmlValue b = hml_convert_to_type(_tmp40, HML_VAL_U32);
    HmlValue _tmp47 = color;
    hml_retain_if_needed(&_tmp47);
    HmlValue _tmp48 = hml_val_i32(24);
    HmlValue _tmp46 = hml_both_i32(_tmp47, _tmp48) ? hml_i32_rshift(_tmp47, _tmp48) : (hml_both_i64(_tmp47, _tmp48) ? hml_i64_rshift(_tmp47, _tmp48) : hml_binary_op(HML_OP_RSHIFT, _tmp47, _tmp48));
    hml_release_if_needed(&_tmp47);
    hml_release_if_needed(&_tmp48);
    HmlValue _tmp49 = hml_val_i32(255);
    HmlValue _tmp45 = hml_both_i32(_tmp46, _tmp49) ? hml_i32_bit_and(_tmp46, _tmp49) : (hml_both_i64(_tmp46, _tmp49) ? hml_i64_bit_and(_tmp46, _tmp49) : hml_binary_op(HML_OP_BIT_AND, _tmp46, _tmp49));
    hml_release_if_needed(&_tmp46);
    hml_release_if_needed(&_tmp49);
    HmlValue a = hml_convert_to_type(_tmp45, HML_VAL_U32);
    HmlValue _tmp51 = r;
    hml_retain_if_needed(&_tmp51);
    HmlValue _tmp52 = factor;
    hml_retain_if_needed(&_tmp52);
    HmlValue _tmp50 = hml_both_i32(_tmp51, _tmp52) ? hml_i32_mul(_tmp51, _tmp52) : (hml_both_i64(_tmp51, _tmp52) ? hml_i64_mul(_tmp51, _tmp52) : hml_binary_op(HML_OP_MUL, _tmp51, _tmp52));
    hml_release_if_needed(&_tmp51);
    hml_release_if_needed(&_tmp52);
    HmlValue nr = hml_convert_to_type(_tmp50, HML_VAL_I32);
    HmlValue _tmp54 = g;
    hml_retain_if_needed(&_tmp54);
    HmlValue _tmp55 = factor;
    hml_retain_if_needed(&_tmp55);
    HmlValue _tmp53 = hml_both_i32(_tmp54, _tmp55) ? hml_i32_mul(_tmp54, _tmp55) : (hml_both_i64(_tmp54, _tmp55) ? hml_i64_mul(_tmp54, _tmp55) : hml_binary_op(HML_OP_MUL, _tmp54, _tmp55));
    hml_release_if_needed(&_tmp54);
    hml_release_if_needed(&_tmp55);
    HmlValue ng = hml_convert_to_type(_tmp53, HML_VAL_I32);
    HmlValue _tmp57 = b;
    hml_retain_if_needed(&_tmp57);
    HmlValue _tmp58 = factor;
    hml_retain_if_needed(&_tmp58);
    HmlValue _tmp56 = hml_both_i32(_tmp57, _tmp58) ? hml_i32_mul(_tmp57, _tmp58) : (hml_both_i64(_tmp57, _tmp58) ? hml_i64_mul(_tmp57, _tmp58) : hml_binary_op(HML_OP_MUL, _tmp57, _tmp58));
    hml_release_if_needed(&_tmp57);
    hml_release_if_needed(&_tmp58);
    HmlValue nb = hml_convert_to_type(_tmp56, HML_VAL_I32);
    HmlValue _tmp60 = nr;
    hml_retain_if_needed(&_tmp60);
    HmlValue _tmp61 = hml_val_i32(255);
    HmlValue _tmp59 = hml_both_i32(_tmp60, _tmp61) ? hml_i32_gt(_tmp60, _tmp61) : (hml_both_i64(_tmp60, _tmp61) ? hml_i64_gt(_tmp60, _tmp61) : hml_binary_op(HML_OP_GREATER, _tmp60, _tmp61));
    hml_release_if_needed(&_tmp60);
    hml_release_if_needed(&_tmp61);
    if (hml_to_bool(_tmp59)) {
        {
            HmlValue _tmp63 = hml_val_i32(255);
            hml_release(&nr);
            nr = _tmp63;
            hml_retain(&nr);
            HmlValue _tmp62 = nr;
            hml_retain(&_tmp62);
            hml_release(&_tmp62);
        }
    }
    hml_release(&_tmp59);
    HmlValue _tmp65 = ng;
    hml_retain_if_needed(&_tmp65);
    HmlValue _tmp66 = hml_val_i32(255);
    HmlValue _tmp64 = hml_both_i32(_tmp65, _tmp66) ? hml_i32_gt(_tmp65, _tmp66) : (hml_both_i64(_tmp65, _tmp66) ? hml_i64_gt(_tmp65, _tmp66) : hml_binary_op(HML_OP_GREATER, _tmp65, _tmp66));
    hml_release_if_needed(&_tmp65);
    hml_release_if_needed(&_tmp66);
    if (hml_to_bool(_tmp64)) {
        {
            HmlValue _tmp68 = hml_val_i32(255);
            hml_release(&ng);
            ng = _tmp68;
            hml_retain(&ng);
            HmlValue _tmp67 = ng;
            hml_retain(&_tmp67);
            hml_release(&_tmp67);
        }
    }
    hml_release(&_tmp64);
    HmlValue _tmp70 = nb;
    hml_retain_if_needed(&_tmp70);
    HmlValue _tmp71 = hml_val_i32(255);
    HmlValue _tmp69 = hml_both_i32(_tmp70, _tmp71) ? hml_i32_gt(_tmp70, _tmp71) : (hml_both_i64(_tmp70, _tmp71) ? hml_i64_gt(_tmp70, _tmp71) : hml_binary_op(HML_OP_GREATER, _tmp70, _tmp71));
    hml_release_if_needed(&_tmp70);
    hml_release_if_needed(&_tmp71);
    if (hml_to_bool(_tmp69)) {
        {
            HmlValue _tmp73 = hml_val_i32(255);
            hml_release(&nb);
            nb = _tmp73;
            hml_retain(&nb);
            HmlValue _tmp72 = nb;
            hml_retain(&_tmp72);
            hml_release(&_tmp72);
        }
    }
    hml_release(&_tmp69);
    HmlValue _tmp75 = nr;
    hml_retain_if_needed(&_tmp75);
    HmlValue _tmp76 = hml_val_i32(0);
    HmlValue _tmp74 = hml_both_i32(_tmp75, _tmp76) ? hml_i32_lt(_tmp75, _tmp76) : (hml_both_i64(_tmp75, _tmp76) ? hml_i64_lt(_tmp75, _tmp76) : hml_binary_op(HML_OP_LESS, _tmp75, _tmp76));
    hml_release_if_needed(&_tmp75);
    hml_release_if_needed(&_tmp76);
    if (hml_to_bool(_tmp74)) {
        {
            HmlValue _tmp78 = hml_val_i32(0);
            hml_release(&nr);
            nr = _tmp78;
            hml_retain(&nr);
            HmlValue _tmp77 = nr;
            hml_retain(&_tmp77);
            hml_release(&_tmp77);
        }
    }
    hml_release(&_tmp74);
    HmlValue _tmp80 = ng;
    hml_retain_if_needed(&_tmp80);
    HmlValue _tmp81 = hml_val_i32(0);
    HmlValue _tmp79 = hml_both_i32(_tmp80, _tmp81) ? hml_i32_lt(_tmp80, _tmp81) : (hml_both_i64(_tmp80, _tmp81) ? hml_i64_lt(_tmp80, _tmp81) : hml_binary_op(HML_OP_LESS, _tmp80, _tmp81));
    hml_release_if_needed(&_tmp80);
    hml_release_if_needed(&_tmp81);
    if (hml_to_bool(_tmp79)) {
        {
            HmlValue _tmp83 = hml_val_i32(0);
            hml_release(&ng);
            ng = _tmp83;
            hml_retain(&ng);
            HmlValue _tmp82 = ng;
            hml_retain(&_tmp82);
            hml_release(&_tmp82);
        }
    }
    hml_release(&_tmp79);
    HmlValue _tmp85 = nb;
    hml_retain_if_needed(&_tmp85);
    HmlValue _tmp86 = hml_val_i32(0);
    HmlValue _tmp84 = hml_both_i32(_tmp85, _tmp86) ? hml_i32_lt(_tmp85, _tmp86) : (hml_both_i64(_tmp85, _tmp86) ? hml_i64_lt(_tmp85, _tmp86) : hml_binary_op(HML_OP_LESS, _tmp85, _tmp86));
    hml_release_if_needed(&_tmp85);
    hml_release_if_needed(&_tmp86);
    if (hml_to_bool(_tmp84)) {
        {
            HmlValue _tmp88 = hml_val_i32(0);
            hml_release(&nb);
            nb = _tmp88;
            hml_retain(&nb);
            HmlValue _tmp87 = nb;
            hml_retain(&_tmp87);
            hml_release(&_tmp87);
        }
    }
    hml_release(&_tmp84);
    HmlValue _tmp90 = nr;
    hml_retain_if_needed(&_tmp90);
    HmlValue _tmp91 = ng;
    hml_retain_if_needed(&_tmp91);
    HmlValue _tmp92 = nb;
    hml_retain_if_needed(&_tmp92);
    HmlValue _tmp93 = a;
    hml_retain_if_needed(&_tmp93);
    HmlValue _tmp89 = _mod0_fn_Color(NULL, _tmp90, _tmp91, _tmp92, _tmp93);
    hml_release(&_tmp90);
    hml_release(&_tmp91);
    hml_release(&_tmp92);
    hml_release(&_tmp93);
    HML_CALL_EXIT();
    return _tmp89;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorGetR(HmlClosureEnv *_closure_env, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp95 = color;
    hml_retain_if_needed(&_tmp95);
    HmlValue _tmp96 = hml_val_i32(255);
    HmlValue _tmp94 = hml_both_i32(_tmp95, _tmp96) ? hml_i32_bit_and(_tmp95, _tmp96) : (hml_both_i64(_tmp95, _tmp96) ? hml_i64_bit_and(_tmp95, _tmp96) : hml_binary_op(HML_OP_BIT_AND, _tmp95, _tmp96));
    hml_release_if_needed(&_tmp95);
    hml_release_if_needed(&_tmp96);
    HML_CALL_EXIT();
    return _tmp94;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorGetG(HmlClosureEnv *_closure_env, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp99 = color;
    hml_retain_if_needed(&_tmp99);
    HmlValue _tmp100 = hml_val_i32(8);
    HmlValue _tmp98 = hml_both_i32(_tmp99, _tmp100) ? hml_i32_rshift(_tmp99, _tmp100) : (hml_both_i64(_tmp99, _tmp100) ? hml_i64_rshift(_tmp99, _tmp100) : hml_binary_op(HML_OP_RSHIFT, _tmp99, _tmp100));
    hml_release_if_needed(&_tmp99);
    hml_release_if_needed(&_tmp100);
    HmlValue _tmp101 = hml_val_i32(255);
    HmlValue _tmp97 = hml_both_i32(_tmp98, _tmp101) ? hml_i32_bit_and(_tmp98, _tmp101) : (hml_both_i64(_tmp98, _tmp101) ? hml_i64_bit_and(_tmp98, _tmp101) : hml_binary_op(HML_OP_BIT_AND, _tmp98, _tmp101));
    hml_release_if_needed(&_tmp98);
    hml_release_if_needed(&_tmp101);
    HML_CALL_EXIT();
    return _tmp97;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorGetB(HmlClosureEnv *_closure_env, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp104 = color;
    hml_retain_if_needed(&_tmp104);
    HmlValue _tmp105 = hml_val_i32(16);
    HmlValue _tmp103 = hml_both_i32(_tmp104, _tmp105) ? hml_i32_rshift(_tmp104, _tmp105) : (hml_both_i64(_tmp104, _tmp105) ? hml_i64_rshift(_tmp104, _tmp105) : hml_binary_op(HML_OP_RSHIFT, _tmp104, _tmp105));
    hml_release_if_needed(&_tmp104);
    hml_release_if_needed(&_tmp105);
    HmlValue _tmp106 = hml_val_i32(255);
    HmlValue _tmp102 = hml_both_i32(_tmp103, _tmp106) ? hml_i32_bit_and(_tmp103, _tmp106) : (hml_both_i64(_tmp103, _tmp106) ? hml_i64_bit_and(_tmp103, _tmp106) : hml_binary_op(HML_OP_BIT_AND, _tmp103, _tmp106));
    hml_release_if_needed(&_tmp103);
    hml_release_if_needed(&_tmp106);
    HML_CALL_EXIT();
    return _tmp102;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorGetA(HmlClosureEnv *_closure_env, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp109 = color;
    hml_retain_if_needed(&_tmp109);
    HmlValue _tmp110 = hml_val_i32(24);
    HmlValue _tmp108 = hml_both_i32(_tmp109, _tmp110) ? hml_i32_rshift(_tmp109, _tmp110) : (hml_both_i64(_tmp109, _tmp110) ? hml_i64_rshift(_tmp109, _tmp110) : hml_binary_op(HML_OP_RSHIFT, _tmp109, _tmp110));
    hml_release_if_needed(&_tmp109);
    hml_release_if_needed(&_tmp110);
    HmlValue _tmp111 = hml_val_i32(255);
    HmlValue _tmp107 = hml_both_i32(_tmp108, _tmp111) ? hml_i32_bit_and(_tmp108, _tmp111) : (hml_both_i64(_tmp108, _tmp111) ? hml_i64_bit_and(_tmp108, _tmp111) : hml_binary_op(HML_OP_BIT_AND, _tmp108, _tmp111));
    hml_release_if_needed(&_tmp108);
    hml_release_if_needed(&_tmp111);
    HML_CALL_EXIT();
    return _tmp107;
    return hml_val_null();
}

HmlValue _mod0_fn_DrawCircleFill(HmlClosureEnv *_closure_env, HmlValue centerX, HmlValue centerY, HmlValue radius, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp113 = radius;
    hml_retain_if_needed(&_tmp113);
    HmlValue _tmp114 = radius;
    hml_retain_if_needed(&_tmp114);
    HmlValue _tmp112 = hml_both_i32(_tmp113, _tmp114) ? hml_i32_mul(_tmp113, _tmp114) : (hml_both_i64(_tmp113, _tmp114) ? hml_i64_mul(_tmp113, _tmp114) : hml_binary_op(HML_OP_MUL, _tmp113, _tmp114));
    hml_release_if_needed(&_tmp113);
    hml_release_if_needed(&_tmp114);
    HmlValue r2 = _tmp112;
    HmlValue _tmp116 = radius;
    hml_retain_if_needed(&_tmp116);
    HmlValue _tmp115 = hml_unary_op(HML_UNARY_NEGATE, _tmp116);
    hml_release_if_needed(&_tmp116);
    HmlValue y = _tmp115;
    while (1) {
        HmlValue _tmp118 = y;
        hml_retain_if_needed(&_tmp118);
        HmlValue _tmp119 = radius;
        hml_retain_if_needed(&_tmp119);
        HmlValue _tmp117 = hml_both_i32(_tmp118, _tmp119) ? hml_i32_le(_tmp118, _tmp119) : (hml_both_i64(_tmp118, _tmp119) ? hml_i64_le(_tmp118, _tmp119) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp118, _tmp119));
        hml_release_if_needed(&_tmp118);
        hml_release_if_needed(&_tmp119);
        if (!hml_to_bool(_tmp117)) { hml_release(&_tmp117); break; }
        hml_release(&_tmp117);
        {
            HmlValue _tmp121 = radius;
            hml_retain_if_needed(&_tmp121);
            HmlValue _tmp120 = hml_unary_op(HML_UNARY_NEGATE, _tmp121);
            hml_release_if_needed(&_tmp121);
            HmlValue x = _tmp120;
            while (1) {
                HmlValue _tmp123 = x;
                hml_retain_if_needed(&_tmp123);
                HmlValue _tmp124 = radius;
                hml_retain_if_needed(&_tmp124);
                HmlValue _tmp122 = hml_both_i32(_tmp123, _tmp124) ? hml_i32_le(_tmp123, _tmp124) : (hml_both_i64(_tmp123, _tmp124) ? hml_i64_le(_tmp123, _tmp124) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp123, _tmp124));
                hml_release_if_needed(&_tmp123);
                hml_release_if_needed(&_tmp124);
                if (!hml_to_bool(_tmp122)) { hml_release(&_tmp122); break; }
                hml_release(&_tmp122);
                {
                    HmlValue _tmp128 = x;
                    hml_retain_if_needed(&_tmp128);
                    HmlValue _tmp129 = x;
                    hml_retain_if_needed(&_tmp129);
                    HmlValue _tmp127 = hml_both_i32(_tmp128, _tmp129) ? hml_i32_mul(_tmp128, _tmp129) : (hml_both_i64(_tmp128, _tmp129) ? hml_i64_mul(_tmp128, _tmp129) : hml_binary_op(HML_OP_MUL, _tmp128, _tmp129));
                    hml_release_if_needed(&_tmp128);
                    hml_release_if_needed(&_tmp129);
                    HmlValue _tmp131 = y;
                    hml_retain_if_needed(&_tmp131);
                    HmlValue _tmp132 = y;
                    hml_retain_if_needed(&_tmp132);
                    HmlValue _tmp130 = hml_both_i32(_tmp131, _tmp132) ? hml_i32_mul(_tmp131, _tmp132) : (hml_both_i64(_tmp131, _tmp132) ? hml_i64_mul(_tmp131, _tmp132) : hml_binary_op(HML_OP_MUL, _tmp131, _tmp132));
                    hml_release_if_needed(&_tmp131);
                    hml_release_if_needed(&_tmp132);
                    HmlValue _tmp126 = hml_both_i32(_tmp127, _tmp130) ? hml_i32_add(_tmp127, _tmp130) : (hml_both_i64(_tmp127, _tmp130) ? hml_i64_add(_tmp127, _tmp130) : hml_binary_op(HML_OP_ADD, _tmp127, _tmp130));
                    hml_release_if_needed(&_tmp127);
                    hml_release_if_needed(&_tmp130);
                    HmlValue _tmp133 = r2;
                    hml_retain_if_needed(&_tmp133);
                    HmlValue _tmp125 = hml_both_i32(_tmp126, _tmp133) ? hml_i32_le(_tmp126, _tmp133) : (hml_both_i64(_tmp126, _tmp133) ? hml_i64_le(_tmp126, _tmp133) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp126, _tmp133));
                    hml_release_if_needed(&_tmp126);
                    hml_release_if_needed(&_tmp133);
                    if (hml_to_bool(_tmp125)) {
                        {
                            HmlValue _tmp136 = centerX;
                            hml_retain_if_needed(&_tmp136);
                            HmlValue _tmp137 = x;
                            hml_retain_if_needed(&_tmp137);
                            HmlValue _tmp135 = hml_both_i32(_tmp136, _tmp137) ? hml_i32_add(_tmp136, _tmp137) : (hml_both_i64(_tmp136, _tmp137) ? hml_i64_add(_tmp136, _tmp137) : hml_binary_op(HML_OP_ADD, _tmp136, _tmp137));
                            hml_release_if_needed(&_tmp136);
                            hml_release_if_needed(&_tmp137);
                            HmlValue _tmp139 = centerY;
                            hml_retain_if_needed(&_tmp139);
                            HmlValue _tmp140 = y;
                            hml_retain_if_needed(&_tmp140);
                            HmlValue _tmp138 = hml_both_i32(_tmp139, _tmp140) ? hml_i32_add(_tmp139, _tmp140) : (hml_both_i64(_tmp139, _tmp140) ? hml_i64_add(_tmp139, _tmp140) : hml_binary_op(HML_OP_ADD, _tmp139, _tmp140));
                            hml_release_if_needed(&_tmp139);
                            hml_release_if_needed(&_tmp140);
                            HmlValue _tmp141 = color;
                            hml_retain_if_needed(&_tmp141);
                            HmlValue _tmp134 = hml_fn_DrawPixel(NULL, _tmp135, _tmp138, _tmp141);
                            hml_release(&_tmp135);
                            hml_release(&_tmp138);
                            hml_release(&_tmp141);
                            hml_release(&_tmp134);
                        }
                    }
                    hml_release(&_tmp125);
                    HmlValue _tmp144 = x;
                    hml_retain_if_needed(&_tmp144);
                    HmlValue _tmp145 = hml_val_i32(1);
                    HmlValue _tmp143 = hml_both_i32(_tmp144, _tmp145) ? hml_i32_add(_tmp144, _tmp145) : (hml_both_i64(_tmp144, _tmp145) ? hml_i64_add(_tmp144, _tmp145) : hml_binary_op(HML_OP_ADD, _tmp144, _tmp145));
                    hml_release_if_needed(&_tmp144);
                    hml_release_if_needed(&_tmp145);
                    hml_release(&x);
                    x = _tmp143;
                    hml_retain(&x);
                    HmlValue _tmp142 = x;
                    hml_retain(&_tmp142);
                    hml_release(&_tmp142);
                }
            }
            HmlValue _tmp148 = y;
            hml_retain_if_needed(&_tmp148);
            HmlValue _tmp149 = hml_val_i32(1);
            HmlValue _tmp147 = hml_both_i32(_tmp148, _tmp149) ? hml_i32_add(_tmp148, _tmp149) : (hml_both_i64(_tmp148, _tmp149) ? hml_i64_add(_tmp148, _tmp149) : hml_binary_op(HML_OP_ADD, _tmp148, _tmp149));
            hml_release_if_needed(&_tmp148);
            hml_release_if_needed(&_tmp149);
            hml_release(&y);
            y = _tmp147;
            hml_retain(&y);
            HmlValue _tmp146 = y;
            hml_retain(&_tmp146);
            hml_release(&_tmp146);
        }
    }
    return hml_val_null();
}

HmlValue _mod0_fn_DrawCircleOutline(HmlClosureEnv *_closure_env, HmlValue centerX, HmlValue centerY, HmlValue radius, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp150 = radius;
    hml_retain_if_needed(&_tmp150);
    HmlValue x = _tmp150;
    HmlValue _tmp151 = hml_val_i32(0);
    HmlValue y = _tmp151;
    HmlValue _tmp152 = hml_val_i32(0);
    HmlValue err = _tmp152;
    while (1) {
        HmlValue _tmp154 = x;
        hml_retain_if_needed(&_tmp154);
        HmlValue _tmp155 = y;
        hml_retain_if_needed(&_tmp155);
        HmlValue _tmp153 = hml_both_i32(_tmp154, _tmp155) ? hml_i32_ge(_tmp154, _tmp155) : (hml_both_i64(_tmp154, _tmp155) ? hml_i64_ge(_tmp154, _tmp155) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp154, _tmp155));
        hml_release_if_needed(&_tmp154);
        hml_release_if_needed(&_tmp155);
        if (!hml_to_bool(_tmp153)) { hml_release(&_tmp153); break; }
        hml_release(&_tmp153);
        {
            HmlValue _tmp158 = centerX;
            hml_retain_if_needed(&_tmp158);
            HmlValue _tmp159 = x;
            hml_retain_if_needed(&_tmp159);
            HmlValue _tmp157 = hml_both_i32(_tmp158, _tmp159) ? hml_i32_add(_tmp158, _tmp159) : (hml_both_i64(_tmp158, _tmp159) ? hml_i64_add(_tmp158, _tmp159) : hml_binary_op(HML_OP_ADD, _tmp158, _tmp159));
            hml_release_if_needed(&_tmp158);
            hml_release_if_needed(&_tmp159);
            HmlValue _tmp161 = centerY;
            hml_retain_if_needed(&_tmp161);
            HmlValue _tmp162 = y;
            hml_retain_if_needed(&_tmp162);
            HmlValue _tmp160 = hml_both_i32(_tmp161, _tmp162) ? hml_i32_add(_tmp161, _tmp162) : (hml_both_i64(_tmp161, _tmp162) ? hml_i64_add(_tmp161, _tmp162) : hml_binary_op(HML_OP_ADD, _tmp161, _tmp162));
            hml_release_if_needed(&_tmp161);
            hml_release_if_needed(&_tmp162);
            HmlValue _tmp163 = color;
            hml_retain_if_needed(&_tmp163);
            HmlValue _tmp156 = hml_fn_DrawPixel(NULL, _tmp157, _tmp160, _tmp163);
            hml_release(&_tmp157);
            hml_release(&_tmp160);
            hml_release(&_tmp163);
            hml_release(&_tmp156);
            HmlValue _tmp166 = centerX;
            hml_retain_if_needed(&_tmp166);
            HmlValue _tmp167 = y;
            hml_retain_if_needed(&_tmp167);
            HmlValue _tmp165 = hml_both_i32(_tmp166, _tmp167) ? hml_i32_add(_tmp166, _tmp167) : (hml_both_i64(_tmp166, _tmp167) ? hml_i64_add(_tmp166, _tmp167) : hml_binary_op(HML_OP_ADD, _tmp166, _tmp167));
            hml_release_if_needed(&_tmp166);
            hml_release_if_needed(&_tmp167);
            HmlValue _tmp169 = centerY;
            hml_retain_if_needed(&_tmp169);
            HmlValue _tmp170 = x;
            hml_retain_if_needed(&_tmp170);
            HmlValue _tmp168 = hml_both_i32(_tmp169, _tmp170) ? hml_i32_add(_tmp169, _tmp170) : (hml_both_i64(_tmp169, _tmp170) ? hml_i64_add(_tmp169, _tmp170) : hml_binary_op(HML_OP_ADD, _tmp169, _tmp170));
            hml_release_if_needed(&_tmp169);
            hml_release_if_needed(&_tmp170);
            HmlValue _tmp171 = color;
            hml_retain_if_needed(&_tmp171);
            HmlValue _tmp164 = hml_fn_DrawPixel(NULL, _tmp165, _tmp168, _tmp171);
            hml_release(&_tmp165);
            hml_release(&_tmp168);
            hml_release(&_tmp171);
            hml_release(&_tmp164);
            HmlValue _tmp174 = centerX;
            hml_retain_if_needed(&_tmp174);
            HmlValue _tmp175 = y;
            hml_retain_if_needed(&_tmp175);
            HmlValue _tmp173 = hml_both_i32(_tmp174, _tmp175) ? hml_i32_sub(_tmp174, _tmp175) : (hml_both_i64(_tmp174, _tmp175) ? hml_i64_sub(_tmp174, _tmp175) : hml_binary_op(HML_OP_SUB, _tmp174, _tmp175));
            hml_release_if_needed(&_tmp174);
            hml_release_if_needed(&_tmp175);
            HmlValue _tmp177 = centerY;
            hml_retain_if_needed(&_tmp177);
            HmlValue _tmp178 = x;
            hml_retain_if_needed(&_tmp178);
            HmlValue _tmp176 = hml_both_i32(_tmp177, _tmp178) ? hml_i32_add(_tmp177, _tmp178) : (hml_both_i64(_tmp177, _tmp178) ? hml_i64_add(_tmp177, _tmp178) : hml_binary_op(HML_OP_ADD, _tmp177, _tmp178));
            hml_release_if_needed(&_tmp177);
            hml_release_if_needed(&_tmp178);
            HmlValue _tmp179 = color;
            hml_retain_if_needed(&_tmp179);
            HmlValue _tmp172 = hml_fn_DrawPixel(NULL, _tmp173, _tmp176, _tmp179);
            hml_release(&_tmp173);
            hml_release(&_tmp176);
            hml_release(&_tmp179);
            hml_release(&_tmp172);
            HmlValue _tmp182 = centerX;
            hml_retain_if_needed(&_tmp182);
            HmlValue _tmp183 = x;
            hml_retain_if_needed(&_tmp183);
            HmlValue _tmp181 = hml_both_i32(_tmp182, _tmp183) ? hml_i32_sub(_tmp182, _tmp183) : (hml_both_i64(_tmp182, _tmp183) ? hml_i64_sub(_tmp182, _tmp183) : hml_binary_op(HML_OP_SUB, _tmp182, _tmp183));
            hml_release_if_needed(&_tmp182);
            hml_release_if_needed(&_tmp183);
            HmlValue _tmp185 = centerY;
            hml_retain_if_needed(&_tmp185);
            HmlValue _tmp186 = y;
            hml_retain_if_needed(&_tmp186);
            HmlValue _tmp184 = hml_both_i32(_tmp185, _tmp186) ? hml_i32_add(_tmp185, _tmp186) : (hml_both_i64(_tmp185, _tmp186) ? hml_i64_add(_tmp185, _tmp186) : hml_binary_op(HML_OP_ADD, _tmp185, _tmp186));
            hml_release_if_needed(&_tmp185);
            hml_release_if_needed(&_tmp186);
            HmlValue _tmp187 = color;
            hml_retain_if_needed(&_tmp187);
            HmlValue _tmp180 = hml_fn_DrawPixel(NULL, _tmp181, _tmp184, _tmp187);
            hml_release(&_tmp181);
            hml_release(&_tmp184);
            hml_release(&_tmp187);
            hml_release(&_tmp180);
            HmlValue _tmp190 = centerX;
            hml_retain_if_needed(&_tmp190);
            HmlValue _tmp191 = x;
            hml_retain_if_needed(&_tmp191);
            HmlValue _tmp189 = hml_both_i32(_tmp190, _tmp191) ? hml_i32_sub(_tmp190, _tmp191) : (hml_both_i64(_tmp190, _tmp191) ? hml_i64_sub(_tmp190, _tmp191) : hml_binary_op(HML_OP_SUB, _tmp190, _tmp191));
            hml_release_if_needed(&_tmp190);
            hml_release_if_needed(&_tmp191);
            HmlValue _tmp193 = centerY;
            hml_retain_if_needed(&_tmp193);
            HmlValue _tmp194 = y;
            hml_retain_if_needed(&_tmp194);
            HmlValue _tmp192 = hml_both_i32(_tmp193, _tmp194) ? hml_i32_sub(_tmp193, _tmp194) : (hml_both_i64(_tmp193, _tmp194) ? hml_i64_sub(_tmp193, _tmp194) : hml_binary_op(HML_OP_SUB, _tmp193, _tmp194));
            hml_release_if_needed(&_tmp193);
            hml_release_if_needed(&_tmp194);
            HmlValue _tmp195 = color;
            hml_retain_if_needed(&_tmp195);
            HmlValue _tmp188 = hml_fn_DrawPixel(NULL, _tmp189, _tmp192, _tmp195);
            hml_release(&_tmp189);
            hml_release(&_tmp192);
            hml_release(&_tmp195);
            hml_release(&_tmp188);
            HmlValue _tmp198 = centerX;
            hml_retain_if_needed(&_tmp198);
            HmlValue _tmp199 = y;
            hml_retain_if_needed(&_tmp199);
            HmlValue _tmp197 = hml_both_i32(_tmp198, _tmp199) ? hml_i32_sub(_tmp198, _tmp199) : (hml_both_i64(_tmp198, _tmp199) ? hml_i64_sub(_tmp198, _tmp199) : hml_binary_op(HML_OP_SUB, _tmp198, _tmp199));
            hml_release_if_needed(&_tmp198);
            hml_release_if_needed(&_tmp199);
            HmlValue _tmp201 = centerY;
            hml_retain_if_needed(&_tmp201);
            HmlValue _tmp202 = x;
            hml_retain_if_needed(&_tmp202);
            HmlValue _tmp200 = hml_both_i32(_tmp201, _tmp202) ? hml_i32_sub(_tmp201, _tmp202) : (hml_both_i64(_tmp201, _tmp202) ? hml_i64_sub(_tmp201, _tmp202) : hml_binary_op(HML_OP_SUB, _tmp201, _tmp202));
            hml_release_if_needed(&_tmp201);
            hml_release_if_needed(&_tmp202);
            HmlValue _tmp203 = color;
            hml_retain_if_needed(&_tmp203);
            HmlValue _tmp196 = hml_fn_DrawPixel(NULL, _tmp197, _tmp200, _tmp203);
            hml_release(&_tmp197);
            hml_release(&_tmp200);
            hml_release(&_tmp203);
            hml_release(&_tmp196);
            HmlValue _tmp206 = centerX;
            hml_retain_if_needed(&_tmp206);
            HmlValue _tmp207 = y;
            hml_retain_if_needed(&_tmp207);
            HmlValue _tmp205 = hml_both_i32(_tmp206, _tmp207) ? hml_i32_add(_tmp206, _tmp207) : (hml_both_i64(_tmp206, _tmp207) ? hml_i64_add(_tmp206, _tmp207) : hml_binary_op(HML_OP_ADD, _tmp206, _tmp207));
            hml_release_if_needed(&_tmp206);
            hml_release_if_needed(&_tmp207);
            HmlValue _tmp209 = centerY;
            hml_retain_if_needed(&_tmp209);
            HmlValue _tmp210 = x;
            hml_retain_if_needed(&_tmp210);
            HmlValue _tmp208 = hml_both_i32(_tmp209, _tmp210) ? hml_i32_sub(_tmp209, _tmp210) : (hml_both_i64(_tmp209, _tmp210) ? hml_i64_sub(_tmp209, _tmp210) : hml_binary_op(HML_OP_SUB, _tmp209, _tmp210));
            hml_release_if_needed(&_tmp209);
            hml_release_if_needed(&_tmp210);
            HmlValue _tmp211 = color;
            hml_retain_if_needed(&_tmp211);
            HmlValue _tmp204 = hml_fn_DrawPixel(NULL, _tmp205, _tmp208, _tmp211);
            hml_release(&_tmp205);
            hml_release(&_tmp208);
            hml_release(&_tmp211);
            hml_release(&_tmp204);
            HmlValue _tmp214 = centerX;
            hml_retain_if_needed(&_tmp214);
            HmlValue _tmp215 = x;
            hml_retain_if_needed(&_tmp215);
            HmlValue _tmp213 = hml_both_i32(_tmp214, _tmp215) ? hml_i32_add(_tmp214, _tmp215) : (hml_both_i64(_tmp214, _tmp215) ? hml_i64_add(_tmp214, _tmp215) : hml_binary_op(HML_OP_ADD, _tmp214, _tmp215));
            hml_release_if_needed(&_tmp214);
            hml_release_if_needed(&_tmp215);
            HmlValue _tmp217 = centerY;
            hml_retain_if_needed(&_tmp217);
            HmlValue _tmp218 = y;
            hml_retain_if_needed(&_tmp218);
            HmlValue _tmp216 = hml_both_i32(_tmp217, _tmp218) ? hml_i32_sub(_tmp217, _tmp218) : (hml_both_i64(_tmp217, _tmp218) ? hml_i64_sub(_tmp217, _tmp218) : hml_binary_op(HML_OP_SUB, _tmp217, _tmp218));
            hml_release_if_needed(&_tmp217);
            hml_release_if_needed(&_tmp218);
            HmlValue _tmp219 = color;
            hml_retain_if_needed(&_tmp219);
            HmlValue _tmp212 = hml_fn_DrawPixel(NULL, _tmp213, _tmp216, _tmp219);
            hml_release(&_tmp213);
            hml_release(&_tmp216);
            hml_release(&_tmp219);
            hml_release(&_tmp212);
            HmlValue _tmp222 = y;
            hml_retain_if_needed(&_tmp222);
            HmlValue _tmp223 = hml_val_i32(1);
            HmlValue _tmp221 = hml_both_i32(_tmp222, _tmp223) ? hml_i32_add(_tmp222, _tmp223) : (hml_both_i64(_tmp222, _tmp223) ? hml_i64_add(_tmp222, _tmp223) : hml_binary_op(HML_OP_ADD, _tmp222, _tmp223));
            hml_release_if_needed(&_tmp222);
            hml_release_if_needed(&_tmp223);
            hml_release(&y);
            y = _tmp221;
            hml_retain(&y);
            HmlValue _tmp220 = y;
            hml_retain(&_tmp220);
            hml_release(&_tmp220);
            HmlValue _tmp227 = err;
            hml_retain_if_needed(&_tmp227);
            HmlValue _tmp228 = hml_val_i32(1);
            HmlValue _tmp226 = hml_both_i32(_tmp227, _tmp228) ? hml_i32_add(_tmp227, _tmp228) : (hml_both_i64(_tmp227, _tmp228) ? hml_i64_add(_tmp227, _tmp228) : hml_binary_op(HML_OP_ADD, _tmp227, _tmp228));
            hml_release_if_needed(&_tmp227);
            hml_release_if_needed(&_tmp228);
            HmlValue _tmp230 = hml_val_i32(2);
            HmlValue _tmp231 = y;
            hml_retain_if_needed(&_tmp231);
            HmlValue _tmp229 = hml_both_i32(_tmp230, _tmp231) ? hml_i32_mul(_tmp230, _tmp231) : (hml_both_i64(_tmp230, _tmp231) ? hml_i64_mul(_tmp230, _tmp231) : hml_binary_op(HML_OP_MUL, _tmp230, _tmp231));
            hml_release_if_needed(&_tmp230);
            hml_release_if_needed(&_tmp231);
            HmlValue _tmp225 = hml_both_i32(_tmp226, _tmp229) ? hml_i32_add(_tmp226, _tmp229) : (hml_both_i64(_tmp226, _tmp229) ? hml_i64_add(_tmp226, _tmp229) : hml_binary_op(HML_OP_ADD, _tmp226, _tmp229));
            hml_release_if_needed(&_tmp226);
            hml_release_if_needed(&_tmp229);
            hml_release(&err);
            err = _tmp225;
            hml_retain(&err);
            HmlValue _tmp224 = err;
            hml_retain(&_tmp224);
            hml_release(&_tmp224);
            HmlValue _tmp235 = hml_val_i32(2);
            HmlValue _tmp237 = err;
            hml_retain_if_needed(&_tmp237);
            HmlValue _tmp238 = x;
            hml_retain_if_needed(&_tmp238);
            HmlValue _tmp236 = hml_both_i32(_tmp237, _tmp238) ? hml_i32_sub(_tmp237, _tmp238) : (hml_both_i64(_tmp237, _tmp238) ? hml_i64_sub(_tmp237, _tmp238) : hml_binary_op(HML_OP_SUB, _tmp237, _tmp238));
            hml_release_if_needed(&_tmp237);
            hml_release_if_needed(&_tmp238);
            HmlValue _tmp234 = hml_both_i32(_tmp235, _tmp236) ? hml_i32_mul(_tmp235, _tmp236) : (hml_both_i64(_tmp235, _tmp236) ? hml_i64_mul(_tmp235, _tmp236) : hml_binary_op(HML_OP_MUL, _tmp235, _tmp236));
            hml_release_if_needed(&_tmp235);
            hml_release_if_needed(&_tmp236);
            HmlValue _tmp239 = hml_val_i32(1);
            HmlValue _tmp233 = hml_both_i32(_tmp234, _tmp239) ? hml_i32_add(_tmp234, _tmp239) : (hml_both_i64(_tmp234, _tmp239) ? hml_i64_add(_tmp234, _tmp239) : hml_binary_op(HML_OP_ADD, _tmp234, _tmp239));
            hml_release_if_needed(&_tmp234);
            hml_release_if_needed(&_tmp239);
            HmlValue _tmp240 = hml_val_i32(0);
            HmlValue _tmp232 = hml_both_i32(_tmp233, _tmp240) ? hml_i32_gt(_tmp233, _tmp240) : (hml_both_i64(_tmp233, _tmp240) ? hml_i64_gt(_tmp233, _tmp240) : hml_binary_op(HML_OP_GREATER, _tmp233, _tmp240));
            hml_release_if_needed(&_tmp233);
            hml_release_if_needed(&_tmp240);
            if (hml_to_bool(_tmp232)) {
                {
                    HmlValue _tmp243 = x;
                    hml_retain_if_needed(&_tmp243);
                    HmlValue _tmp244 = hml_val_i32(1);
                    HmlValue _tmp242 = hml_both_i32(_tmp243, _tmp244) ? hml_i32_sub(_tmp243, _tmp244) : (hml_both_i64(_tmp243, _tmp244) ? hml_i64_sub(_tmp243, _tmp244) : hml_binary_op(HML_OP_SUB, _tmp243, _tmp244));
                    hml_release_if_needed(&_tmp243);
                    hml_release_if_needed(&_tmp244);
                    hml_release(&x);
                    x = _tmp242;
                    hml_retain(&x);
                    HmlValue _tmp241 = x;
                    hml_retain(&_tmp241);
                    hml_release(&_tmp241);
                    HmlValue _tmp248 = err;
                    hml_retain_if_needed(&_tmp248);
                    HmlValue _tmp249 = hml_val_i32(1);
                    HmlValue _tmp247 = hml_both_i32(_tmp248, _tmp249) ? hml_i32_add(_tmp248, _tmp249) : (hml_both_i64(_tmp248, _tmp249) ? hml_i64_add(_tmp248, _tmp249) : hml_binary_op(HML_OP_ADD, _tmp248, _tmp249));
                    hml_release_if_needed(&_tmp248);
                    hml_release_if_needed(&_tmp249);
                    HmlValue _tmp251 = hml_val_i32(2);
                    HmlValue _tmp252 = x;
                    hml_retain_if_needed(&_tmp252);
                    HmlValue _tmp250 = hml_both_i32(_tmp251, _tmp252) ? hml_i32_mul(_tmp251, _tmp252) : (hml_both_i64(_tmp251, _tmp252) ? hml_i64_mul(_tmp251, _tmp252) : hml_binary_op(HML_OP_MUL, _tmp251, _tmp252));
                    hml_release_if_needed(&_tmp251);
                    hml_release_if_needed(&_tmp252);
                    HmlValue _tmp246 = hml_both_i32(_tmp247, _tmp250) ? hml_i32_sub(_tmp247, _tmp250) : (hml_both_i64(_tmp247, _tmp250) ? hml_i64_sub(_tmp247, _tmp250) : hml_binary_op(HML_OP_SUB, _tmp247, _tmp250));
                    hml_release_if_needed(&_tmp247);
                    hml_release_if_needed(&_tmp250);
                    hml_release(&err);
                    err = _tmp246;
                    hml_retain(&err);
                    HmlValue _tmp245 = err;
                    hml_retain(&_tmp245);
                    hml_release(&_tmp245);
                }
            }
            hml_release(&_tmp232);
        }
    }
    return hml_val_null();
}

HmlValue _mod0_fn_DrawTriangleFill(HmlClosureEnv *_closure_env, HmlValue v1x, HmlValue v1y, HmlValue v2x, HmlValue v2y, HmlValue v3x, HmlValue v3y, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp254 = color;
    hml_retain_if_needed(&_tmp254);
    HmlValue _tmp253 = _mod0_fn_ColorGetR(NULL, _tmp254);
    hml_release(&_tmp254);
    HmlValue r = _tmp253;
    HmlValue _tmp256 = color;
    hml_retain_if_needed(&_tmp256);
    HmlValue _tmp255 = _mod0_fn_ColorGetG(NULL, _tmp256);
    hml_release(&_tmp256);
    HmlValue g = _tmp255;
    HmlValue _tmp258 = color;
    hml_retain_if_needed(&_tmp258);
    HmlValue _tmp257 = _mod0_fn_ColorGetB(NULL, _tmp258);
    hml_release(&_tmp258);
    HmlValue b = _tmp257;
    HmlValue _tmp260 = color;
    hml_retain_if_needed(&_tmp260);
    HmlValue _tmp259 = _mod0_fn_ColorGetA(NULL, _tmp260);
    hml_release(&_tmp260);
    HmlValue a = _tmp259;
    HmlValue _tmp262 = _mod0_RL_TRIANGLES;
    hml_retain_if_needed(&_tmp262);
    HmlValue _tmp261 = hml_fn_rlBegin(NULL, _tmp262);
    hml_release(&_tmp262);
    hml_release(&_tmp261);
    HmlValue _tmp264 = r;
    hml_retain_if_needed(&_tmp264);
    HmlValue _tmp265 = g;
    hml_retain_if_needed(&_tmp265);
    HmlValue _tmp266 = b;
    hml_retain_if_needed(&_tmp266);
    HmlValue _tmp267 = a;
    hml_retain_if_needed(&_tmp267);
    HmlValue _tmp263 = hml_fn_rlColor4ub(NULL, _tmp264, _tmp265, _tmp266, _tmp267);
    hml_release(&_tmp264);
    hml_release(&_tmp265);
    hml_release(&_tmp266);
    hml_release(&_tmp267);
    hml_release(&_tmp263);
    HmlValue _tmp269 = v1x;
    hml_retain_if_needed(&_tmp269);
    HmlValue _tmp270 = v1y;
    hml_retain_if_needed(&_tmp270);
    HmlValue _tmp268 = hml_fn_rlVertex2f(NULL, _tmp269, _tmp270);
    hml_release(&_tmp269);
    hml_release(&_tmp270);
    hml_release(&_tmp268);
    HmlValue _tmp272 = v2x;
    hml_retain_if_needed(&_tmp272);
    HmlValue _tmp273 = v2y;
    hml_retain_if_needed(&_tmp273);
    HmlValue _tmp271 = hml_fn_rlVertex2f(NULL, _tmp272, _tmp273);
    hml_release(&_tmp272);
    hml_release(&_tmp273);
    hml_release(&_tmp271);
    HmlValue _tmp275 = v3x;
    hml_retain_if_needed(&_tmp275);
    HmlValue _tmp276 = v3y;
    hml_retain_if_needed(&_tmp276);
    HmlValue _tmp274 = hml_fn_rlVertex2f(NULL, _tmp275, _tmp276);
    hml_release(&_tmp275);
    hml_release(&_tmp276);
    hml_release(&_tmp274);
    HmlValue _tmp277 = hml_fn_rlEnd(NULL);
    hml_release(&_tmp277);
    return hml_val_null();
}

HmlValue _mod0_fn_DrawTriangleOutline(HmlClosureEnv *_closure_env, HmlValue v1x, HmlValue v1y, HmlValue v2x, HmlValue v2y, HmlValue v3x, HmlValue v3y, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp279 = color;
    hml_retain_if_needed(&_tmp279);
    HmlValue _tmp278 = _mod0_fn_ColorGetR(NULL, _tmp279);
    hml_release(&_tmp279);
    HmlValue r = _tmp278;
    HmlValue _tmp281 = color;
    hml_retain_if_needed(&_tmp281);
    HmlValue _tmp280 = _mod0_fn_ColorGetG(NULL, _tmp281);
    hml_release(&_tmp281);
    HmlValue g = _tmp280;
    HmlValue _tmp283 = color;
    hml_retain_if_needed(&_tmp283);
    HmlValue _tmp282 = _mod0_fn_ColorGetB(NULL, _tmp283);
    hml_release(&_tmp283);
    HmlValue b = _tmp282;
    HmlValue _tmp285 = color;
    hml_retain_if_needed(&_tmp285);
    HmlValue _tmp284 = _mod0_fn_ColorGetA(NULL, _tmp285);
    hml_release(&_tmp285);
    HmlValue a = _tmp284;
    HmlValue _tmp287 = _mod0_RL_LINES;
    hml_retain_if_needed(&_tmp287);
    HmlValue _tmp286 = hml_fn_rlBegin(NULL, _tmp287);
    hml_release(&_tmp287);
    hml_release(&_tmp286);
    HmlValue _tmp289 = r;
    hml_retain_if_needed(&_tmp289);
    HmlValue _tmp290 = g;
    hml_retain_if_needed(&_tmp290);
    HmlValue _tmp291 = b;
    hml_retain_if_needed(&_tmp291);
    HmlValue _tmp292 = a;
    hml_retain_if_needed(&_tmp292);
    HmlValue _tmp288 = hml_fn_rlColor4ub(NULL, _tmp289, _tmp290, _tmp291, _tmp292);
    hml_release(&_tmp289);
    hml_release(&_tmp290);
    hml_release(&_tmp291);
    hml_release(&_tmp292);
    hml_release(&_tmp288);
    HmlValue _tmp294 = v1x;
    hml_retain_if_needed(&_tmp294);
    HmlValue _tmp295 = v1y;
    hml_retain_if_needed(&_tmp295);
    HmlValue _tmp293 = hml_fn_rlVertex2f(NULL, _tmp294, _tmp295);
    hml_release(&_tmp294);
    hml_release(&_tmp295);
    hml_release(&_tmp293);
    HmlValue _tmp297 = v2x;
    hml_retain_if_needed(&_tmp297);
    HmlValue _tmp298 = v2y;
    hml_retain_if_needed(&_tmp298);
    HmlValue _tmp296 = hml_fn_rlVertex2f(NULL, _tmp297, _tmp298);
    hml_release(&_tmp297);
    hml_release(&_tmp298);
    hml_release(&_tmp296);
    HmlValue _tmp300 = v2x;
    hml_retain_if_needed(&_tmp300);
    HmlValue _tmp301 = v2y;
    hml_retain_if_needed(&_tmp301);
    HmlValue _tmp299 = hml_fn_rlVertex2f(NULL, _tmp300, _tmp301);
    hml_release(&_tmp300);
    hml_release(&_tmp301);
    hml_release(&_tmp299);
    HmlValue _tmp303 = v3x;
    hml_retain_if_needed(&_tmp303);
    HmlValue _tmp304 = v3y;
    hml_retain_if_needed(&_tmp304);
    HmlValue _tmp302 = hml_fn_rlVertex2f(NULL, _tmp303, _tmp304);
    hml_release(&_tmp303);
    hml_release(&_tmp304);
    hml_release(&_tmp302);
    HmlValue _tmp306 = v3x;
    hml_retain_if_needed(&_tmp306);
    HmlValue _tmp307 = v3y;
    hml_retain_if_needed(&_tmp307);
    HmlValue _tmp305 = hml_fn_rlVertex2f(NULL, _tmp306, _tmp307);
    hml_release(&_tmp306);
    hml_release(&_tmp307);
    hml_release(&_tmp305);
    HmlValue _tmp309 = v1x;
    hml_retain_if_needed(&_tmp309);
    HmlValue _tmp310 = v1y;
    hml_retain_if_needed(&_tmp310);
    HmlValue _tmp308 = hml_fn_rlVertex2f(NULL, _tmp309, _tmp310);
    hml_release(&_tmp309);
    hml_release(&_tmp310);
    hml_release(&_tmp308);
    HmlValue _tmp311 = hml_fn_rlEnd(NULL);
    hml_release(&_tmp311);
    return hml_val_null();
}

HmlValue _mod0_fn_CheckCollisionCirclesXY(HmlClosureEnv *_closure_env, HmlValue c1x, HmlValue c1y, HmlValue r1, HmlValue c2x, HmlValue c2y, HmlValue r2) {
    (void)_closure_env;
    HmlValue _tmp313 = c2x;
    hml_retain_if_needed(&_tmp313);
    HmlValue _tmp314 = c1x;
    hml_retain_if_needed(&_tmp314);
    HmlValue _tmp312 = hml_both_i32(_tmp313, _tmp314) ? hml_i32_sub(_tmp313, _tmp314) : (hml_both_i64(_tmp313, _tmp314) ? hml_i64_sub(_tmp313, _tmp314) : hml_binary_op(HML_OP_SUB, _tmp313, _tmp314));
    hml_release_if_needed(&_tmp313);
    hml_release_if_needed(&_tmp314);
    HmlValue dx = _tmp312;
    HmlValue _tmp316 = c2y;
    hml_retain_if_needed(&_tmp316);
    HmlValue _tmp317 = c1y;
    hml_retain_if_needed(&_tmp317);
    HmlValue _tmp315 = hml_both_i32(_tmp316, _tmp317) ? hml_i32_sub(_tmp316, _tmp317) : (hml_both_i64(_tmp316, _tmp317) ? hml_i64_sub(_tmp316, _tmp317) : hml_binary_op(HML_OP_SUB, _tmp316, _tmp317));
    hml_release_if_needed(&_tmp316);
    hml_release_if_needed(&_tmp317);
    HmlValue dy = _tmp315;
    HmlValue _tmp320 = dx;
    hml_retain_if_needed(&_tmp320);
    HmlValue _tmp321 = dx;
    hml_retain_if_needed(&_tmp321);
    HmlValue _tmp319 = hml_both_i32(_tmp320, _tmp321) ? hml_i32_mul(_tmp320, _tmp321) : (hml_both_i64(_tmp320, _tmp321) ? hml_i64_mul(_tmp320, _tmp321) : hml_binary_op(HML_OP_MUL, _tmp320, _tmp321));
    hml_release_if_needed(&_tmp320);
    hml_release_if_needed(&_tmp321);
    HmlValue _tmp323 = dy;
    hml_retain_if_needed(&_tmp323);
    HmlValue _tmp324 = dy;
    hml_retain_if_needed(&_tmp324);
    HmlValue _tmp322 = hml_both_i32(_tmp323, _tmp324) ? hml_i32_mul(_tmp323, _tmp324) : (hml_both_i64(_tmp323, _tmp324) ? hml_i64_mul(_tmp323, _tmp324) : hml_binary_op(HML_OP_MUL, _tmp323, _tmp324));
    hml_release_if_needed(&_tmp323);
    hml_release_if_needed(&_tmp324);
    HmlValue _tmp318 = hml_both_i32(_tmp319, _tmp322) ? hml_i32_add(_tmp319, _tmp322) : (hml_both_i64(_tmp319, _tmp322) ? hml_i64_add(_tmp319, _tmp322) : hml_binary_op(HML_OP_ADD, _tmp319, _tmp322));
    hml_release_if_needed(&_tmp319);
    hml_release_if_needed(&_tmp322);
    HmlValue distSq = _tmp318;
    HmlValue _tmp326 = r1;
    hml_retain_if_needed(&_tmp326);
    HmlValue _tmp327 = r2;
    hml_retain_if_needed(&_tmp327);
    HmlValue _tmp325 = hml_both_i32(_tmp326, _tmp327) ? hml_i32_add(_tmp326, _tmp327) : (hml_both_i64(_tmp326, _tmp327) ? hml_i64_add(_tmp326, _tmp327) : hml_binary_op(HML_OP_ADD, _tmp326, _tmp327));
    hml_release_if_needed(&_tmp326);
    hml_release_if_needed(&_tmp327);
    HmlValue radiusSum = _tmp325;
    HmlValue _tmp329 = distSq;
    hml_retain_if_needed(&_tmp329);
    HmlValue _tmp331 = radiusSum;
    hml_retain_if_needed(&_tmp331);
    HmlValue _tmp332 = radiusSum;
    hml_retain_if_needed(&_tmp332);
    HmlValue _tmp330 = hml_both_i32(_tmp331, _tmp332) ? hml_i32_mul(_tmp331, _tmp332) : (hml_both_i64(_tmp331, _tmp332) ? hml_i64_mul(_tmp331, _tmp332) : hml_binary_op(HML_OP_MUL, _tmp331, _tmp332));
    hml_release_if_needed(&_tmp331);
    hml_release_if_needed(&_tmp332);
    HmlValue _tmp328 = hml_both_i32(_tmp329, _tmp330) ? hml_i32_le(_tmp329, _tmp330) : (hml_both_i64(_tmp329, _tmp330) ? hml_i64_le(_tmp329, _tmp330) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp329, _tmp330));
    hml_release_if_needed(&_tmp329);
    hml_release_if_needed(&_tmp330);
    if (hml_to_bool(_tmp328)) {
        {
            HmlValue _tmp333 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp333;
        }
    }
    hml_release(&_tmp328);
    HmlValue _tmp334 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp334;
    return hml_val_null();
}

HmlValue _mod0_fn_CheckCollisionRectsXY(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue y1, HmlValue w1, HmlValue h1, HmlValue x2, HmlValue y2, HmlValue w2, HmlValue h2) {
    (void)_closure_env;
    HmlValue _tmp339 = x1;
    hml_retain_if_needed(&_tmp339);
    HmlValue _tmp341 = x2;
    hml_retain_if_needed(&_tmp341);
    HmlValue _tmp342 = w2;
    hml_retain_if_needed(&_tmp342);
    HmlValue _tmp340 = hml_both_i32(_tmp341, _tmp342) ? hml_i32_add(_tmp341, _tmp342) : (hml_both_i64(_tmp341, _tmp342) ? hml_i64_add(_tmp341, _tmp342) : hml_binary_op(HML_OP_ADD, _tmp341, _tmp342));
    hml_release_if_needed(&_tmp341);
    hml_release_if_needed(&_tmp342);
    HmlValue _tmp338 = hml_both_i32(_tmp339, _tmp340) ? hml_i32_lt(_tmp339, _tmp340) : (hml_both_i64(_tmp339, _tmp340) ? hml_i64_lt(_tmp339, _tmp340) : hml_binary_op(HML_OP_LESS, _tmp339, _tmp340));
    hml_release_if_needed(&_tmp339);
    hml_release_if_needed(&_tmp340);
    HmlValue _tmp337;
    if (!hml_to_bool(_tmp338)) {
        _tmp337 = hml_val_bool(0);
    } else {
        HmlValue _tmp345 = x1;
        hml_retain_if_needed(&_tmp345);
        HmlValue _tmp346 = w1;
        hml_retain_if_needed(&_tmp346);
        HmlValue _tmp344 = hml_both_i32(_tmp345, _tmp346) ? hml_i32_add(_tmp345, _tmp346) : (hml_both_i64(_tmp345, _tmp346) ? hml_i64_add(_tmp345, _tmp346) : hml_binary_op(HML_OP_ADD, _tmp345, _tmp346));
        hml_release_if_needed(&_tmp345);
        hml_release_if_needed(&_tmp346);
        HmlValue _tmp347 = x2;
        hml_retain_if_needed(&_tmp347);
        HmlValue _tmp343 = hml_both_i32(_tmp344, _tmp347) ? hml_i32_gt(_tmp344, _tmp347) : (hml_both_i64(_tmp344, _tmp347) ? hml_i64_gt(_tmp344, _tmp347) : hml_binary_op(HML_OP_GREATER, _tmp344, _tmp347));
        hml_release_if_needed(&_tmp344);
        hml_release_if_needed(&_tmp347);
        _tmp337 = hml_val_bool(hml_to_bool(_tmp343));
        hml_release_if_needed(&_tmp343);
    }
    hml_release_if_needed(&_tmp338);
    HmlValue _tmp336;
    if (!hml_to_bool(_tmp337)) {
        _tmp336 = hml_val_bool(0);
    } else {
        HmlValue _tmp349 = y1;
        hml_retain_if_needed(&_tmp349);
        HmlValue _tmp351 = y2;
        hml_retain_if_needed(&_tmp351);
        HmlValue _tmp352 = h2;
        hml_retain_if_needed(&_tmp352);
        HmlValue _tmp350 = hml_both_i32(_tmp351, _tmp352) ? hml_i32_add(_tmp351, _tmp352) : (hml_both_i64(_tmp351, _tmp352) ? hml_i64_add(_tmp351, _tmp352) : hml_binary_op(HML_OP_ADD, _tmp351, _tmp352));
        hml_release_if_needed(&_tmp351);
        hml_release_if_needed(&_tmp352);
        HmlValue _tmp348 = hml_both_i32(_tmp349, _tmp350) ? hml_i32_lt(_tmp349, _tmp350) : (hml_both_i64(_tmp349, _tmp350) ? hml_i64_lt(_tmp349, _tmp350) : hml_binary_op(HML_OP_LESS, _tmp349, _tmp350));
        hml_release_if_needed(&_tmp349);
        hml_release_if_needed(&_tmp350);
        _tmp336 = hml_val_bool(hml_to_bool(_tmp348));
        hml_release_if_needed(&_tmp348);
    }
    hml_release_if_needed(&_tmp337);
    HmlValue _tmp335;
    if (!hml_to_bool(_tmp336)) {
        _tmp335 = hml_val_bool(0);
    } else {
        HmlValue _tmp355 = y1;
        hml_retain_if_needed(&_tmp355);
        HmlValue _tmp356 = h1;
        hml_retain_if_needed(&_tmp356);
        HmlValue _tmp354 = hml_both_i32(_tmp355, _tmp356) ? hml_i32_add(_tmp355, _tmp356) : (hml_both_i64(_tmp355, _tmp356) ? hml_i64_add(_tmp355, _tmp356) : hml_binary_op(HML_OP_ADD, _tmp355, _tmp356));
        hml_release_if_needed(&_tmp355);
        hml_release_if_needed(&_tmp356);
        HmlValue _tmp357 = y2;
        hml_retain_if_needed(&_tmp357);
        HmlValue _tmp353 = hml_both_i32(_tmp354, _tmp357) ? hml_i32_gt(_tmp354, _tmp357) : (hml_both_i64(_tmp354, _tmp357) ? hml_i64_gt(_tmp354, _tmp357) : hml_binary_op(HML_OP_GREATER, _tmp354, _tmp357));
        hml_release_if_needed(&_tmp354);
        hml_release_if_needed(&_tmp357);
        _tmp335 = hml_val_bool(hml_to_bool(_tmp353));
        hml_release_if_needed(&_tmp353);
    }
    hml_release_if_needed(&_tmp336);
    if (hml_to_bool(_tmp335)) {
        {
            HmlValue _tmp358 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp358;
        }
    }
    hml_release(&_tmp335);
    HmlValue _tmp359 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp359;
    return hml_val_null();
}

HmlValue _mod0_fn_CheckCollisionPointRectXY(HmlClosureEnv *_closure_env, HmlValue px, HmlValue py, HmlValue rx, HmlValue ry, HmlValue rw, HmlValue rh) {
    (void)_closure_env;
    HmlValue _tmp364 = px;
    hml_retain_if_needed(&_tmp364);
    HmlValue _tmp365 = rx;
    hml_retain_if_needed(&_tmp365);
    HmlValue _tmp363 = hml_both_i32(_tmp364, _tmp365) ? hml_i32_ge(_tmp364, _tmp365) : (hml_both_i64(_tmp364, _tmp365) ? hml_i64_ge(_tmp364, _tmp365) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp364, _tmp365));
    hml_release_if_needed(&_tmp364);
    hml_release_if_needed(&_tmp365);
    HmlValue _tmp362;
    if (!hml_to_bool(_tmp363)) {
        _tmp362 = hml_val_bool(0);
    } else {
        HmlValue _tmp367 = px;
        hml_retain_if_needed(&_tmp367);
        HmlValue _tmp369 = rx;
        hml_retain_if_needed(&_tmp369);
        HmlValue _tmp370 = rw;
        hml_retain_if_needed(&_tmp370);
        HmlValue _tmp368 = hml_both_i32(_tmp369, _tmp370) ? hml_i32_add(_tmp369, _tmp370) : (hml_both_i64(_tmp369, _tmp370) ? hml_i64_add(_tmp369, _tmp370) : hml_binary_op(HML_OP_ADD, _tmp369, _tmp370));
        hml_release_if_needed(&_tmp369);
        hml_release_if_needed(&_tmp370);
        HmlValue _tmp366 = hml_both_i32(_tmp367, _tmp368) ? hml_i32_le(_tmp367, _tmp368) : (hml_both_i64(_tmp367, _tmp368) ? hml_i64_le(_tmp367, _tmp368) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp367, _tmp368));
        hml_release_if_needed(&_tmp367);
        hml_release_if_needed(&_tmp368);
        _tmp362 = hml_val_bool(hml_to_bool(_tmp366));
        hml_release_if_needed(&_tmp366);
    }
    hml_release_if_needed(&_tmp363);
    HmlValue _tmp361;
    if (!hml_to_bool(_tmp362)) {
        _tmp361 = hml_val_bool(0);
    } else {
        HmlValue _tmp372 = py;
        hml_retain_if_needed(&_tmp372);
        HmlValue _tmp373 = ry;
        hml_retain_if_needed(&_tmp373);
        HmlValue _tmp371 = hml_both_i32(_tmp372, _tmp373) ? hml_i32_ge(_tmp372, _tmp373) : (hml_both_i64(_tmp372, _tmp373) ? hml_i64_ge(_tmp372, _tmp373) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp372, _tmp373));
        hml_release_if_needed(&_tmp372);
        hml_release_if_needed(&_tmp373);
        _tmp361 = hml_val_bool(hml_to_bool(_tmp371));
        hml_release_if_needed(&_tmp371);
    }
    hml_release_if_needed(&_tmp362);
    HmlValue _tmp360;
    if (!hml_to_bool(_tmp361)) {
        _tmp360 = hml_val_bool(0);
    } else {
        HmlValue _tmp375 = py;
        hml_retain_if_needed(&_tmp375);
        HmlValue _tmp377 = ry;
        hml_retain_if_needed(&_tmp377);
        HmlValue _tmp378 = rh;
        hml_retain_if_needed(&_tmp378);
        HmlValue _tmp376 = hml_both_i32(_tmp377, _tmp378) ? hml_i32_add(_tmp377, _tmp378) : (hml_both_i64(_tmp377, _tmp378) ? hml_i64_add(_tmp377, _tmp378) : hml_binary_op(HML_OP_ADD, _tmp377, _tmp378));
        hml_release_if_needed(&_tmp377);
        hml_release_if_needed(&_tmp378);
        HmlValue _tmp374 = hml_both_i32(_tmp375, _tmp376) ? hml_i32_le(_tmp375, _tmp376) : (hml_both_i64(_tmp375, _tmp376) ? hml_i64_le(_tmp375, _tmp376) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp375, _tmp376));
        hml_release_if_needed(&_tmp375);
        hml_release_if_needed(&_tmp376);
        _tmp360 = hml_val_bool(hml_to_bool(_tmp374));
        hml_release_if_needed(&_tmp374);
    }
    hml_release_if_needed(&_tmp361);
    if (hml_to_bool(_tmp360)) {
        {
            HmlValue _tmp379 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp379;
        }
    }
    hml_release(&_tmp360);
    HmlValue _tmp380 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp380;
    return hml_val_null();
}

HmlValue _mod0_fn_CheckCollisionPointCircleXY(HmlClosureEnv *_closure_env, HmlValue px, HmlValue py, HmlValue cx, HmlValue cy, HmlValue r) {
    (void)_closure_env;
    HmlValue _tmp382 = px;
    hml_retain_if_needed(&_tmp382);
    HmlValue _tmp383 = cx;
    hml_retain_if_needed(&_tmp383);
    HmlValue _tmp381 = hml_both_i32(_tmp382, _tmp383) ? hml_i32_sub(_tmp382, _tmp383) : (hml_both_i64(_tmp382, _tmp383) ? hml_i64_sub(_tmp382, _tmp383) : hml_binary_op(HML_OP_SUB, _tmp382, _tmp383));
    hml_release_if_needed(&_tmp382);
    hml_release_if_needed(&_tmp383);
    HmlValue dx = _tmp381;
    HmlValue _tmp385 = py;
    hml_retain_if_needed(&_tmp385);
    HmlValue _tmp386 = cy;
    hml_retain_if_needed(&_tmp386);
    HmlValue _tmp384 = hml_both_i32(_tmp385, _tmp386) ? hml_i32_sub(_tmp385, _tmp386) : (hml_both_i64(_tmp385, _tmp386) ? hml_i64_sub(_tmp385, _tmp386) : hml_binary_op(HML_OP_SUB, _tmp385, _tmp386));
    hml_release_if_needed(&_tmp385);
    hml_release_if_needed(&_tmp386);
    HmlValue dy = _tmp384;
    HmlValue _tmp389 = dx;
    hml_retain_if_needed(&_tmp389);
    HmlValue _tmp390 = dx;
    hml_retain_if_needed(&_tmp390);
    HmlValue _tmp388 = hml_both_i32(_tmp389, _tmp390) ? hml_i32_mul(_tmp389, _tmp390) : (hml_both_i64(_tmp389, _tmp390) ? hml_i64_mul(_tmp389, _tmp390) : hml_binary_op(HML_OP_MUL, _tmp389, _tmp390));
    hml_release_if_needed(&_tmp389);
    hml_release_if_needed(&_tmp390);
    HmlValue _tmp392 = dy;
    hml_retain_if_needed(&_tmp392);
    HmlValue _tmp393 = dy;
    hml_retain_if_needed(&_tmp393);
    HmlValue _tmp391 = hml_both_i32(_tmp392, _tmp393) ? hml_i32_mul(_tmp392, _tmp393) : (hml_both_i64(_tmp392, _tmp393) ? hml_i64_mul(_tmp392, _tmp393) : hml_binary_op(HML_OP_MUL, _tmp392, _tmp393));
    hml_release_if_needed(&_tmp392);
    hml_release_if_needed(&_tmp393);
    HmlValue _tmp387 = hml_both_i32(_tmp388, _tmp391) ? hml_i32_add(_tmp388, _tmp391) : (hml_both_i64(_tmp388, _tmp391) ? hml_i64_add(_tmp388, _tmp391) : hml_binary_op(HML_OP_ADD, _tmp388, _tmp391));
    hml_release_if_needed(&_tmp388);
    hml_release_if_needed(&_tmp391);
    HmlValue distSq = _tmp387;
    HmlValue _tmp395 = distSq;
    hml_retain_if_needed(&_tmp395);
    HmlValue _tmp397 = r;
    hml_retain_if_needed(&_tmp397);
    HmlValue _tmp398 = r;
    hml_retain_if_needed(&_tmp398);
    HmlValue _tmp396 = hml_both_i32(_tmp397, _tmp398) ? hml_i32_mul(_tmp397, _tmp398) : (hml_both_i64(_tmp397, _tmp398) ? hml_i64_mul(_tmp397, _tmp398) : hml_binary_op(HML_OP_MUL, _tmp397, _tmp398));
    hml_release_if_needed(&_tmp397);
    hml_release_if_needed(&_tmp398);
    HmlValue _tmp394 = hml_both_i32(_tmp395, _tmp396) ? hml_i32_le(_tmp395, _tmp396) : (hml_both_i64(_tmp395, _tmp396) ? hml_i64_le(_tmp395, _tmp396) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp395, _tmp396));
    hml_release_if_needed(&_tmp395);
    hml_release_if_needed(&_tmp396);
    if (hml_to_bool(_tmp394)) {
        {
            HmlValue _tmp399 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp399;
        }
    }
    hml_release(&_tmp394);
    HmlValue _tmp400 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp400;
    return hml_val_null();
}

HmlValue _mod0_fn_CheckCollisionCircleRecXY(HmlClosureEnv *_closure_env, HmlValue cx, HmlValue cy, HmlValue r, HmlValue rx, HmlValue ry, HmlValue rw, HmlValue rh) {
    (void)_closure_env;
    HmlValue _tmp401 = cx;
    hml_retain_if_needed(&_tmp401);
    HmlValue closestX = _tmp401;
    HmlValue _tmp402 = cy;
    hml_retain_if_needed(&_tmp402);
    HmlValue closestY = _tmp402;
    HmlValue _tmp404 = cx;
    hml_retain_if_needed(&_tmp404);
    HmlValue _tmp405 = rx;
    hml_retain_if_needed(&_tmp405);
    HmlValue _tmp403 = hml_both_i32(_tmp404, _tmp405) ? hml_i32_lt(_tmp404, _tmp405) : (hml_both_i64(_tmp404, _tmp405) ? hml_i64_lt(_tmp404, _tmp405) : hml_binary_op(HML_OP_LESS, _tmp404, _tmp405));
    hml_release_if_needed(&_tmp404);
    hml_release_if_needed(&_tmp405);
    if (hml_to_bool(_tmp403)) {
        {
            HmlValue _tmp407 = rx;
            hml_retain_if_needed(&_tmp407);
            hml_release(&closestX);
            closestX = _tmp407;
            hml_retain(&closestX);
            HmlValue _tmp406 = closestX;
            hml_retain(&_tmp406);
            hml_release(&_tmp406);
        }
    } else {
        HmlValue _tmp409 = cx;
        hml_retain_if_needed(&_tmp409);
        HmlValue _tmp411 = rx;
        hml_retain_if_needed(&_tmp411);
        HmlValue _tmp412 = rw;
        hml_retain_if_needed(&_tmp412);
        HmlValue _tmp410 = hml_both_i32(_tmp411, _tmp412) ? hml_i32_add(_tmp411, _tmp412) : (hml_both_i64(_tmp411, _tmp412) ? hml_i64_add(_tmp411, _tmp412) : hml_binary_op(HML_OP_ADD, _tmp411, _tmp412));
        hml_release_if_needed(&_tmp411);
        hml_release_if_needed(&_tmp412);
        HmlValue _tmp408 = hml_both_i32(_tmp409, _tmp410) ? hml_i32_gt(_tmp409, _tmp410) : (hml_both_i64(_tmp409, _tmp410) ? hml_i64_gt(_tmp409, _tmp410) : hml_binary_op(HML_OP_GREATER, _tmp409, _tmp410));
        hml_release_if_needed(&_tmp409);
        hml_release_if_needed(&_tmp410);
        if (hml_to_bool(_tmp408)) {
            {
                HmlValue _tmp415 = rx;
                hml_retain_if_needed(&_tmp415);
                HmlValue _tmp416 = rw;
                hml_retain_if_needed(&_tmp416);
                HmlValue _tmp414 = hml_both_i32(_tmp415, _tmp416) ? hml_i32_add(_tmp415, _tmp416) : (hml_both_i64(_tmp415, _tmp416) ? hml_i64_add(_tmp415, _tmp416) : hml_binary_op(HML_OP_ADD, _tmp415, _tmp416));
                hml_release_if_needed(&_tmp415);
                hml_release_if_needed(&_tmp416);
                hml_release(&closestX);
                closestX = _tmp414;
                hml_retain(&closestX);
                HmlValue _tmp413 = closestX;
                hml_retain(&_tmp413);
                hml_release(&_tmp413);
            }
        }
        hml_release(&_tmp408);
    }
    hml_release(&_tmp403);
    HmlValue _tmp418 = cy;
    hml_retain_if_needed(&_tmp418);
    HmlValue _tmp419 = ry;
    hml_retain_if_needed(&_tmp419);
    HmlValue _tmp417 = hml_both_i32(_tmp418, _tmp419) ? hml_i32_lt(_tmp418, _tmp419) : (hml_both_i64(_tmp418, _tmp419) ? hml_i64_lt(_tmp418, _tmp419) : hml_binary_op(HML_OP_LESS, _tmp418, _tmp419));
    hml_release_if_needed(&_tmp418);
    hml_release_if_needed(&_tmp419);
    if (hml_to_bool(_tmp417)) {
        {
            HmlValue _tmp421 = ry;
            hml_retain_if_needed(&_tmp421);
            hml_release(&closestY);
            closestY = _tmp421;
            hml_retain(&closestY);
            HmlValue _tmp420 = closestY;
            hml_retain(&_tmp420);
            hml_release(&_tmp420);
        }
    } else {
        HmlValue _tmp423 = cy;
        hml_retain_if_needed(&_tmp423);
        HmlValue _tmp425 = ry;
        hml_retain_if_needed(&_tmp425);
        HmlValue _tmp426 = rh;
        hml_retain_if_needed(&_tmp426);
        HmlValue _tmp424 = hml_both_i32(_tmp425, _tmp426) ? hml_i32_add(_tmp425, _tmp426) : (hml_both_i64(_tmp425, _tmp426) ? hml_i64_add(_tmp425, _tmp426) : hml_binary_op(HML_OP_ADD, _tmp425, _tmp426));
        hml_release_if_needed(&_tmp425);
        hml_release_if_needed(&_tmp426);
        HmlValue _tmp422 = hml_both_i32(_tmp423, _tmp424) ? hml_i32_gt(_tmp423, _tmp424) : (hml_both_i64(_tmp423, _tmp424) ? hml_i64_gt(_tmp423, _tmp424) : hml_binary_op(HML_OP_GREATER, _tmp423, _tmp424));
        hml_release_if_needed(&_tmp423);
        hml_release_if_needed(&_tmp424);
        if (hml_to_bool(_tmp422)) {
            {
                HmlValue _tmp429 = ry;
                hml_retain_if_needed(&_tmp429);
                HmlValue _tmp430 = rh;
                hml_retain_if_needed(&_tmp430);
                HmlValue _tmp428 = hml_both_i32(_tmp429, _tmp430) ? hml_i32_add(_tmp429, _tmp430) : (hml_both_i64(_tmp429, _tmp430) ? hml_i64_add(_tmp429, _tmp430) : hml_binary_op(HML_OP_ADD, _tmp429, _tmp430));
                hml_release_if_needed(&_tmp429);
                hml_release_if_needed(&_tmp430);
                hml_release(&closestY);
                closestY = _tmp428;
                hml_retain(&closestY);
                HmlValue _tmp427 = closestY;
                hml_retain(&_tmp427);
                hml_release(&_tmp427);
            }
        }
        hml_release(&_tmp422);
    }
    hml_release(&_tmp417);
    HmlValue _tmp432 = cx;
    hml_retain_if_needed(&_tmp432);
    HmlValue _tmp433 = closestX;
    hml_retain_if_needed(&_tmp433);
    HmlValue _tmp431 = hml_both_i32(_tmp432, _tmp433) ? hml_i32_sub(_tmp432, _tmp433) : (hml_both_i64(_tmp432, _tmp433) ? hml_i64_sub(_tmp432, _tmp433) : hml_binary_op(HML_OP_SUB, _tmp432, _tmp433));
    hml_release_if_needed(&_tmp432);
    hml_release_if_needed(&_tmp433);
    HmlValue dx = _tmp431;
    HmlValue _tmp435 = cy;
    hml_retain_if_needed(&_tmp435);
    HmlValue _tmp436 = closestY;
    hml_retain_if_needed(&_tmp436);
    HmlValue _tmp434 = hml_both_i32(_tmp435, _tmp436) ? hml_i32_sub(_tmp435, _tmp436) : (hml_both_i64(_tmp435, _tmp436) ? hml_i64_sub(_tmp435, _tmp436) : hml_binary_op(HML_OP_SUB, _tmp435, _tmp436));
    hml_release_if_needed(&_tmp435);
    hml_release_if_needed(&_tmp436);
    HmlValue dy = _tmp434;
    HmlValue _tmp439 = dx;
    hml_retain_if_needed(&_tmp439);
    HmlValue _tmp440 = dx;
    hml_retain_if_needed(&_tmp440);
    HmlValue _tmp438 = hml_both_i32(_tmp439, _tmp440) ? hml_i32_mul(_tmp439, _tmp440) : (hml_both_i64(_tmp439, _tmp440) ? hml_i64_mul(_tmp439, _tmp440) : hml_binary_op(HML_OP_MUL, _tmp439, _tmp440));
    hml_release_if_needed(&_tmp439);
    hml_release_if_needed(&_tmp440);
    HmlValue _tmp442 = dy;
    hml_retain_if_needed(&_tmp442);
    HmlValue _tmp443 = dy;
    hml_retain_if_needed(&_tmp443);
    HmlValue _tmp441 = hml_both_i32(_tmp442, _tmp443) ? hml_i32_mul(_tmp442, _tmp443) : (hml_both_i64(_tmp442, _tmp443) ? hml_i64_mul(_tmp442, _tmp443) : hml_binary_op(HML_OP_MUL, _tmp442, _tmp443));
    hml_release_if_needed(&_tmp442);
    hml_release_if_needed(&_tmp443);
    HmlValue _tmp437 = hml_both_i32(_tmp438, _tmp441) ? hml_i32_add(_tmp438, _tmp441) : (hml_both_i64(_tmp438, _tmp441) ? hml_i64_add(_tmp438, _tmp441) : hml_binary_op(HML_OP_ADD, _tmp438, _tmp441));
    hml_release_if_needed(&_tmp438);
    hml_release_if_needed(&_tmp441);
    HmlValue distSq = _tmp437;
    HmlValue _tmp445 = distSq;
    hml_retain_if_needed(&_tmp445);
    HmlValue _tmp447 = r;
    hml_retain_if_needed(&_tmp447);
    HmlValue _tmp448 = r;
    hml_retain_if_needed(&_tmp448);
    HmlValue _tmp446 = hml_both_i32(_tmp447, _tmp448) ? hml_i32_mul(_tmp447, _tmp448) : (hml_both_i64(_tmp447, _tmp448) ? hml_i64_mul(_tmp447, _tmp448) : hml_binary_op(HML_OP_MUL, _tmp447, _tmp448));
    hml_release_if_needed(&_tmp447);
    hml_release_if_needed(&_tmp448);
    HmlValue _tmp444 = hml_both_i32(_tmp445, _tmp446) ? hml_i32_le(_tmp445, _tmp446) : (hml_both_i64(_tmp445, _tmp446) ? hml_i64_le(_tmp445, _tmp446) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp445, _tmp446));
    hml_release_if_needed(&_tmp445);
    hml_release_if_needed(&_tmp446);
    if (hml_to_bool(_tmp444)) {
        {
            HmlValue _tmp449 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp449;
        }
    }
    hml_release(&_tmp444);
    HmlValue _tmp450 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp450;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2Distance(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue y1, HmlValue x2, HmlValue y2) {
    (void)_closure_env;
    HmlValue _tmp452 = x2;
    hml_retain_if_needed(&_tmp452);
    HmlValue _tmp453 = x1;
    hml_retain_if_needed(&_tmp453);
    HmlValue _tmp451 = hml_both_i32(_tmp452, _tmp453) ? hml_i32_sub(_tmp452, _tmp453) : (hml_both_i64(_tmp452, _tmp453) ? hml_i64_sub(_tmp452, _tmp453) : hml_binary_op(HML_OP_SUB, _tmp452, _tmp453));
    hml_release_if_needed(&_tmp452);
    hml_release_if_needed(&_tmp453);
    HmlValue dx = _tmp451;
    HmlValue _tmp455 = y2;
    hml_retain_if_needed(&_tmp455);
    HmlValue _tmp456 = y1;
    hml_retain_if_needed(&_tmp456);
    HmlValue _tmp454 = hml_both_i32(_tmp455, _tmp456) ? hml_i32_sub(_tmp455, _tmp456) : (hml_both_i64(_tmp455, _tmp456) ? hml_i64_sub(_tmp455, _tmp456) : hml_binary_op(HML_OP_SUB, _tmp455, _tmp456));
    hml_release_if_needed(&_tmp455);
    hml_release_if_needed(&_tmp456);
    HmlValue dy = _tmp454;
    HmlValue _tmp460 = dx;
    hml_retain_if_needed(&_tmp460);
    HmlValue _tmp461 = dx;
    hml_retain_if_needed(&_tmp461);
    HmlValue _tmp459 = hml_both_i32(_tmp460, _tmp461) ? hml_i32_mul(_tmp460, _tmp461) : (hml_both_i64(_tmp460, _tmp461) ? hml_i64_mul(_tmp460, _tmp461) : hml_binary_op(HML_OP_MUL, _tmp460, _tmp461));
    hml_release_if_needed(&_tmp460);
    hml_release_if_needed(&_tmp461);
    HmlValue _tmp463 = dy;
    hml_retain_if_needed(&_tmp463);
    HmlValue _tmp464 = dy;
    hml_retain_if_needed(&_tmp464);
    HmlValue _tmp462 = hml_both_i32(_tmp463, _tmp464) ? hml_i32_mul(_tmp463, _tmp464) : (hml_both_i64(_tmp463, _tmp464) ? hml_i64_mul(_tmp463, _tmp464) : hml_binary_op(HML_OP_MUL, _tmp463, _tmp464));
    hml_release_if_needed(&_tmp463);
    hml_release_if_needed(&_tmp464);
    HmlValue _tmp458 = hml_both_i32(_tmp459, _tmp462) ? hml_i32_add(_tmp459, _tmp462) : (hml_both_i64(_tmp459, _tmp462) ? hml_i64_add(_tmp459, _tmp462) : hml_binary_op(HML_OP_ADD, _tmp459, _tmp462));
    hml_release_if_needed(&_tmp459);
    hml_release_if_needed(&_tmp462);
    HmlValue _tmp457 = hml_sqrt(_tmp458);
    hml_release(&_tmp458);
    HML_CALL_EXIT();
    return _tmp457;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2Length(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y) {
    (void)_closure_env;
    HmlValue _tmp468 = x;
    hml_retain_if_needed(&_tmp468);
    HmlValue _tmp469 = x;
    hml_retain_if_needed(&_tmp469);
    HmlValue _tmp467 = hml_both_i32(_tmp468, _tmp469) ? hml_i32_mul(_tmp468, _tmp469) : (hml_both_i64(_tmp468, _tmp469) ? hml_i64_mul(_tmp468, _tmp469) : hml_binary_op(HML_OP_MUL, _tmp468, _tmp469));
    hml_release_if_needed(&_tmp468);
    hml_release_if_needed(&_tmp469);
    HmlValue _tmp471 = y;
    hml_retain_if_needed(&_tmp471);
    HmlValue _tmp472 = y;
    hml_retain_if_needed(&_tmp472);
    HmlValue _tmp470 = hml_both_i32(_tmp471, _tmp472) ? hml_i32_mul(_tmp471, _tmp472) : (hml_both_i64(_tmp471, _tmp472) ? hml_i64_mul(_tmp471, _tmp472) : hml_binary_op(HML_OP_MUL, _tmp471, _tmp472));
    hml_release_if_needed(&_tmp471);
    hml_release_if_needed(&_tmp472);
    HmlValue _tmp466 = hml_both_i32(_tmp467, _tmp470) ? hml_i32_add(_tmp467, _tmp470) : (hml_both_i64(_tmp467, _tmp470) ? hml_i64_add(_tmp467, _tmp470) : hml_binary_op(HML_OP_ADD, _tmp467, _tmp470));
    hml_release_if_needed(&_tmp467);
    hml_release_if_needed(&_tmp470);
    HmlValue _tmp465 = hml_sqrt(_tmp466);
    hml_release(&_tmp466);
    HML_CALL_EXIT();
    return _tmp465;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2Dot(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue y1, HmlValue x2, HmlValue y2) {
    (void)_closure_env;
    HmlValue _tmp475 = x1;
    hml_retain_if_needed(&_tmp475);
    HmlValue _tmp476 = x2;
    hml_retain_if_needed(&_tmp476);
    HmlValue _tmp474 = hml_both_i32(_tmp475, _tmp476) ? hml_i32_mul(_tmp475, _tmp476) : (hml_both_i64(_tmp475, _tmp476) ? hml_i64_mul(_tmp475, _tmp476) : hml_binary_op(HML_OP_MUL, _tmp475, _tmp476));
    hml_release_if_needed(&_tmp475);
    hml_release_if_needed(&_tmp476);
    HmlValue _tmp478 = y1;
    hml_retain_if_needed(&_tmp478);
    HmlValue _tmp479 = y2;
    hml_retain_if_needed(&_tmp479);
    HmlValue _tmp477 = hml_both_i32(_tmp478, _tmp479) ? hml_i32_mul(_tmp478, _tmp479) : (hml_both_i64(_tmp478, _tmp479) ? hml_i64_mul(_tmp478, _tmp479) : hml_binary_op(HML_OP_MUL, _tmp478, _tmp479));
    hml_release_if_needed(&_tmp478);
    hml_release_if_needed(&_tmp479);
    HmlValue _tmp473 = hml_both_i32(_tmp474, _tmp477) ? hml_i32_add(_tmp474, _tmp477) : (hml_both_i64(_tmp474, _tmp477) ? hml_i64_add(_tmp474, _tmp477) : hml_binary_op(HML_OP_ADD, _tmp474, _tmp477));
    hml_release_if_needed(&_tmp474);
    hml_release_if_needed(&_tmp477);
    HML_CALL_EXIT();
    return _tmp473;
    return hml_val_null();
}

HmlValue _mod0_fn_Lerp(HmlClosureEnv *_closure_env, HmlValue start, HmlValue end, HmlValue amount) {
    (void)_closure_env;
    HmlValue _tmp481 = start;
    hml_retain_if_needed(&_tmp481);
    HmlValue _tmp483 = amount;
    hml_retain_if_needed(&_tmp483);
    HmlValue _tmp485 = end;
    hml_retain_if_needed(&_tmp485);
    HmlValue _tmp486 = start;
    hml_retain_if_needed(&_tmp486);
    HmlValue _tmp484 = hml_both_i32(_tmp485, _tmp486) ? hml_i32_sub(_tmp485, _tmp486) : (hml_both_i64(_tmp485, _tmp486) ? hml_i64_sub(_tmp485, _tmp486) : hml_binary_op(HML_OP_SUB, _tmp485, _tmp486));
    hml_release_if_needed(&_tmp485);
    hml_release_if_needed(&_tmp486);
    HmlValue _tmp482 = hml_both_i32(_tmp483, _tmp484) ? hml_i32_mul(_tmp483, _tmp484) : (hml_both_i64(_tmp483, _tmp484) ? hml_i64_mul(_tmp483, _tmp484) : hml_binary_op(HML_OP_MUL, _tmp483, _tmp484));
    hml_release_if_needed(&_tmp483);
    hml_release_if_needed(&_tmp484);
    HmlValue _tmp480 = hml_both_i32(_tmp481, _tmp482) ? hml_i32_add(_tmp481, _tmp482) : (hml_both_i64(_tmp481, _tmp482) ? hml_i64_add(_tmp481, _tmp482) : hml_binary_op(HML_OP_ADD, _tmp481, _tmp482));
    hml_release_if_needed(&_tmp481);
    hml_release_if_needed(&_tmp482);
    HML_CALL_EXIT();
    return _tmp480;
    return hml_val_null();
}

HmlValue _mod0_fn_Clamp(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max) {
    (void)_closure_env;
    HmlValue _tmp488 = value;
    hml_retain_if_needed(&_tmp488);
    HmlValue _tmp489 = min;
    hml_retain_if_needed(&_tmp489);
    HmlValue _tmp487 = hml_both_i32(_tmp488, _tmp489) ? hml_i32_lt(_tmp488, _tmp489) : (hml_both_i64(_tmp488, _tmp489) ? hml_i64_lt(_tmp488, _tmp489) : hml_binary_op(HML_OP_LESS, _tmp488, _tmp489));
    hml_release_if_needed(&_tmp488);
    hml_release_if_needed(&_tmp489);
    if (hml_to_bool(_tmp487)) {
        {
            HmlValue _tmp490 = min;
            hml_retain_if_needed(&_tmp490);
            HML_CALL_EXIT();
            return _tmp490;
        }
    }
    hml_release(&_tmp487);
    HmlValue _tmp492 = value;
    hml_retain_if_needed(&_tmp492);
    HmlValue _tmp493 = max;
    hml_retain_if_needed(&_tmp493);
    HmlValue _tmp491 = hml_both_i32(_tmp492, _tmp493) ? hml_i32_gt(_tmp492, _tmp493) : (hml_both_i64(_tmp492, _tmp493) ? hml_i64_gt(_tmp492, _tmp493) : hml_binary_op(HML_OP_GREATER, _tmp492, _tmp493));
    hml_release_if_needed(&_tmp492);
    hml_release_if_needed(&_tmp493);
    if (hml_to_bool(_tmp491)) {
        {
            HmlValue _tmp494 = max;
            hml_retain_if_needed(&_tmp494);
            HML_CALL_EXIT();
            return _tmp494;
        }
    }
    hml_release(&_tmp491);
    HmlValue _tmp495 = value;
    hml_retain_if_needed(&_tmp495);
    HML_CALL_EXIT();
    return _tmp495;
    return hml_val_null();
}

HmlValue _mod0_fn_ClampInt(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max) {
    (void)_closure_env;
    HmlValue _tmp497 = value;
    hml_retain_if_needed(&_tmp497);
    HmlValue _tmp498 = min;
    hml_retain_if_needed(&_tmp498);
    HmlValue _tmp496 = hml_both_i32(_tmp497, _tmp498) ? hml_i32_lt(_tmp497, _tmp498) : (hml_both_i64(_tmp497, _tmp498) ? hml_i64_lt(_tmp497, _tmp498) : hml_binary_op(HML_OP_LESS, _tmp497, _tmp498));
    hml_release_if_needed(&_tmp497);
    hml_release_if_needed(&_tmp498);
    if (hml_to_bool(_tmp496)) {
        {
            HmlValue _tmp499 = min;
            hml_retain_if_needed(&_tmp499);
            HML_CALL_EXIT();
            return _tmp499;
        }
    }
    hml_release(&_tmp496);
    HmlValue _tmp501 = value;
    hml_retain_if_needed(&_tmp501);
    HmlValue _tmp502 = max;
    hml_retain_if_needed(&_tmp502);
    HmlValue _tmp500 = hml_both_i32(_tmp501, _tmp502) ? hml_i32_gt(_tmp501, _tmp502) : (hml_both_i64(_tmp501, _tmp502) ? hml_i64_gt(_tmp501, _tmp502) : hml_binary_op(HML_OP_GREATER, _tmp501, _tmp502));
    hml_release_if_needed(&_tmp501);
    hml_release_if_needed(&_tmp502);
    if (hml_to_bool(_tmp500)) {
        {
            HmlValue _tmp503 = max;
            hml_retain_if_needed(&_tmp503);
            HML_CALL_EXIT();
            return _tmp503;
        }
    }
    hml_release(&_tmp500);
    HmlValue _tmp504 = value;
    hml_retain_if_needed(&_tmp504);
    HML_CALL_EXIT();
    return _tmp504;
    return hml_val_null();
}

HmlValue _mod0_fn_Remap(HmlClosureEnv *_closure_env, HmlValue value, HmlValue inputStart, HmlValue inputEnd, HmlValue outputStart, HmlValue outputEnd) {
    (void)_closure_env;
    HmlValue _tmp506 = outputStart;
    hml_retain_if_needed(&_tmp506);
    HmlValue _tmp510 = value;
    hml_retain_if_needed(&_tmp510);
    HmlValue _tmp511 = inputStart;
    hml_retain_if_needed(&_tmp511);
    HmlValue _tmp509 = hml_both_i32(_tmp510, _tmp511) ? hml_i32_sub(_tmp510, _tmp511) : (hml_both_i64(_tmp510, _tmp511) ? hml_i64_sub(_tmp510, _tmp511) : hml_binary_op(HML_OP_SUB, _tmp510, _tmp511));
    hml_release_if_needed(&_tmp510);
    hml_release_if_needed(&_tmp511);
    HmlValue _tmp513 = inputEnd;
    hml_retain_if_needed(&_tmp513);
    HmlValue _tmp514 = inputStart;
    hml_retain_if_needed(&_tmp514);
    HmlValue _tmp512 = hml_both_i32(_tmp513, _tmp514) ? hml_i32_sub(_tmp513, _tmp514) : (hml_both_i64(_tmp513, _tmp514) ? hml_i64_sub(_tmp513, _tmp514) : hml_binary_op(HML_OP_SUB, _tmp513, _tmp514));
    hml_release_if_needed(&_tmp513);
    hml_release_if_needed(&_tmp514);
    HmlValue _tmp508 = hml_binary_op(HML_OP_DIV, _tmp509, _tmp512);
    hml_release_if_needed(&_tmp509);
    hml_release_if_needed(&_tmp512);
    HmlValue _tmp516 = outputEnd;
    hml_retain_if_needed(&_tmp516);
    HmlValue _tmp517 = outputStart;
    hml_retain_if_needed(&_tmp517);
    HmlValue _tmp515 = hml_both_i32(_tmp516, _tmp517) ? hml_i32_sub(_tmp516, _tmp517) : (hml_both_i64(_tmp516, _tmp517) ? hml_i64_sub(_tmp516, _tmp517) : hml_binary_op(HML_OP_SUB, _tmp516, _tmp517));
    hml_release_if_needed(&_tmp516);
    hml_release_if_needed(&_tmp517);
    HmlValue _tmp507 = hml_both_i32(_tmp508, _tmp515) ? hml_i32_mul(_tmp508, _tmp515) : (hml_both_i64(_tmp508, _tmp515) ? hml_i64_mul(_tmp508, _tmp515) : hml_binary_op(HML_OP_MUL, _tmp508, _tmp515));
    hml_release_if_needed(&_tmp508);
    hml_release_if_needed(&_tmp515);
    HmlValue _tmp505 = hml_both_i32(_tmp506, _tmp507) ? hml_i32_add(_tmp506, _tmp507) : (hml_both_i64(_tmp506, _tmp507) ? hml_i64_add(_tmp506, _tmp507) : hml_binary_op(HML_OP_ADD, _tmp506, _tmp507));
    hml_release_if_needed(&_tmp506);
    hml_release_if_needed(&_tmp507);
    HML_CALL_EXIT();
    return _tmp505;
    return hml_val_null();
}

HmlValue _mod0_fn_Wrap(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max) {
    (void)_closure_env;
    HmlValue _tmp519 = max;
    hml_retain_if_needed(&_tmp519);
    HmlValue _tmp520 = min;
    hml_retain_if_needed(&_tmp520);
    HmlValue _tmp518 = hml_both_i32(_tmp519, _tmp520) ? hml_i32_sub(_tmp519, _tmp520) : (hml_both_i64(_tmp519, _tmp520) ? hml_i64_sub(_tmp519, _tmp520) : hml_binary_op(HML_OP_SUB, _tmp519, _tmp520));
    hml_release_if_needed(&_tmp519);
    hml_release_if_needed(&_tmp520);
    HmlValue range = _tmp518;
    HmlValue _tmp522 = value;
    hml_retain_if_needed(&_tmp522);
    HmlValue _tmp523 = min;
    hml_retain_if_needed(&_tmp523);
    HmlValue _tmp521 = hml_both_i32(_tmp522, _tmp523) ? hml_i32_sub(_tmp522, _tmp523) : (hml_both_i64(_tmp522, _tmp523) ? hml_i64_sub(_tmp522, _tmp523) : hml_binary_op(HML_OP_SUB, _tmp522, _tmp523));
    hml_release_if_needed(&_tmp522);
    hml_release_if_needed(&_tmp523);
    HmlValue result = _tmp521;
    while (1) {
        HmlValue _tmp525 = result;
        hml_retain_if_needed(&_tmp525);
        HmlValue _tmp526 = hml_val_f64(0);
        HmlValue _tmp524 = hml_both_i32(_tmp525, _tmp526) ? hml_i32_lt(_tmp525, _tmp526) : (hml_both_i64(_tmp525, _tmp526) ? hml_i64_lt(_tmp525, _tmp526) : hml_binary_op(HML_OP_LESS, _tmp525, _tmp526));
        hml_release_if_needed(&_tmp525);
        hml_release_if_needed(&_tmp526);
        if (!hml_to_bool(_tmp524)) { hml_release(&_tmp524); break; }
        hml_release(&_tmp524);
        {
            HmlValue _tmp529 = result;
            hml_retain_if_needed(&_tmp529);
            HmlValue _tmp530 = range;
            hml_retain_if_needed(&_tmp530);
            HmlValue _tmp528 = hml_both_i32(_tmp529, _tmp530) ? hml_i32_add(_tmp529, _tmp530) : (hml_both_i64(_tmp529, _tmp530) ? hml_i64_add(_tmp529, _tmp530) : hml_binary_op(HML_OP_ADD, _tmp529, _tmp530));
            hml_release_if_needed(&_tmp529);
            hml_release_if_needed(&_tmp530);
            hml_release(&result);
            result = _tmp528;
            hml_retain(&result);
            HmlValue _tmp527 = result;
            hml_retain(&_tmp527);
            hml_release(&_tmp527);
        }
    }
    while (1) {
        HmlValue _tmp532 = result;
        hml_retain_if_needed(&_tmp532);
        HmlValue _tmp533 = range;
        hml_retain_if_needed(&_tmp533);
        HmlValue _tmp531 = hml_both_i32(_tmp532, _tmp533) ? hml_i32_ge(_tmp532, _tmp533) : (hml_both_i64(_tmp532, _tmp533) ? hml_i64_ge(_tmp532, _tmp533) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp532, _tmp533));
        hml_release_if_needed(&_tmp532);
        hml_release_if_needed(&_tmp533);
        if (!hml_to_bool(_tmp531)) { hml_release(&_tmp531); break; }
        hml_release(&_tmp531);
        {
            HmlValue _tmp536 = result;
            hml_retain_if_needed(&_tmp536);
            HmlValue _tmp537 = range;
            hml_retain_if_needed(&_tmp537);
            HmlValue _tmp535 = hml_both_i32(_tmp536, _tmp537) ? hml_i32_sub(_tmp536, _tmp537) : (hml_both_i64(_tmp536, _tmp537) ? hml_i64_sub(_tmp536, _tmp537) : hml_binary_op(HML_OP_SUB, _tmp536, _tmp537));
            hml_release_if_needed(&_tmp536);
            hml_release_if_needed(&_tmp537);
            hml_release(&result);
            result = _tmp535;
            hml_retain(&result);
            HmlValue _tmp534 = result;
            hml_retain(&_tmp534);
            hml_release(&_tmp534);
        }
    }
    HmlValue _tmp539 = result;
    hml_retain_if_needed(&_tmp539);
    HmlValue _tmp540 = min;
    hml_retain_if_needed(&_tmp540);
    HmlValue _tmp538 = hml_both_i32(_tmp539, _tmp540) ? hml_i32_add(_tmp539, _tmp540) : (hml_both_i64(_tmp539, _tmp540) ? hml_i64_add(_tmp539, _tmp540) : hml_binary_op(HML_OP_ADD, _tmp539, _tmp540));
    hml_release_if_needed(&_tmp539);
    hml_release_if_needed(&_tmp540);
    HML_CALL_EXIT();
    return _tmp538;
    return hml_val_null();
}

HmlValue _mod0_fn_NormalizeAngle(HmlClosureEnv *_closure_env, HmlValue angle) {
    (void)_closure_env;
    HmlValue _tmp541 = angle;
    hml_retain_if_needed(&_tmp541);
    HmlValue result = _tmp541;
    while (1) {
        HmlValue _tmp543 = result;
        hml_retain_if_needed(&_tmp543);
        HmlValue _tmp544 = hml_val_f64(0);
        HmlValue _tmp542 = hml_both_i32(_tmp543, _tmp544) ? hml_i32_lt(_tmp543, _tmp544) : (hml_both_i64(_tmp543, _tmp544) ? hml_i64_lt(_tmp543, _tmp544) : hml_binary_op(HML_OP_LESS, _tmp543, _tmp544));
        hml_release_if_needed(&_tmp543);
        hml_release_if_needed(&_tmp544);
        if (!hml_to_bool(_tmp542)) { hml_release(&_tmp542); break; }
        hml_release(&_tmp542);
        {
            HmlValue _tmp547 = result;
            hml_retain_if_needed(&_tmp547);
            HmlValue _tmp548 = hml_val_f64(360);
            HmlValue _tmp546 = hml_both_i32(_tmp547, _tmp548) ? hml_i32_add(_tmp547, _tmp548) : (hml_both_i64(_tmp547, _tmp548) ? hml_i64_add(_tmp547, _tmp548) : hml_binary_op(HML_OP_ADD, _tmp547, _tmp548));
            hml_release_if_needed(&_tmp547);
            hml_release_if_needed(&_tmp548);
            hml_release(&result);
            result = _tmp546;
            hml_retain(&result);
            HmlValue _tmp545 = result;
            hml_retain(&_tmp545);
            hml_release(&_tmp545);
        }
    }
    while (1) {
        HmlValue _tmp550 = result;
        hml_retain_if_needed(&_tmp550);
        HmlValue _tmp551 = hml_val_f64(360);
        HmlValue _tmp549 = hml_both_i32(_tmp550, _tmp551) ? hml_i32_ge(_tmp550, _tmp551) : (hml_both_i64(_tmp550, _tmp551) ? hml_i64_ge(_tmp550, _tmp551) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp550, _tmp551));
        hml_release_if_needed(&_tmp550);
        hml_release_if_needed(&_tmp551);
        if (!hml_to_bool(_tmp549)) { hml_release(&_tmp549); break; }
        hml_release(&_tmp549);
        {
            HmlValue _tmp554 = result;
            hml_retain_if_needed(&_tmp554);
            HmlValue _tmp555 = hml_val_f64(360);
            HmlValue _tmp553 = hml_both_i32(_tmp554, _tmp555) ? hml_i32_sub(_tmp554, _tmp555) : (hml_both_i64(_tmp554, _tmp555) ? hml_i64_sub(_tmp554, _tmp555) : hml_binary_op(HML_OP_SUB, _tmp554, _tmp555));
            hml_release_if_needed(&_tmp554);
            hml_release_if_needed(&_tmp555);
            hml_release(&result);
            result = _tmp553;
            hml_retain(&result);
            HmlValue _tmp552 = result;
            hml_retain(&_tmp552);
            hml_release(&_tmp552);
        }
    }
    HmlValue _tmp556 = result;
    hml_retain_if_needed(&_tmp556);
    HML_CALL_EXIT();
    return _tmp556;
    return hml_val_null();
}

HmlValue _mod0_fn_Deg2Rad(HmlClosureEnv *_closure_env, HmlValue degrees) {
    (void)_closure_env;
    HmlValue _tmp558 = degrees;
    hml_retain_if_needed(&_tmp558);
    HmlValue _tmp559 = hml_val_f64(0.0174533);
    HmlValue _tmp557 = hml_both_i32(_tmp558, _tmp559) ? hml_i32_mul(_tmp558, _tmp559) : (hml_both_i64(_tmp558, _tmp559) ? hml_i64_mul(_tmp558, _tmp559) : hml_binary_op(HML_OP_MUL, _tmp558, _tmp559));
    hml_release_if_needed(&_tmp558);
    hml_release_if_needed(&_tmp559);
    HML_CALL_EXIT();
    return _tmp557;
    return hml_val_null();
}

HmlValue _mod0_fn_Rad2Deg(HmlClosureEnv *_closure_env, HmlValue radians) {
    (void)_closure_env;
    HmlValue _tmp561 = radians;
    hml_retain_if_needed(&_tmp561);
    HmlValue _tmp562 = hml_val_f64(57.2958);
    HmlValue _tmp560 = hml_both_i32(_tmp561, _tmp562) ? hml_i32_mul(_tmp561, _tmp562) : (hml_both_i64(_tmp561, _tmp562) ? hml_i64_mul(_tmp561, _tmp562) : hml_binary_op(HML_OP_MUL, _tmp561, _tmp562));
    hml_release_if_needed(&_tmp561);
    hml_release_if_needed(&_tmp562);
    HML_CALL_EXIT();
    return _tmp560;
    return hml_val_null();
}

HmlValue _mod0_fn_Sign(HmlClosureEnv *_closure_env, HmlValue value) {
    (void)_closure_env;
    HmlValue _tmp564 = value;
    hml_retain_if_needed(&_tmp564);
    HmlValue _tmp565 = hml_val_f64(0);
    HmlValue _tmp563 = hml_both_i32(_tmp564, _tmp565) ? hml_i32_gt(_tmp564, _tmp565) : (hml_both_i64(_tmp564, _tmp565) ? hml_i64_gt(_tmp564, _tmp565) : hml_binary_op(HML_OP_GREATER, _tmp564, _tmp565));
    hml_release_if_needed(&_tmp564);
    hml_release_if_needed(&_tmp565);
    if (hml_to_bool(_tmp563)) {
        {
            HmlValue _tmp566 = hml_val_f64(1);
            HML_CALL_EXIT();
            return _tmp566;
        }
    }
    hml_release(&_tmp563);
    HmlValue _tmp568 = value;
    hml_retain_if_needed(&_tmp568);
    HmlValue _tmp569 = hml_val_f64(0);
    HmlValue _tmp567 = hml_both_i32(_tmp568, _tmp569) ? hml_i32_lt(_tmp568, _tmp569) : (hml_both_i64(_tmp568, _tmp569) ? hml_i64_lt(_tmp568, _tmp569) : hml_binary_op(HML_OP_LESS, _tmp568, _tmp569));
    hml_release_if_needed(&_tmp568);
    hml_release_if_needed(&_tmp569);
    if (hml_to_bool(_tmp567)) {
        {
            HmlValue _tmp571 = hml_val_f64(1);
            HmlValue _tmp570 = hml_unary_op(HML_UNARY_NEGATE, _tmp571);
            hml_release_if_needed(&_tmp571);
            HML_CALL_EXIT();
            return _tmp570;
        }
    }
    hml_release(&_tmp567);
    HmlValue _tmp572 = hml_val_f64(0);
    HML_CALL_EXIT();
    return _tmp572;
    return hml_val_null();
}

HmlValue _mod0_fn_SignInt(HmlClosureEnv *_closure_env, HmlValue value) {
    (void)_closure_env;
    HmlValue _tmp574 = value;
    hml_retain_if_needed(&_tmp574);
    HmlValue _tmp575 = hml_val_i32(0);
    HmlValue _tmp573 = hml_both_i32(_tmp574, _tmp575) ? hml_i32_gt(_tmp574, _tmp575) : (hml_both_i64(_tmp574, _tmp575) ? hml_i64_gt(_tmp574, _tmp575) : hml_binary_op(HML_OP_GREATER, _tmp574, _tmp575));
    hml_release_if_needed(&_tmp574);
    hml_release_if_needed(&_tmp575);
    if (hml_to_bool(_tmp573)) {
        {
            HmlValue _tmp576 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp576;
        }
    }
    hml_release(&_tmp573);
    HmlValue _tmp578 = value;
    hml_retain_if_needed(&_tmp578);
    HmlValue _tmp579 = hml_val_i32(0);
    HmlValue _tmp577 = hml_both_i32(_tmp578, _tmp579) ? hml_i32_lt(_tmp578, _tmp579) : (hml_both_i64(_tmp578, _tmp579) ? hml_i64_lt(_tmp578, _tmp579) : hml_binary_op(HML_OP_LESS, _tmp578, _tmp579));
    hml_release_if_needed(&_tmp578);
    hml_release_if_needed(&_tmp579);
    if (hml_to_bool(_tmp577)) {
        {
            HmlValue _tmp580 = hml_val_i32(-1);
            HML_CALL_EXIT();
            return _tmp580;
        }
    }
    hml_release(&_tmp577);
    HmlValue _tmp581 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp581;
    return hml_val_null();
}

HmlValue _mod0_fn_Abs(HmlClosureEnv *_closure_env, HmlValue value) {
    (void)_closure_env;
    HmlValue _tmp583 = value;
    hml_retain_if_needed(&_tmp583);
    HmlValue _tmp584 = hml_val_f64(0);
    HmlValue _tmp582 = hml_both_i32(_tmp583, _tmp584) ? hml_i32_lt(_tmp583, _tmp584) : (hml_both_i64(_tmp583, _tmp584) ? hml_i64_lt(_tmp583, _tmp584) : hml_binary_op(HML_OP_LESS, _tmp583, _tmp584));
    hml_release_if_needed(&_tmp583);
    hml_release_if_needed(&_tmp584);
    if (hml_to_bool(_tmp582)) {
        {
            HmlValue _tmp586 = value;
            hml_retain_if_needed(&_tmp586);
            HmlValue _tmp585 = hml_unary_op(HML_UNARY_NEGATE, _tmp586);
            hml_release_if_needed(&_tmp586);
            HML_CALL_EXIT();
            return _tmp585;
        }
    }
    hml_release(&_tmp582);
    HmlValue _tmp587 = value;
    hml_retain_if_needed(&_tmp587);
    HML_CALL_EXIT();
    return _tmp587;
    return hml_val_null();
}

HmlValue _mod0_fn_AbsInt(HmlClosureEnv *_closure_env, HmlValue value) {
    (void)_closure_env;
    HmlValue _tmp589 = value;
    hml_retain_if_needed(&_tmp589);
    HmlValue _tmp590 = hml_val_i32(0);
    HmlValue _tmp588 = hml_both_i32(_tmp589, _tmp590) ? hml_i32_lt(_tmp589, _tmp590) : (hml_both_i64(_tmp589, _tmp590) ? hml_i64_lt(_tmp589, _tmp590) : hml_binary_op(HML_OP_LESS, _tmp589, _tmp590));
    hml_release_if_needed(&_tmp589);
    hml_release_if_needed(&_tmp590);
    if (hml_to_bool(_tmp588)) {
        {
            HmlValue _tmp592 = value;
            hml_retain_if_needed(&_tmp592);
            HmlValue _tmp591 = hml_unary_op(HML_UNARY_NEGATE, _tmp592);
            hml_release_if_needed(&_tmp592);
            HML_CALL_EXIT();
            return _tmp591;
        }
    }
    hml_release(&_tmp588);
    HmlValue _tmp593 = value;
    hml_retain_if_needed(&_tmp593);
    HML_CALL_EXIT();
    return _tmp593;
    return hml_val_null();
}

HmlValue _mod0_fn_Min(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b) {
    (void)_closure_env;
    HmlValue _tmp595 = a;
    hml_retain_if_needed(&_tmp595);
    HmlValue _tmp596 = b;
    hml_retain_if_needed(&_tmp596);
    HmlValue _tmp594 = hml_both_i32(_tmp595, _tmp596) ? hml_i32_lt(_tmp595, _tmp596) : (hml_both_i64(_tmp595, _tmp596) ? hml_i64_lt(_tmp595, _tmp596) : hml_binary_op(HML_OP_LESS, _tmp595, _tmp596));
    hml_release_if_needed(&_tmp595);
    hml_release_if_needed(&_tmp596);
    if (hml_to_bool(_tmp594)) {
        {
            HmlValue _tmp597 = a;
            hml_retain_if_needed(&_tmp597);
            HML_CALL_EXIT();
            return _tmp597;
        }
    }
    hml_release(&_tmp594);
    HmlValue _tmp598 = b;
    hml_retain_if_needed(&_tmp598);
    HML_CALL_EXIT();
    return _tmp598;
    return hml_val_null();
}

HmlValue _mod0_fn_Max(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b) {
    (void)_closure_env;
    HmlValue _tmp600 = a;
    hml_retain_if_needed(&_tmp600);
    HmlValue _tmp601 = b;
    hml_retain_if_needed(&_tmp601);
    HmlValue _tmp599 = hml_both_i32(_tmp600, _tmp601) ? hml_i32_gt(_tmp600, _tmp601) : (hml_both_i64(_tmp600, _tmp601) ? hml_i64_gt(_tmp600, _tmp601) : hml_binary_op(HML_OP_GREATER, _tmp600, _tmp601));
    hml_release_if_needed(&_tmp600);
    hml_release_if_needed(&_tmp601);
    if (hml_to_bool(_tmp599)) {
        {
            HmlValue _tmp602 = a;
            hml_retain_if_needed(&_tmp602);
            HML_CALL_EXIT();
            return _tmp602;
        }
    }
    hml_release(&_tmp599);
    HmlValue _tmp603 = b;
    hml_retain_if_needed(&_tmp603);
    HML_CALL_EXIT();
    return _tmp603;
    return hml_val_null();
}

HmlValue _mod0_fn_MinInt(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b) {
    (void)_closure_env;
    HmlValue _tmp605 = a;
    hml_retain_if_needed(&_tmp605);
    HmlValue _tmp606 = b;
    hml_retain_if_needed(&_tmp606);
    HmlValue _tmp604 = hml_both_i32(_tmp605, _tmp606) ? hml_i32_lt(_tmp605, _tmp606) : (hml_both_i64(_tmp605, _tmp606) ? hml_i64_lt(_tmp605, _tmp606) : hml_binary_op(HML_OP_LESS, _tmp605, _tmp606));
    hml_release_if_needed(&_tmp605);
    hml_release_if_needed(&_tmp606);
    if (hml_to_bool(_tmp604)) {
        {
            HmlValue _tmp607 = a;
            hml_retain_if_needed(&_tmp607);
            HML_CALL_EXIT();
            return _tmp607;
        }
    }
    hml_release(&_tmp604);
    HmlValue _tmp608 = b;
    hml_retain_if_needed(&_tmp608);
    HML_CALL_EXIT();
    return _tmp608;
    return hml_val_null();
}

HmlValue _mod0_fn_MaxInt(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b) {
    (void)_closure_env;
    HmlValue _tmp610 = a;
    hml_retain_if_needed(&_tmp610);
    HmlValue _tmp611 = b;
    hml_retain_if_needed(&_tmp611);
    HmlValue _tmp609 = hml_both_i32(_tmp610, _tmp611) ? hml_i32_gt(_tmp610, _tmp611) : (hml_both_i64(_tmp610, _tmp611) ? hml_i64_gt(_tmp610, _tmp611) : hml_binary_op(HML_OP_GREATER, _tmp610, _tmp611));
    hml_release_if_needed(&_tmp610);
    hml_release_if_needed(&_tmp611);
    if (hml_to_bool(_tmp609)) {
        {
            HmlValue _tmp612 = a;
            hml_retain_if_needed(&_tmp612);
            HML_CALL_EXIT();
            return _tmp612;
        }
    }
    hml_release(&_tmp609);
    HmlValue _tmp613 = b;
    hml_retain_if_needed(&_tmp613);
    HML_CALL_EXIT();
    return _tmp613;
    return hml_val_null();
}

HmlValue _mod0_fn_FloorInt(HmlClosureEnv *_closure_env, HmlValue value) {
    (void)_closure_env;
    HmlValue _tmp614 = value;
    hml_retain_if_needed(&_tmp614);
    HmlValue i = hml_convert_to_type(_tmp614, HML_VAL_I32);
    HmlValue _tmp617 = value;
    hml_retain_if_needed(&_tmp617);
    HmlValue _tmp618 = hml_val_f64(0);
    HmlValue _tmp616 = hml_both_i32(_tmp617, _tmp618) ? hml_i32_lt(_tmp617, _tmp618) : (hml_both_i64(_tmp617, _tmp618) ? hml_i64_lt(_tmp617, _tmp618) : hml_binary_op(HML_OP_LESS, _tmp617, _tmp618));
    hml_release_if_needed(&_tmp617);
    hml_release_if_needed(&_tmp618);
    HmlValue _tmp615;
    if (!hml_to_bool(_tmp616)) {
        _tmp615 = hml_val_bool(0);
    } else {
        HmlValue _tmp620 = value;
        hml_retain_if_needed(&_tmp620);
        HmlValue _tmp621 = i;
        hml_retain_if_needed(&_tmp621);
        HmlValue _tmp619 = hml_both_i32(_tmp620, _tmp621) ? hml_i32_ne(_tmp620, _tmp621) : (hml_both_i64(_tmp620, _tmp621) ? hml_i64_ne(_tmp620, _tmp621) : hml_binary_op(HML_OP_NOT_EQUAL, _tmp620, _tmp621));
        hml_release_if_needed(&_tmp620);
        hml_release_if_needed(&_tmp621);
        _tmp615 = hml_val_bool(hml_to_bool(_tmp619));
        hml_release_if_needed(&_tmp619);
    }
    hml_release_if_needed(&_tmp616);
    if (hml_to_bool(_tmp615)) {
        {
            HmlValue _tmp623 = i;
            hml_retain_if_needed(&_tmp623);
            HmlValue _tmp624 = hml_val_i32(1);
            HmlValue _tmp622 = hml_both_i32(_tmp623, _tmp624) ? hml_i32_sub(_tmp623, _tmp624) : (hml_both_i64(_tmp623, _tmp624) ? hml_i64_sub(_tmp623, _tmp624) : hml_binary_op(HML_OP_SUB, _tmp623, _tmp624));
            hml_release_if_needed(&_tmp623);
            hml_release_if_needed(&_tmp624);
            HML_CALL_EXIT();
            return _tmp622;
        }
    }
    hml_release(&_tmp615);
    HmlValue _tmp625 = i;
    hml_retain_if_needed(&_tmp625);
    HML_CALL_EXIT();
    return _tmp625;
    return hml_val_null();
}

HmlValue _mod0_fn_CeilInt(HmlClosureEnv *_closure_env, HmlValue value) {
    (void)_closure_env;
    HmlValue _tmp626 = value;
    hml_retain_if_needed(&_tmp626);
    HmlValue i = hml_convert_to_type(_tmp626, HML_VAL_I32);
    HmlValue _tmp629 = value;
    hml_retain_if_needed(&_tmp629);
    HmlValue _tmp630 = hml_val_f64(0);
    HmlValue _tmp628 = hml_both_i32(_tmp629, _tmp630) ? hml_i32_gt(_tmp629, _tmp630) : (hml_both_i64(_tmp629, _tmp630) ? hml_i64_gt(_tmp629, _tmp630) : hml_binary_op(HML_OP_GREATER, _tmp629, _tmp630));
    hml_release_if_needed(&_tmp629);
    hml_release_if_needed(&_tmp630);
    HmlValue _tmp627;
    if (!hml_to_bool(_tmp628)) {
        _tmp627 = hml_val_bool(0);
    } else {
        HmlValue _tmp632 = value;
        hml_retain_if_needed(&_tmp632);
        HmlValue _tmp633 = i;
        hml_retain_if_needed(&_tmp633);
        HmlValue _tmp631 = hml_both_i32(_tmp632, _tmp633) ? hml_i32_ne(_tmp632, _tmp633) : (hml_both_i64(_tmp632, _tmp633) ? hml_i64_ne(_tmp632, _tmp633) : hml_binary_op(HML_OP_NOT_EQUAL, _tmp632, _tmp633));
        hml_release_if_needed(&_tmp632);
        hml_release_if_needed(&_tmp633);
        _tmp627 = hml_val_bool(hml_to_bool(_tmp631));
        hml_release_if_needed(&_tmp631);
    }
    hml_release_if_needed(&_tmp628);
    if (hml_to_bool(_tmp627)) {
        {
            HmlValue _tmp635 = i;
            hml_retain_if_needed(&_tmp635);
            HmlValue _tmp636 = hml_val_i32(1);
            HmlValue _tmp634 = hml_both_i32(_tmp635, _tmp636) ? hml_i32_add(_tmp635, _tmp636) : (hml_both_i64(_tmp635, _tmp636) ? hml_i64_add(_tmp635, _tmp636) : hml_binary_op(HML_OP_ADD, _tmp635, _tmp636));
            hml_release_if_needed(&_tmp635);
            hml_release_if_needed(&_tmp636);
            HML_CALL_EXIT();
            return _tmp634;
        }
    }
    hml_release(&_tmp627);
    HmlValue _tmp637 = i;
    hml_retain_if_needed(&_tmp637);
    HML_CALL_EXIT();
    return _tmp637;
    return hml_val_null();
}

HmlValue _mod0_fn_RoundInt(HmlClosureEnv *_closure_env, HmlValue value) {
    (void)_closure_env;
    HmlValue _tmp639 = value;
    hml_retain_if_needed(&_tmp639);
    HmlValue _tmp640 = hml_val_f64(0);
    HmlValue _tmp638 = hml_both_i32(_tmp639, _tmp640) ? hml_i32_ge(_tmp639, _tmp640) : (hml_both_i64(_tmp639, _tmp640) ? hml_i64_ge(_tmp639, _tmp640) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp639, _tmp640));
    hml_release_if_needed(&_tmp639);
    hml_release_if_needed(&_tmp640);
    if (hml_to_bool(_tmp638)) {
        {
            HmlValue _tmp643 = value;
            hml_retain_if_needed(&_tmp643);
            HmlValue _tmp644 = hml_val_f64(0.5);
            HmlValue _tmp642 = hml_both_i32(_tmp643, _tmp644) ? hml_i32_add(_tmp643, _tmp644) : (hml_both_i64(_tmp643, _tmp644) ? hml_i64_add(_tmp643, _tmp644) : hml_binary_op(HML_OP_ADD, _tmp643, _tmp644));
            hml_release_if_needed(&_tmp643);
            hml_release_if_needed(&_tmp644);
            HmlValue _tmp641 = _mod0_fn_FloorInt(NULL, _tmp642);
            hml_release(&_tmp642);
            HML_CALL_EXIT();
            return _tmp641;
        }
    }
    hml_release(&_tmp638);
    HmlValue _tmp647 = value;
    hml_retain_if_needed(&_tmp647);
    HmlValue _tmp648 = hml_val_f64(0.5);
    HmlValue _tmp646 = hml_both_i32(_tmp647, _tmp648) ? hml_i32_sub(_tmp647, _tmp648) : (hml_both_i64(_tmp647, _tmp648) ? hml_i64_sub(_tmp647, _tmp648) : hml_binary_op(HML_OP_SUB, _tmp647, _tmp648));
    hml_release_if_needed(&_tmp647);
    hml_release_if_needed(&_tmp648);
    HmlValue _tmp645 = _mod0_fn_CeilInt(NULL, _tmp646);
    hml_release(&_tmp646);
    HML_CALL_EXIT();
    return _tmp645;
    return hml_val_null();
}

HmlValue _mod0_fn_SmoothStep(HmlClosureEnv *_closure_env, HmlValue edge0, HmlValue edge1, HmlValue x) {
    (void)_closure_env;
    HmlValue _tmp652 = x;
    hml_retain_if_needed(&_tmp652);
    HmlValue _tmp653 = edge0;
    hml_retain_if_needed(&_tmp653);
    HmlValue _tmp651 = hml_both_i32(_tmp652, _tmp653) ? hml_i32_sub(_tmp652, _tmp653) : (hml_both_i64(_tmp652, _tmp653) ? hml_i64_sub(_tmp652, _tmp653) : hml_binary_op(HML_OP_SUB, _tmp652, _tmp653));
    hml_release_if_needed(&_tmp652);
    hml_release_if_needed(&_tmp653);
    HmlValue _tmp655 = edge1;
    hml_retain_if_needed(&_tmp655);
    HmlValue _tmp656 = edge0;
    hml_retain_if_needed(&_tmp656);
    HmlValue _tmp654 = hml_both_i32(_tmp655, _tmp656) ? hml_i32_sub(_tmp655, _tmp656) : (hml_both_i64(_tmp655, _tmp656) ? hml_i64_sub(_tmp655, _tmp656) : hml_binary_op(HML_OP_SUB, _tmp655, _tmp656));
    hml_release_if_needed(&_tmp655);
    hml_release_if_needed(&_tmp656);
    HmlValue _tmp650 = hml_binary_op(HML_OP_DIV, _tmp651, _tmp654);
    hml_release_if_needed(&_tmp651);
    hml_release_if_needed(&_tmp654);
    HmlValue _tmp657 = hml_val_f64(0);
    HmlValue _tmp658 = hml_val_f64(1);
    HmlValue _tmp649 = _mod0_fn_Clamp(NULL, _tmp650, _tmp657, _tmp658);
    hml_release(&_tmp650);
    hml_release(&_tmp657);
    hml_release(&_tmp658);
    HmlValue t = _tmp649;
    HmlValue _tmp661 = t;
    hml_retain_if_needed(&_tmp661);
    HmlValue _tmp662 = t;
    hml_retain_if_needed(&_tmp662);
    HmlValue _tmp660 = hml_both_i32(_tmp661, _tmp662) ? hml_i32_mul(_tmp661, _tmp662) : (hml_both_i64(_tmp661, _tmp662) ? hml_i64_mul(_tmp661, _tmp662) : hml_binary_op(HML_OP_MUL, _tmp661, _tmp662));
    hml_release_if_needed(&_tmp661);
    hml_release_if_needed(&_tmp662);
    HmlValue _tmp664 = hml_val_f64(3);
    HmlValue _tmp666 = hml_val_f64(2);
    HmlValue _tmp667 = t;
    hml_retain_if_needed(&_tmp667);
    HmlValue _tmp665 = hml_both_i32(_tmp666, _tmp667) ? hml_i32_mul(_tmp666, _tmp667) : (hml_both_i64(_tmp666, _tmp667) ? hml_i64_mul(_tmp666, _tmp667) : hml_binary_op(HML_OP_MUL, _tmp666, _tmp667));
    hml_release_if_needed(&_tmp666);
    hml_release_if_needed(&_tmp667);
    HmlValue _tmp663 = hml_both_i32(_tmp664, _tmp665) ? hml_i32_sub(_tmp664, _tmp665) : (hml_both_i64(_tmp664, _tmp665) ? hml_i64_sub(_tmp664, _tmp665) : hml_binary_op(HML_OP_SUB, _tmp664, _tmp665));
    hml_release_if_needed(&_tmp664);
    hml_release_if_needed(&_tmp665);
    HmlValue _tmp659 = hml_both_i32(_tmp660, _tmp663) ? hml_i32_mul(_tmp660, _tmp663) : (hml_both_i64(_tmp660, _tmp663) ? hml_i64_mul(_tmp660, _tmp663) : hml_binary_op(HML_OP_MUL, _tmp660, _tmp663));
    hml_release_if_needed(&_tmp660);
    hml_release_if_needed(&_tmp663);
    HML_CALL_EXIT();
    return _tmp659;
    return hml_val_null();
}

HmlValue _mod0_fn_InverseLerp(HmlClosureEnv *_closure_env, HmlValue start, HmlValue end, HmlValue value) {
    (void)_closure_env;
    HmlValue _tmp669 = start;
    hml_retain_if_needed(&_tmp669);
    HmlValue _tmp670 = end;
    hml_retain_if_needed(&_tmp670);
    HmlValue _tmp668 = hml_both_i32(_tmp669, _tmp670) ? hml_i32_eq(_tmp669, _tmp670) : (hml_both_i64(_tmp669, _tmp670) ? hml_i64_eq(_tmp669, _tmp670) : hml_binary_op(HML_OP_EQUAL, _tmp669, _tmp670));
    hml_release_if_needed(&_tmp669);
    hml_release_if_needed(&_tmp670);
    if (hml_to_bool(_tmp668)) {
        {
            HmlValue _tmp671 = hml_val_f64(0);
            HML_CALL_EXIT();
            return _tmp671;
        }
    }
    hml_release(&_tmp668);
    HmlValue _tmp674 = value;
    hml_retain_if_needed(&_tmp674);
    HmlValue _tmp675 = start;
    hml_retain_if_needed(&_tmp675);
    HmlValue _tmp673 = hml_both_i32(_tmp674, _tmp675) ? hml_i32_sub(_tmp674, _tmp675) : (hml_both_i64(_tmp674, _tmp675) ? hml_i64_sub(_tmp674, _tmp675) : hml_binary_op(HML_OP_SUB, _tmp674, _tmp675));
    hml_release_if_needed(&_tmp674);
    hml_release_if_needed(&_tmp675);
    HmlValue _tmp677 = end;
    hml_retain_if_needed(&_tmp677);
    HmlValue _tmp678 = start;
    hml_retain_if_needed(&_tmp678);
    HmlValue _tmp676 = hml_both_i32(_tmp677, _tmp678) ? hml_i32_sub(_tmp677, _tmp678) : (hml_both_i64(_tmp677, _tmp678) ? hml_i64_sub(_tmp677, _tmp678) : hml_binary_op(HML_OP_SUB, _tmp677, _tmp678));
    hml_release_if_needed(&_tmp677);
    hml_release_if_needed(&_tmp678);
    HmlValue _tmp672 = hml_binary_op(HML_OP_DIV, _tmp673, _tmp676);
    hml_release_if_needed(&_tmp673);
    hml_release_if_needed(&_tmp676);
    HML_CALL_EXIT();
    return _tmp672;
    return hml_val_null();
}

HmlValue _mod0_fn_MoveTowards(HmlClosureEnv *_closure_env, HmlValue current, HmlValue target, HmlValue maxDelta) {
    (void)_closure_env;
    HmlValue _tmp680 = target;
    hml_retain_if_needed(&_tmp680);
    HmlValue _tmp681 = current;
    hml_retain_if_needed(&_tmp681);
    HmlValue _tmp679 = hml_both_i32(_tmp680, _tmp681) ? hml_i32_sub(_tmp680, _tmp681) : (hml_both_i64(_tmp680, _tmp681) ? hml_i64_sub(_tmp680, _tmp681) : hml_binary_op(HML_OP_SUB, _tmp680, _tmp681));
    hml_release_if_needed(&_tmp680);
    hml_release_if_needed(&_tmp681);
    HmlValue diff = _tmp679;
    HmlValue _tmp684 = diff;
    hml_retain_if_needed(&_tmp684);
    HmlValue _tmp683 = _mod0_fn_Abs(NULL, _tmp684);
    hml_release(&_tmp684);
    HmlValue _tmp685 = maxDelta;
    hml_retain_if_needed(&_tmp685);
    HmlValue _tmp682 = hml_both_i32(_tmp683, _tmp685) ? hml_i32_le(_tmp683, _tmp685) : (hml_both_i64(_tmp683, _tmp685) ? hml_i64_le(_tmp683, _tmp685) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp683, _tmp685));
    hml_release_if_needed(&_tmp683);
    hml_release_if_needed(&_tmp685);
    if (hml_to_bool(_tmp682)) {
        {
            HmlValue _tmp686 = target;
            hml_retain_if_needed(&_tmp686);
            HML_CALL_EXIT();
            return _tmp686;
        }
    }
    hml_release(&_tmp682);
    HmlValue _tmp688 = current;
    hml_retain_if_needed(&_tmp688);
    HmlValue _tmp691 = diff;
    hml_retain_if_needed(&_tmp691);
    HmlValue _tmp690 = _mod0_fn_Sign(NULL, _tmp691);
    hml_release(&_tmp691);
    HmlValue _tmp692 = maxDelta;
    hml_retain_if_needed(&_tmp692);
    HmlValue _tmp689 = hml_both_i32(_tmp690, _tmp692) ? hml_i32_mul(_tmp690, _tmp692) : (hml_both_i64(_tmp690, _tmp692) ? hml_i64_mul(_tmp690, _tmp692) : hml_binary_op(HML_OP_MUL, _tmp690, _tmp692));
    hml_release_if_needed(&_tmp690);
    hml_release_if_needed(&_tmp692);
    HmlValue _tmp687 = hml_both_i32(_tmp688, _tmp689) ? hml_i32_add(_tmp688, _tmp689) : (hml_both_i64(_tmp688, _tmp689) ? hml_i64_add(_tmp688, _tmp689) : hml_binary_op(HML_OP_ADD, _tmp688, _tmp689));
    hml_release_if_needed(&_tmp688);
    hml_release_if_needed(&_tmp689);
    HML_CALL_EXIT();
    return _tmp687;
    return hml_val_null();
}

HmlValue _mod0_fn_MoveTowardsInt(HmlClosureEnv *_closure_env, HmlValue current, HmlValue target, HmlValue maxDelta) {
    (void)_closure_env;
    HmlValue _tmp694 = target;
    hml_retain_if_needed(&_tmp694);
    HmlValue _tmp695 = current;
    hml_retain_if_needed(&_tmp695);
    HmlValue _tmp693 = hml_both_i32(_tmp694, _tmp695) ? hml_i32_sub(_tmp694, _tmp695) : (hml_both_i64(_tmp694, _tmp695) ? hml_i64_sub(_tmp694, _tmp695) : hml_binary_op(HML_OP_SUB, _tmp694, _tmp695));
    hml_release_if_needed(&_tmp694);
    hml_release_if_needed(&_tmp695);
    HmlValue diff = _tmp693;
    HmlValue _tmp698 = diff;
    hml_retain_if_needed(&_tmp698);
    HmlValue _tmp697 = _mod0_fn_AbsInt(NULL, _tmp698);
    hml_release(&_tmp698);
    HmlValue _tmp699 = maxDelta;
    hml_retain_if_needed(&_tmp699);
    HmlValue _tmp696 = hml_both_i32(_tmp697, _tmp699) ? hml_i32_le(_tmp697, _tmp699) : (hml_both_i64(_tmp697, _tmp699) ? hml_i64_le(_tmp697, _tmp699) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp697, _tmp699));
    hml_release_if_needed(&_tmp697);
    hml_release_if_needed(&_tmp699);
    if (hml_to_bool(_tmp696)) {
        {
            HmlValue _tmp700 = target;
            hml_retain_if_needed(&_tmp700);
            HML_CALL_EXIT();
            return _tmp700;
        }
    }
    hml_release(&_tmp696);
    HmlValue _tmp702 = current;
    hml_retain_if_needed(&_tmp702);
    HmlValue _tmp705 = diff;
    hml_retain_if_needed(&_tmp705);
    HmlValue _tmp704 = _mod0_fn_SignInt(NULL, _tmp705);
    hml_release(&_tmp705);
    HmlValue _tmp706 = maxDelta;
    hml_retain_if_needed(&_tmp706);
    HmlValue _tmp703 = hml_both_i32(_tmp704, _tmp706) ? hml_i32_mul(_tmp704, _tmp706) : (hml_both_i64(_tmp704, _tmp706) ? hml_i64_mul(_tmp704, _tmp706) : hml_binary_op(HML_OP_MUL, _tmp704, _tmp706));
    hml_release_if_needed(&_tmp704);
    hml_release_if_needed(&_tmp706);
    HmlValue _tmp701 = hml_both_i32(_tmp702, _tmp703) ? hml_i32_add(_tmp702, _tmp703) : (hml_both_i64(_tmp702, _tmp703) ? hml_i64_add(_tmp702, _tmp703) : hml_binary_op(HML_OP_ADD, _tmp702, _tmp703));
    hml_release_if_needed(&_tmp702);
    hml_release_if_needed(&_tmp703);
    HML_CALL_EXIT();
    return _tmp701;
    return hml_val_null();
}

HmlValue _mod0_fn_Approximately(HmlClosureEnv *_closure_env, HmlValue a, HmlValue b, HmlValue epsilon) {
    (void)_closure_env;
    HmlValue _tmp708 = a;
    hml_retain_if_needed(&_tmp708);
    HmlValue _tmp709 = b;
    hml_retain_if_needed(&_tmp709);
    HmlValue _tmp707 = hml_both_i32(_tmp708, _tmp709) ? hml_i32_sub(_tmp708, _tmp709) : (hml_both_i64(_tmp708, _tmp709) ? hml_i64_sub(_tmp708, _tmp709) : hml_binary_op(HML_OP_SUB, _tmp708, _tmp709));
    hml_release_if_needed(&_tmp708);
    hml_release_if_needed(&_tmp709);
    HmlValue diff = _tmp707;
    HmlValue _tmp711 = diff;
    hml_retain_if_needed(&_tmp711);
    HmlValue _tmp712 = hml_val_f64(0);
    HmlValue _tmp710 = hml_both_i32(_tmp711, _tmp712) ? hml_i32_lt(_tmp711, _tmp712) : (hml_both_i64(_tmp711, _tmp712) ? hml_i64_lt(_tmp711, _tmp712) : hml_binary_op(HML_OP_LESS, _tmp711, _tmp712));
    hml_release_if_needed(&_tmp711);
    hml_release_if_needed(&_tmp712);
    if (hml_to_bool(_tmp710)) {
        {
            HmlValue _tmp715 = diff;
            hml_retain_if_needed(&_tmp715);
            HmlValue _tmp714 = hml_unary_op(HML_UNARY_NEGATE, _tmp715);
            hml_release_if_needed(&_tmp715);
            hml_release(&diff);
            diff = _tmp714;
            hml_retain(&diff);
            HmlValue _tmp713 = diff;
            hml_retain(&_tmp713);
            hml_release(&_tmp713);
        }
    }
    hml_release(&_tmp710);
    HmlValue _tmp717 = diff;
    hml_retain_if_needed(&_tmp717);
    HmlValue _tmp718 = epsilon;
    hml_retain_if_needed(&_tmp718);
    HmlValue _tmp716 = hml_both_i32(_tmp717, _tmp718) ? hml_i32_le(_tmp717, _tmp718) : (hml_both_i64(_tmp717, _tmp718) ? hml_i64_le(_tmp717, _tmp718) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp717, _tmp718));
    hml_release_if_needed(&_tmp717);
    hml_release_if_needed(&_tmp718);
    if (hml_to_bool(_tmp716)) {
        {
            HmlValue _tmp719 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp719;
        }
    }
    hml_release(&_tmp716);
    HmlValue _tmp720 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp720;
    return hml_val_null();
}

HmlValue _mod0_fn_InRange(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max) {
    (void)_closure_env;
    HmlValue _tmp723 = value;
    hml_retain_if_needed(&_tmp723);
    HmlValue _tmp724 = min;
    hml_retain_if_needed(&_tmp724);
    HmlValue _tmp722 = hml_both_i32(_tmp723, _tmp724) ? hml_i32_ge(_tmp723, _tmp724) : (hml_both_i64(_tmp723, _tmp724) ? hml_i64_ge(_tmp723, _tmp724) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp723, _tmp724));
    hml_release_if_needed(&_tmp723);
    hml_release_if_needed(&_tmp724);
    HmlValue _tmp721;
    if (!hml_to_bool(_tmp722)) {
        _tmp721 = hml_val_bool(0);
    } else {
        HmlValue _tmp726 = value;
        hml_retain_if_needed(&_tmp726);
        HmlValue _tmp727 = max;
        hml_retain_if_needed(&_tmp727);
        HmlValue _tmp725 = hml_both_i32(_tmp726, _tmp727) ? hml_i32_le(_tmp726, _tmp727) : (hml_both_i64(_tmp726, _tmp727) ? hml_i64_le(_tmp726, _tmp727) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp726, _tmp727));
        hml_release_if_needed(&_tmp726);
        hml_release_if_needed(&_tmp727);
        _tmp721 = hml_val_bool(hml_to_bool(_tmp725));
        hml_release_if_needed(&_tmp725);
    }
    hml_release_if_needed(&_tmp722);
    if (hml_to_bool(_tmp721)) {
        {
            HmlValue _tmp728 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp728;
        }
    }
    hml_release(&_tmp721);
    HmlValue _tmp729 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp729;
    return hml_val_null();
}

HmlValue _mod0_fn_InRangeInt(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max) {
    (void)_closure_env;
    HmlValue _tmp732 = value;
    hml_retain_if_needed(&_tmp732);
    HmlValue _tmp733 = min;
    hml_retain_if_needed(&_tmp733);
    HmlValue _tmp731 = hml_both_i32(_tmp732, _tmp733) ? hml_i32_ge(_tmp732, _tmp733) : (hml_both_i64(_tmp732, _tmp733) ? hml_i64_ge(_tmp732, _tmp733) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp732, _tmp733));
    hml_release_if_needed(&_tmp732);
    hml_release_if_needed(&_tmp733);
    HmlValue _tmp730;
    if (!hml_to_bool(_tmp731)) {
        _tmp730 = hml_val_bool(0);
    } else {
        HmlValue _tmp735 = value;
        hml_retain_if_needed(&_tmp735);
        HmlValue _tmp736 = max;
        hml_retain_if_needed(&_tmp736);
        HmlValue _tmp734 = hml_both_i32(_tmp735, _tmp736) ? hml_i32_le(_tmp735, _tmp736) : (hml_both_i64(_tmp735, _tmp736) ? hml_i64_le(_tmp735, _tmp736) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp735, _tmp736));
        hml_release_if_needed(&_tmp735);
        hml_release_if_needed(&_tmp736);
        _tmp730 = hml_val_bool(hml_to_bool(_tmp734));
        hml_release_if_needed(&_tmp734);
    }
    hml_release_if_needed(&_tmp731);
    if (hml_to_bool(_tmp730)) {
        {
            HmlValue _tmp737 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp737;
        }
    }
    hml_release(&_tmp730);
    HmlValue _tmp738 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp738;
    return hml_val_null();
}

HmlValue _mod0_fn_WrapInt(HmlClosureEnv *_closure_env, HmlValue value, HmlValue min, HmlValue max) {
    (void)_closure_env;
    HmlValue _tmp740 = max;
    hml_retain_if_needed(&_tmp740);
    HmlValue _tmp741 = min;
    hml_retain_if_needed(&_tmp741);
    HmlValue _tmp739 = hml_both_i32(_tmp740, _tmp741) ? hml_i32_sub(_tmp740, _tmp741) : (hml_both_i64(_tmp740, _tmp741) ? hml_i64_sub(_tmp740, _tmp741) : hml_binary_op(HML_OP_SUB, _tmp740, _tmp741));
    hml_release_if_needed(&_tmp740);
    hml_release_if_needed(&_tmp741);
    HmlValue range = _tmp739;
    HmlValue _tmp743 = value;
    hml_retain_if_needed(&_tmp743);
    HmlValue _tmp744 = min;
    hml_retain_if_needed(&_tmp744);
    HmlValue _tmp742 = hml_both_i32(_tmp743, _tmp744) ? hml_i32_sub(_tmp743, _tmp744) : (hml_both_i64(_tmp743, _tmp744) ? hml_i64_sub(_tmp743, _tmp744) : hml_binary_op(HML_OP_SUB, _tmp743, _tmp744));
    hml_release_if_needed(&_tmp743);
    hml_release_if_needed(&_tmp744);
    HmlValue result = _tmp742;
    while (1) {
        HmlValue _tmp746 = result;
        hml_retain_if_needed(&_tmp746);
        HmlValue _tmp747 = hml_val_i32(0);
        HmlValue _tmp745 = hml_both_i32(_tmp746, _tmp747) ? hml_i32_lt(_tmp746, _tmp747) : (hml_both_i64(_tmp746, _tmp747) ? hml_i64_lt(_tmp746, _tmp747) : hml_binary_op(HML_OP_LESS, _tmp746, _tmp747));
        hml_release_if_needed(&_tmp746);
        hml_release_if_needed(&_tmp747);
        if (!hml_to_bool(_tmp745)) { hml_release(&_tmp745); break; }
        hml_release(&_tmp745);
        {
            HmlValue _tmp750 = result;
            hml_retain_if_needed(&_tmp750);
            HmlValue _tmp751 = range;
            hml_retain_if_needed(&_tmp751);
            HmlValue _tmp749 = hml_both_i32(_tmp750, _tmp751) ? hml_i32_add(_tmp750, _tmp751) : (hml_both_i64(_tmp750, _tmp751) ? hml_i64_add(_tmp750, _tmp751) : hml_binary_op(HML_OP_ADD, _tmp750, _tmp751));
            hml_release_if_needed(&_tmp750);
            hml_release_if_needed(&_tmp751);
            hml_release(&result);
            result = _tmp749;
            hml_retain(&result);
            HmlValue _tmp748 = result;
            hml_retain(&_tmp748);
            hml_release(&_tmp748);
        }
    }
    while (1) {
        HmlValue _tmp753 = result;
        hml_retain_if_needed(&_tmp753);
        HmlValue _tmp754 = range;
        hml_retain_if_needed(&_tmp754);
        HmlValue _tmp752 = hml_both_i32(_tmp753, _tmp754) ? hml_i32_ge(_tmp753, _tmp754) : (hml_both_i64(_tmp753, _tmp754) ? hml_i64_ge(_tmp753, _tmp754) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp753, _tmp754));
        hml_release_if_needed(&_tmp753);
        hml_release_if_needed(&_tmp754);
        if (!hml_to_bool(_tmp752)) { hml_release(&_tmp752); break; }
        hml_release(&_tmp752);
        {
            HmlValue _tmp757 = result;
            hml_retain_if_needed(&_tmp757);
            HmlValue _tmp758 = range;
            hml_retain_if_needed(&_tmp758);
            HmlValue _tmp756 = hml_both_i32(_tmp757, _tmp758) ? hml_i32_sub(_tmp757, _tmp758) : (hml_both_i64(_tmp757, _tmp758) ? hml_i64_sub(_tmp757, _tmp758) : hml_binary_op(HML_OP_SUB, _tmp757, _tmp758));
            hml_release_if_needed(&_tmp757);
            hml_release_if_needed(&_tmp758);
            hml_release(&result);
            result = _tmp756;
            hml_retain(&result);
            HmlValue _tmp755 = result;
            hml_retain(&_tmp755);
            hml_release(&_tmp755);
        }
    }
    HmlValue _tmp760 = result;
    hml_retain_if_needed(&_tmp760);
    HmlValue _tmp761 = min;
    hml_retain_if_needed(&_tmp761);
    HmlValue _tmp759 = hml_both_i32(_tmp760, _tmp761) ? hml_i32_add(_tmp760, _tmp761) : (hml_both_i64(_tmp760, _tmp761) ? hml_i64_add(_tmp760, _tmp761) : hml_binary_op(HML_OP_ADD, _tmp760, _tmp761));
    hml_release_if_needed(&_tmp760);
    hml_release_if_needed(&_tmp761);
    HML_CALL_EXIT();
    return _tmp759;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2LengthSq(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y) {
    (void)_closure_env;
    HmlValue _tmp764 = x;
    hml_retain_if_needed(&_tmp764);
    HmlValue _tmp765 = x;
    hml_retain_if_needed(&_tmp765);
    HmlValue _tmp763 = hml_both_i32(_tmp764, _tmp765) ? hml_i32_mul(_tmp764, _tmp765) : (hml_both_i64(_tmp764, _tmp765) ? hml_i64_mul(_tmp764, _tmp765) : hml_binary_op(HML_OP_MUL, _tmp764, _tmp765));
    hml_release_if_needed(&_tmp764);
    hml_release_if_needed(&_tmp765);
    HmlValue _tmp767 = y;
    hml_retain_if_needed(&_tmp767);
    HmlValue _tmp768 = y;
    hml_retain_if_needed(&_tmp768);
    HmlValue _tmp766 = hml_both_i32(_tmp767, _tmp768) ? hml_i32_mul(_tmp767, _tmp768) : (hml_both_i64(_tmp767, _tmp768) ? hml_i64_mul(_tmp767, _tmp768) : hml_binary_op(HML_OP_MUL, _tmp767, _tmp768));
    hml_release_if_needed(&_tmp767);
    hml_release_if_needed(&_tmp768);
    HmlValue _tmp762 = hml_both_i32(_tmp763, _tmp766) ? hml_i32_add(_tmp763, _tmp766) : (hml_both_i64(_tmp763, _tmp766) ? hml_i64_add(_tmp763, _tmp766) : hml_binary_op(HML_OP_ADD, _tmp763, _tmp766));
    hml_release_if_needed(&_tmp763);
    hml_release_if_needed(&_tmp766);
    HML_CALL_EXIT();
    return _tmp762;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2NormalizeGetLength(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y) {
    (void)_closure_env;
    HmlValue _tmp770 = x;
    hml_retain_if_needed(&_tmp770);
    HmlValue _tmp771 = y;
    hml_retain_if_needed(&_tmp771);
    HmlValue _tmp769 = _mod0_fn_Vector2Length(NULL, _tmp770, _tmp771);
    hml_release(&_tmp770);
    hml_release(&_tmp771);
    HmlValue length = _tmp769;
    HmlValue _tmp773 = length;
    hml_retain_if_needed(&_tmp773);
    HmlValue _tmp774 = hml_val_f64(0);
    HmlValue _tmp772 = hml_both_i32(_tmp773, _tmp774) ? hml_i32_eq(_tmp773, _tmp774) : (hml_both_i64(_tmp773, _tmp774) ? hml_i64_eq(_tmp773, _tmp774) : hml_binary_op(HML_OP_EQUAL, _tmp773, _tmp774));
    hml_release_if_needed(&_tmp773);
    hml_release_if_needed(&_tmp774);
    if (hml_to_bool(_tmp772)) {
        {
            HmlValue _tmp775 = hml_val_f64(0);
            HML_CALL_EXIT();
            return _tmp775;
        }
    }
    hml_release(&_tmp772);
    HmlValue _tmp776 = length;
    hml_retain_if_needed(&_tmp776);
    HML_CALL_EXIT();
    return _tmp776;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2ScaleX(HmlClosureEnv *_closure_env, HmlValue x, HmlValue scale) {
    (void)_closure_env;
    HmlValue _tmp778 = x;
    hml_retain_if_needed(&_tmp778);
    HmlValue _tmp779 = scale;
    hml_retain_if_needed(&_tmp779);
    HmlValue _tmp777 = hml_both_i32(_tmp778, _tmp779) ? hml_i32_mul(_tmp778, _tmp779) : (hml_both_i64(_tmp778, _tmp779) ? hml_i64_mul(_tmp778, _tmp779) : hml_binary_op(HML_OP_MUL, _tmp778, _tmp779));
    hml_release_if_needed(&_tmp778);
    hml_release_if_needed(&_tmp779);
    HML_CALL_EXIT();
    return _tmp777;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2ScaleY(HmlClosureEnv *_closure_env, HmlValue y, HmlValue scale) {
    (void)_closure_env;
    HmlValue _tmp781 = y;
    hml_retain_if_needed(&_tmp781);
    HmlValue _tmp782 = scale;
    hml_retain_if_needed(&_tmp782);
    HmlValue _tmp780 = hml_both_i32(_tmp781, _tmp782) ? hml_i32_mul(_tmp781, _tmp782) : (hml_both_i64(_tmp781, _tmp782) ? hml_i64_mul(_tmp781, _tmp782) : hml_binary_op(HML_OP_MUL, _tmp781, _tmp782));
    hml_release_if_needed(&_tmp781);
    hml_release_if_needed(&_tmp782);
    HML_CALL_EXIT();
    return _tmp780;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2AddX(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue x2) {
    (void)_closure_env;
    HmlValue _tmp784 = x1;
    hml_retain_if_needed(&_tmp784);
    HmlValue _tmp785 = x2;
    hml_retain_if_needed(&_tmp785);
    HmlValue _tmp783 = hml_both_i32(_tmp784, _tmp785) ? hml_i32_add(_tmp784, _tmp785) : (hml_both_i64(_tmp784, _tmp785) ? hml_i64_add(_tmp784, _tmp785) : hml_binary_op(HML_OP_ADD, _tmp784, _tmp785));
    hml_release_if_needed(&_tmp784);
    hml_release_if_needed(&_tmp785);
    HML_CALL_EXIT();
    return _tmp783;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2AddY(HmlClosureEnv *_closure_env, HmlValue y1, HmlValue y2) {
    (void)_closure_env;
    HmlValue _tmp787 = y1;
    hml_retain_if_needed(&_tmp787);
    HmlValue _tmp788 = y2;
    hml_retain_if_needed(&_tmp788);
    HmlValue _tmp786 = hml_both_i32(_tmp787, _tmp788) ? hml_i32_add(_tmp787, _tmp788) : (hml_both_i64(_tmp787, _tmp788) ? hml_i64_add(_tmp787, _tmp788) : hml_binary_op(HML_OP_ADD, _tmp787, _tmp788));
    hml_release_if_needed(&_tmp787);
    hml_release_if_needed(&_tmp788);
    HML_CALL_EXIT();
    return _tmp786;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2SubtractX(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue x2) {
    (void)_closure_env;
    HmlValue _tmp790 = x1;
    hml_retain_if_needed(&_tmp790);
    HmlValue _tmp791 = x2;
    hml_retain_if_needed(&_tmp791);
    HmlValue _tmp789 = hml_both_i32(_tmp790, _tmp791) ? hml_i32_sub(_tmp790, _tmp791) : (hml_both_i64(_tmp790, _tmp791) ? hml_i64_sub(_tmp790, _tmp791) : hml_binary_op(HML_OP_SUB, _tmp790, _tmp791));
    hml_release_if_needed(&_tmp790);
    hml_release_if_needed(&_tmp791);
    HML_CALL_EXIT();
    return _tmp789;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2SubtractY(HmlClosureEnv *_closure_env, HmlValue y1, HmlValue y2) {
    (void)_closure_env;
    HmlValue _tmp793 = y1;
    hml_retain_if_needed(&_tmp793);
    HmlValue _tmp794 = y2;
    hml_retain_if_needed(&_tmp794);
    HmlValue _tmp792 = hml_both_i32(_tmp793, _tmp794) ? hml_i32_sub(_tmp793, _tmp794) : (hml_both_i64(_tmp793, _tmp794) ? hml_i64_sub(_tmp793, _tmp794) : hml_binary_op(HML_OP_SUB, _tmp793, _tmp794));
    hml_release_if_needed(&_tmp793);
    hml_release_if_needed(&_tmp794);
    HML_CALL_EXIT();
    return _tmp792;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2NegateX(HmlClosureEnv *_closure_env, HmlValue x) {
    (void)_closure_env;
    HmlValue _tmp796 = x;
    hml_retain_if_needed(&_tmp796);
    HmlValue _tmp795 = hml_unary_op(HML_UNARY_NEGATE, _tmp796);
    hml_release_if_needed(&_tmp796);
    HML_CALL_EXIT();
    return _tmp795;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2NegateY(HmlClosureEnv *_closure_env, HmlValue y) {
    (void)_closure_env;
    HmlValue _tmp798 = y;
    hml_retain_if_needed(&_tmp798);
    HmlValue _tmp797 = hml_unary_op(HML_UNARY_NEGATE, _tmp798);
    hml_release_if_needed(&_tmp798);
    HML_CALL_EXIT();
    return _tmp797;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2RotateX(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y, HmlValue angle) {
    (void)_closure_env;
    HmlValue _tmp800 = angle;
    hml_retain_if_needed(&_tmp800);
    HmlValue _tmp799 = _mod0_fn_Deg2Rad(NULL, _tmp800);
    hml_release(&_tmp800);
    HmlValue rad = _tmp799;
    HmlValue _tmp802 = rad;
    hml_retain_if_needed(&_tmp802);
    HmlValue _tmp801 = hml_cos(_tmp802);
    hml_release(&_tmp802);
    HmlValue cosA = _tmp801;
    HmlValue _tmp804 = rad;
    hml_retain_if_needed(&_tmp804);
    HmlValue _tmp803 = hml_sin(_tmp804);
    hml_release(&_tmp804);
    HmlValue sinA = _tmp803;
    HmlValue _tmp807 = x;
    hml_retain_if_needed(&_tmp807);
    HmlValue _tmp808 = cosA;
    hml_retain_if_needed(&_tmp808);
    HmlValue _tmp806 = hml_both_i32(_tmp807, _tmp808) ? hml_i32_mul(_tmp807, _tmp808) : (hml_both_i64(_tmp807, _tmp808) ? hml_i64_mul(_tmp807, _tmp808) : hml_binary_op(HML_OP_MUL, _tmp807, _tmp808));
    hml_release_if_needed(&_tmp807);
    hml_release_if_needed(&_tmp808);
    HmlValue _tmp810 = y;
    hml_retain_if_needed(&_tmp810);
    HmlValue _tmp811 = sinA;
    hml_retain_if_needed(&_tmp811);
    HmlValue _tmp809 = hml_both_i32(_tmp810, _tmp811) ? hml_i32_mul(_tmp810, _tmp811) : (hml_both_i64(_tmp810, _tmp811) ? hml_i64_mul(_tmp810, _tmp811) : hml_binary_op(HML_OP_MUL, _tmp810, _tmp811));
    hml_release_if_needed(&_tmp810);
    hml_release_if_needed(&_tmp811);
    HmlValue _tmp805 = hml_both_i32(_tmp806, _tmp809) ? hml_i32_sub(_tmp806, _tmp809) : (hml_both_i64(_tmp806, _tmp809) ? hml_i64_sub(_tmp806, _tmp809) : hml_binary_op(HML_OP_SUB, _tmp806, _tmp809));
    hml_release_if_needed(&_tmp806);
    hml_release_if_needed(&_tmp809);
    HML_CALL_EXIT();
    return _tmp805;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2RotateY(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y, HmlValue angle) {
    (void)_closure_env;
    HmlValue _tmp813 = angle;
    hml_retain_if_needed(&_tmp813);
    HmlValue _tmp812 = _mod0_fn_Deg2Rad(NULL, _tmp813);
    hml_release(&_tmp813);
    HmlValue rad = _tmp812;
    HmlValue _tmp815 = rad;
    hml_retain_if_needed(&_tmp815);
    HmlValue _tmp814 = hml_cos(_tmp815);
    hml_release(&_tmp815);
    HmlValue cosA = _tmp814;
    HmlValue _tmp817 = rad;
    hml_retain_if_needed(&_tmp817);
    HmlValue _tmp816 = hml_sin(_tmp817);
    hml_release(&_tmp817);
    HmlValue sinA = _tmp816;
    HmlValue _tmp820 = x;
    hml_retain_if_needed(&_tmp820);
    HmlValue _tmp821 = sinA;
    hml_retain_if_needed(&_tmp821);
    HmlValue _tmp819 = hml_both_i32(_tmp820, _tmp821) ? hml_i32_mul(_tmp820, _tmp821) : (hml_both_i64(_tmp820, _tmp821) ? hml_i64_mul(_tmp820, _tmp821) : hml_binary_op(HML_OP_MUL, _tmp820, _tmp821));
    hml_release_if_needed(&_tmp820);
    hml_release_if_needed(&_tmp821);
    HmlValue _tmp823 = y;
    hml_retain_if_needed(&_tmp823);
    HmlValue _tmp824 = cosA;
    hml_retain_if_needed(&_tmp824);
    HmlValue _tmp822 = hml_both_i32(_tmp823, _tmp824) ? hml_i32_mul(_tmp823, _tmp824) : (hml_both_i64(_tmp823, _tmp824) ? hml_i64_mul(_tmp823, _tmp824) : hml_binary_op(HML_OP_MUL, _tmp823, _tmp824));
    hml_release_if_needed(&_tmp823);
    hml_release_if_needed(&_tmp824);
    HmlValue _tmp818 = hml_both_i32(_tmp819, _tmp822) ? hml_i32_add(_tmp819, _tmp822) : (hml_both_i64(_tmp819, _tmp822) ? hml_i64_add(_tmp819, _tmp822) : hml_binary_op(HML_OP_ADD, _tmp819, _tmp822));
    hml_release_if_needed(&_tmp819);
    hml_release_if_needed(&_tmp822);
    HML_CALL_EXIT();
    return _tmp818;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2LerpX(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue x2, HmlValue amount) {
    (void)_closure_env;
    HmlValue _tmp826 = x1;
    hml_retain_if_needed(&_tmp826);
    HmlValue _tmp827 = x2;
    hml_retain_if_needed(&_tmp827);
    HmlValue _tmp828 = amount;
    hml_retain_if_needed(&_tmp828);
    HmlValue _tmp825 = _mod0_fn_Lerp(NULL, _tmp826, _tmp827, _tmp828);
    hml_release(&_tmp826);
    hml_release(&_tmp827);
    hml_release(&_tmp828);
    HML_CALL_EXIT();
    return _tmp825;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2LerpY(HmlClosureEnv *_closure_env, HmlValue y1, HmlValue y2, HmlValue amount) {
    (void)_closure_env;
    HmlValue _tmp830 = y1;
    hml_retain_if_needed(&_tmp830);
    HmlValue _tmp831 = y2;
    hml_retain_if_needed(&_tmp831);
    HmlValue _tmp832 = amount;
    hml_retain_if_needed(&_tmp832);
    HmlValue _tmp829 = _mod0_fn_Lerp(NULL, _tmp830, _tmp831, _tmp832);
    hml_release(&_tmp830);
    hml_release(&_tmp831);
    hml_release(&_tmp832);
    HML_CALL_EXIT();
    return _tmp829;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2ReflectX(HmlClosureEnv *_closure_env, HmlValue vx, HmlValue vy, HmlValue nx, HmlValue ny) {
    (void)_closure_env;
    HmlValue _tmp834 = vx;
    hml_retain_if_needed(&_tmp834);
    HmlValue _tmp835 = vy;
    hml_retain_if_needed(&_tmp835);
    HmlValue _tmp836 = nx;
    hml_retain_if_needed(&_tmp836);
    HmlValue _tmp837 = ny;
    hml_retain_if_needed(&_tmp837);
    HmlValue _tmp833 = _mod0_fn_Vector2Dot(NULL, _tmp834, _tmp835, _tmp836, _tmp837);
    hml_release(&_tmp834);
    hml_release(&_tmp835);
    hml_release(&_tmp836);
    hml_release(&_tmp837);
    HmlValue dot = _tmp833;
    HmlValue _tmp839 = vx;
    hml_retain_if_needed(&_tmp839);
    HmlValue _tmp842 = hml_val_f64(2);
    HmlValue _tmp843 = dot;
    hml_retain_if_needed(&_tmp843);
    HmlValue _tmp841 = hml_both_i32(_tmp842, _tmp843) ? hml_i32_mul(_tmp842, _tmp843) : (hml_both_i64(_tmp842, _tmp843) ? hml_i64_mul(_tmp842, _tmp843) : hml_binary_op(HML_OP_MUL, _tmp842, _tmp843));
    hml_release_if_needed(&_tmp842);
    hml_release_if_needed(&_tmp843);
    HmlValue _tmp844 = nx;
    hml_retain_if_needed(&_tmp844);
    HmlValue _tmp840 = hml_both_i32(_tmp841, _tmp844) ? hml_i32_mul(_tmp841, _tmp844) : (hml_both_i64(_tmp841, _tmp844) ? hml_i64_mul(_tmp841, _tmp844) : hml_binary_op(HML_OP_MUL, _tmp841, _tmp844));
    hml_release_if_needed(&_tmp841);
    hml_release_if_needed(&_tmp844);
    HmlValue _tmp838 = hml_both_i32(_tmp839, _tmp840) ? hml_i32_sub(_tmp839, _tmp840) : (hml_both_i64(_tmp839, _tmp840) ? hml_i64_sub(_tmp839, _tmp840) : hml_binary_op(HML_OP_SUB, _tmp839, _tmp840));
    hml_release_if_needed(&_tmp839);
    hml_release_if_needed(&_tmp840);
    HML_CALL_EXIT();
    return _tmp838;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2ReflectY(HmlClosureEnv *_closure_env, HmlValue vx, HmlValue vy, HmlValue nx, HmlValue ny) {
    (void)_closure_env;
    HmlValue _tmp846 = vx;
    hml_retain_if_needed(&_tmp846);
    HmlValue _tmp847 = vy;
    hml_retain_if_needed(&_tmp847);
    HmlValue _tmp848 = nx;
    hml_retain_if_needed(&_tmp848);
    HmlValue _tmp849 = ny;
    hml_retain_if_needed(&_tmp849);
    HmlValue _tmp845 = _mod0_fn_Vector2Dot(NULL, _tmp846, _tmp847, _tmp848, _tmp849);
    hml_release(&_tmp846);
    hml_release(&_tmp847);
    hml_release(&_tmp848);
    hml_release(&_tmp849);
    HmlValue dot = _tmp845;
    HmlValue _tmp851 = vy;
    hml_retain_if_needed(&_tmp851);
    HmlValue _tmp854 = hml_val_f64(2);
    HmlValue _tmp855 = dot;
    hml_retain_if_needed(&_tmp855);
    HmlValue _tmp853 = hml_both_i32(_tmp854, _tmp855) ? hml_i32_mul(_tmp854, _tmp855) : (hml_both_i64(_tmp854, _tmp855) ? hml_i64_mul(_tmp854, _tmp855) : hml_binary_op(HML_OP_MUL, _tmp854, _tmp855));
    hml_release_if_needed(&_tmp854);
    hml_release_if_needed(&_tmp855);
    HmlValue _tmp856 = ny;
    hml_retain_if_needed(&_tmp856);
    HmlValue _tmp852 = hml_both_i32(_tmp853, _tmp856) ? hml_i32_mul(_tmp853, _tmp856) : (hml_both_i64(_tmp853, _tmp856) ? hml_i64_mul(_tmp853, _tmp856) : hml_binary_op(HML_OP_MUL, _tmp853, _tmp856));
    hml_release_if_needed(&_tmp853);
    hml_release_if_needed(&_tmp856);
    HmlValue _tmp850 = hml_both_i32(_tmp851, _tmp852) ? hml_i32_sub(_tmp851, _tmp852) : (hml_both_i64(_tmp851, _tmp852) ? hml_i64_sub(_tmp851, _tmp852) : hml_binary_op(HML_OP_SUB, _tmp851, _tmp852));
    hml_release_if_needed(&_tmp851);
    hml_release_if_needed(&_tmp852);
    HML_CALL_EXIT();
    return _tmp850;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2Angle(HmlClosureEnv *_closure_env, HmlValue x1, HmlValue y1, HmlValue x2, HmlValue y2) {
    (void)_closure_env;
    HmlValue _tmp858 = x1;
    hml_retain_if_needed(&_tmp858);
    HmlValue _tmp859 = y1;
    hml_retain_if_needed(&_tmp859);
    HmlValue _tmp860 = x2;
    hml_retain_if_needed(&_tmp860);
    HmlValue _tmp861 = y2;
    hml_retain_if_needed(&_tmp861);
    HmlValue _tmp857 = _mod0_fn_Vector2Dot(NULL, _tmp858, _tmp859, _tmp860, _tmp861);
    hml_release(&_tmp858);
    hml_release(&_tmp859);
    hml_release(&_tmp860);
    hml_release(&_tmp861);
    HmlValue dot = _tmp857;
    HmlValue _tmp863 = x1;
    hml_retain_if_needed(&_tmp863);
    HmlValue _tmp864 = y1;
    hml_retain_if_needed(&_tmp864);
    HmlValue _tmp862 = _mod0_fn_Vector2Length(NULL, _tmp863, _tmp864);
    hml_release(&_tmp863);
    hml_release(&_tmp864);
    HmlValue len1 = _tmp862;
    HmlValue _tmp866 = x2;
    hml_retain_if_needed(&_tmp866);
    HmlValue _tmp867 = y2;
    hml_retain_if_needed(&_tmp867);
    HmlValue _tmp865 = _mod0_fn_Vector2Length(NULL, _tmp866, _tmp867);
    hml_release(&_tmp866);
    hml_release(&_tmp867);
    HmlValue len2 = _tmp865;
    HmlValue _tmp870 = len1;
    hml_retain_if_needed(&_tmp870);
    HmlValue _tmp871 = hml_val_f64(0);
    HmlValue _tmp869 = hml_both_i32(_tmp870, _tmp871) ? hml_i32_eq(_tmp870, _tmp871) : (hml_both_i64(_tmp870, _tmp871) ? hml_i64_eq(_tmp870, _tmp871) : hml_binary_op(HML_OP_EQUAL, _tmp870, _tmp871));
    hml_release_if_needed(&_tmp870);
    hml_release_if_needed(&_tmp871);
    HmlValue _tmp868;
    if (hml_to_bool(_tmp869)) {
        _tmp868 = hml_val_bool(1);
    } else {
        HmlValue _tmp873 = len2;
        hml_retain_if_needed(&_tmp873);
        HmlValue _tmp874 = hml_val_f64(0);
        HmlValue _tmp872 = hml_both_i32(_tmp873, _tmp874) ? hml_i32_eq(_tmp873, _tmp874) : (hml_both_i64(_tmp873, _tmp874) ? hml_i64_eq(_tmp873, _tmp874) : hml_binary_op(HML_OP_EQUAL, _tmp873, _tmp874));
        hml_release_if_needed(&_tmp873);
        hml_release_if_needed(&_tmp874);
        _tmp868 = hml_val_bool(hml_to_bool(_tmp872));
        hml_release_if_needed(&_tmp872);
    }
    hml_release_if_needed(&_tmp869);
    if (hml_to_bool(_tmp868)) {
        {
            HmlValue _tmp875 = hml_val_f64(0);
            HML_CALL_EXIT();
            return _tmp875;
        }
    }
    hml_release(&_tmp868);
    HmlValue _tmp877 = dot;
    hml_retain_if_needed(&_tmp877);
    HmlValue _tmp879 = len1;
    hml_retain_if_needed(&_tmp879);
    HmlValue _tmp880 = len2;
    hml_retain_if_needed(&_tmp880);
    HmlValue _tmp878 = hml_both_i32(_tmp879, _tmp880) ? hml_i32_mul(_tmp879, _tmp880) : (hml_both_i64(_tmp879, _tmp880) ? hml_i64_mul(_tmp879, _tmp880) : hml_binary_op(HML_OP_MUL, _tmp879, _tmp880));
    hml_release_if_needed(&_tmp879);
    hml_release_if_needed(&_tmp880);
    HmlValue _tmp876 = hml_binary_op(HML_OP_DIV, _tmp877, _tmp878);
    hml_release_if_needed(&_tmp877);
    hml_release_if_needed(&_tmp878);
    HmlValue cosAngle = _tmp876;
    HmlValue _tmp882 = cosAngle;
    hml_retain_if_needed(&_tmp882);
    HmlValue _tmp883 = hml_val_f64(1);
    HmlValue _tmp881 = hml_both_i32(_tmp882, _tmp883) ? hml_i32_gt(_tmp882, _tmp883) : (hml_both_i64(_tmp882, _tmp883) ? hml_i64_gt(_tmp882, _tmp883) : hml_binary_op(HML_OP_GREATER, _tmp882, _tmp883));
    hml_release_if_needed(&_tmp882);
    hml_release_if_needed(&_tmp883);
    if (hml_to_bool(_tmp881)) {
        {
            HmlValue _tmp885 = hml_val_f64(1);
            hml_release(&cosAngle);
            cosAngle = _tmp885;
            hml_retain(&cosAngle);
            HmlValue _tmp884 = cosAngle;
            hml_retain(&_tmp884);
            hml_release(&_tmp884);
        }
    }
    hml_release(&_tmp881);
    HmlValue _tmp887 = cosAngle;
    hml_retain_if_needed(&_tmp887);
    HmlValue _tmp889 = hml_val_f64(1);
    HmlValue _tmp888 = hml_unary_op(HML_UNARY_NEGATE, _tmp889);
    hml_release_if_needed(&_tmp889);
    HmlValue _tmp886 = hml_both_i32(_tmp887, _tmp888) ? hml_i32_lt(_tmp887, _tmp888) : (hml_both_i64(_tmp887, _tmp888) ? hml_i64_lt(_tmp887, _tmp888) : hml_binary_op(HML_OP_LESS, _tmp887, _tmp888));
    hml_release_if_needed(&_tmp887);
    hml_release_if_needed(&_tmp888);
    if (hml_to_bool(_tmp886)) {
        {
            HmlValue _tmp892 = hml_val_f64(1);
            HmlValue _tmp891 = hml_unary_op(HML_UNARY_NEGATE, _tmp892);
            hml_release_if_needed(&_tmp892);
            hml_release(&cosAngle);
            cosAngle = _tmp891;
            hml_retain(&cosAngle);
            HmlValue _tmp890 = cosAngle;
            hml_retain(&_tmp890);
            hml_release(&_tmp890);
        }
    }
    hml_release(&_tmp886);
    HmlValue _tmp895 = cosAngle;
    hml_retain_if_needed(&_tmp895);
    HmlValue _tmp894 = hml_acos(_tmp895);
    hml_release(&_tmp895);
    HmlValue _tmp893 = _mod0_fn_Rad2Deg(NULL, _tmp894);
    hml_release(&_tmp894);
    HML_CALL_EXIT();
    return _tmp893;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2AngleFromX(HmlClosureEnv *_closure_env, HmlValue x, HmlValue y) {
    (void)_closure_env;
    HmlValue _tmp898 = y;
    hml_retain_if_needed(&_tmp898);
    HmlValue _tmp899 = x;
    hml_retain_if_needed(&_tmp899);
    HmlValue _tmp897 = hml_atan2(_tmp898, _tmp899);
    hml_release(&_tmp898);
    hml_release(&_tmp899);
    HmlValue _tmp896 = _mod0_fn_Rad2Deg(NULL, _tmp897);
    hml_release(&_tmp897);
    HML_CALL_EXIT();
    return _tmp896;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2MoveTowardsX(HmlClosureEnv *_closure_env, HmlValue currentX, HmlValue currentY, HmlValue targetX, HmlValue targetY, HmlValue maxDistance) {
    (void)_closure_env;
    HmlValue _tmp901 = targetX;
    hml_retain_if_needed(&_tmp901);
    HmlValue _tmp902 = currentX;
    hml_retain_if_needed(&_tmp902);
    HmlValue _tmp900 = hml_both_i32(_tmp901, _tmp902) ? hml_i32_sub(_tmp901, _tmp902) : (hml_both_i64(_tmp901, _tmp902) ? hml_i64_sub(_tmp901, _tmp902) : hml_binary_op(HML_OP_SUB, _tmp901, _tmp902));
    hml_release_if_needed(&_tmp901);
    hml_release_if_needed(&_tmp902);
    HmlValue dx = _tmp900;
    HmlValue _tmp904 = targetY;
    hml_retain_if_needed(&_tmp904);
    HmlValue _tmp905 = currentY;
    hml_retain_if_needed(&_tmp905);
    HmlValue _tmp903 = hml_both_i32(_tmp904, _tmp905) ? hml_i32_sub(_tmp904, _tmp905) : (hml_both_i64(_tmp904, _tmp905) ? hml_i64_sub(_tmp904, _tmp905) : hml_binary_op(HML_OP_SUB, _tmp904, _tmp905));
    hml_release_if_needed(&_tmp904);
    hml_release_if_needed(&_tmp905);
    HmlValue dy = _tmp903;
    HmlValue _tmp907 = dx;
    hml_retain_if_needed(&_tmp907);
    HmlValue _tmp908 = dy;
    hml_retain_if_needed(&_tmp908);
    HmlValue _tmp906 = _mod0_fn_Vector2Length(NULL, _tmp907, _tmp908);
    hml_release(&_tmp907);
    hml_release(&_tmp908);
    HmlValue dist = _tmp906;
    HmlValue _tmp911 = dist;
    hml_retain_if_needed(&_tmp911);
    HmlValue _tmp912 = maxDistance;
    hml_retain_if_needed(&_tmp912);
    HmlValue _tmp910 = hml_both_i32(_tmp911, _tmp912) ? hml_i32_le(_tmp911, _tmp912) : (hml_both_i64(_tmp911, _tmp912) ? hml_i64_le(_tmp911, _tmp912) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp911, _tmp912));
    hml_release_if_needed(&_tmp911);
    hml_release_if_needed(&_tmp912);
    HmlValue _tmp909;
    if (hml_to_bool(_tmp910)) {
        _tmp909 = hml_val_bool(1);
    } else {
        HmlValue _tmp914 = dist;
        hml_retain_if_needed(&_tmp914);
        HmlValue _tmp915 = hml_val_f64(0);
        HmlValue _tmp913 = hml_both_i32(_tmp914, _tmp915) ? hml_i32_eq(_tmp914, _tmp915) : (hml_both_i64(_tmp914, _tmp915) ? hml_i64_eq(_tmp914, _tmp915) : hml_binary_op(HML_OP_EQUAL, _tmp914, _tmp915));
        hml_release_if_needed(&_tmp914);
        hml_release_if_needed(&_tmp915);
        _tmp909 = hml_val_bool(hml_to_bool(_tmp913));
        hml_release_if_needed(&_tmp913);
    }
    hml_release_if_needed(&_tmp910);
    if (hml_to_bool(_tmp909)) {
        {
            HmlValue _tmp916 = targetX;
            hml_retain_if_needed(&_tmp916);
            HML_CALL_EXIT();
            return _tmp916;
        }
    }
    hml_release(&_tmp909);
    HmlValue _tmp918 = currentX;
    hml_retain_if_needed(&_tmp918);
    HmlValue _tmp921 = dx;
    hml_retain_if_needed(&_tmp921);
    HmlValue _tmp922 = dist;
    hml_retain_if_needed(&_tmp922);
    HmlValue _tmp920 = hml_binary_op(HML_OP_DIV, _tmp921, _tmp922);
    hml_release_if_needed(&_tmp921);
    hml_release_if_needed(&_tmp922);
    HmlValue _tmp923 = maxDistance;
    hml_retain_if_needed(&_tmp923);
    HmlValue _tmp919 = hml_both_i32(_tmp920, _tmp923) ? hml_i32_mul(_tmp920, _tmp923) : (hml_both_i64(_tmp920, _tmp923) ? hml_i64_mul(_tmp920, _tmp923) : hml_binary_op(HML_OP_MUL, _tmp920, _tmp923));
    hml_release_if_needed(&_tmp920);
    hml_release_if_needed(&_tmp923);
    HmlValue _tmp917 = hml_both_i32(_tmp918, _tmp919) ? hml_i32_add(_tmp918, _tmp919) : (hml_both_i64(_tmp918, _tmp919) ? hml_i64_add(_tmp918, _tmp919) : hml_binary_op(HML_OP_ADD, _tmp918, _tmp919));
    hml_release_if_needed(&_tmp918);
    hml_release_if_needed(&_tmp919);
    HML_CALL_EXIT();
    return _tmp917;
    return hml_val_null();
}

HmlValue _mod0_fn_Vector2MoveTowardsY(HmlClosureEnv *_closure_env, HmlValue currentX, HmlValue currentY, HmlValue targetX, HmlValue targetY, HmlValue maxDistance) {
    (void)_closure_env;
    HmlValue _tmp925 = targetX;
    hml_retain_if_needed(&_tmp925);
    HmlValue _tmp926 = currentX;
    hml_retain_if_needed(&_tmp926);
    HmlValue _tmp924 = hml_both_i32(_tmp925, _tmp926) ? hml_i32_sub(_tmp925, _tmp926) : (hml_both_i64(_tmp925, _tmp926) ? hml_i64_sub(_tmp925, _tmp926) : hml_binary_op(HML_OP_SUB, _tmp925, _tmp926));
    hml_release_if_needed(&_tmp925);
    hml_release_if_needed(&_tmp926);
    HmlValue dx = _tmp924;
    HmlValue _tmp928 = targetY;
    hml_retain_if_needed(&_tmp928);
    HmlValue _tmp929 = currentY;
    hml_retain_if_needed(&_tmp929);
    HmlValue _tmp927 = hml_both_i32(_tmp928, _tmp929) ? hml_i32_sub(_tmp928, _tmp929) : (hml_both_i64(_tmp928, _tmp929) ? hml_i64_sub(_tmp928, _tmp929) : hml_binary_op(HML_OP_SUB, _tmp928, _tmp929));
    hml_release_if_needed(&_tmp928);
    hml_release_if_needed(&_tmp929);
    HmlValue dy = _tmp927;
    HmlValue _tmp931 = dx;
    hml_retain_if_needed(&_tmp931);
    HmlValue _tmp932 = dy;
    hml_retain_if_needed(&_tmp932);
    HmlValue _tmp930 = _mod0_fn_Vector2Length(NULL, _tmp931, _tmp932);
    hml_release(&_tmp931);
    hml_release(&_tmp932);
    HmlValue dist = _tmp930;
    HmlValue _tmp935 = dist;
    hml_retain_if_needed(&_tmp935);
    HmlValue _tmp936 = maxDistance;
    hml_retain_if_needed(&_tmp936);
    HmlValue _tmp934 = hml_both_i32(_tmp935, _tmp936) ? hml_i32_le(_tmp935, _tmp936) : (hml_both_i64(_tmp935, _tmp936) ? hml_i64_le(_tmp935, _tmp936) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp935, _tmp936));
    hml_release_if_needed(&_tmp935);
    hml_release_if_needed(&_tmp936);
    HmlValue _tmp933;
    if (hml_to_bool(_tmp934)) {
        _tmp933 = hml_val_bool(1);
    } else {
        HmlValue _tmp938 = dist;
        hml_retain_if_needed(&_tmp938);
        HmlValue _tmp939 = hml_val_f64(0);
        HmlValue _tmp937 = hml_both_i32(_tmp938, _tmp939) ? hml_i32_eq(_tmp938, _tmp939) : (hml_both_i64(_tmp938, _tmp939) ? hml_i64_eq(_tmp938, _tmp939) : hml_binary_op(HML_OP_EQUAL, _tmp938, _tmp939));
        hml_release_if_needed(&_tmp938);
        hml_release_if_needed(&_tmp939);
        _tmp933 = hml_val_bool(hml_to_bool(_tmp937));
        hml_release_if_needed(&_tmp937);
    }
    hml_release_if_needed(&_tmp934);
    if (hml_to_bool(_tmp933)) {
        {
            HmlValue _tmp940 = targetY;
            hml_retain_if_needed(&_tmp940);
            HML_CALL_EXIT();
            return _tmp940;
        }
    }
    hml_release(&_tmp933);
    HmlValue _tmp942 = currentY;
    hml_retain_if_needed(&_tmp942);
    HmlValue _tmp945 = dy;
    hml_retain_if_needed(&_tmp945);
    HmlValue _tmp946 = dist;
    hml_retain_if_needed(&_tmp946);
    HmlValue _tmp944 = hml_binary_op(HML_OP_DIV, _tmp945, _tmp946);
    hml_release_if_needed(&_tmp945);
    hml_release_if_needed(&_tmp946);
    HmlValue _tmp947 = maxDistance;
    hml_retain_if_needed(&_tmp947);
    HmlValue _tmp943 = hml_both_i32(_tmp944, _tmp947) ? hml_i32_mul(_tmp944, _tmp947) : (hml_both_i64(_tmp944, _tmp947) ? hml_i64_mul(_tmp944, _tmp947) : hml_binary_op(HML_OP_MUL, _tmp944, _tmp947));
    hml_release_if_needed(&_tmp944);
    hml_release_if_needed(&_tmp947);
    HmlValue _tmp941 = hml_both_i32(_tmp942, _tmp943) ? hml_i32_add(_tmp942, _tmp943) : (hml_both_i64(_tmp942, _tmp943) ? hml_i64_add(_tmp942, _tmp943) : hml_binary_op(HML_OP_ADD, _tmp942, _tmp943));
    hml_release_if_needed(&_tmp942);
    hml_release_if_needed(&_tmp943);
    HML_CALL_EXIT();
    return _tmp941;
    return hml_val_null();
}

HmlValue _mod0_fn_CheckCollisionLinesXY(HmlClosureEnv *_closure_env, HmlValue p1x, HmlValue p1y, HmlValue p2x, HmlValue p2y, HmlValue p3x, HmlValue p3y, HmlValue p4x, HmlValue p4y) {
    (void)_closure_env;
    HmlValue _tmp949 = p2x;
    hml_retain_if_needed(&_tmp949);
    HmlValue _tmp950 = p1x;
    hml_retain_if_needed(&_tmp950);
    HmlValue _tmp948 = hml_both_i32(_tmp949, _tmp950) ? hml_i32_sub(_tmp949, _tmp950) : (hml_both_i64(_tmp949, _tmp950) ? hml_i64_sub(_tmp949, _tmp950) : hml_binary_op(HML_OP_SUB, _tmp949, _tmp950));
    hml_release_if_needed(&_tmp949);
    hml_release_if_needed(&_tmp950);
    HmlValue d1x = _tmp948;
    HmlValue _tmp952 = p2y;
    hml_retain_if_needed(&_tmp952);
    HmlValue _tmp953 = p1y;
    hml_retain_if_needed(&_tmp953);
    HmlValue _tmp951 = hml_both_i32(_tmp952, _tmp953) ? hml_i32_sub(_tmp952, _tmp953) : (hml_both_i64(_tmp952, _tmp953) ? hml_i64_sub(_tmp952, _tmp953) : hml_binary_op(HML_OP_SUB, _tmp952, _tmp953));
    hml_release_if_needed(&_tmp952);
    hml_release_if_needed(&_tmp953);
    HmlValue d1y = _tmp951;
    HmlValue _tmp955 = p4x;
    hml_retain_if_needed(&_tmp955);
    HmlValue _tmp956 = p3x;
    hml_retain_if_needed(&_tmp956);
    HmlValue _tmp954 = hml_both_i32(_tmp955, _tmp956) ? hml_i32_sub(_tmp955, _tmp956) : (hml_both_i64(_tmp955, _tmp956) ? hml_i64_sub(_tmp955, _tmp956) : hml_binary_op(HML_OP_SUB, _tmp955, _tmp956));
    hml_release_if_needed(&_tmp955);
    hml_release_if_needed(&_tmp956);
    HmlValue d2x = _tmp954;
    HmlValue _tmp958 = p4y;
    hml_retain_if_needed(&_tmp958);
    HmlValue _tmp959 = p3y;
    hml_retain_if_needed(&_tmp959);
    HmlValue _tmp957 = hml_both_i32(_tmp958, _tmp959) ? hml_i32_sub(_tmp958, _tmp959) : (hml_both_i64(_tmp958, _tmp959) ? hml_i64_sub(_tmp958, _tmp959) : hml_binary_op(HML_OP_SUB, _tmp958, _tmp959));
    hml_release_if_needed(&_tmp958);
    hml_release_if_needed(&_tmp959);
    HmlValue d2y = _tmp957;
    HmlValue _tmp962 = d1x;
    hml_retain_if_needed(&_tmp962);
    HmlValue _tmp963 = hml_val_f64(0);
    HmlValue _tmp961 = hml_both_i32(_tmp962, _tmp963) ? hml_i32_eq(_tmp962, _tmp963) : (hml_both_i64(_tmp962, _tmp963) ? hml_i64_eq(_tmp962, _tmp963) : hml_binary_op(HML_OP_EQUAL, _tmp962, _tmp963));
    hml_release_if_needed(&_tmp962);
    hml_release_if_needed(&_tmp963);
    HmlValue _tmp960;
    if (!hml_to_bool(_tmp961)) {
        _tmp960 = hml_val_bool(0);
    } else {
        HmlValue _tmp965 = d1y;
        hml_retain_if_needed(&_tmp965);
        HmlValue _tmp966 = hml_val_f64(0);
        HmlValue _tmp964 = hml_both_i32(_tmp965, _tmp966) ? hml_i32_eq(_tmp965, _tmp966) : (hml_both_i64(_tmp965, _tmp966) ? hml_i64_eq(_tmp965, _tmp966) : hml_binary_op(HML_OP_EQUAL, _tmp965, _tmp966));
        hml_release_if_needed(&_tmp965);
        hml_release_if_needed(&_tmp966);
        _tmp960 = hml_val_bool(hml_to_bool(_tmp964));
        hml_release_if_needed(&_tmp964);
    }
    hml_release_if_needed(&_tmp961);
    if (hml_to_bool(_tmp960)) {
        {
            HmlValue _tmp967 = hml_val_i32(0);
            HML_CALL_EXIT();
            return _tmp967;
        }
    }
    hml_release(&_tmp960);
    HmlValue _tmp970 = d2x;
    hml_retain_if_needed(&_tmp970);
    HmlValue _tmp971 = hml_val_f64(0);
    HmlValue _tmp969 = hml_both_i32(_tmp970, _tmp971) ? hml_i32_eq(_tmp970, _tmp971) : (hml_both_i64(_tmp970, _tmp971) ? hml_i64_eq(_tmp970, _tmp971) : hml_binary_op(HML_OP_EQUAL, _tmp970, _tmp971));
    hml_release_if_needed(&_tmp970);
    hml_release_if_needed(&_tmp971);
    HmlValue _tmp968;
    if (!hml_to_bool(_tmp969)) {
        _tmp968 = hml_val_bool(0);
    } else {
        HmlValue _tmp973 = d2y;
        hml_retain_if_needed(&_tmp973);
        HmlValue _tmp974 = hml_val_f64(0);
        HmlValue _tmp972 = hml_both_i32(_tmp973, _tmp974) ? hml_i32_eq(_tmp973, _tmp974) : (hml_both_i64(_tmp973, _tmp974) ? hml_i64_eq(_tmp973, _tmp974) : hml_binary_op(HML_OP_EQUAL, _tmp973, _tmp974));
        hml_release_if_needed(&_tmp973);
        hml_release_if_needed(&_tmp974);
        _tmp968 = hml_val_bool(hml_to_bool(_tmp972));
        hml_release_if_needed(&_tmp972);
    }
    hml_release_if_needed(&_tmp969);
    if (hml_to_bool(_tmp968)) {
        {
            HmlValue _tmp975 = hml_val_i32(0);
            HML_CALL_EXIT();
            return _tmp975;
        }
    }
    hml_release(&_tmp968);
    HmlValue _tmp978 = d1x;
    hml_retain_if_needed(&_tmp978);
    HmlValue _tmp979 = d2y;
    hml_retain_if_needed(&_tmp979);
    HmlValue _tmp977 = hml_both_i32(_tmp978, _tmp979) ? hml_i32_mul(_tmp978, _tmp979) : (hml_both_i64(_tmp978, _tmp979) ? hml_i64_mul(_tmp978, _tmp979) : hml_binary_op(HML_OP_MUL, _tmp978, _tmp979));
    hml_release_if_needed(&_tmp978);
    hml_release_if_needed(&_tmp979);
    HmlValue _tmp981 = d1y;
    hml_retain_if_needed(&_tmp981);
    HmlValue _tmp982 = d2x;
    hml_retain_if_needed(&_tmp982);
    HmlValue _tmp980 = hml_both_i32(_tmp981, _tmp982) ? hml_i32_mul(_tmp981, _tmp982) : (hml_both_i64(_tmp981, _tmp982) ? hml_i64_mul(_tmp981, _tmp982) : hml_binary_op(HML_OP_MUL, _tmp981, _tmp982));
    hml_release_if_needed(&_tmp981);
    hml_release_if_needed(&_tmp982);
    HmlValue _tmp976 = hml_both_i32(_tmp977, _tmp980) ? hml_i32_sub(_tmp977, _tmp980) : (hml_both_i64(_tmp977, _tmp980) ? hml_i64_sub(_tmp977, _tmp980) : hml_binary_op(HML_OP_SUB, _tmp977, _tmp980));
    hml_release_if_needed(&_tmp977);
    hml_release_if_needed(&_tmp980);
    HmlValue cross = _tmp976;
    HmlValue _tmp983 = hml_val_f64(0);
    HmlValue crossP3 = hml_convert_to_type(_tmp983, HML_VAL_F32);
    HmlValue _tmp984 = hml_val_f64(0);
    HmlValue min1 = hml_convert_to_type(_tmp984, HML_VAL_F32);
    HmlValue _tmp985 = hml_val_f64(0);
    HmlValue max1 = hml_convert_to_type(_tmp985, HML_VAL_F32);
    HmlValue _tmp986 = hml_val_f64(0);
    HmlValue min2 = hml_convert_to_type(_tmp986, HML_VAL_F32);
    HmlValue _tmp987 = hml_val_f64(0);
    HmlValue max2 = hml_convert_to_type(_tmp987, HML_VAL_F32);
    HmlValue _tmp989 = cross;
    hml_retain_if_needed(&_tmp989);
    HmlValue _tmp990 = hml_val_f64(0);
    HmlValue _tmp988 = hml_both_i32(_tmp989, _tmp990) ? hml_i32_eq(_tmp989, _tmp990) : (hml_both_i64(_tmp989, _tmp990) ? hml_i64_eq(_tmp989, _tmp990) : hml_binary_op(HML_OP_EQUAL, _tmp989, _tmp990));
    hml_release_if_needed(&_tmp989);
    hml_release_if_needed(&_tmp990);
    if (hml_to_bool(_tmp988)) {
        {
            HmlValue _tmp995 = p3x;
            hml_retain_if_needed(&_tmp995);
            HmlValue _tmp996 = p1x;
            hml_retain_if_needed(&_tmp996);
            HmlValue _tmp994 = hml_both_i32(_tmp995, _tmp996) ? hml_i32_sub(_tmp995, _tmp996) : (hml_both_i64(_tmp995, _tmp996) ? hml_i64_sub(_tmp995, _tmp996) : hml_binary_op(HML_OP_SUB, _tmp995, _tmp996));
            hml_release_if_needed(&_tmp995);
            hml_release_if_needed(&_tmp996);
            HmlValue _tmp997 = d1y;
            hml_retain_if_needed(&_tmp997);
            HmlValue _tmp993 = hml_both_i32(_tmp994, _tmp997) ? hml_i32_mul(_tmp994, _tmp997) : (hml_both_i64(_tmp994, _tmp997) ? hml_i64_mul(_tmp994, _tmp997) : hml_binary_op(HML_OP_MUL, _tmp994, _tmp997));
            hml_release_if_needed(&_tmp994);
            hml_release_if_needed(&_tmp997);
            HmlValue _tmp1000 = p3y;
            hml_retain_if_needed(&_tmp1000);
            HmlValue _tmp1001 = p1y;
            hml_retain_if_needed(&_tmp1001);
            HmlValue _tmp999 = hml_both_i32(_tmp1000, _tmp1001) ? hml_i32_sub(_tmp1000, _tmp1001) : (hml_both_i64(_tmp1000, _tmp1001) ? hml_i64_sub(_tmp1000, _tmp1001) : hml_binary_op(HML_OP_SUB, _tmp1000, _tmp1001));
            hml_release_if_needed(&_tmp1000);
            hml_release_if_needed(&_tmp1001);
            HmlValue _tmp1002 = d1x;
            hml_retain_if_needed(&_tmp1002);
            HmlValue _tmp998 = hml_both_i32(_tmp999, _tmp1002) ? hml_i32_mul(_tmp999, _tmp1002) : (hml_both_i64(_tmp999, _tmp1002) ? hml_i64_mul(_tmp999, _tmp1002) : hml_binary_op(HML_OP_MUL, _tmp999, _tmp1002));
            hml_release_if_needed(&_tmp999);
            hml_release_if_needed(&_tmp1002);
            HmlValue _tmp992 = hml_both_i32(_tmp993, _tmp998) ? hml_i32_sub(_tmp993, _tmp998) : (hml_both_i64(_tmp993, _tmp998) ? hml_i64_sub(_tmp993, _tmp998) : hml_binary_op(HML_OP_SUB, _tmp993, _tmp998));
            hml_release_if_needed(&_tmp993);
            hml_release_if_needed(&_tmp998);
            hml_release(&crossP3);
            crossP3 = _tmp992;
            hml_retain(&crossP3);
            HmlValue _tmp991 = crossP3;
            hml_retain(&_tmp991);
            hml_release(&_tmp991);
            HmlValue _tmp1004 = crossP3;
            hml_retain_if_needed(&_tmp1004);
            HmlValue _tmp1005 = hml_val_f64(0);
            HmlValue _tmp1003 = hml_both_i32(_tmp1004, _tmp1005) ? hml_i32_ne(_tmp1004, _tmp1005) : (hml_both_i64(_tmp1004, _tmp1005) ? hml_i64_ne(_tmp1004, _tmp1005) : hml_binary_op(HML_OP_NOT_EQUAL, _tmp1004, _tmp1005));
            hml_release_if_needed(&_tmp1004);
            hml_release_if_needed(&_tmp1005);
            if (hml_to_bool(_tmp1003)) {
                {
                    HmlValue _tmp1006 = hml_val_i32(0);
                    HML_CALL_EXIT();
                    return _tmp1006;
                }
            }
            hml_release(&_tmp1003);
            HmlValue _tmp1009 = d1x;
            hml_retain_if_needed(&_tmp1009);
            HmlValue _tmp1008 = _mod0_fn_Abs(NULL, _tmp1009);
            hml_release(&_tmp1009);
            HmlValue _tmp1011 = d1y;
            hml_retain_if_needed(&_tmp1011);
            HmlValue _tmp1010 = _mod0_fn_Abs(NULL, _tmp1011);
            hml_release(&_tmp1011);
            HmlValue _tmp1007 = hml_both_i32(_tmp1008, _tmp1010) ? hml_i32_ge(_tmp1008, _tmp1010) : (hml_both_i64(_tmp1008, _tmp1010) ? hml_i64_ge(_tmp1008, _tmp1010) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp1008, _tmp1010));
            hml_release_if_needed(&_tmp1008);
            hml_release_if_needed(&_tmp1010);
            if (hml_to_bool(_tmp1007)) {
                {
                    HmlValue _tmp1014 = p1x;
                    hml_retain_if_needed(&_tmp1014);
                    HmlValue _tmp1015 = p2x;
                    hml_retain_if_needed(&_tmp1015);
                    HmlValue _tmp1013 = _mod0_fn_Min(NULL, _tmp1014, _tmp1015);
                    hml_release(&_tmp1014);
                    hml_release(&_tmp1015);
                    hml_release(&min1);
                    min1 = _tmp1013;
                    hml_retain(&min1);
                    HmlValue _tmp1012 = min1;
                    hml_retain(&_tmp1012);
                    hml_release(&_tmp1012);
                    HmlValue _tmp1018 = p1x;
                    hml_retain_if_needed(&_tmp1018);
                    HmlValue _tmp1019 = p2x;
                    hml_retain_if_needed(&_tmp1019);
                    HmlValue _tmp1017 = _mod0_fn_Max(NULL, _tmp1018, _tmp1019);
                    hml_release(&_tmp1018);
                    hml_release(&_tmp1019);
                    hml_release(&max1);
                    max1 = _tmp1017;
                    hml_retain(&max1);
                    HmlValue _tmp1016 = max1;
                    hml_retain(&_tmp1016);
                    hml_release(&_tmp1016);
                    HmlValue _tmp1022 = p3x;
                    hml_retain_if_needed(&_tmp1022);
                    HmlValue _tmp1023 = p4x;
                    hml_retain_if_needed(&_tmp1023);
                    HmlValue _tmp1021 = _mod0_fn_Min(NULL, _tmp1022, _tmp1023);
                    hml_release(&_tmp1022);
                    hml_release(&_tmp1023);
                    hml_release(&min2);
                    min2 = _tmp1021;
                    hml_retain(&min2);
                    HmlValue _tmp1020 = min2;
                    hml_retain(&_tmp1020);
                    hml_release(&_tmp1020);
                    HmlValue _tmp1026 = p3x;
                    hml_retain_if_needed(&_tmp1026);
                    HmlValue _tmp1027 = p4x;
                    hml_retain_if_needed(&_tmp1027);
                    HmlValue _tmp1025 = _mod0_fn_Max(NULL, _tmp1026, _tmp1027);
                    hml_release(&_tmp1026);
                    hml_release(&_tmp1027);
                    hml_release(&max2);
                    max2 = _tmp1025;
                    hml_retain(&max2);
                    HmlValue _tmp1024 = max2;
                    hml_retain(&_tmp1024);
                    hml_release(&_tmp1024);
                }
            } else {
                {
                    HmlValue _tmp1030 = p1y;
                    hml_retain_if_needed(&_tmp1030);
                    HmlValue _tmp1031 = p2y;
                    hml_retain_if_needed(&_tmp1031);
                    HmlValue _tmp1029 = _mod0_fn_Min(NULL, _tmp1030, _tmp1031);
                    hml_release(&_tmp1030);
                    hml_release(&_tmp1031);
                    hml_release(&min1);
                    min1 = _tmp1029;
                    hml_retain(&min1);
                    HmlValue _tmp1028 = min1;
                    hml_retain(&_tmp1028);
                    hml_release(&_tmp1028);
                    HmlValue _tmp1034 = p1y;
                    hml_retain_if_needed(&_tmp1034);
                    HmlValue _tmp1035 = p2y;
                    hml_retain_if_needed(&_tmp1035);
                    HmlValue _tmp1033 = _mod0_fn_Max(NULL, _tmp1034, _tmp1035);
                    hml_release(&_tmp1034);
                    hml_release(&_tmp1035);
                    hml_release(&max1);
                    max1 = _tmp1033;
                    hml_retain(&max1);
                    HmlValue _tmp1032 = max1;
                    hml_retain(&_tmp1032);
                    hml_release(&_tmp1032);
                    HmlValue _tmp1038 = p3y;
                    hml_retain_if_needed(&_tmp1038);
                    HmlValue _tmp1039 = p4y;
                    hml_retain_if_needed(&_tmp1039);
                    HmlValue _tmp1037 = _mod0_fn_Min(NULL, _tmp1038, _tmp1039);
                    hml_release(&_tmp1038);
                    hml_release(&_tmp1039);
                    hml_release(&min2);
                    min2 = _tmp1037;
                    hml_retain(&min2);
                    HmlValue _tmp1036 = min2;
                    hml_retain(&_tmp1036);
                    hml_release(&_tmp1036);
                    HmlValue _tmp1042 = p3y;
                    hml_retain_if_needed(&_tmp1042);
                    HmlValue _tmp1043 = p4y;
                    hml_retain_if_needed(&_tmp1043);
                    HmlValue _tmp1041 = _mod0_fn_Max(NULL, _tmp1042, _tmp1043);
                    hml_release(&_tmp1042);
                    hml_release(&_tmp1043);
                    hml_release(&max2);
                    max2 = _tmp1041;
                    hml_retain(&max2);
                    HmlValue _tmp1040 = max2;
                    hml_retain(&_tmp1040);
                    hml_release(&_tmp1040);
                }
            }
            hml_release(&_tmp1007);
            HmlValue _tmp1046 = max1;
            hml_retain_if_needed(&_tmp1046);
            HmlValue _tmp1047 = min2;
            hml_retain_if_needed(&_tmp1047);
            HmlValue _tmp1045 = hml_both_i32(_tmp1046, _tmp1047) ? hml_i32_ge(_tmp1046, _tmp1047) : (hml_both_i64(_tmp1046, _tmp1047) ? hml_i64_ge(_tmp1046, _tmp1047) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp1046, _tmp1047));
            hml_release_if_needed(&_tmp1046);
            hml_release_if_needed(&_tmp1047);
            HmlValue _tmp1044;
            if (!hml_to_bool(_tmp1045)) {
                _tmp1044 = hml_val_bool(0);
            } else {
                HmlValue _tmp1049 = max2;
                hml_retain_if_needed(&_tmp1049);
                HmlValue _tmp1050 = min1;
                hml_retain_if_needed(&_tmp1050);
                HmlValue _tmp1048 = hml_both_i32(_tmp1049, _tmp1050) ? hml_i32_ge(_tmp1049, _tmp1050) : (hml_both_i64(_tmp1049, _tmp1050) ? hml_i64_ge(_tmp1049, _tmp1050) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp1049, _tmp1050));
                hml_release_if_needed(&_tmp1049);
                hml_release_if_needed(&_tmp1050);
                _tmp1044 = hml_val_bool(hml_to_bool(_tmp1048));
                hml_release_if_needed(&_tmp1048);
            }
            hml_release_if_needed(&_tmp1045);
            if (hml_to_bool(_tmp1044)) {
                {
                    HmlValue _tmp1051 = hml_val_i32(1);
                    HML_CALL_EXIT();
                    return _tmp1051;
                }
            }
            hml_release(&_tmp1044);
            HmlValue _tmp1052 = hml_val_i32(0);
            HML_CALL_EXIT();
            return _tmp1052;
        }
    }
    hml_release(&_tmp988);
    HmlValue _tmp1054 = p3x;
    hml_retain_if_needed(&_tmp1054);
    HmlValue _tmp1055 = p1x;
    hml_retain_if_needed(&_tmp1055);
    HmlValue _tmp1053 = hml_both_i32(_tmp1054, _tmp1055) ? hml_i32_sub(_tmp1054, _tmp1055) : (hml_both_i64(_tmp1054, _tmp1055) ? hml_i64_sub(_tmp1054, _tmp1055) : hml_binary_op(HML_OP_SUB, _tmp1054, _tmp1055));
    hml_release_if_needed(&_tmp1054);
    hml_release_if_needed(&_tmp1055);
    HmlValue dx = _tmp1053;
    HmlValue _tmp1057 = p3y;
    hml_retain_if_needed(&_tmp1057);
    HmlValue _tmp1058 = p1y;
    hml_retain_if_needed(&_tmp1058);
    HmlValue _tmp1056 = hml_both_i32(_tmp1057, _tmp1058) ? hml_i32_sub(_tmp1057, _tmp1058) : (hml_both_i64(_tmp1057, _tmp1058) ? hml_i64_sub(_tmp1057, _tmp1058) : hml_binary_op(HML_OP_SUB, _tmp1057, _tmp1058));
    hml_release_if_needed(&_tmp1057);
    hml_release_if_needed(&_tmp1058);
    HmlValue dy = _tmp1056;
    HmlValue _tmp1062 = dx;
    hml_retain_if_needed(&_tmp1062);
    HmlValue _tmp1063 = d2y;
    hml_retain_if_needed(&_tmp1063);
    HmlValue _tmp1061 = hml_both_i32(_tmp1062, _tmp1063) ? hml_i32_mul(_tmp1062, _tmp1063) : (hml_both_i64(_tmp1062, _tmp1063) ? hml_i64_mul(_tmp1062, _tmp1063) : hml_binary_op(HML_OP_MUL, _tmp1062, _tmp1063));
    hml_release_if_needed(&_tmp1062);
    hml_release_if_needed(&_tmp1063);
    HmlValue _tmp1065 = dy;
    hml_retain_if_needed(&_tmp1065);
    HmlValue _tmp1066 = d2x;
    hml_retain_if_needed(&_tmp1066);
    HmlValue _tmp1064 = hml_both_i32(_tmp1065, _tmp1066) ? hml_i32_mul(_tmp1065, _tmp1066) : (hml_both_i64(_tmp1065, _tmp1066) ? hml_i64_mul(_tmp1065, _tmp1066) : hml_binary_op(HML_OP_MUL, _tmp1065, _tmp1066));
    hml_release_if_needed(&_tmp1065);
    hml_release_if_needed(&_tmp1066);
    HmlValue _tmp1060 = hml_both_i32(_tmp1061, _tmp1064) ? hml_i32_sub(_tmp1061, _tmp1064) : (hml_both_i64(_tmp1061, _tmp1064) ? hml_i64_sub(_tmp1061, _tmp1064) : hml_binary_op(HML_OP_SUB, _tmp1061, _tmp1064));
    hml_release_if_needed(&_tmp1061);
    hml_release_if_needed(&_tmp1064);
    HmlValue _tmp1067 = cross;
    hml_retain_if_needed(&_tmp1067);
    HmlValue _tmp1059 = hml_binary_op(HML_OP_DIV, _tmp1060, _tmp1067);
    hml_release_if_needed(&_tmp1060);
    hml_release_if_needed(&_tmp1067);
    HmlValue t = _tmp1059;
    HmlValue _tmp1071 = dx;
    hml_retain_if_needed(&_tmp1071);
    HmlValue _tmp1072 = d1y;
    hml_retain_if_needed(&_tmp1072);
    HmlValue _tmp1070 = hml_both_i32(_tmp1071, _tmp1072) ? hml_i32_mul(_tmp1071, _tmp1072) : (hml_both_i64(_tmp1071, _tmp1072) ? hml_i64_mul(_tmp1071, _tmp1072) : hml_binary_op(HML_OP_MUL, _tmp1071, _tmp1072));
    hml_release_if_needed(&_tmp1071);
    hml_release_if_needed(&_tmp1072);
    HmlValue _tmp1074 = dy;
    hml_retain_if_needed(&_tmp1074);
    HmlValue _tmp1075 = d1x;
    hml_retain_if_needed(&_tmp1075);
    HmlValue _tmp1073 = hml_both_i32(_tmp1074, _tmp1075) ? hml_i32_mul(_tmp1074, _tmp1075) : (hml_both_i64(_tmp1074, _tmp1075) ? hml_i64_mul(_tmp1074, _tmp1075) : hml_binary_op(HML_OP_MUL, _tmp1074, _tmp1075));
    hml_release_if_needed(&_tmp1074);
    hml_release_if_needed(&_tmp1075);
    HmlValue _tmp1069 = hml_both_i32(_tmp1070, _tmp1073) ? hml_i32_sub(_tmp1070, _tmp1073) : (hml_both_i64(_tmp1070, _tmp1073) ? hml_i64_sub(_tmp1070, _tmp1073) : hml_binary_op(HML_OP_SUB, _tmp1070, _tmp1073));
    hml_release_if_needed(&_tmp1070);
    hml_release_if_needed(&_tmp1073);
    HmlValue _tmp1076 = cross;
    hml_retain_if_needed(&_tmp1076);
    HmlValue _tmp1068 = hml_binary_op(HML_OP_DIV, _tmp1069, _tmp1076);
    hml_release_if_needed(&_tmp1069);
    hml_release_if_needed(&_tmp1076);
    HmlValue u = _tmp1068;
    HmlValue _tmp1081 = t;
    hml_retain_if_needed(&_tmp1081);
    HmlValue _tmp1082 = hml_val_f64(0);
    HmlValue _tmp1080 = hml_both_i32(_tmp1081, _tmp1082) ? hml_i32_ge(_tmp1081, _tmp1082) : (hml_both_i64(_tmp1081, _tmp1082) ? hml_i64_ge(_tmp1081, _tmp1082) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp1081, _tmp1082));
    hml_release_if_needed(&_tmp1081);
    hml_release_if_needed(&_tmp1082);
    HmlValue _tmp1079;
    if (!hml_to_bool(_tmp1080)) {
        _tmp1079 = hml_val_bool(0);
    } else {
        HmlValue _tmp1084 = t;
        hml_retain_if_needed(&_tmp1084);
        HmlValue _tmp1085 = hml_val_f64(1);
        HmlValue _tmp1083 = hml_both_i32(_tmp1084, _tmp1085) ? hml_i32_le(_tmp1084, _tmp1085) : (hml_both_i64(_tmp1084, _tmp1085) ? hml_i64_le(_tmp1084, _tmp1085) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp1084, _tmp1085));
        hml_release_if_needed(&_tmp1084);
        hml_release_if_needed(&_tmp1085);
        _tmp1079 = hml_val_bool(hml_to_bool(_tmp1083));
        hml_release_if_needed(&_tmp1083);
    }
    hml_release_if_needed(&_tmp1080);
    HmlValue _tmp1078;
    if (!hml_to_bool(_tmp1079)) {
        _tmp1078 = hml_val_bool(0);
    } else {
        HmlValue _tmp1087 = u;
        hml_retain_if_needed(&_tmp1087);
        HmlValue _tmp1088 = hml_val_f64(0);
        HmlValue _tmp1086 = hml_both_i32(_tmp1087, _tmp1088) ? hml_i32_ge(_tmp1087, _tmp1088) : (hml_both_i64(_tmp1087, _tmp1088) ? hml_i64_ge(_tmp1087, _tmp1088) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp1087, _tmp1088));
        hml_release_if_needed(&_tmp1087);
        hml_release_if_needed(&_tmp1088);
        _tmp1078 = hml_val_bool(hml_to_bool(_tmp1086));
        hml_release_if_needed(&_tmp1086);
    }
    hml_release_if_needed(&_tmp1079);
    HmlValue _tmp1077;
    if (!hml_to_bool(_tmp1078)) {
        _tmp1077 = hml_val_bool(0);
    } else {
        HmlValue _tmp1090 = u;
        hml_retain_if_needed(&_tmp1090);
        HmlValue _tmp1091 = hml_val_f64(1);
        HmlValue _tmp1089 = hml_both_i32(_tmp1090, _tmp1091) ? hml_i32_le(_tmp1090, _tmp1091) : (hml_both_i64(_tmp1090, _tmp1091) ? hml_i64_le(_tmp1090, _tmp1091) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp1090, _tmp1091));
        hml_release_if_needed(&_tmp1090);
        hml_release_if_needed(&_tmp1091);
        _tmp1077 = hml_val_bool(hml_to_bool(_tmp1089));
        hml_release_if_needed(&_tmp1089);
    }
    hml_release_if_needed(&_tmp1078);
    if (hml_to_bool(_tmp1077)) {
        {
            HmlValue _tmp1092 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp1092;
        }
    }
    hml_release(&_tmp1077);
    HmlValue _tmp1093 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp1093;
    return hml_val_null();
}

HmlValue _mod0_fn_CheckCollisionPointTriangleXY(HmlClosureEnv *_closure_env, HmlValue px, HmlValue py, HmlValue ax, HmlValue ay, HmlValue bx, HmlValue by, HmlValue cx, HmlValue cy) {
    (void)_closure_env;
    HmlValue _tmp1095 = cx;
    hml_retain_if_needed(&_tmp1095);
    HmlValue _tmp1096 = ax;
    hml_retain_if_needed(&_tmp1096);
    HmlValue _tmp1094 = hml_both_i32(_tmp1095, _tmp1096) ? hml_i32_sub(_tmp1095, _tmp1096) : (hml_both_i64(_tmp1095, _tmp1096) ? hml_i64_sub(_tmp1095, _tmp1096) : hml_binary_op(HML_OP_SUB, _tmp1095, _tmp1096));
    hml_release_if_needed(&_tmp1095);
    hml_release_if_needed(&_tmp1096);
    HmlValue v0x = _tmp1094;
    HmlValue _tmp1098 = cy;
    hml_retain_if_needed(&_tmp1098);
    HmlValue _tmp1099 = ay;
    hml_retain_if_needed(&_tmp1099);
    HmlValue _tmp1097 = hml_both_i32(_tmp1098, _tmp1099) ? hml_i32_sub(_tmp1098, _tmp1099) : (hml_both_i64(_tmp1098, _tmp1099) ? hml_i64_sub(_tmp1098, _tmp1099) : hml_binary_op(HML_OP_SUB, _tmp1098, _tmp1099));
    hml_release_if_needed(&_tmp1098);
    hml_release_if_needed(&_tmp1099);
    HmlValue v0y = _tmp1097;
    HmlValue _tmp1101 = bx;
    hml_retain_if_needed(&_tmp1101);
    HmlValue _tmp1102 = ax;
    hml_retain_if_needed(&_tmp1102);
    HmlValue _tmp1100 = hml_both_i32(_tmp1101, _tmp1102) ? hml_i32_sub(_tmp1101, _tmp1102) : (hml_both_i64(_tmp1101, _tmp1102) ? hml_i64_sub(_tmp1101, _tmp1102) : hml_binary_op(HML_OP_SUB, _tmp1101, _tmp1102));
    hml_release_if_needed(&_tmp1101);
    hml_release_if_needed(&_tmp1102);
    HmlValue v1x = _tmp1100;
    HmlValue _tmp1104 = by;
    hml_retain_if_needed(&_tmp1104);
    HmlValue _tmp1105 = ay;
    hml_retain_if_needed(&_tmp1105);
    HmlValue _tmp1103 = hml_both_i32(_tmp1104, _tmp1105) ? hml_i32_sub(_tmp1104, _tmp1105) : (hml_both_i64(_tmp1104, _tmp1105) ? hml_i64_sub(_tmp1104, _tmp1105) : hml_binary_op(HML_OP_SUB, _tmp1104, _tmp1105));
    hml_release_if_needed(&_tmp1104);
    hml_release_if_needed(&_tmp1105);
    HmlValue v1y = _tmp1103;
    HmlValue _tmp1107 = px;
    hml_retain_if_needed(&_tmp1107);
    HmlValue _tmp1108 = ax;
    hml_retain_if_needed(&_tmp1108);
    HmlValue _tmp1106 = hml_both_i32(_tmp1107, _tmp1108) ? hml_i32_sub(_tmp1107, _tmp1108) : (hml_both_i64(_tmp1107, _tmp1108) ? hml_i64_sub(_tmp1107, _tmp1108) : hml_binary_op(HML_OP_SUB, _tmp1107, _tmp1108));
    hml_release_if_needed(&_tmp1107);
    hml_release_if_needed(&_tmp1108);
    HmlValue v2x = _tmp1106;
    HmlValue _tmp1110 = py;
    hml_retain_if_needed(&_tmp1110);
    HmlValue _tmp1111 = ay;
    hml_retain_if_needed(&_tmp1111);
    HmlValue _tmp1109 = hml_both_i32(_tmp1110, _tmp1111) ? hml_i32_sub(_tmp1110, _tmp1111) : (hml_both_i64(_tmp1110, _tmp1111) ? hml_i64_sub(_tmp1110, _tmp1111) : hml_binary_op(HML_OP_SUB, _tmp1110, _tmp1111));
    hml_release_if_needed(&_tmp1110);
    hml_release_if_needed(&_tmp1111);
    HmlValue v2y = _tmp1109;
    HmlValue _tmp1114 = v0x;
    hml_retain_if_needed(&_tmp1114);
    HmlValue _tmp1115 = v0x;
    hml_retain_if_needed(&_tmp1115);
    HmlValue _tmp1113 = hml_both_i32(_tmp1114, _tmp1115) ? hml_i32_mul(_tmp1114, _tmp1115) : (hml_both_i64(_tmp1114, _tmp1115) ? hml_i64_mul(_tmp1114, _tmp1115) : hml_binary_op(HML_OP_MUL, _tmp1114, _tmp1115));
    hml_release_if_needed(&_tmp1114);
    hml_release_if_needed(&_tmp1115);
    HmlValue _tmp1117 = v0y;
    hml_retain_if_needed(&_tmp1117);
    HmlValue _tmp1118 = v0y;
    hml_retain_if_needed(&_tmp1118);
    HmlValue _tmp1116 = hml_both_i32(_tmp1117, _tmp1118) ? hml_i32_mul(_tmp1117, _tmp1118) : (hml_both_i64(_tmp1117, _tmp1118) ? hml_i64_mul(_tmp1117, _tmp1118) : hml_binary_op(HML_OP_MUL, _tmp1117, _tmp1118));
    hml_release_if_needed(&_tmp1117);
    hml_release_if_needed(&_tmp1118);
    HmlValue _tmp1112 = hml_both_i32(_tmp1113, _tmp1116) ? hml_i32_add(_tmp1113, _tmp1116) : (hml_both_i64(_tmp1113, _tmp1116) ? hml_i64_add(_tmp1113, _tmp1116) : hml_binary_op(HML_OP_ADD, _tmp1113, _tmp1116));
    hml_release_if_needed(&_tmp1113);
    hml_release_if_needed(&_tmp1116);
    HmlValue dot00 = _tmp1112;
    HmlValue _tmp1121 = v0x;
    hml_retain_if_needed(&_tmp1121);
    HmlValue _tmp1122 = v1x;
    hml_retain_if_needed(&_tmp1122);
    HmlValue _tmp1120 = hml_both_i32(_tmp1121, _tmp1122) ? hml_i32_mul(_tmp1121, _tmp1122) : (hml_both_i64(_tmp1121, _tmp1122) ? hml_i64_mul(_tmp1121, _tmp1122) : hml_binary_op(HML_OP_MUL, _tmp1121, _tmp1122));
    hml_release_if_needed(&_tmp1121);
    hml_release_if_needed(&_tmp1122);
    HmlValue _tmp1124 = v0y;
    hml_retain_if_needed(&_tmp1124);
    HmlValue _tmp1125 = v1y;
    hml_retain_if_needed(&_tmp1125);
    HmlValue _tmp1123 = hml_both_i32(_tmp1124, _tmp1125) ? hml_i32_mul(_tmp1124, _tmp1125) : (hml_both_i64(_tmp1124, _tmp1125) ? hml_i64_mul(_tmp1124, _tmp1125) : hml_binary_op(HML_OP_MUL, _tmp1124, _tmp1125));
    hml_release_if_needed(&_tmp1124);
    hml_release_if_needed(&_tmp1125);
    HmlValue _tmp1119 = hml_both_i32(_tmp1120, _tmp1123) ? hml_i32_add(_tmp1120, _tmp1123) : (hml_both_i64(_tmp1120, _tmp1123) ? hml_i64_add(_tmp1120, _tmp1123) : hml_binary_op(HML_OP_ADD, _tmp1120, _tmp1123));
    hml_release_if_needed(&_tmp1120);
    hml_release_if_needed(&_tmp1123);
    HmlValue dot01 = _tmp1119;
    HmlValue _tmp1128 = v0x;
    hml_retain_if_needed(&_tmp1128);
    HmlValue _tmp1129 = v2x;
    hml_retain_if_needed(&_tmp1129);
    HmlValue _tmp1127 = hml_both_i32(_tmp1128, _tmp1129) ? hml_i32_mul(_tmp1128, _tmp1129) : (hml_both_i64(_tmp1128, _tmp1129) ? hml_i64_mul(_tmp1128, _tmp1129) : hml_binary_op(HML_OP_MUL, _tmp1128, _tmp1129));
    hml_release_if_needed(&_tmp1128);
    hml_release_if_needed(&_tmp1129);
    HmlValue _tmp1131 = v0y;
    hml_retain_if_needed(&_tmp1131);
    HmlValue _tmp1132 = v2y;
    hml_retain_if_needed(&_tmp1132);
    HmlValue _tmp1130 = hml_both_i32(_tmp1131, _tmp1132) ? hml_i32_mul(_tmp1131, _tmp1132) : (hml_both_i64(_tmp1131, _tmp1132) ? hml_i64_mul(_tmp1131, _tmp1132) : hml_binary_op(HML_OP_MUL, _tmp1131, _tmp1132));
    hml_release_if_needed(&_tmp1131);
    hml_release_if_needed(&_tmp1132);
    HmlValue _tmp1126 = hml_both_i32(_tmp1127, _tmp1130) ? hml_i32_add(_tmp1127, _tmp1130) : (hml_both_i64(_tmp1127, _tmp1130) ? hml_i64_add(_tmp1127, _tmp1130) : hml_binary_op(HML_OP_ADD, _tmp1127, _tmp1130));
    hml_release_if_needed(&_tmp1127);
    hml_release_if_needed(&_tmp1130);
    HmlValue dot02 = _tmp1126;
    HmlValue _tmp1135 = v1x;
    hml_retain_if_needed(&_tmp1135);
    HmlValue _tmp1136 = v1x;
    hml_retain_if_needed(&_tmp1136);
    HmlValue _tmp1134 = hml_both_i32(_tmp1135, _tmp1136) ? hml_i32_mul(_tmp1135, _tmp1136) : (hml_both_i64(_tmp1135, _tmp1136) ? hml_i64_mul(_tmp1135, _tmp1136) : hml_binary_op(HML_OP_MUL, _tmp1135, _tmp1136));
    hml_release_if_needed(&_tmp1135);
    hml_release_if_needed(&_tmp1136);
    HmlValue _tmp1138 = v1y;
    hml_retain_if_needed(&_tmp1138);
    HmlValue _tmp1139 = v1y;
    hml_retain_if_needed(&_tmp1139);
    HmlValue _tmp1137 = hml_both_i32(_tmp1138, _tmp1139) ? hml_i32_mul(_tmp1138, _tmp1139) : (hml_both_i64(_tmp1138, _tmp1139) ? hml_i64_mul(_tmp1138, _tmp1139) : hml_binary_op(HML_OP_MUL, _tmp1138, _tmp1139));
    hml_release_if_needed(&_tmp1138);
    hml_release_if_needed(&_tmp1139);
    HmlValue _tmp1133 = hml_both_i32(_tmp1134, _tmp1137) ? hml_i32_add(_tmp1134, _tmp1137) : (hml_both_i64(_tmp1134, _tmp1137) ? hml_i64_add(_tmp1134, _tmp1137) : hml_binary_op(HML_OP_ADD, _tmp1134, _tmp1137));
    hml_release_if_needed(&_tmp1134);
    hml_release_if_needed(&_tmp1137);
    HmlValue dot11 = _tmp1133;
    HmlValue _tmp1142 = v1x;
    hml_retain_if_needed(&_tmp1142);
    HmlValue _tmp1143 = v2x;
    hml_retain_if_needed(&_tmp1143);
    HmlValue _tmp1141 = hml_both_i32(_tmp1142, _tmp1143) ? hml_i32_mul(_tmp1142, _tmp1143) : (hml_both_i64(_tmp1142, _tmp1143) ? hml_i64_mul(_tmp1142, _tmp1143) : hml_binary_op(HML_OP_MUL, _tmp1142, _tmp1143));
    hml_release_if_needed(&_tmp1142);
    hml_release_if_needed(&_tmp1143);
    HmlValue _tmp1145 = v1y;
    hml_retain_if_needed(&_tmp1145);
    HmlValue _tmp1146 = v2y;
    hml_retain_if_needed(&_tmp1146);
    HmlValue _tmp1144 = hml_both_i32(_tmp1145, _tmp1146) ? hml_i32_mul(_tmp1145, _tmp1146) : (hml_both_i64(_tmp1145, _tmp1146) ? hml_i64_mul(_tmp1145, _tmp1146) : hml_binary_op(HML_OP_MUL, _tmp1145, _tmp1146));
    hml_release_if_needed(&_tmp1145);
    hml_release_if_needed(&_tmp1146);
    HmlValue _tmp1140 = hml_both_i32(_tmp1141, _tmp1144) ? hml_i32_add(_tmp1141, _tmp1144) : (hml_both_i64(_tmp1141, _tmp1144) ? hml_i64_add(_tmp1141, _tmp1144) : hml_binary_op(HML_OP_ADD, _tmp1141, _tmp1144));
    hml_release_if_needed(&_tmp1141);
    hml_release_if_needed(&_tmp1144);
    HmlValue dot12 = _tmp1140;
    HmlValue _tmp1149 = dot00;
    hml_retain_if_needed(&_tmp1149);
    HmlValue _tmp1150 = dot11;
    hml_retain_if_needed(&_tmp1150);
    HmlValue _tmp1148 = hml_both_i32(_tmp1149, _tmp1150) ? hml_i32_mul(_tmp1149, _tmp1150) : (hml_both_i64(_tmp1149, _tmp1150) ? hml_i64_mul(_tmp1149, _tmp1150) : hml_binary_op(HML_OP_MUL, _tmp1149, _tmp1150));
    hml_release_if_needed(&_tmp1149);
    hml_release_if_needed(&_tmp1150);
    HmlValue _tmp1152 = dot01;
    hml_retain_if_needed(&_tmp1152);
    HmlValue _tmp1153 = dot01;
    hml_retain_if_needed(&_tmp1153);
    HmlValue _tmp1151 = hml_both_i32(_tmp1152, _tmp1153) ? hml_i32_mul(_tmp1152, _tmp1153) : (hml_both_i64(_tmp1152, _tmp1153) ? hml_i64_mul(_tmp1152, _tmp1153) : hml_binary_op(HML_OP_MUL, _tmp1152, _tmp1153));
    hml_release_if_needed(&_tmp1152);
    hml_release_if_needed(&_tmp1153);
    HmlValue _tmp1147 = hml_both_i32(_tmp1148, _tmp1151) ? hml_i32_sub(_tmp1148, _tmp1151) : (hml_both_i64(_tmp1148, _tmp1151) ? hml_i64_sub(_tmp1148, _tmp1151) : hml_binary_op(HML_OP_SUB, _tmp1148, _tmp1151));
    hml_release_if_needed(&_tmp1148);
    hml_release_if_needed(&_tmp1151);
    HmlValue denom = _tmp1147;
    HmlValue _tmp1155 = denom;
    hml_retain_if_needed(&_tmp1155);
    HmlValue _tmp1156 = hml_val_f64(0);
    HmlValue _tmp1154 = hml_both_i32(_tmp1155, _tmp1156) ? hml_i32_eq(_tmp1155, _tmp1156) : (hml_both_i64(_tmp1155, _tmp1156) ? hml_i64_eq(_tmp1155, _tmp1156) : hml_binary_op(HML_OP_EQUAL, _tmp1155, _tmp1156));
    hml_release_if_needed(&_tmp1155);
    hml_release_if_needed(&_tmp1156);
    if (hml_to_bool(_tmp1154)) {
        {
            HmlValue _tmp1159 = px;
            hml_retain_if_needed(&_tmp1159);
            HmlValue _tmp1160 = ax;
            hml_retain_if_needed(&_tmp1160);
            HmlValue _tmp1158 = hml_both_i32(_tmp1159, _tmp1160) ? hml_i32_eq(_tmp1159, _tmp1160) : (hml_both_i64(_tmp1159, _tmp1160) ? hml_i64_eq(_tmp1159, _tmp1160) : hml_binary_op(HML_OP_EQUAL, _tmp1159, _tmp1160));
            hml_release_if_needed(&_tmp1159);
            hml_release_if_needed(&_tmp1160);
            HmlValue _tmp1157;
            if (!hml_to_bool(_tmp1158)) {
                _tmp1157 = hml_val_bool(0);
            } else {
                HmlValue _tmp1162 = py;
                hml_retain_if_needed(&_tmp1162);
                HmlValue _tmp1163 = ay;
                hml_retain_if_needed(&_tmp1163);
                HmlValue _tmp1161 = hml_both_i32(_tmp1162, _tmp1163) ? hml_i32_eq(_tmp1162, _tmp1163) : (hml_both_i64(_tmp1162, _tmp1163) ? hml_i64_eq(_tmp1162, _tmp1163) : hml_binary_op(HML_OP_EQUAL, _tmp1162, _tmp1163));
                hml_release_if_needed(&_tmp1162);
                hml_release_if_needed(&_tmp1163);
                _tmp1157 = hml_val_bool(hml_to_bool(_tmp1161));
                hml_release_if_needed(&_tmp1161);
            }
            hml_release_if_needed(&_tmp1158);
            if (hml_to_bool(_tmp1157)) {
                {
                    HmlValue _tmp1164 = hml_val_i32(1);
                    HML_CALL_EXIT();
                    return _tmp1164;
                }
            }
            hml_release(&_tmp1157);
            HmlValue _tmp1165 = hml_val_i32(0);
            HML_CALL_EXIT();
            return _tmp1165;
        }
    }
    hml_release(&_tmp1154);
    HmlValue _tmp1167 = hml_val_f64(1);
    HmlValue _tmp1168 = denom;
    hml_retain_if_needed(&_tmp1168);
    HmlValue _tmp1166 = hml_binary_op(HML_OP_DIV, _tmp1167, _tmp1168);
    hml_release_if_needed(&_tmp1167);
    hml_release_if_needed(&_tmp1168);
    HmlValue invDenom = _tmp1166;
    HmlValue _tmp1172 = dot11;
    hml_retain_if_needed(&_tmp1172);
    HmlValue _tmp1173 = dot02;
    hml_retain_if_needed(&_tmp1173);
    HmlValue _tmp1171 = hml_both_i32(_tmp1172, _tmp1173) ? hml_i32_mul(_tmp1172, _tmp1173) : (hml_both_i64(_tmp1172, _tmp1173) ? hml_i64_mul(_tmp1172, _tmp1173) : hml_binary_op(HML_OP_MUL, _tmp1172, _tmp1173));
    hml_release_if_needed(&_tmp1172);
    hml_release_if_needed(&_tmp1173);
    HmlValue _tmp1175 = dot01;
    hml_retain_if_needed(&_tmp1175);
    HmlValue _tmp1176 = dot12;
    hml_retain_if_needed(&_tmp1176);
    HmlValue _tmp1174 = hml_both_i32(_tmp1175, _tmp1176) ? hml_i32_mul(_tmp1175, _tmp1176) : (hml_both_i64(_tmp1175, _tmp1176) ? hml_i64_mul(_tmp1175, _tmp1176) : hml_binary_op(HML_OP_MUL, _tmp1175, _tmp1176));
    hml_release_if_needed(&_tmp1175);
    hml_release_if_needed(&_tmp1176);
    HmlValue _tmp1170 = hml_both_i32(_tmp1171, _tmp1174) ? hml_i32_sub(_tmp1171, _tmp1174) : (hml_both_i64(_tmp1171, _tmp1174) ? hml_i64_sub(_tmp1171, _tmp1174) : hml_binary_op(HML_OP_SUB, _tmp1171, _tmp1174));
    hml_release_if_needed(&_tmp1171);
    hml_release_if_needed(&_tmp1174);
    HmlValue _tmp1177 = invDenom;
    hml_retain_if_needed(&_tmp1177);
    HmlValue _tmp1169 = hml_both_i32(_tmp1170, _tmp1177) ? hml_i32_mul(_tmp1170, _tmp1177) : (hml_both_i64(_tmp1170, _tmp1177) ? hml_i64_mul(_tmp1170, _tmp1177) : hml_binary_op(HML_OP_MUL, _tmp1170, _tmp1177));
    hml_release_if_needed(&_tmp1170);
    hml_release_if_needed(&_tmp1177);
    HmlValue u = _tmp1169;
    HmlValue _tmp1181 = dot00;
    hml_retain_if_needed(&_tmp1181);
    HmlValue _tmp1182 = dot12;
    hml_retain_if_needed(&_tmp1182);
    HmlValue _tmp1180 = hml_both_i32(_tmp1181, _tmp1182) ? hml_i32_mul(_tmp1181, _tmp1182) : (hml_both_i64(_tmp1181, _tmp1182) ? hml_i64_mul(_tmp1181, _tmp1182) : hml_binary_op(HML_OP_MUL, _tmp1181, _tmp1182));
    hml_release_if_needed(&_tmp1181);
    hml_release_if_needed(&_tmp1182);
    HmlValue _tmp1184 = dot01;
    hml_retain_if_needed(&_tmp1184);
    HmlValue _tmp1185 = dot02;
    hml_retain_if_needed(&_tmp1185);
    HmlValue _tmp1183 = hml_both_i32(_tmp1184, _tmp1185) ? hml_i32_mul(_tmp1184, _tmp1185) : (hml_both_i64(_tmp1184, _tmp1185) ? hml_i64_mul(_tmp1184, _tmp1185) : hml_binary_op(HML_OP_MUL, _tmp1184, _tmp1185));
    hml_release_if_needed(&_tmp1184);
    hml_release_if_needed(&_tmp1185);
    HmlValue _tmp1179 = hml_both_i32(_tmp1180, _tmp1183) ? hml_i32_sub(_tmp1180, _tmp1183) : (hml_both_i64(_tmp1180, _tmp1183) ? hml_i64_sub(_tmp1180, _tmp1183) : hml_binary_op(HML_OP_SUB, _tmp1180, _tmp1183));
    hml_release_if_needed(&_tmp1180);
    hml_release_if_needed(&_tmp1183);
    HmlValue _tmp1186 = invDenom;
    hml_retain_if_needed(&_tmp1186);
    HmlValue _tmp1178 = hml_both_i32(_tmp1179, _tmp1186) ? hml_i32_mul(_tmp1179, _tmp1186) : (hml_both_i64(_tmp1179, _tmp1186) ? hml_i64_mul(_tmp1179, _tmp1186) : hml_binary_op(HML_OP_MUL, _tmp1179, _tmp1186));
    hml_release_if_needed(&_tmp1179);
    hml_release_if_needed(&_tmp1186);
    HmlValue v = _tmp1178;
    HmlValue _tmp1190 = u;
    hml_retain_if_needed(&_tmp1190);
    HmlValue _tmp1191 = hml_val_f64(0);
    HmlValue _tmp1189 = hml_both_i32(_tmp1190, _tmp1191) ? hml_i32_ge(_tmp1190, _tmp1191) : (hml_both_i64(_tmp1190, _tmp1191) ? hml_i64_ge(_tmp1190, _tmp1191) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp1190, _tmp1191));
    hml_release_if_needed(&_tmp1190);
    hml_release_if_needed(&_tmp1191);
    HmlValue _tmp1188;
    if (!hml_to_bool(_tmp1189)) {
        _tmp1188 = hml_val_bool(0);
    } else {
        HmlValue _tmp1193 = v;
        hml_retain_if_needed(&_tmp1193);
        HmlValue _tmp1194 = hml_val_f64(0);
        HmlValue _tmp1192 = hml_both_i32(_tmp1193, _tmp1194) ? hml_i32_ge(_tmp1193, _tmp1194) : (hml_both_i64(_tmp1193, _tmp1194) ? hml_i64_ge(_tmp1193, _tmp1194) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp1193, _tmp1194));
        hml_release_if_needed(&_tmp1193);
        hml_release_if_needed(&_tmp1194);
        _tmp1188 = hml_val_bool(hml_to_bool(_tmp1192));
        hml_release_if_needed(&_tmp1192);
    }
    hml_release_if_needed(&_tmp1189);
    HmlValue _tmp1187;
    if (!hml_to_bool(_tmp1188)) {
        _tmp1187 = hml_val_bool(0);
    } else {
        HmlValue _tmp1197 = u;
        hml_retain_if_needed(&_tmp1197);
        HmlValue _tmp1198 = v;
        hml_retain_if_needed(&_tmp1198);
        HmlValue _tmp1196 = hml_both_i32(_tmp1197, _tmp1198) ? hml_i32_add(_tmp1197, _tmp1198) : (hml_both_i64(_tmp1197, _tmp1198) ? hml_i64_add(_tmp1197, _tmp1198) : hml_binary_op(HML_OP_ADD, _tmp1197, _tmp1198));
        hml_release_if_needed(&_tmp1197);
        hml_release_if_needed(&_tmp1198);
        HmlValue _tmp1199 = hml_val_f64(1);
        HmlValue _tmp1195 = hml_both_i32(_tmp1196, _tmp1199) ? hml_i32_le(_tmp1196, _tmp1199) : (hml_both_i64(_tmp1196, _tmp1199) ? hml_i64_le(_tmp1196, _tmp1199) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp1196, _tmp1199));
        hml_release_if_needed(&_tmp1196);
        hml_release_if_needed(&_tmp1199);
        _tmp1187 = hml_val_bool(hml_to_bool(_tmp1195));
        hml_release_if_needed(&_tmp1195);
    }
    hml_release_if_needed(&_tmp1188);
    if (hml_to_bool(_tmp1187)) {
        {
            HmlValue _tmp1200 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp1200;
        }
    }
    hml_release(&_tmp1187);
    HmlValue _tmp1201 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp1201;
    return hml_val_null();
}

HmlValue _mod0_fn_CheckCollisionPointLineXY(HmlClosureEnv *_closure_env, HmlValue px, HmlValue py, HmlValue p1x, HmlValue p1y, HmlValue p2x, HmlValue p2y, HmlValue threshold) {
    (void)_closure_env;
    HmlValue _tmp1203 = px;
    hml_retain_if_needed(&_tmp1203);
    HmlValue _tmp1204 = py;
    hml_retain_if_needed(&_tmp1204);
    HmlValue _tmp1205 = p1x;
    hml_retain_if_needed(&_tmp1205);
    HmlValue _tmp1206 = p1y;
    hml_retain_if_needed(&_tmp1206);
    HmlValue _tmp1202 = _mod0_fn_Vector2Distance(NULL, _tmp1203, _tmp1204, _tmp1205, _tmp1206);
    hml_release(&_tmp1203);
    hml_release(&_tmp1204);
    hml_release(&_tmp1205);
    hml_release(&_tmp1206);
    HmlValue d1 = _tmp1202;
    HmlValue _tmp1208 = px;
    hml_retain_if_needed(&_tmp1208);
    HmlValue _tmp1209 = py;
    hml_retain_if_needed(&_tmp1209);
    HmlValue _tmp1210 = p2x;
    hml_retain_if_needed(&_tmp1210);
    HmlValue _tmp1211 = p2y;
    hml_retain_if_needed(&_tmp1211);
    HmlValue _tmp1207 = _mod0_fn_Vector2Distance(NULL, _tmp1208, _tmp1209, _tmp1210, _tmp1211);
    hml_release(&_tmp1208);
    hml_release(&_tmp1209);
    hml_release(&_tmp1210);
    hml_release(&_tmp1211);
    HmlValue d2 = _tmp1207;
    HmlValue _tmp1213 = p1x;
    hml_retain_if_needed(&_tmp1213);
    HmlValue _tmp1214 = p1y;
    hml_retain_if_needed(&_tmp1214);
    HmlValue _tmp1215 = p2x;
    hml_retain_if_needed(&_tmp1215);
    HmlValue _tmp1216 = p2y;
    hml_retain_if_needed(&_tmp1216);
    HmlValue _tmp1212 = _mod0_fn_Vector2Distance(NULL, _tmp1213, _tmp1214, _tmp1215, _tmp1216);
    hml_release(&_tmp1213);
    hml_release(&_tmp1214);
    hml_release(&_tmp1215);
    hml_release(&_tmp1216);
    HmlValue lineLen = _tmp1212;
    HmlValue _tmp1220 = d1;
    hml_retain_if_needed(&_tmp1220);
    HmlValue _tmp1221 = d2;
    hml_retain_if_needed(&_tmp1221);
    HmlValue _tmp1219 = hml_both_i32(_tmp1220, _tmp1221) ? hml_i32_add(_tmp1220, _tmp1221) : (hml_both_i64(_tmp1220, _tmp1221) ? hml_i64_add(_tmp1220, _tmp1221) : hml_binary_op(HML_OP_ADD, _tmp1220, _tmp1221));
    hml_release_if_needed(&_tmp1220);
    hml_release_if_needed(&_tmp1221);
    HmlValue _tmp1223 = lineLen;
    hml_retain_if_needed(&_tmp1223);
    HmlValue _tmp1224 = threshold;
    hml_retain_if_needed(&_tmp1224);
    HmlValue _tmp1222 = hml_both_i32(_tmp1223, _tmp1224) ? hml_i32_sub(_tmp1223, _tmp1224) : (hml_both_i64(_tmp1223, _tmp1224) ? hml_i64_sub(_tmp1223, _tmp1224) : hml_binary_op(HML_OP_SUB, _tmp1223, _tmp1224));
    hml_release_if_needed(&_tmp1223);
    hml_release_if_needed(&_tmp1224);
    HmlValue _tmp1218 = hml_both_i32(_tmp1219, _tmp1222) ? hml_i32_ge(_tmp1219, _tmp1222) : (hml_both_i64(_tmp1219, _tmp1222) ? hml_i64_ge(_tmp1219, _tmp1222) : hml_binary_op(HML_OP_GREATER_EQUAL, _tmp1219, _tmp1222));
    hml_release_if_needed(&_tmp1219);
    hml_release_if_needed(&_tmp1222);
    HmlValue _tmp1217;
    if (!hml_to_bool(_tmp1218)) {
        _tmp1217 = hml_val_bool(0);
    } else {
        HmlValue _tmp1227 = d1;
        hml_retain_if_needed(&_tmp1227);
        HmlValue _tmp1228 = d2;
        hml_retain_if_needed(&_tmp1228);
        HmlValue _tmp1226 = hml_both_i32(_tmp1227, _tmp1228) ? hml_i32_add(_tmp1227, _tmp1228) : (hml_both_i64(_tmp1227, _tmp1228) ? hml_i64_add(_tmp1227, _tmp1228) : hml_binary_op(HML_OP_ADD, _tmp1227, _tmp1228));
        hml_release_if_needed(&_tmp1227);
        hml_release_if_needed(&_tmp1228);
        HmlValue _tmp1230 = lineLen;
        hml_retain_if_needed(&_tmp1230);
        HmlValue _tmp1231 = threshold;
        hml_retain_if_needed(&_tmp1231);
        HmlValue _tmp1229 = hml_both_i32(_tmp1230, _tmp1231) ? hml_i32_add(_tmp1230, _tmp1231) : (hml_both_i64(_tmp1230, _tmp1231) ? hml_i64_add(_tmp1230, _tmp1231) : hml_binary_op(HML_OP_ADD, _tmp1230, _tmp1231));
        hml_release_if_needed(&_tmp1230);
        hml_release_if_needed(&_tmp1231);
        HmlValue _tmp1225 = hml_both_i32(_tmp1226, _tmp1229) ? hml_i32_le(_tmp1226, _tmp1229) : (hml_both_i64(_tmp1226, _tmp1229) ? hml_i64_le(_tmp1226, _tmp1229) : hml_binary_op(HML_OP_LESS_EQUAL, _tmp1226, _tmp1229));
        hml_release_if_needed(&_tmp1226);
        hml_release_if_needed(&_tmp1229);
        _tmp1217 = hml_val_bool(hml_to_bool(_tmp1225));
        hml_release_if_needed(&_tmp1225);
    }
    hml_release_if_needed(&_tmp1218);
    if (hml_to_bool(_tmp1217)) {
        {
            HmlValue _tmp1232 = hml_val_i32(1);
            HML_CALL_EXIT();
            return _tmp1232;
        }
    }
    hml_release(&_tmp1217);
    HmlValue _tmp1233 = hml_val_i32(0);
    HML_CALL_EXIT();
    return _tmp1233;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseLinear(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1234 = t;
    hml_retain_if_needed(&_tmp1234);
    HML_CALL_EXIT();
    return _tmp1234;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInQuad(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1236 = t;
    hml_retain_if_needed(&_tmp1236);
    HmlValue _tmp1237 = t;
    hml_retain_if_needed(&_tmp1237);
    HmlValue _tmp1235 = hml_both_i32(_tmp1236, _tmp1237) ? hml_i32_mul(_tmp1236, _tmp1237) : (hml_both_i64(_tmp1236, _tmp1237) ? hml_i64_mul(_tmp1236, _tmp1237) : hml_binary_op(HML_OP_MUL, _tmp1236, _tmp1237));
    hml_release_if_needed(&_tmp1236);
    hml_release_if_needed(&_tmp1237);
    HML_CALL_EXIT();
    return _tmp1235;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutQuad(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1239 = t;
    hml_retain_if_needed(&_tmp1239);
    HmlValue _tmp1241 = hml_val_f64(2);
    HmlValue _tmp1242 = t;
    hml_retain_if_needed(&_tmp1242);
    HmlValue _tmp1240 = hml_both_i32(_tmp1241, _tmp1242) ? hml_i32_sub(_tmp1241, _tmp1242) : (hml_both_i64(_tmp1241, _tmp1242) ? hml_i64_sub(_tmp1241, _tmp1242) : hml_binary_op(HML_OP_SUB, _tmp1241, _tmp1242));
    hml_release_if_needed(&_tmp1241);
    hml_release_if_needed(&_tmp1242);
    HmlValue _tmp1238 = hml_both_i32(_tmp1239, _tmp1240) ? hml_i32_mul(_tmp1239, _tmp1240) : (hml_both_i64(_tmp1239, _tmp1240) ? hml_i64_mul(_tmp1239, _tmp1240) : hml_binary_op(HML_OP_MUL, _tmp1239, _tmp1240));
    hml_release_if_needed(&_tmp1239);
    hml_release_if_needed(&_tmp1240);
    HML_CALL_EXIT();
    return _tmp1238;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutQuad(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1244 = t;
    hml_retain_if_needed(&_tmp1244);
    HmlValue _tmp1245 = hml_val_f64(0.5);
    HmlValue _tmp1243 = hml_both_i32(_tmp1244, _tmp1245) ? hml_i32_lt(_tmp1244, _tmp1245) : (hml_both_i64(_tmp1244, _tmp1245) ? hml_i64_lt(_tmp1244, _tmp1245) : hml_binary_op(HML_OP_LESS, _tmp1244, _tmp1245));
    hml_release_if_needed(&_tmp1244);
    hml_release_if_needed(&_tmp1245);
    if (hml_to_bool(_tmp1243)) {
        {
            HmlValue _tmp1248 = hml_val_f64(2);
            HmlValue _tmp1249 = t;
            hml_retain_if_needed(&_tmp1249);
            HmlValue _tmp1247 = hml_both_i32(_tmp1248, _tmp1249) ? hml_i32_mul(_tmp1248, _tmp1249) : (hml_both_i64(_tmp1248, _tmp1249) ? hml_i64_mul(_tmp1248, _tmp1249) : hml_binary_op(HML_OP_MUL, _tmp1248, _tmp1249));
            hml_release_if_needed(&_tmp1248);
            hml_release_if_needed(&_tmp1249);
            HmlValue _tmp1250 = t;
            hml_retain_if_needed(&_tmp1250);
            HmlValue _tmp1246 = hml_both_i32(_tmp1247, _tmp1250) ? hml_i32_mul(_tmp1247, _tmp1250) : (hml_both_i64(_tmp1247, _tmp1250) ? hml_i64_mul(_tmp1247, _tmp1250) : hml_binary_op(HML_OP_MUL, _tmp1247, _tmp1250));
            hml_release_if_needed(&_tmp1247);
            hml_release_if_needed(&_tmp1250);
            HML_CALL_EXIT();
            return _tmp1246;
        }
    }
    hml_release(&_tmp1243);
    HmlValue _tmp1253 = hml_val_f64(1);
    HmlValue _tmp1252 = hml_unary_op(HML_UNARY_NEGATE, _tmp1253);
    hml_release_if_needed(&_tmp1253);
    HmlValue _tmp1256 = hml_val_f64(4);
    HmlValue _tmp1258 = hml_val_f64(2);
    HmlValue _tmp1259 = t;
    hml_retain_if_needed(&_tmp1259);
    HmlValue _tmp1257 = hml_both_i32(_tmp1258, _tmp1259) ? hml_i32_mul(_tmp1258, _tmp1259) : (hml_both_i64(_tmp1258, _tmp1259) ? hml_i64_mul(_tmp1258, _tmp1259) : hml_binary_op(HML_OP_MUL, _tmp1258, _tmp1259));
    hml_release_if_needed(&_tmp1258);
    hml_release_if_needed(&_tmp1259);
    HmlValue _tmp1255 = hml_both_i32(_tmp1256, _tmp1257) ? hml_i32_sub(_tmp1256, _tmp1257) : (hml_both_i64(_tmp1256, _tmp1257) ? hml_i64_sub(_tmp1256, _tmp1257) : hml_binary_op(HML_OP_SUB, _tmp1256, _tmp1257));
    hml_release_if_needed(&_tmp1256);
    hml_release_if_needed(&_tmp1257);
    HmlValue _tmp1260 = t;
    hml_retain_if_needed(&_tmp1260);
    HmlValue _tmp1254 = hml_both_i32(_tmp1255, _tmp1260) ? hml_i32_mul(_tmp1255, _tmp1260) : (hml_both_i64(_tmp1255, _tmp1260) ? hml_i64_mul(_tmp1255, _tmp1260) : hml_binary_op(HML_OP_MUL, _tmp1255, _tmp1260));
    hml_release_if_needed(&_tmp1255);
    hml_release_if_needed(&_tmp1260);
    HmlValue _tmp1251 = hml_both_i32(_tmp1252, _tmp1254) ? hml_i32_add(_tmp1252, _tmp1254) : (hml_both_i64(_tmp1252, _tmp1254) ? hml_i64_add(_tmp1252, _tmp1254) : hml_binary_op(HML_OP_ADD, _tmp1252, _tmp1254));
    hml_release_if_needed(&_tmp1252);
    hml_release_if_needed(&_tmp1254);
    HML_CALL_EXIT();
    return _tmp1251;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInCubic(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1263 = t;
    hml_retain_if_needed(&_tmp1263);
    HmlValue _tmp1264 = t;
    hml_retain_if_needed(&_tmp1264);
    HmlValue _tmp1262 = hml_both_i32(_tmp1263, _tmp1264) ? hml_i32_mul(_tmp1263, _tmp1264) : (hml_both_i64(_tmp1263, _tmp1264) ? hml_i64_mul(_tmp1263, _tmp1264) : hml_binary_op(HML_OP_MUL, _tmp1263, _tmp1264));
    hml_release_if_needed(&_tmp1263);
    hml_release_if_needed(&_tmp1264);
    HmlValue _tmp1265 = t;
    hml_retain_if_needed(&_tmp1265);
    HmlValue _tmp1261 = hml_both_i32(_tmp1262, _tmp1265) ? hml_i32_mul(_tmp1262, _tmp1265) : (hml_both_i64(_tmp1262, _tmp1265) ? hml_i64_mul(_tmp1262, _tmp1265) : hml_binary_op(HML_OP_MUL, _tmp1262, _tmp1265));
    hml_release_if_needed(&_tmp1262);
    hml_release_if_needed(&_tmp1265);
    HML_CALL_EXIT();
    return _tmp1261;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutCubic(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1267 = t;
    hml_retain_if_needed(&_tmp1267);
    HmlValue _tmp1268 = hml_val_f64(1);
    HmlValue _tmp1266 = hml_both_i32(_tmp1267, _tmp1268) ? hml_i32_sub(_tmp1267, _tmp1268) : (hml_both_i64(_tmp1267, _tmp1268) ? hml_i64_sub(_tmp1267, _tmp1268) : hml_binary_op(HML_OP_SUB, _tmp1267, _tmp1268));
    hml_release_if_needed(&_tmp1267);
    hml_release_if_needed(&_tmp1268);
    HmlValue t1 = _tmp1266;
    HmlValue _tmp1272 = t1;
    hml_retain_if_needed(&_tmp1272);
    HmlValue _tmp1273 = t1;
    hml_retain_if_needed(&_tmp1273);
    HmlValue _tmp1271 = hml_both_i32(_tmp1272, _tmp1273) ? hml_i32_mul(_tmp1272, _tmp1273) : (hml_both_i64(_tmp1272, _tmp1273) ? hml_i64_mul(_tmp1272, _tmp1273) : hml_binary_op(HML_OP_MUL, _tmp1272, _tmp1273));
    hml_release_if_needed(&_tmp1272);
    hml_release_if_needed(&_tmp1273);
    HmlValue _tmp1274 = t1;
    hml_retain_if_needed(&_tmp1274);
    HmlValue _tmp1270 = hml_both_i32(_tmp1271, _tmp1274) ? hml_i32_mul(_tmp1271, _tmp1274) : (hml_both_i64(_tmp1271, _tmp1274) ? hml_i64_mul(_tmp1271, _tmp1274) : hml_binary_op(HML_OP_MUL, _tmp1271, _tmp1274));
    hml_release_if_needed(&_tmp1271);
    hml_release_if_needed(&_tmp1274);
    HmlValue _tmp1275 = hml_val_f64(1);
    HmlValue _tmp1269 = hml_both_i32(_tmp1270, _tmp1275) ? hml_i32_add(_tmp1270, _tmp1275) : (hml_both_i64(_tmp1270, _tmp1275) ? hml_i64_add(_tmp1270, _tmp1275) : hml_binary_op(HML_OP_ADD, _tmp1270, _tmp1275));
    hml_release_if_needed(&_tmp1270);
    hml_release_if_needed(&_tmp1275);
    HML_CALL_EXIT();
    return _tmp1269;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutCubic(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1277 = t;
    hml_retain_if_needed(&_tmp1277);
    HmlValue _tmp1278 = hml_val_f64(0.5);
    HmlValue _tmp1276 = hml_both_i32(_tmp1277, _tmp1278) ? hml_i32_lt(_tmp1277, _tmp1278) : (hml_both_i64(_tmp1277, _tmp1278) ? hml_i64_lt(_tmp1277, _tmp1278) : hml_binary_op(HML_OP_LESS, _tmp1277, _tmp1278));
    hml_release_if_needed(&_tmp1277);
    hml_release_if_needed(&_tmp1278);
    if (hml_to_bool(_tmp1276)) {
        {
            HmlValue _tmp1282 = hml_val_f64(4);
            HmlValue _tmp1283 = t;
            hml_retain_if_needed(&_tmp1283);
            HmlValue _tmp1281 = hml_both_i32(_tmp1282, _tmp1283) ? hml_i32_mul(_tmp1282, _tmp1283) : (hml_both_i64(_tmp1282, _tmp1283) ? hml_i64_mul(_tmp1282, _tmp1283) : hml_binary_op(HML_OP_MUL, _tmp1282, _tmp1283));
            hml_release_if_needed(&_tmp1282);
            hml_release_if_needed(&_tmp1283);
            HmlValue _tmp1284 = t;
            hml_retain_if_needed(&_tmp1284);
            HmlValue _tmp1280 = hml_both_i32(_tmp1281, _tmp1284) ? hml_i32_mul(_tmp1281, _tmp1284) : (hml_both_i64(_tmp1281, _tmp1284) ? hml_i64_mul(_tmp1281, _tmp1284) : hml_binary_op(HML_OP_MUL, _tmp1281, _tmp1284));
            hml_release_if_needed(&_tmp1281);
            hml_release_if_needed(&_tmp1284);
            HmlValue _tmp1285 = t;
            hml_retain_if_needed(&_tmp1285);
            HmlValue _tmp1279 = hml_both_i32(_tmp1280, _tmp1285) ? hml_i32_mul(_tmp1280, _tmp1285) : (hml_both_i64(_tmp1280, _tmp1285) ? hml_i64_mul(_tmp1280, _tmp1285) : hml_binary_op(HML_OP_MUL, _tmp1280, _tmp1285));
            hml_release_if_needed(&_tmp1280);
            hml_release_if_needed(&_tmp1285);
            HML_CALL_EXIT();
            return _tmp1279;
        }
    }
    hml_release(&_tmp1276);
    HmlValue _tmp1288 = hml_val_f64(2);
    HmlValue _tmp1289 = t;
    hml_retain_if_needed(&_tmp1289);
    HmlValue _tmp1287 = hml_both_i32(_tmp1288, _tmp1289) ? hml_i32_mul(_tmp1288, _tmp1289) : (hml_both_i64(_tmp1288, _tmp1289) ? hml_i64_mul(_tmp1288, _tmp1289) : hml_binary_op(HML_OP_MUL, _tmp1288, _tmp1289));
    hml_release_if_needed(&_tmp1288);
    hml_release_if_needed(&_tmp1289);
    HmlValue _tmp1290 = hml_val_f64(2);
    HmlValue _tmp1286 = hml_both_i32(_tmp1287, _tmp1290) ? hml_i32_sub(_tmp1287, _tmp1290) : (hml_both_i64(_tmp1287, _tmp1290) ? hml_i64_sub(_tmp1287, _tmp1290) : hml_binary_op(HML_OP_SUB, _tmp1287, _tmp1290));
    hml_release_if_needed(&_tmp1287);
    hml_release_if_needed(&_tmp1290);
    HmlValue t1 = _tmp1286;
    HmlValue _tmp1295 = hml_val_f64(0.5);
    HmlValue _tmp1296 = t1;
    hml_retain_if_needed(&_tmp1296);
    HmlValue _tmp1294 = hml_both_i32(_tmp1295, _tmp1296) ? hml_i32_mul(_tmp1295, _tmp1296) : (hml_both_i64(_tmp1295, _tmp1296) ? hml_i64_mul(_tmp1295, _tmp1296) : hml_binary_op(HML_OP_MUL, _tmp1295, _tmp1296));
    hml_release_if_needed(&_tmp1295);
    hml_release_if_needed(&_tmp1296);
    HmlValue _tmp1297 = t1;
    hml_retain_if_needed(&_tmp1297);
    HmlValue _tmp1293 = hml_both_i32(_tmp1294, _tmp1297) ? hml_i32_mul(_tmp1294, _tmp1297) : (hml_both_i64(_tmp1294, _tmp1297) ? hml_i64_mul(_tmp1294, _tmp1297) : hml_binary_op(HML_OP_MUL, _tmp1294, _tmp1297));
    hml_release_if_needed(&_tmp1294);
    hml_release_if_needed(&_tmp1297);
    HmlValue _tmp1298 = t1;
    hml_retain_if_needed(&_tmp1298);
    HmlValue _tmp1292 = hml_both_i32(_tmp1293, _tmp1298) ? hml_i32_mul(_tmp1293, _tmp1298) : (hml_both_i64(_tmp1293, _tmp1298) ? hml_i64_mul(_tmp1293, _tmp1298) : hml_binary_op(HML_OP_MUL, _tmp1293, _tmp1298));
    hml_release_if_needed(&_tmp1293);
    hml_release_if_needed(&_tmp1298);
    HmlValue _tmp1299 = hml_val_f64(1);
    HmlValue _tmp1291 = hml_both_i32(_tmp1292, _tmp1299) ? hml_i32_add(_tmp1292, _tmp1299) : (hml_both_i64(_tmp1292, _tmp1299) ? hml_i64_add(_tmp1292, _tmp1299) : hml_binary_op(HML_OP_ADD, _tmp1292, _tmp1299));
    hml_release_if_needed(&_tmp1292);
    hml_release_if_needed(&_tmp1299);
    HML_CALL_EXIT();
    return _tmp1291;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInQuart(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1303 = t;
    hml_retain_if_needed(&_tmp1303);
    HmlValue _tmp1304 = t;
    hml_retain_if_needed(&_tmp1304);
    HmlValue _tmp1302 = hml_both_i32(_tmp1303, _tmp1304) ? hml_i32_mul(_tmp1303, _tmp1304) : (hml_both_i64(_tmp1303, _tmp1304) ? hml_i64_mul(_tmp1303, _tmp1304) : hml_binary_op(HML_OP_MUL, _tmp1303, _tmp1304));
    hml_release_if_needed(&_tmp1303);
    hml_release_if_needed(&_tmp1304);
    HmlValue _tmp1305 = t;
    hml_retain_if_needed(&_tmp1305);
    HmlValue _tmp1301 = hml_both_i32(_tmp1302, _tmp1305) ? hml_i32_mul(_tmp1302, _tmp1305) : (hml_both_i64(_tmp1302, _tmp1305) ? hml_i64_mul(_tmp1302, _tmp1305) : hml_binary_op(HML_OP_MUL, _tmp1302, _tmp1305));
    hml_release_if_needed(&_tmp1302);
    hml_release_if_needed(&_tmp1305);
    HmlValue _tmp1306 = t;
    hml_retain_if_needed(&_tmp1306);
    HmlValue _tmp1300 = hml_both_i32(_tmp1301, _tmp1306) ? hml_i32_mul(_tmp1301, _tmp1306) : (hml_both_i64(_tmp1301, _tmp1306) ? hml_i64_mul(_tmp1301, _tmp1306) : hml_binary_op(HML_OP_MUL, _tmp1301, _tmp1306));
    hml_release_if_needed(&_tmp1301);
    hml_release_if_needed(&_tmp1306);
    HML_CALL_EXIT();
    return _tmp1300;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutQuart(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1308 = t;
    hml_retain_if_needed(&_tmp1308);
    HmlValue _tmp1309 = hml_val_f64(1);
    HmlValue _tmp1307 = hml_both_i32(_tmp1308, _tmp1309) ? hml_i32_sub(_tmp1308, _tmp1309) : (hml_both_i64(_tmp1308, _tmp1309) ? hml_i64_sub(_tmp1308, _tmp1309) : hml_binary_op(HML_OP_SUB, _tmp1308, _tmp1309));
    hml_release_if_needed(&_tmp1308);
    hml_release_if_needed(&_tmp1309);
    HmlValue t1 = _tmp1307;
    HmlValue _tmp1311 = hml_val_f64(1);
    HmlValue _tmp1315 = t1;
    hml_retain_if_needed(&_tmp1315);
    HmlValue _tmp1316 = t1;
    hml_retain_if_needed(&_tmp1316);
    HmlValue _tmp1314 = hml_both_i32(_tmp1315, _tmp1316) ? hml_i32_mul(_tmp1315, _tmp1316) : (hml_both_i64(_tmp1315, _tmp1316) ? hml_i64_mul(_tmp1315, _tmp1316) : hml_binary_op(HML_OP_MUL, _tmp1315, _tmp1316));
    hml_release_if_needed(&_tmp1315);
    hml_release_if_needed(&_tmp1316);
    HmlValue _tmp1317 = t1;
    hml_retain_if_needed(&_tmp1317);
    HmlValue _tmp1313 = hml_both_i32(_tmp1314, _tmp1317) ? hml_i32_mul(_tmp1314, _tmp1317) : (hml_both_i64(_tmp1314, _tmp1317) ? hml_i64_mul(_tmp1314, _tmp1317) : hml_binary_op(HML_OP_MUL, _tmp1314, _tmp1317));
    hml_release_if_needed(&_tmp1314);
    hml_release_if_needed(&_tmp1317);
    HmlValue _tmp1318 = t1;
    hml_retain_if_needed(&_tmp1318);
    HmlValue _tmp1312 = hml_both_i32(_tmp1313, _tmp1318) ? hml_i32_mul(_tmp1313, _tmp1318) : (hml_both_i64(_tmp1313, _tmp1318) ? hml_i64_mul(_tmp1313, _tmp1318) : hml_binary_op(HML_OP_MUL, _tmp1313, _tmp1318));
    hml_release_if_needed(&_tmp1313);
    hml_release_if_needed(&_tmp1318);
    HmlValue _tmp1310 = hml_both_i32(_tmp1311, _tmp1312) ? hml_i32_sub(_tmp1311, _tmp1312) : (hml_both_i64(_tmp1311, _tmp1312) ? hml_i64_sub(_tmp1311, _tmp1312) : hml_binary_op(HML_OP_SUB, _tmp1311, _tmp1312));
    hml_release_if_needed(&_tmp1311);
    hml_release_if_needed(&_tmp1312);
    HML_CALL_EXIT();
    return _tmp1310;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutQuart(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1320 = t;
    hml_retain_if_needed(&_tmp1320);
    HmlValue _tmp1321 = hml_val_f64(0.5);
    HmlValue _tmp1319 = hml_both_i32(_tmp1320, _tmp1321) ? hml_i32_lt(_tmp1320, _tmp1321) : (hml_both_i64(_tmp1320, _tmp1321) ? hml_i64_lt(_tmp1320, _tmp1321) : hml_binary_op(HML_OP_LESS, _tmp1320, _tmp1321));
    hml_release_if_needed(&_tmp1320);
    hml_release_if_needed(&_tmp1321);
    if (hml_to_bool(_tmp1319)) {
        {
            HmlValue _tmp1326 = hml_val_f64(8);
            HmlValue _tmp1327 = t;
            hml_retain_if_needed(&_tmp1327);
            HmlValue _tmp1325 = hml_both_i32(_tmp1326, _tmp1327) ? hml_i32_mul(_tmp1326, _tmp1327) : (hml_both_i64(_tmp1326, _tmp1327) ? hml_i64_mul(_tmp1326, _tmp1327) : hml_binary_op(HML_OP_MUL, _tmp1326, _tmp1327));
            hml_release_if_needed(&_tmp1326);
            hml_release_if_needed(&_tmp1327);
            HmlValue _tmp1328 = t;
            hml_retain_if_needed(&_tmp1328);
            HmlValue _tmp1324 = hml_both_i32(_tmp1325, _tmp1328) ? hml_i32_mul(_tmp1325, _tmp1328) : (hml_both_i64(_tmp1325, _tmp1328) ? hml_i64_mul(_tmp1325, _tmp1328) : hml_binary_op(HML_OP_MUL, _tmp1325, _tmp1328));
            hml_release_if_needed(&_tmp1325);
            hml_release_if_needed(&_tmp1328);
            HmlValue _tmp1329 = t;
            hml_retain_if_needed(&_tmp1329);
            HmlValue _tmp1323 = hml_both_i32(_tmp1324, _tmp1329) ? hml_i32_mul(_tmp1324, _tmp1329) : (hml_both_i64(_tmp1324, _tmp1329) ? hml_i64_mul(_tmp1324, _tmp1329) : hml_binary_op(HML_OP_MUL, _tmp1324, _tmp1329));
            hml_release_if_needed(&_tmp1324);
            hml_release_if_needed(&_tmp1329);
            HmlValue _tmp1330 = t;
            hml_retain_if_needed(&_tmp1330);
            HmlValue _tmp1322 = hml_both_i32(_tmp1323, _tmp1330) ? hml_i32_mul(_tmp1323, _tmp1330) : (hml_both_i64(_tmp1323, _tmp1330) ? hml_i64_mul(_tmp1323, _tmp1330) : hml_binary_op(HML_OP_MUL, _tmp1323, _tmp1330));
            hml_release_if_needed(&_tmp1323);
            hml_release_if_needed(&_tmp1330);
            HML_CALL_EXIT();
            return _tmp1322;
        }
    }
    hml_release(&_tmp1319);
    HmlValue _tmp1332 = t;
    hml_retain_if_needed(&_tmp1332);
    HmlValue _tmp1333 = hml_val_f64(1);
    HmlValue _tmp1331 = hml_both_i32(_tmp1332, _tmp1333) ? hml_i32_sub(_tmp1332, _tmp1333) : (hml_both_i64(_tmp1332, _tmp1333) ? hml_i64_sub(_tmp1332, _tmp1333) : hml_binary_op(HML_OP_SUB, _tmp1332, _tmp1333));
    hml_release_if_needed(&_tmp1332);
    hml_release_if_needed(&_tmp1333);
    HmlValue t1 = _tmp1331;
    HmlValue _tmp1335 = hml_val_f64(1);
    HmlValue _tmp1340 = hml_val_f64(8);
    HmlValue _tmp1341 = t1;
    hml_retain_if_needed(&_tmp1341);
    HmlValue _tmp1339 = hml_both_i32(_tmp1340, _tmp1341) ? hml_i32_mul(_tmp1340, _tmp1341) : (hml_both_i64(_tmp1340, _tmp1341) ? hml_i64_mul(_tmp1340, _tmp1341) : hml_binary_op(HML_OP_MUL, _tmp1340, _tmp1341));
    hml_release_if_needed(&_tmp1340);
    hml_release_if_needed(&_tmp1341);
    HmlValue _tmp1342 = t1;
    hml_retain_if_needed(&_tmp1342);
    HmlValue _tmp1338 = hml_both_i32(_tmp1339, _tmp1342) ? hml_i32_mul(_tmp1339, _tmp1342) : (hml_both_i64(_tmp1339, _tmp1342) ? hml_i64_mul(_tmp1339, _tmp1342) : hml_binary_op(HML_OP_MUL, _tmp1339, _tmp1342));
    hml_release_if_needed(&_tmp1339);
    hml_release_if_needed(&_tmp1342);
    HmlValue _tmp1343 = t1;
    hml_retain_if_needed(&_tmp1343);
    HmlValue _tmp1337 = hml_both_i32(_tmp1338, _tmp1343) ? hml_i32_mul(_tmp1338, _tmp1343) : (hml_both_i64(_tmp1338, _tmp1343) ? hml_i64_mul(_tmp1338, _tmp1343) : hml_binary_op(HML_OP_MUL, _tmp1338, _tmp1343));
    hml_release_if_needed(&_tmp1338);
    hml_release_if_needed(&_tmp1343);
    HmlValue _tmp1344 = t1;
    hml_retain_if_needed(&_tmp1344);
    HmlValue _tmp1336 = hml_both_i32(_tmp1337, _tmp1344) ? hml_i32_mul(_tmp1337, _tmp1344) : (hml_both_i64(_tmp1337, _tmp1344) ? hml_i64_mul(_tmp1337, _tmp1344) : hml_binary_op(HML_OP_MUL, _tmp1337, _tmp1344));
    hml_release_if_needed(&_tmp1337);
    hml_release_if_needed(&_tmp1344);
    HmlValue _tmp1334 = hml_both_i32(_tmp1335, _tmp1336) ? hml_i32_sub(_tmp1335, _tmp1336) : (hml_both_i64(_tmp1335, _tmp1336) ? hml_i64_sub(_tmp1335, _tmp1336) : hml_binary_op(HML_OP_SUB, _tmp1335, _tmp1336));
    hml_release_if_needed(&_tmp1335);
    hml_release_if_needed(&_tmp1336);
    HML_CALL_EXIT();
    return _tmp1334;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInQuint(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1349 = t;
    hml_retain_if_needed(&_tmp1349);
    HmlValue _tmp1350 = t;
    hml_retain_if_needed(&_tmp1350);
    HmlValue _tmp1348 = hml_both_i32(_tmp1349, _tmp1350) ? hml_i32_mul(_tmp1349, _tmp1350) : (hml_both_i64(_tmp1349, _tmp1350) ? hml_i64_mul(_tmp1349, _tmp1350) : hml_binary_op(HML_OP_MUL, _tmp1349, _tmp1350));
    hml_release_if_needed(&_tmp1349);
    hml_release_if_needed(&_tmp1350);
    HmlValue _tmp1351 = t;
    hml_retain_if_needed(&_tmp1351);
    HmlValue _tmp1347 = hml_both_i32(_tmp1348, _tmp1351) ? hml_i32_mul(_tmp1348, _tmp1351) : (hml_both_i64(_tmp1348, _tmp1351) ? hml_i64_mul(_tmp1348, _tmp1351) : hml_binary_op(HML_OP_MUL, _tmp1348, _tmp1351));
    hml_release_if_needed(&_tmp1348);
    hml_release_if_needed(&_tmp1351);
    HmlValue _tmp1352 = t;
    hml_retain_if_needed(&_tmp1352);
    HmlValue _tmp1346 = hml_both_i32(_tmp1347, _tmp1352) ? hml_i32_mul(_tmp1347, _tmp1352) : (hml_both_i64(_tmp1347, _tmp1352) ? hml_i64_mul(_tmp1347, _tmp1352) : hml_binary_op(HML_OP_MUL, _tmp1347, _tmp1352));
    hml_release_if_needed(&_tmp1347);
    hml_release_if_needed(&_tmp1352);
    HmlValue _tmp1353 = t;
    hml_retain_if_needed(&_tmp1353);
    HmlValue _tmp1345 = hml_both_i32(_tmp1346, _tmp1353) ? hml_i32_mul(_tmp1346, _tmp1353) : (hml_both_i64(_tmp1346, _tmp1353) ? hml_i64_mul(_tmp1346, _tmp1353) : hml_binary_op(HML_OP_MUL, _tmp1346, _tmp1353));
    hml_release_if_needed(&_tmp1346);
    hml_release_if_needed(&_tmp1353);
    HML_CALL_EXIT();
    return _tmp1345;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutQuint(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1355 = t;
    hml_retain_if_needed(&_tmp1355);
    HmlValue _tmp1356 = hml_val_f64(1);
    HmlValue _tmp1354 = hml_both_i32(_tmp1355, _tmp1356) ? hml_i32_sub(_tmp1355, _tmp1356) : (hml_both_i64(_tmp1355, _tmp1356) ? hml_i64_sub(_tmp1355, _tmp1356) : hml_binary_op(HML_OP_SUB, _tmp1355, _tmp1356));
    hml_release_if_needed(&_tmp1355);
    hml_release_if_needed(&_tmp1356);
    HmlValue t1 = _tmp1354;
    HmlValue _tmp1358 = hml_val_f64(1);
    HmlValue _tmp1363 = t1;
    hml_retain_if_needed(&_tmp1363);
    HmlValue _tmp1364 = t1;
    hml_retain_if_needed(&_tmp1364);
    HmlValue _tmp1362 = hml_both_i32(_tmp1363, _tmp1364) ? hml_i32_mul(_tmp1363, _tmp1364) : (hml_both_i64(_tmp1363, _tmp1364) ? hml_i64_mul(_tmp1363, _tmp1364) : hml_binary_op(HML_OP_MUL, _tmp1363, _tmp1364));
    hml_release_if_needed(&_tmp1363);
    hml_release_if_needed(&_tmp1364);
    HmlValue _tmp1365 = t1;
    hml_retain_if_needed(&_tmp1365);
    HmlValue _tmp1361 = hml_both_i32(_tmp1362, _tmp1365) ? hml_i32_mul(_tmp1362, _tmp1365) : (hml_both_i64(_tmp1362, _tmp1365) ? hml_i64_mul(_tmp1362, _tmp1365) : hml_binary_op(HML_OP_MUL, _tmp1362, _tmp1365));
    hml_release_if_needed(&_tmp1362);
    hml_release_if_needed(&_tmp1365);
    HmlValue _tmp1366 = t1;
    hml_retain_if_needed(&_tmp1366);
    HmlValue _tmp1360 = hml_both_i32(_tmp1361, _tmp1366) ? hml_i32_mul(_tmp1361, _tmp1366) : (hml_both_i64(_tmp1361, _tmp1366) ? hml_i64_mul(_tmp1361, _tmp1366) : hml_binary_op(HML_OP_MUL, _tmp1361, _tmp1366));
    hml_release_if_needed(&_tmp1361);
    hml_release_if_needed(&_tmp1366);
    HmlValue _tmp1367 = t1;
    hml_retain_if_needed(&_tmp1367);
    HmlValue _tmp1359 = hml_both_i32(_tmp1360, _tmp1367) ? hml_i32_mul(_tmp1360, _tmp1367) : (hml_both_i64(_tmp1360, _tmp1367) ? hml_i64_mul(_tmp1360, _tmp1367) : hml_binary_op(HML_OP_MUL, _tmp1360, _tmp1367));
    hml_release_if_needed(&_tmp1360);
    hml_release_if_needed(&_tmp1367);
    HmlValue _tmp1357 = hml_both_i32(_tmp1358, _tmp1359) ? hml_i32_add(_tmp1358, _tmp1359) : (hml_both_i64(_tmp1358, _tmp1359) ? hml_i64_add(_tmp1358, _tmp1359) : hml_binary_op(HML_OP_ADD, _tmp1358, _tmp1359));
    hml_release_if_needed(&_tmp1358);
    hml_release_if_needed(&_tmp1359);
    HML_CALL_EXIT();
    return _tmp1357;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutQuint(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1369 = t;
    hml_retain_if_needed(&_tmp1369);
    HmlValue _tmp1370 = hml_val_f64(0.5);
    HmlValue _tmp1368 = hml_both_i32(_tmp1369, _tmp1370) ? hml_i32_lt(_tmp1369, _tmp1370) : (hml_both_i64(_tmp1369, _tmp1370) ? hml_i64_lt(_tmp1369, _tmp1370) : hml_binary_op(HML_OP_LESS, _tmp1369, _tmp1370));
    hml_release_if_needed(&_tmp1369);
    hml_release_if_needed(&_tmp1370);
    if (hml_to_bool(_tmp1368)) {
        {
            HmlValue _tmp1376 = hml_val_f64(16);
            HmlValue _tmp1377 = t;
            hml_retain_if_needed(&_tmp1377);
            HmlValue _tmp1375 = hml_both_i32(_tmp1376, _tmp1377) ? hml_i32_mul(_tmp1376, _tmp1377) : (hml_both_i64(_tmp1376, _tmp1377) ? hml_i64_mul(_tmp1376, _tmp1377) : hml_binary_op(HML_OP_MUL, _tmp1376, _tmp1377));
            hml_release_if_needed(&_tmp1376);
            hml_release_if_needed(&_tmp1377);
            HmlValue _tmp1378 = t;
            hml_retain_if_needed(&_tmp1378);
            HmlValue _tmp1374 = hml_both_i32(_tmp1375, _tmp1378) ? hml_i32_mul(_tmp1375, _tmp1378) : (hml_both_i64(_tmp1375, _tmp1378) ? hml_i64_mul(_tmp1375, _tmp1378) : hml_binary_op(HML_OP_MUL, _tmp1375, _tmp1378));
            hml_release_if_needed(&_tmp1375);
            hml_release_if_needed(&_tmp1378);
            HmlValue _tmp1379 = t;
            hml_retain_if_needed(&_tmp1379);
            HmlValue _tmp1373 = hml_both_i32(_tmp1374, _tmp1379) ? hml_i32_mul(_tmp1374, _tmp1379) : (hml_both_i64(_tmp1374, _tmp1379) ? hml_i64_mul(_tmp1374, _tmp1379) : hml_binary_op(HML_OP_MUL, _tmp1374, _tmp1379));
            hml_release_if_needed(&_tmp1374);
            hml_release_if_needed(&_tmp1379);
            HmlValue _tmp1380 = t;
            hml_retain_if_needed(&_tmp1380);
            HmlValue _tmp1372 = hml_both_i32(_tmp1373, _tmp1380) ? hml_i32_mul(_tmp1373, _tmp1380) : (hml_both_i64(_tmp1373, _tmp1380) ? hml_i64_mul(_tmp1373, _tmp1380) : hml_binary_op(HML_OP_MUL, _tmp1373, _tmp1380));
            hml_release_if_needed(&_tmp1373);
            hml_release_if_needed(&_tmp1380);
            HmlValue _tmp1381 = t;
            hml_retain_if_needed(&_tmp1381);
            HmlValue _tmp1371 = hml_both_i32(_tmp1372, _tmp1381) ? hml_i32_mul(_tmp1372, _tmp1381) : (hml_both_i64(_tmp1372, _tmp1381) ? hml_i64_mul(_tmp1372, _tmp1381) : hml_binary_op(HML_OP_MUL, _tmp1372, _tmp1381));
            hml_release_if_needed(&_tmp1372);
            hml_release_if_needed(&_tmp1381);
            HML_CALL_EXIT();
            return _tmp1371;
        }
    }
    hml_release(&_tmp1368);
    HmlValue _tmp1384 = hml_val_f64(2);
    HmlValue _tmp1385 = t;
    hml_retain_if_needed(&_tmp1385);
    HmlValue _tmp1383 = hml_both_i32(_tmp1384, _tmp1385) ? hml_i32_mul(_tmp1384, _tmp1385) : (hml_both_i64(_tmp1384, _tmp1385) ? hml_i64_mul(_tmp1384, _tmp1385) : hml_binary_op(HML_OP_MUL, _tmp1384, _tmp1385));
    hml_release_if_needed(&_tmp1384);
    hml_release_if_needed(&_tmp1385);
    HmlValue _tmp1386 = hml_val_f64(2);
    HmlValue _tmp1382 = hml_both_i32(_tmp1383, _tmp1386) ? hml_i32_sub(_tmp1383, _tmp1386) : (hml_both_i64(_tmp1383, _tmp1386) ? hml_i64_sub(_tmp1383, _tmp1386) : hml_binary_op(HML_OP_SUB, _tmp1383, _tmp1386));
    hml_release_if_needed(&_tmp1383);
    hml_release_if_needed(&_tmp1386);
    HmlValue t1 = _tmp1382;
    HmlValue _tmp1393 = hml_val_f64(0.5);
    HmlValue _tmp1394 = t1;
    hml_retain_if_needed(&_tmp1394);
    HmlValue _tmp1392 = hml_both_i32(_tmp1393, _tmp1394) ? hml_i32_mul(_tmp1393, _tmp1394) : (hml_both_i64(_tmp1393, _tmp1394) ? hml_i64_mul(_tmp1393, _tmp1394) : hml_binary_op(HML_OP_MUL, _tmp1393, _tmp1394));
    hml_release_if_needed(&_tmp1393);
    hml_release_if_needed(&_tmp1394);
    HmlValue _tmp1395 = t1;
    hml_retain_if_needed(&_tmp1395);
    HmlValue _tmp1391 = hml_both_i32(_tmp1392, _tmp1395) ? hml_i32_mul(_tmp1392, _tmp1395) : (hml_both_i64(_tmp1392, _tmp1395) ? hml_i64_mul(_tmp1392, _tmp1395) : hml_binary_op(HML_OP_MUL, _tmp1392, _tmp1395));
    hml_release_if_needed(&_tmp1392);
    hml_release_if_needed(&_tmp1395);
    HmlValue _tmp1396 = t1;
    hml_retain_if_needed(&_tmp1396);
    HmlValue _tmp1390 = hml_both_i32(_tmp1391, _tmp1396) ? hml_i32_mul(_tmp1391, _tmp1396) : (hml_both_i64(_tmp1391, _tmp1396) ? hml_i64_mul(_tmp1391, _tmp1396) : hml_binary_op(HML_OP_MUL, _tmp1391, _tmp1396));
    hml_release_if_needed(&_tmp1391);
    hml_release_if_needed(&_tmp1396);
    HmlValue _tmp1397 = t1;
    hml_retain_if_needed(&_tmp1397);
    HmlValue _tmp1389 = hml_both_i32(_tmp1390, _tmp1397) ? hml_i32_mul(_tmp1390, _tmp1397) : (hml_both_i64(_tmp1390, _tmp1397) ? hml_i64_mul(_tmp1390, _tmp1397) : hml_binary_op(HML_OP_MUL, _tmp1390, _tmp1397));
    hml_release_if_needed(&_tmp1390);
    hml_release_if_needed(&_tmp1397);
    HmlValue _tmp1398 = t1;
    hml_retain_if_needed(&_tmp1398);
    HmlValue _tmp1388 = hml_both_i32(_tmp1389, _tmp1398) ? hml_i32_mul(_tmp1389, _tmp1398) : (hml_both_i64(_tmp1389, _tmp1398) ? hml_i64_mul(_tmp1389, _tmp1398) : hml_binary_op(HML_OP_MUL, _tmp1389, _tmp1398));
    hml_release_if_needed(&_tmp1389);
    hml_release_if_needed(&_tmp1398);
    HmlValue _tmp1399 = hml_val_f64(1);
    HmlValue _tmp1387 = hml_both_i32(_tmp1388, _tmp1399) ? hml_i32_add(_tmp1388, _tmp1399) : (hml_both_i64(_tmp1388, _tmp1399) ? hml_i64_add(_tmp1388, _tmp1399) : hml_binary_op(HML_OP_ADD, _tmp1388, _tmp1399));
    hml_release_if_needed(&_tmp1388);
    hml_release_if_needed(&_tmp1399);
    HML_CALL_EXIT();
    return _tmp1387;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInSine(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1401 = hml_val_f64(1);
    HmlValue _tmp1404 = t;
    hml_retain_if_needed(&_tmp1404);
    HmlValue _tmp1405 = hml_val_f64(1.5708);
    HmlValue _tmp1403 = hml_both_i32(_tmp1404, _tmp1405) ? hml_i32_mul(_tmp1404, _tmp1405) : (hml_both_i64(_tmp1404, _tmp1405) ? hml_i64_mul(_tmp1404, _tmp1405) : hml_binary_op(HML_OP_MUL, _tmp1404, _tmp1405));
    hml_release_if_needed(&_tmp1404);
    hml_release_if_needed(&_tmp1405);
    HmlValue _tmp1402 = hml_cos(_tmp1403);
    hml_release(&_tmp1403);
    HmlValue _tmp1400 = hml_both_i32(_tmp1401, _tmp1402) ? hml_i32_sub(_tmp1401, _tmp1402) : (hml_both_i64(_tmp1401, _tmp1402) ? hml_i64_sub(_tmp1401, _tmp1402) : hml_binary_op(HML_OP_SUB, _tmp1401, _tmp1402));
    hml_release_if_needed(&_tmp1401);
    hml_release_if_needed(&_tmp1402);
    HML_CALL_EXIT();
    return _tmp1400;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutSine(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1408 = t;
    hml_retain_if_needed(&_tmp1408);
    HmlValue _tmp1409 = hml_val_f64(1.5708);
    HmlValue _tmp1407 = hml_both_i32(_tmp1408, _tmp1409) ? hml_i32_mul(_tmp1408, _tmp1409) : (hml_both_i64(_tmp1408, _tmp1409) ? hml_i64_mul(_tmp1408, _tmp1409) : hml_binary_op(HML_OP_MUL, _tmp1408, _tmp1409));
    hml_release_if_needed(&_tmp1408);
    hml_release_if_needed(&_tmp1409);
    HmlValue _tmp1406 = hml_sin(_tmp1407);
    hml_release(&_tmp1407);
    HML_CALL_EXIT();
    return _tmp1406;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutSine(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1411 = hml_val_f64(0.5);
    HmlValue _tmp1413 = hml_val_f64(1);
    HmlValue _tmp1416 = hml_val_f64(3.14159);
    HmlValue _tmp1417 = t;
    hml_retain_if_needed(&_tmp1417);
    HmlValue _tmp1415 = hml_both_i32(_tmp1416, _tmp1417) ? hml_i32_mul(_tmp1416, _tmp1417) : (hml_both_i64(_tmp1416, _tmp1417) ? hml_i64_mul(_tmp1416, _tmp1417) : hml_binary_op(HML_OP_MUL, _tmp1416, _tmp1417));
    hml_release_if_needed(&_tmp1416);
    hml_release_if_needed(&_tmp1417);
    HmlValue _tmp1414 = hml_cos(_tmp1415);
    hml_release(&_tmp1415);
    HmlValue _tmp1412 = hml_both_i32(_tmp1413, _tmp1414) ? hml_i32_sub(_tmp1413, _tmp1414) : (hml_both_i64(_tmp1413, _tmp1414) ? hml_i64_sub(_tmp1413, _tmp1414) : hml_binary_op(HML_OP_SUB, _tmp1413, _tmp1414));
    hml_release_if_needed(&_tmp1413);
    hml_release_if_needed(&_tmp1414);
    HmlValue _tmp1410 = hml_both_i32(_tmp1411, _tmp1412) ? hml_i32_mul(_tmp1411, _tmp1412) : (hml_both_i64(_tmp1411, _tmp1412) ? hml_i64_mul(_tmp1411, _tmp1412) : hml_binary_op(HML_OP_MUL, _tmp1411, _tmp1412));
    hml_release_if_needed(&_tmp1411);
    hml_release_if_needed(&_tmp1412);
    HML_CALL_EXIT();
    return _tmp1410;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInExpo(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1419 = t;
    hml_retain_if_needed(&_tmp1419);
    HmlValue _tmp1420 = hml_val_f64(0);
    HmlValue _tmp1418 = hml_both_i32(_tmp1419, _tmp1420) ? hml_i32_eq(_tmp1419, _tmp1420) : (hml_both_i64(_tmp1419, _tmp1420) ? hml_i64_eq(_tmp1419, _tmp1420) : hml_binary_op(HML_OP_EQUAL, _tmp1419, _tmp1420));
    hml_release_if_needed(&_tmp1419);
    hml_release_if_needed(&_tmp1420);
    if (hml_to_bool(_tmp1418)) {
        {
            HmlValue _tmp1421 = hml_val_f64(0);
            HML_CALL_EXIT();
            return _tmp1421;
        }
    }
    hml_release(&_tmp1418);
    HmlValue _tmp1423 = hml_val_f64(2);
    HmlValue _tmp1425 = hml_val_f64(10);
    HmlValue _tmp1427 = t;
    hml_retain_if_needed(&_tmp1427);
    HmlValue _tmp1428 = hml_val_f64(1);
    HmlValue _tmp1426 = hml_both_i32(_tmp1427, _tmp1428) ? hml_i32_sub(_tmp1427, _tmp1428) : (hml_both_i64(_tmp1427, _tmp1428) ? hml_i64_sub(_tmp1427, _tmp1428) : hml_binary_op(HML_OP_SUB, _tmp1427, _tmp1428));
    hml_release_if_needed(&_tmp1427);
    hml_release_if_needed(&_tmp1428);
    HmlValue _tmp1424 = hml_both_i32(_tmp1425, _tmp1426) ? hml_i32_mul(_tmp1425, _tmp1426) : (hml_both_i64(_tmp1425, _tmp1426) ? hml_i64_mul(_tmp1425, _tmp1426) : hml_binary_op(HML_OP_MUL, _tmp1425, _tmp1426));
    hml_release_if_needed(&_tmp1425);
    hml_release_if_needed(&_tmp1426);
    HmlValue _tmp1422 = hml_pow(_tmp1423, _tmp1424);
    hml_release(&_tmp1423);
    hml_release(&_tmp1424);
    HML_CALL_EXIT();
    return _tmp1422;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutExpo(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1430 = t;
    hml_retain_if_needed(&_tmp1430);
    HmlValue _tmp1431 = hml_val_f64(1);
    HmlValue _tmp1429 = hml_both_i32(_tmp1430, _tmp1431) ? hml_i32_eq(_tmp1430, _tmp1431) : (hml_both_i64(_tmp1430, _tmp1431) ? hml_i64_eq(_tmp1430, _tmp1431) : hml_binary_op(HML_OP_EQUAL, _tmp1430, _tmp1431));
    hml_release_if_needed(&_tmp1430);
    hml_release_if_needed(&_tmp1431);
    if (hml_to_bool(_tmp1429)) {
        {
            HmlValue _tmp1432 = hml_val_f64(1);
            HML_CALL_EXIT();
            return _tmp1432;
        }
    }
    hml_release(&_tmp1429);
    HmlValue _tmp1434 = hml_val_f64(1);
    HmlValue _tmp1436 = hml_val_f64(2);
    HmlValue _tmp1439 = hml_val_f64(10);
    HmlValue _tmp1438 = hml_unary_op(HML_UNARY_NEGATE, _tmp1439);
    hml_release_if_needed(&_tmp1439);
    HmlValue _tmp1440 = t;
    hml_retain_if_needed(&_tmp1440);
    HmlValue _tmp1437 = hml_both_i32(_tmp1438, _tmp1440) ? hml_i32_mul(_tmp1438, _tmp1440) : (hml_both_i64(_tmp1438, _tmp1440) ? hml_i64_mul(_tmp1438, _tmp1440) : hml_binary_op(HML_OP_MUL, _tmp1438, _tmp1440));
    hml_release_if_needed(&_tmp1438);
    hml_release_if_needed(&_tmp1440);
    HmlValue _tmp1435 = hml_pow(_tmp1436, _tmp1437);
    hml_release(&_tmp1436);
    hml_release(&_tmp1437);
    HmlValue _tmp1433 = hml_both_i32(_tmp1434, _tmp1435) ? hml_i32_sub(_tmp1434, _tmp1435) : (hml_both_i64(_tmp1434, _tmp1435) ? hml_i64_sub(_tmp1434, _tmp1435) : hml_binary_op(HML_OP_SUB, _tmp1434, _tmp1435));
    hml_release_if_needed(&_tmp1434);
    hml_release_if_needed(&_tmp1435);
    HML_CALL_EXIT();
    return _tmp1433;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutExpo(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1442 = t;
    hml_retain_if_needed(&_tmp1442);
    HmlValue _tmp1443 = hml_val_f64(0);
    HmlValue _tmp1441 = hml_both_i32(_tmp1442, _tmp1443) ? hml_i32_eq(_tmp1442, _tmp1443) : (hml_both_i64(_tmp1442, _tmp1443) ? hml_i64_eq(_tmp1442, _tmp1443) : hml_binary_op(HML_OP_EQUAL, _tmp1442, _tmp1443));
    hml_release_if_needed(&_tmp1442);
    hml_release_if_needed(&_tmp1443);
    if (hml_to_bool(_tmp1441)) {
        {
            HmlValue _tmp1444 = hml_val_f64(0);
            HML_CALL_EXIT();
            return _tmp1444;
        }
    }
    hml_release(&_tmp1441);
    HmlValue _tmp1446 = t;
    hml_retain_if_needed(&_tmp1446);
    HmlValue _tmp1447 = hml_val_f64(1);
    HmlValue _tmp1445 = hml_both_i32(_tmp1446, _tmp1447) ? hml_i32_eq(_tmp1446, _tmp1447) : (hml_both_i64(_tmp1446, _tmp1447) ? hml_i64_eq(_tmp1446, _tmp1447) : hml_binary_op(HML_OP_EQUAL, _tmp1446, _tmp1447));
    hml_release_if_needed(&_tmp1446);
    hml_release_if_needed(&_tmp1447);
    if (hml_to_bool(_tmp1445)) {
        {
            HmlValue _tmp1448 = hml_val_f64(1);
            HML_CALL_EXIT();
            return _tmp1448;
        }
    }
    hml_release(&_tmp1445);
    HmlValue _tmp1450 = t;
    hml_retain_if_needed(&_tmp1450);
    HmlValue _tmp1451 = hml_val_f64(0.5);
    HmlValue _tmp1449 = hml_both_i32(_tmp1450, _tmp1451) ? hml_i32_lt(_tmp1450, _tmp1451) : (hml_both_i64(_tmp1450, _tmp1451) ? hml_i64_lt(_tmp1450, _tmp1451) : hml_binary_op(HML_OP_LESS, _tmp1450, _tmp1451));
    hml_release_if_needed(&_tmp1450);
    hml_release_if_needed(&_tmp1451);
    if (hml_to_bool(_tmp1449)) {
        {
            HmlValue _tmp1453 = hml_val_f64(0.5);
            HmlValue _tmp1455 = hml_val_f64(2);
            HmlValue _tmp1458 = hml_val_f64(20);
            HmlValue _tmp1459 = t;
            hml_retain_if_needed(&_tmp1459);
            HmlValue _tmp1457 = hml_both_i32(_tmp1458, _tmp1459) ? hml_i32_mul(_tmp1458, _tmp1459) : (hml_both_i64(_tmp1458, _tmp1459) ? hml_i64_mul(_tmp1458, _tmp1459) : hml_binary_op(HML_OP_MUL, _tmp1458, _tmp1459));
            hml_release_if_needed(&_tmp1458);
            hml_release_if_needed(&_tmp1459);
            HmlValue _tmp1460 = hml_val_f64(10);
            HmlValue _tmp1456 = hml_both_i32(_tmp1457, _tmp1460) ? hml_i32_sub(_tmp1457, _tmp1460) : (hml_both_i64(_tmp1457, _tmp1460) ? hml_i64_sub(_tmp1457, _tmp1460) : hml_binary_op(HML_OP_SUB, _tmp1457, _tmp1460));
            hml_release_if_needed(&_tmp1457);
            hml_release_if_needed(&_tmp1460);
            HmlValue _tmp1454 = hml_pow(_tmp1455, _tmp1456);
            hml_release(&_tmp1455);
            hml_release(&_tmp1456);
            HmlValue _tmp1452 = hml_both_i32(_tmp1453, _tmp1454) ? hml_i32_mul(_tmp1453, _tmp1454) : (hml_both_i64(_tmp1453, _tmp1454) ? hml_i64_mul(_tmp1453, _tmp1454) : hml_binary_op(HML_OP_MUL, _tmp1453, _tmp1454));
            hml_release_if_needed(&_tmp1453);
            hml_release_if_needed(&_tmp1454);
            HML_CALL_EXIT();
            return _tmp1452;
        }
    }
    hml_release(&_tmp1449);
    HmlValue _tmp1462 = hml_val_f64(1);
    HmlValue _tmp1464 = hml_val_f64(0.5);
    HmlValue _tmp1466 = hml_val_f64(2);
    HmlValue _tmp1470 = hml_val_f64(20);
    HmlValue _tmp1469 = hml_unary_op(HML_UNARY_NEGATE, _tmp1470);
    hml_release_if_needed(&_tmp1470);
    HmlValue _tmp1471 = t;
    hml_retain_if_needed(&_tmp1471);
    HmlValue _tmp1468 = hml_both_i32(_tmp1469, _tmp1471) ? hml_i32_mul(_tmp1469, _tmp1471) : (hml_both_i64(_tmp1469, _tmp1471) ? hml_i64_mul(_tmp1469, _tmp1471) : hml_binary_op(HML_OP_MUL, _tmp1469, _tmp1471));
    hml_release_if_needed(&_tmp1469);
    hml_release_if_needed(&_tmp1471);
    HmlValue _tmp1472 = hml_val_f64(10);
    HmlValue _tmp1467 = hml_both_i32(_tmp1468, _tmp1472) ? hml_i32_add(_tmp1468, _tmp1472) : (hml_both_i64(_tmp1468, _tmp1472) ? hml_i64_add(_tmp1468, _tmp1472) : hml_binary_op(HML_OP_ADD, _tmp1468, _tmp1472));
    hml_release_if_needed(&_tmp1468);
    hml_release_if_needed(&_tmp1472);
    HmlValue _tmp1465 = hml_pow(_tmp1466, _tmp1467);
    hml_release(&_tmp1466);
    hml_release(&_tmp1467);
    HmlValue _tmp1463 = hml_both_i32(_tmp1464, _tmp1465) ? hml_i32_mul(_tmp1464, _tmp1465) : (hml_both_i64(_tmp1464, _tmp1465) ? hml_i64_mul(_tmp1464, _tmp1465) : hml_binary_op(HML_OP_MUL, _tmp1464, _tmp1465));
    hml_release_if_needed(&_tmp1464);
    hml_release_if_needed(&_tmp1465);
    HmlValue _tmp1461 = hml_both_i32(_tmp1462, _tmp1463) ? hml_i32_sub(_tmp1462, _tmp1463) : (hml_both_i64(_tmp1462, _tmp1463) ? hml_i64_sub(_tmp1462, _tmp1463) : hml_binary_op(HML_OP_SUB, _tmp1462, _tmp1463));
    hml_release_if_needed(&_tmp1462);
    hml_release_if_needed(&_tmp1463);
    HML_CALL_EXIT();
    return _tmp1461;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInCirc(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1474 = hml_val_f64(1);
    HmlValue _tmp1477 = hml_val_f64(1);
    HmlValue _tmp1479 = t;
    hml_retain_if_needed(&_tmp1479);
    HmlValue _tmp1480 = t;
    hml_retain_if_needed(&_tmp1480);
    HmlValue _tmp1478 = hml_both_i32(_tmp1479, _tmp1480) ? hml_i32_mul(_tmp1479, _tmp1480) : (hml_both_i64(_tmp1479, _tmp1480) ? hml_i64_mul(_tmp1479, _tmp1480) : hml_binary_op(HML_OP_MUL, _tmp1479, _tmp1480));
    hml_release_if_needed(&_tmp1479);
    hml_release_if_needed(&_tmp1480);
    HmlValue _tmp1476 = hml_both_i32(_tmp1477, _tmp1478) ? hml_i32_sub(_tmp1477, _tmp1478) : (hml_both_i64(_tmp1477, _tmp1478) ? hml_i64_sub(_tmp1477, _tmp1478) : hml_binary_op(HML_OP_SUB, _tmp1477, _tmp1478));
    hml_release_if_needed(&_tmp1477);
    hml_release_if_needed(&_tmp1478);
    HmlValue _tmp1475 = hml_sqrt(_tmp1476);
    hml_release(&_tmp1476);
    HmlValue _tmp1473 = hml_both_i32(_tmp1474, _tmp1475) ? hml_i32_sub(_tmp1474, _tmp1475) : (hml_both_i64(_tmp1474, _tmp1475) ? hml_i64_sub(_tmp1474, _tmp1475) : hml_binary_op(HML_OP_SUB, _tmp1474, _tmp1475));
    hml_release_if_needed(&_tmp1474);
    hml_release_if_needed(&_tmp1475);
    HML_CALL_EXIT();
    return _tmp1473;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutCirc(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1482 = t;
    hml_retain_if_needed(&_tmp1482);
    HmlValue _tmp1483 = hml_val_f64(1);
    HmlValue _tmp1481 = hml_both_i32(_tmp1482, _tmp1483) ? hml_i32_sub(_tmp1482, _tmp1483) : (hml_both_i64(_tmp1482, _tmp1483) ? hml_i64_sub(_tmp1482, _tmp1483) : hml_binary_op(HML_OP_SUB, _tmp1482, _tmp1483));
    hml_release_if_needed(&_tmp1482);
    hml_release_if_needed(&_tmp1483);
    HmlValue t1 = _tmp1481;
    HmlValue _tmp1486 = hml_val_f64(1);
    HmlValue _tmp1488 = t1;
    hml_retain_if_needed(&_tmp1488);
    HmlValue _tmp1489 = t1;
    hml_retain_if_needed(&_tmp1489);
    HmlValue _tmp1487 = hml_both_i32(_tmp1488, _tmp1489) ? hml_i32_mul(_tmp1488, _tmp1489) : (hml_both_i64(_tmp1488, _tmp1489) ? hml_i64_mul(_tmp1488, _tmp1489) : hml_binary_op(HML_OP_MUL, _tmp1488, _tmp1489));
    hml_release_if_needed(&_tmp1488);
    hml_release_if_needed(&_tmp1489);
    HmlValue _tmp1485 = hml_both_i32(_tmp1486, _tmp1487) ? hml_i32_sub(_tmp1486, _tmp1487) : (hml_both_i64(_tmp1486, _tmp1487) ? hml_i64_sub(_tmp1486, _tmp1487) : hml_binary_op(HML_OP_SUB, _tmp1486, _tmp1487));
    hml_release_if_needed(&_tmp1486);
    hml_release_if_needed(&_tmp1487);
    HmlValue _tmp1484 = hml_sqrt(_tmp1485);
    hml_release(&_tmp1485);
    HML_CALL_EXIT();
    return _tmp1484;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutCirc(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1491 = t;
    hml_retain_if_needed(&_tmp1491);
    HmlValue _tmp1492 = hml_val_f64(0.5);
    HmlValue _tmp1490 = hml_both_i32(_tmp1491, _tmp1492) ? hml_i32_lt(_tmp1491, _tmp1492) : (hml_both_i64(_tmp1491, _tmp1492) ? hml_i64_lt(_tmp1491, _tmp1492) : hml_binary_op(HML_OP_LESS, _tmp1491, _tmp1492));
    hml_release_if_needed(&_tmp1491);
    hml_release_if_needed(&_tmp1492);
    if (hml_to_bool(_tmp1490)) {
        {
            HmlValue _tmp1494 = hml_val_f64(0.5);
            HmlValue _tmp1496 = hml_val_f64(1);
            HmlValue _tmp1499 = hml_val_f64(1);
            HmlValue _tmp1502 = hml_val_f64(4);
            HmlValue _tmp1503 = t;
            hml_retain_if_needed(&_tmp1503);
            HmlValue _tmp1501 = hml_both_i32(_tmp1502, _tmp1503) ? hml_i32_mul(_tmp1502, _tmp1503) : (hml_both_i64(_tmp1502, _tmp1503) ? hml_i64_mul(_tmp1502, _tmp1503) : hml_binary_op(HML_OP_MUL, _tmp1502, _tmp1503));
            hml_release_if_needed(&_tmp1502);
            hml_release_if_needed(&_tmp1503);
            HmlValue _tmp1504 = t;
            hml_retain_if_needed(&_tmp1504);
            HmlValue _tmp1500 = hml_both_i32(_tmp1501, _tmp1504) ? hml_i32_mul(_tmp1501, _tmp1504) : (hml_both_i64(_tmp1501, _tmp1504) ? hml_i64_mul(_tmp1501, _tmp1504) : hml_binary_op(HML_OP_MUL, _tmp1501, _tmp1504));
            hml_release_if_needed(&_tmp1501);
            hml_release_if_needed(&_tmp1504);
            HmlValue _tmp1498 = hml_both_i32(_tmp1499, _tmp1500) ? hml_i32_sub(_tmp1499, _tmp1500) : (hml_both_i64(_tmp1499, _tmp1500) ? hml_i64_sub(_tmp1499, _tmp1500) : hml_binary_op(HML_OP_SUB, _tmp1499, _tmp1500));
            hml_release_if_needed(&_tmp1499);
            hml_release_if_needed(&_tmp1500);
            HmlValue _tmp1497 = hml_sqrt(_tmp1498);
            hml_release(&_tmp1498);
            HmlValue _tmp1495 = hml_both_i32(_tmp1496, _tmp1497) ? hml_i32_sub(_tmp1496, _tmp1497) : (hml_both_i64(_tmp1496, _tmp1497) ? hml_i64_sub(_tmp1496, _tmp1497) : hml_binary_op(HML_OP_SUB, _tmp1496, _tmp1497));
            hml_release_if_needed(&_tmp1496);
            hml_release_if_needed(&_tmp1497);
            HmlValue _tmp1493 = hml_both_i32(_tmp1494, _tmp1495) ? hml_i32_mul(_tmp1494, _tmp1495) : (hml_both_i64(_tmp1494, _tmp1495) ? hml_i64_mul(_tmp1494, _tmp1495) : hml_binary_op(HML_OP_MUL, _tmp1494, _tmp1495));
            hml_release_if_needed(&_tmp1494);
            hml_release_if_needed(&_tmp1495);
            HML_CALL_EXIT();
            return _tmp1493;
        }
    }
    hml_release(&_tmp1490);
    HmlValue _tmp1507 = hml_val_f64(2);
    HmlValue _tmp1508 = t;
    hml_retain_if_needed(&_tmp1508);
    HmlValue _tmp1506 = hml_both_i32(_tmp1507, _tmp1508) ? hml_i32_mul(_tmp1507, _tmp1508) : (hml_both_i64(_tmp1507, _tmp1508) ? hml_i64_mul(_tmp1507, _tmp1508) : hml_binary_op(HML_OP_MUL, _tmp1507, _tmp1508));
    hml_release_if_needed(&_tmp1507);
    hml_release_if_needed(&_tmp1508);
    HmlValue _tmp1509 = hml_val_f64(2);
    HmlValue _tmp1505 = hml_both_i32(_tmp1506, _tmp1509) ? hml_i32_sub(_tmp1506, _tmp1509) : (hml_both_i64(_tmp1506, _tmp1509) ? hml_i64_sub(_tmp1506, _tmp1509) : hml_binary_op(HML_OP_SUB, _tmp1506, _tmp1509));
    hml_release_if_needed(&_tmp1506);
    hml_release_if_needed(&_tmp1509);
    HmlValue t1 = _tmp1505;
    HmlValue _tmp1511 = hml_val_f64(0.5);
    HmlValue _tmp1515 = hml_val_f64(1);
    HmlValue _tmp1517 = t1;
    hml_retain_if_needed(&_tmp1517);
    HmlValue _tmp1518 = t1;
    hml_retain_if_needed(&_tmp1518);
    HmlValue _tmp1516 = hml_both_i32(_tmp1517, _tmp1518) ? hml_i32_mul(_tmp1517, _tmp1518) : (hml_both_i64(_tmp1517, _tmp1518) ? hml_i64_mul(_tmp1517, _tmp1518) : hml_binary_op(HML_OP_MUL, _tmp1517, _tmp1518));
    hml_release_if_needed(&_tmp1517);
    hml_release_if_needed(&_tmp1518);
    HmlValue _tmp1514 = hml_both_i32(_tmp1515, _tmp1516) ? hml_i32_sub(_tmp1515, _tmp1516) : (hml_both_i64(_tmp1515, _tmp1516) ? hml_i64_sub(_tmp1515, _tmp1516) : hml_binary_op(HML_OP_SUB, _tmp1515, _tmp1516));
    hml_release_if_needed(&_tmp1515);
    hml_release_if_needed(&_tmp1516);
    HmlValue _tmp1513 = hml_sqrt(_tmp1514);
    hml_release(&_tmp1514);
    HmlValue _tmp1519 = hml_val_f64(1);
    HmlValue _tmp1512 = hml_both_i32(_tmp1513, _tmp1519) ? hml_i32_add(_tmp1513, _tmp1519) : (hml_both_i64(_tmp1513, _tmp1519) ? hml_i64_add(_tmp1513, _tmp1519) : hml_binary_op(HML_OP_ADD, _tmp1513, _tmp1519));
    hml_release_if_needed(&_tmp1513);
    hml_release_if_needed(&_tmp1519);
    HmlValue _tmp1510 = hml_both_i32(_tmp1511, _tmp1512) ? hml_i32_mul(_tmp1511, _tmp1512) : (hml_both_i64(_tmp1511, _tmp1512) ? hml_i64_mul(_tmp1511, _tmp1512) : hml_binary_op(HML_OP_MUL, _tmp1511, _tmp1512));
    hml_release_if_needed(&_tmp1511);
    hml_release_if_needed(&_tmp1512);
    HML_CALL_EXIT();
    return _tmp1510;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInBack(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1520 = hml_val_f64(1.70158);
    HmlValue c1 = _tmp1520;
    HmlValue _tmp1522 = c1;
    hml_retain_if_needed(&_tmp1522);
    HmlValue _tmp1523 = hml_val_f64(1);
    HmlValue _tmp1521 = hml_both_i32(_tmp1522, _tmp1523) ? hml_i32_add(_tmp1522, _tmp1523) : (hml_both_i64(_tmp1522, _tmp1523) ? hml_i64_add(_tmp1522, _tmp1523) : hml_binary_op(HML_OP_ADD, _tmp1522, _tmp1523));
    hml_release_if_needed(&_tmp1522);
    hml_release_if_needed(&_tmp1523);
    HmlValue c3 = _tmp1521;
    HmlValue _tmp1528 = c3;
    hml_retain_if_needed(&_tmp1528);
    HmlValue _tmp1529 = t;
    hml_retain_if_needed(&_tmp1529);
    HmlValue _tmp1527 = hml_both_i32(_tmp1528, _tmp1529) ? hml_i32_mul(_tmp1528, _tmp1529) : (hml_both_i64(_tmp1528, _tmp1529) ? hml_i64_mul(_tmp1528, _tmp1529) : hml_binary_op(HML_OP_MUL, _tmp1528, _tmp1529));
    hml_release_if_needed(&_tmp1528);
    hml_release_if_needed(&_tmp1529);
    HmlValue _tmp1530 = t;
    hml_retain_if_needed(&_tmp1530);
    HmlValue _tmp1526 = hml_both_i32(_tmp1527, _tmp1530) ? hml_i32_mul(_tmp1527, _tmp1530) : (hml_both_i64(_tmp1527, _tmp1530) ? hml_i64_mul(_tmp1527, _tmp1530) : hml_binary_op(HML_OP_MUL, _tmp1527, _tmp1530));
    hml_release_if_needed(&_tmp1527);
    hml_release_if_needed(&_tmp1530);
    HmlValue _tmp1531 = t;
    hml_retain_if_needed(&_tmp1531);
    HmlValue _tmp1525 = hml_both_i32(_tmp1526, _tmp1531) ? hml_i32_mul(_tmp1526, _tmp1531) : (hml_both_i64(_tmp1526, _tmp1531) ? hml_i64_mul(_tmp1526, _tmp1531) : hml_binary_op(HML_OP_MUL, _tmp1526, _tmp1531));
    hml_release_if_needed(&_tmp1526);
    hml_release_if_needed(&_tmp1531);
    HmlValue _tmp1534 = c1;
    hml_retain_if_needed(&_tmp1534);
    HmlValue _tmp1535 = t;
    hml_retain_if_needed(&_tmp1535);
    HmlValue _tmp1533 = hml_both_i32(_tmp1534, _tmp1535) ? hml_i32_mul(_tmp1534, _tmp1535) : (hml_both_i64(_tmp1534, _tmp1535) ? hml_i64_mul(_tmp1534, _tmp1535) : hml_binary_op(HML_OP_MUL, _tmp1534, _tmp1535));
    hml_release_if_needed(&_tmp1534);
    hml_release_if_needed(&_tmp1535);
    HmlValue _tmp1536 = t;
    hml_retain_if_needed(&_tmp1536);
    HmlValue _tmp1532 = hml_both_i32(_tmp1533, _tmp1536) ? hml_i32_mul(_tmp1533, _tmp1536) : (hml_both_i64(_tmp1533, _tmp1536) ? hml_i64_mul(_tmp1533, _tmp1536) : hml_binary_op(HML_OP_MUL, _tmp1533, _tmp1536));
    hml_release_if_needed(&_tmp1533);
    hml_release_if_needed(&_tmp1536);
    HmlValue _tmp1524 = hml_both_i32(_tmp1525, _tmp1532) ? hml_i32_sub(_tmp1525, _tmp1532) : (hml_both_i64(_tmp1525, _tmp1532) ? hml_i64_sub(_tmp1525, _tmp1532) : hml_binary_op(HML_OP_SUB, _tmp1525, _tmp1532));
    hml_release_if_needed(&_tmp1525);
    hml_release_if_needed(&_tmp1532);
    HML_CALL_EXIT();
    return _tmp1524;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutBack(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1537 = hml_val_f64(1.70158);
    HmlValue c1 = _tmp1537;
    HmlValue _tmp1539 = c1;
    hml_retain_if_needed(&_tmp1539);
    HmlValue _tmp1540 = hml_val_f64(1);
    HmlValue _tmp1538 = hml_both_i32(_tmp1539, _tmp1540) ? hml_i32_add(_tmp1539, _tmp1540) : (hml_both_i64(_tmp1539, _tmp1540) ? hml_i64_add(_tmp1539, _tmp1540) : hml_binary_op(HML_OP_ADD, _tmp1539, _tmp1540));
    hml_release_if_needed(&_tmp1539);
    hml_release_if_needed(&_tmp1540);
    HmlValue c3 = _tmp1538;
    HmlValue _tmp1542 = t;
    hml_retain_if_needed(&_tmp1542);
    HmlValue _tmp1543 = hml_val_f64(1);
    HmlValue _tmp1541 = hml_both_i32(_tmp1542, _tmp1543) ? hml_i32_sub(_tmp1542, _tmp1543) : (hml_both_i64(_tmp1542, _tmp1543) ? hml_i64_sub(_tmp1542, _tmp1543) : hml_binary_op(HML_OP_SUB, _tmp1542, _tmp1543));
    hml_release_if_needed(&_tmp1542);
    hml_release_if_needed(&_tmp1543);
    HmlValue t1 = _tmp1541;
    HmlValue _tmp1546 = hml_val_f64(1);
    HmlValue _tmp1550 = c3;
    hml_retain_if_needed(&_tmp1550);
    HmlValue _tmp1551 = t1;
    hml_retain_if_needed(&_tmp1551);
    HmlValue _tmp1549 = hml_both_i32(_tmp1550, _tmp1551) ? hml_i32_mul(_tmp1550, _tmp1551) : (hml_both_i64(_tmp1550, _tmp1551) ? hml_i64_mul(_tmp1550, _tmp1551) : hml_binary_op(HML_OP_MUL, _tmp1550, _tmp1551));
    hml_release_if_needed(&_tmp1550);
    hml_release_if_needed(&_tmp1551);
    HmlValue _tmp1552 = t1;
    hml_retain_if_needed(&_tmp1552);
    HmlValue _tmp1548 = hml_both_i32(_tmp1549, _tmp1552) ? hml_i32_mul(_tmp1549, _tmp1552) : (hml_both_i64(_tmp1549, _tmp1552) ? hml_i64_mul(_tmp1549, _tmp1552) : hml_binary_op(HML_OP_MUL, _tmp1549, _tmp1552));
    hml_release_if_needed(&_tmp1549);
    hml_release_if_needed(&_tmp1552);
    HmlValue _tmp1553 = t1;
    hml_retain_if_needed(&_tmp1553);
    HmlValue _tmp1547 = hml_both_i32(_tmp1548, _tmp1553) ? hml_i32_mul(_tmp1548, _tmp1553) : (hml_both_i64(_tmp1548, _tmp1553) ? hml_i64_mul(_tmp1548, _tmp1553) : hml_binary_op(HML_OP_MUL, _tmp1548, _tmp1553));
    hml_release_if_needed(&_tmp1548);
    hml_release_if_needed(&_tmp1553);
    HmlValue _tmp1545 = hml_both_i32(_tmp1546, _tmp1547) ? hml_i32_add(_tmp1546, _tmp1547) : (hml_both_i64(_tmp1546, _tmp1547) ? hml_i64_add(_tmp1546, _tmp1547) : hml_binary_op(HML_OP_ADD, _tmp1546, _tmp1547));
    hml_release_if_needed(&_tmp1546);
    hml_release_if_needed(&_tmp1547);
    HmlValue _tmp1556 = c1;
    hml_retain_if_needed(&_tmp1556);
    HmlValue _tmp1557 = t1;
    hml_retain_if_needed(&_tmp1557);
    HmlValue _tmp1555 = hml_both_i32(_tmp1556, _tmp1557) ? hml_i32_mul(_tmp1556, _tmp1557) : (hml_both_i64(_tmp1556, _tmp1557) ? hml_i64_mul(_tmp1556, _tmp1557) : hml_binary_op(HML_OP_MUL, _tmp1556, _tmp1557));
    hml_release_if_needed(&_tmp1556);
    hml_release_if_needed(&_tmp1557);
    HmlValue _tmp1558 = t1;
    hml_retain_if_needed(&_tmp1558);
    HmlValue _tmp1554 = hml_both_i32(_tmp1555, _tmp1558) ? hml_i32_mul(_tmp1555, _tmp1558) : (hml_both_i64(_tmp1555, _tmp1558) ? hml_i64_mul(_tmp1555, _tmp1558) : hml_binary_op(HML_OP_MUL, _tmp1555, _tmp1558));
    hml_release_if_needed(&_tmp1555);
    hml_release_if_needed(&_tmp1558);
    HmlValue _tmp1544 = hml_both_i32(_tmp1545, _tmp1554) ? hml_i32_add(_tmp1545, _tmp1554) : (hml_both_i64(_tmp1545, _tmp1554) ? hml_i64_add(_tmp1545, _tmp1554) : hml_binary_op(HML_OP_ADD, _tmp1545, _tmp1554));
    hml_release_if_needed(&_tmp1545);
    hml_release_if_needed(&_tmp1554);
    HML_CALL_EXIT();
    return _tmp1544;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutBack(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1559 = hml_val_f64(1.70158);
    HmlValue c1 = _tmp1559;
    HmlValue _tmp1561 = c1;
    hml_retain_if_needed(&_tmp1561);
    HmlValue _tmp1562 = hml_val_f64(1.525);
    HmlValue _tmp1560 = hml_both_i32(_tmp1561, _tmp1562) ? hml_i32_mul(_tmp1561, _tmp1562) : (hml_both_i64(_tmp1561, _tmp1562) ? hml_i64_mul(_tmp1561, _tmp1562) : hml_binary_op(HML_OP_MUL, _tmp1561, _tmp1562));
    hml_release_if_needed(&_tmp1561);
    hml_release_if_needed(&_tmp1562);
    HmlValue c2 = _tmp1560;
    HmlValue _tmp1564 = t;
    hml_retain_if_needed(&_tmp1564);
    HmlValue _tmp1565 = hml_val_f64(0.5);
    HmlValue _tmp1563 = hml_both_i32(_tmp1564, _tmp1565) ? hml_i32_lt(_tmp1564, _tmp1565) : (hml_both_i64(_tmp1564, _tmp1565) ? hml_i64_lt(_tmp1564, _tmp1565) : hml_binary_op(HML_OP_LESS, _tmp1564, _tmp1565));
    hml_release_if_needed(&_tmp1564);
    hml_release_if_needed(&_tmp1565);
    if (hml_to_bool(_tmp1563)) {
        {
            HmlValue _tmp1567 = hml_val_f64(0.5);
            HmlValue _tmp1571 = hml_val_f64(4);
            HmlValue _tmp1572 = t;
            hml_retain_if_needed(&_tmp1572);
            HmlValue _tmp1570 = hml_both_i32(_tmp1571, _tmp1572) ? hml_i32_mul(_tmp1571, _tmp1572) : (hml_both_i64(_tmp1571, _tmp1572) ? hml_i64_mul(_tmp1571, _tmp1572) : hml_binary_op(HML_OP_MUL, _tmp1571, _tmp1572));
            hml_release_if_needed(&_tmp1571);
            hml_release_if_needed(&_tmp1572);
            HmlValue _tmp1573 = t;
            hml_retain_if_needed(&_tmp1573);
            HmlValue _tmp1569 = hml_both_i32(_tmp1570, _tmp1573) ? hml_i32_mul(_tmp1570, _tmp1573) : (hml_both_i64(_tmp1570, _tmp1573) ? hml_i64_mul(_tmp1570, _tmp1573) : hml_binary_op(HML_OP_MUL, _tmp1570, _tmp1573));
            hml_release_if_needed(&_tmp1570);
            hml_release_if_needed(&_tmp1573);
            HmlValue _tmp1578 = c2;
            hml_retain_if_needed(&_tmp1578);
            HmlValue _tmp1579 = hml_val_f64(1);
            HmlValue _tmp1577 = hml_both_i32(_tmp1578, _tmp1579) ? hml_i32_add(_tmp1578, _tmp1579) : (hml_both_i64(_tmp1578, _tmp1579) ? hml_i64_add(_tmp1578, _tmp1579) : hml_binary_op(HML_OP_ADD, _tmp1578, _tmp1579));
            hml_release_if_needed(&_tmp1578);
            hml_release_if_needed(&_tmp1579);
            HmlValue _tmp1580 = hml_val_f64(2);
            HmlValue _tmp1576 = hml_both_i32(_tmp1577, _tmp1580) ? hml_i32_mul(_tmp1577, _tmp1580) : (hml_both_i64(_tmp1577, _tmp1580) ? hml_i64_mul(_tmp1577, _tmp1580) : hml_binary_op(HML_OP_MUL, _tmp1577, _tmp1580));
            hml_release_if_needed(&_tmp1577);
            hml_release_if_needed(&_tmp1580);
            HmlValue _tmp1581 = t;
            hml_retain_if_needed(&_tmp1581);
            HmlValue _tmp1575 = hml_both_i32(_tmp1576, _tmp1581) ? hml_i32_mul(_tmp1576, _tmp1581) : (hml_both_i64(_tmp1576, _tmp1581) ? hml_i64_mul(_tmp1576, _tmp1581) : hml_binary_op(HML_OP_MUL, _tmp1576, _tmp1581));
            hml_release_if_needed(&_tmp1576);
            hml_release_if_needed(&_tmp1581);
            HmlValue _tmp1582 = c2;
            hml_retain_if_needed(&_tmp1582);
            HmlValue _tmp1574 = hml_both_i32(_tmp1575, _tmp1582) ? hml_i32_sub(_tmp1575, _tmp1582) : (hml_both_i64(_tmp1575, _tmp1582) ? hml_i64_sub(_tmp1575, _tmp1582) : hml_binary_op(HML_OP_SUB, _tmp1575, _tmp1582));
            hml_release_if_needed(&_tmp1575);
            hml_release_if_needed(&_tmp1582);
            HmlValue _tmp1568 = hml_both_i32(_tmp1569, _tmp1574) ? hml_i32_mul(_tmp1569, _tmp1574) : (hml_both_i64(_tmp1569, _tmp1574) ? hml_i64_mul(_tmp1569, _tmp1574) : hml_binary_op(HML_OP_MUL, _tmp1569, _tmp1574));
            hml_release_if_needed(&_tmp1569);
            hml_release_if_needed(&_tmp1574);
            HmlValue _tmp1566 = hml_both_i32(_tmp1567, _tmp1568) ? hml_i32_mul(_tmp1567, _tmp1568) : (hml_both_i64(_tmp1567, _tmp1568) ? hml_i64_mul(_tmp1567, _tmp1568) : hml_binary_op(HML_OP_MUL, _tmp1567, _tmp1568));
            hml_release_if_needed(&_tmp1567);
            hml_release_if_needed(&_tmp1568);
            HML_CALL_EXIT();
            return _tmp1566;
        }
    }
    hml_release(&_tmp1563);
    HmlValue _tmp1585 = hml_val_f64(2);
    HmlValue _tmp1586 = t;
    hml_retain_if_needed(&_tmp1586);
    HmlValue _tmp1584 = hml_both_i32(_tmp1585, _tmp1586) ? hml_i32_mul(_tmp1585, _tmp1586) : (hml_both_i64(_tmp1585, _tmp1586) ? hml_i64_mul(_tmp1585, _tmp1586) : hml_binary_op(HML_OP_MUL, _tmp1585, _tmp1586));
    hml_release_if_needed(&_tmp1585);
    hml_release_if_needed(&_tmp1586);
    HmlValue _tmp1587 = hml_val_f64(2);
    HmlValue _tmp1583 = hml_both_i32(_tmp1584, _tmp1587) ? hml_i32_sub(_tmp1584, _tmp1587) : (hml_both_i64(_tmp1584, _tmp1587) ? hml_i64_sub(_tmp1584, _tmp1587) : hml_binary_op(HML_OP_SUB, _tmp1584, _tmp1587));
    hml_release_if_needed(&_tmp1584);
    hml_release_if_needed(&_tmp1587);
    HmlValue t1 = _tmp1583;
    HmlValue _tmp1589 = hml_val_f64(0.5);
    HmlValue _tmp1593 = t1;
    hml_retain_if_needed(&_tmp1593);
    HmlValue _tmp1594 = t1;
    hml_retain_if_needed(&_tmp1594);
    HmlValue _tmp1592 = hml_both_i32(_tmp1593, _tmp1594) ? hml_i32_mul(_tmp1593, _tmp1594) : (hml_both_i64(_tmp1593, _tmp1594) ? hml_i64_mul(_tmp1593, _tmp1594) : hml_binary_op(HML_OP_MUL, _tmp1593, _tmp1594));
    hml_release_if_needed(&_tmp1593);
    hml_release_if_needed(&_tmp1594);
    HmlValue _tmp1598 = c2;
    hml_retain_if_needed(&_tmp1598);
    HmlValue _tmp1599 = hml_val_f64(1);
    HmlValue _tmp1597 = hml_both_i32(_tmp1598, _tmp1599) ? hml_i32_add(_tmp1598, _tmp1599) : (hml_both_i64(_tmp1598, _tmp1599) ? hml_i64_add(_tmp1598, _tmp1599) : hml_binary_op(HML_OP_ADD, _tmp1598, _tmp1599));
    hml_release_if_needed(&_tmp1598);
    hml_release_if_needed(&_tmp1599);
    HmlValue _tmp1600 = t1;
    hml_retain_if_needed(&_tmp1600);
    HmlValue _tmp1596 = hml_both_i32(_tmp1597, _tmp1600) ? hml_i32_mul(_tmp1597, _tmp1600) : (hml_both_i64(_tmp1597, _tmp1600) ? hml_i64_mul(_tmp1597, _tmp1600) : hml_binary_op(HML_OP_MUL, _tmp1597, _tmp1600));
    hml_release_if_needed(&_tmp1597);
    hml_release_if_needed(&_tmp1600);
    HmlValue _tmp1601 = c2;
    hml_retain_if_needed(&_tmp1601);
    HmlValue _tmp1595 = hml_both_i32(_tmp1596, _tmp1601) ? hml_i32_add(_tmp1596, _tmp1601) : (hml_both_i64(_tmp1596, _tmp1601) ? hml_i64_add(_tmp1596, _tmp1601) : hml_binary_op(HML_OP_ADD, _tmp1596, _tmp1601));
    hml_release_if_needed(&_tmp1596);
    hml_release_if_needed(&_tmp1601);
    HmlValue _tmp1591 = hml_both_i32(_tmp1592, _tmp1595) ? hml_i32_mul(_tmp1592, _tmp1595) : (hml_both_i64(_tmp1592, _tmp1595) ? hml_i64_mul(_tmp1592, _tmp1595) : hml_binary_op(HML_OP_MUL, _tmp1592, _tmp1595));
    hml_release_if_needed(&_tmp1592);
    hml_release_if_needed(&_tmp1595);
    HmlValue _tmp1602 = hml_val_f64(2);
    HmlValue _tmp1590 = hml_both_i32(_tmp1591, _tmp1602) ? hml_i32_add(_tmp1591, _tmp1602) : (hml_both_i64(_tmp1591, _tmp1602) ? hml_i64_add(_tmp1591, _tmp1602) : hml_binary_op(HML_OP_ADD, _tmp1591, _tmp1602));
    hml_release_if_needed(&_tmp1591);
    hml_release_if_needed(&_tmp1602);
    HmlValue _tmp1588 = hml_both_i32(_tmp1589, _tmp1590) ? hml_i32_mul(_tmp1589, _tmp1590) : (hml_both_i64(_tmp1589, _tmp1590) ? hml_i64_mul(_tmp1589, _tmp1590) : hml_binary_op(HML_OP_MUL, _tmp1589, _tmp1590));
    hml_release_if_needed(&_tmp1589);
    hml_release_if_needed(&_tmp1590);
    HML_CALL_EXIT();
    return _tmp1588;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutBounce(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1603 = hml_val_f64(7.5625);
    HmlValue n1 = _tmp1603;
    HmlValue _tmp1604 = hml_val_f64(2.75);
    HmlValue d1 = _tmp1604;
    HmlValue _tmp1606 = t;
    hml_retain_if_needed(&_tmp1606);
    HmlValue _tmp1608 = hml_val_f64(1);
    HmlValue _tmp1609 = d1;
    hml_retain_if_needed(&_tmp1609);
    HmlValue _tmp1607 = hml_binary_op(HML_OP_DIV, _tmp1608, _tmp1609);
    hml_release_if_needed(&_tmp1608);
    hml_release_if_needed(&_tmp1609);
    HmlValue _tmp1605 = hml_both_i32(_tmp1606, _tmp1607) ? hml_i32_lt(_tmp1606, _tmp1607) : (hml_both_i64(_tmp1606, _tmp1607) ? hml_i64_lt(_tmp1606, _tmp1607) : hml_binary_op(HML_OP_LESS, _tmp1606, _tmp1607));
    hml_release_if_needed(&_tmp1606);
    hml_release_if_needed(&_tmp1607);
    if (hml_to_bool(_tmp1605)) {
        {
            HmlValue _tmp1612 = n1;
            hml_retain_if_needed(&_tmp1612);
            HmlValue _tmp1613 = t;
            hml_retain_if_needed(&_tmp1613);
            HmlValue _tmp1611 = hml_both_i32(_tmp1612, _tmp1613) ? hml_i32_mul(_tmp1612, _tmp1613) : (hml_both_i64(_tmp1612, _tmp1613) ? hml_i64_mul(_tmp1612, _tmp1613) : hml_binary_op(HML_OP_MUL, _tmp1612, _tmp1613));
            hml_release_if_needed(&_tmp1612);
            hml_release_if_needed(&_tmp1613);
            HmlValue _tmp1614 = t;
            hml_retain_if_needed(&_tmp1614);
            HmlValue _tmp1610 = hml_both_i32(_tmp1611, _tmp1614) ? hml_i32_mul(_tmp1611, _tmp1614) : (hml_both_i64(_tmp1611, _tmp1614) ? hml_i64_mul(_tmp1611, _tmp1614) : hml_binary_op(HML_OP_MUL, _tmp1611, _tmp1614));
            hml_release_if_needed(&_tmp1611);
            hml_release_if_needed(&_tmp1614);
            HML_CALL_EXIT();
            return _tmp1610;
        }
    } else {
        HmlValue _tmp1616 = t;
        hml_retain_if_needed(&_tmp1616);
        HmlValue _tmp1618 = hml_val_f64(2);
        HmlValue _tmp1619 = d1;
        hml_retain_if_needed(&_tmp1619);
        HmlValue _tmp1617 = hml_binary_op(HML_OP_DIV, _tmp1618, _tmp1619);
        hml_release_if_needed(&_tmp1618);
        hml_release_if_needed(&_tmp1619);
        HmlValue _tmp1615 = hml_both_i32(_tmp1616, _tmp1617) ? hml_i32_lt(_tmp1616, _tmp1617) : (hml_both_i64(_tmp1616, _tmp1617) ? hml_i64_lt(_tmp1616, _tmp1617) : hml_binary_op(HML_OP_LESS, _tmp1616, _tmp1617));
        hml_release_if_needed(&_tmp1616);
        hml_release_if_needed(&_tmp1617);
        if (hml_to_bool(_tmp1615)) {
            {
                HmlValue _tmp1621 = t;
                hml_retain_if_needed(&_tmp1621);
                HmlValue _tmp1623 = hml_val_f64(1.5);
                HmlValue _tmp1624 = d1;
                hml_retain_if_needed(&_tmp1624);
                HmlValue _tmp1622 = hml_binary_op(HML_OP_DIV, _tmp1623, _tmp1624);
                hml_release_if_needed(&_tmp1623);
                hml_release_if_needed(&_tmp1624);
                HmlValue _tmp1620 = hml_both_i32(_tmp1621, _tmp1622) ? hml_i32_sub(_tmp1621, _tmp1622) : (hml_both_i64(_tmp1621, _tmp1622) ? hml_i64_sub(_tmp1621, _tmp1622) : hml_binary_op(HML_OP_SUB, _tmp1621, _tmp1622));
                hml_release_if_needed(&_tmp1621);
                hml_release_if_needed(&_tmp1622);
                HmlValue t1 = _tmp1620;
                HmlValue _tmp1628 = n1;
                hml_retain_if_needed(&_tmp1628);
                HmlValue _tmp1629 = t1;
                hml_retain_if_needed(&_tmp1629);
                HmlValue _tmp1627 = hml_both_i32(_tmp1628, _tmp1629) ? hml_i32_mul(_tmp1628, _tmp1629) : (hml_both_i64(_tmp1628, _tmp1629) ? hml_i64_mul(_tmp1628, _tmp1629) : hml_binary_op(HML_OP_MUL, _tmp1628, _tmp1629));
                hml_release_if_needed(&_tmp1628);
                hml_release_if_needed(&_tmp1629);
                HmlValue _tmp1630 = t1;
                hml_retain_if_needed(&_tmp1630);
                HmlValue _tmp1626 = hml_both_i32(_tmp1627, _tmp1630) ? hml_i32_mul(_tmp1627, _tmp1630) : (hml_both_i64(_tmp1627, _tmp1630) ? hml_i64_mul(_tmp1627, _tmp1630) : hml_binary_op(HML_OP_MUL, _tmp1627, _tmp1630));
                hml_release_if_needed(&_tmp1627);
                hml_release_if_needed(&_tmp1630);
                HmlValue _tmp1631 = hml_val_f64(0.75);
                HmlValue _tmp1625 = hml_both_i32(_tmp1626, _tmp1631) ? hml_i32_add(_tmp1626, _tmp1631) : (hml_both_i64(_tmp1626, _tmp1631) ? hml_i64_add(_tmp1626, _tmp1631) : hml_binary_op(HML_OP_ADD, _tmp1626, _tmp1631));
                hml_release_if_needed(&_tmp1626);
                hml_release_if_needed(&_tmp1631);
                HML_CALL_EXIT();
                return _tmp1625;
            }
        } else {
            HmlValue _tmp1633 = t;
            hml_retain_if_needed(&_tmp1633);
            HmlValue _tmp1635 = hml_val_f64(2.5);
            HmlValue _tmp1636 = d1;
            hml_retain_if_needed(&_tmp1636);
            HmlValue _tmp1634 = hml_binary_op(HML_OP_DIV, _tmp1635, _tmp1636);
            hml_release_if_needed(&_tmp1635);
            hml_release_if_needed(&_tmp1636);
            HmlValue _tmp1632 = hml_both_i32(_tmp1633, _tmp1634) ? hml_i32_lt(_tmp1633, _tmp1634) : (hml_both_i64(_tmp1633, _tmp1634) ? hml_i64_lt(_tmp1633, _tmp1634) : hml_binary_op(HML_OP_LESS, _tmp1633, _tmp1634));
            hml_release_if_needed(&_tmp1633);
            hml_release_if_needed(&_tmp1634);
            if (hml_to_bool(_tmp1632)) {
                {
                    HmlValue _tmp1638 = t;
                    hml_retain_if_needed(&_tmp1638);
                    HmlValue _tmp1640 = hml_val_f64(2.25);
                    HmlValue _tmp1641 = d1;
                    hml_retain_if_needed(&_tmp1641);
                    HmlValue _tmp1639 = hml_binary_op(HML_OP_DIV, _tmp1640, _tmp1641);
                    hml_release_if_needed(&_tmp1640);
                    hml_release_if_needed(&_tmp1641);
                    HmlValue _tmp1637 = hml_both_i32(_tmp1638, _tmp1639) ? hml_i32_sub(_tmp1638, _tmp1639) : (hml_both_i64(_tmp1638, _tmp1639) ? hml_i64_sub(_tmp1638, _tmp1639) : hml_binary_op(HML_OP_SUB, _tmp1638, _tmp1639));
                    hml_release_if_needed(&_tmp1638);
                    hml_release_if_needed(&_tmp1639);
                    HmlValue t1 = _tmp1637;
                    HmlValue _tmp1645 = n1;
                    hml_retain_if_needed(&_tmp1645);
                    HmlValue _tmp1646 = t1;
                    hml_retain_if_needed(&_tmp1646);
                    HmlValue _tmp1644 = hml_both_i32(_tmp1645, _tmp1646) ? hml_i32_mul(_tmp1645, _tmp1646) : (hml_both_i64(_tmp1645, _tmp1646) ? hml_i64_mul(_tmp1645, _tmp1646) : hml_binary_op(HML_OP_MUL, _tmp1645, _tmp1646));
                    hml_release_if_needed(&_tmp1645);
                    hml_release_if_needed(&_tmp1646);
                    HmlValue _tmp1647 = t1;
                    hml_retain_if_needed(&_tmp1647);
                    HmlValue _tmp1643 = hml_both_i32(_tmp1644, _tmp1647) ? hml_i32_mul(_tmp1644, _tmp1647) : (hml_both_i64(_tmp1644, _tmp1647) ? hml_i64_mul(_tmp1644, _tmp1647) : hml_binary_op(HML_OP_MUL, _tmp1644, _tmp1647));
                    hml_release_if_needed(&_tmp1644);
                    hml_release_if_needed(&_tmp1647);
                    HmlValue _tmp1648 = hml_val_f64(0.9375);
                    HmlValue _tmp1642 = hml_both_i32(_tmp1643, _tmp1648) ? hml_i32_add(_tmp1643, _tmp1648) : (hml_both_i64(_tmp1643, _tmp1648) ? hml_i64_add(_tmp1643, _tmp1648) : hml_binary_op(HML_OP_ADD, _tmp1643, _tmp1648));
                    hml_release_if_needed(&_tmp1643);
                    hml_release_if_needed(&_tmp1648);
                    HML_CALL_EXIT();
                    return _tmp1642;
                }
            } else {
                {
                    HmlValue _tmp1650 = t;
                    hml_retain_if_needed(&_tmp1650);
                    HmlValue _tmp1652 = hml_val_f64(2.625);
                    HmlValue _tmp1653 = d1;
                    hml_retain_if_needed(&_tmp1653);
                    HmlValue _tmp1651 = hml_binary_op(HML_OP_DIV, _tmp1652, _tmp1653);
                    hml_release_if_needed(&_tmp1652);
                    hml_release_if_needed(&_tmp1653);
                    HmlValue _tmp1649 = hml_both_i32(_tmp1650, _tmp1651) ? hml_i32_sub(_tmp1650, _tmp1651) : (hml_both_i64(_tmp1650, _tmp1651) ? hml_i64_sub(_tmp1650, _tmp1651) : hml_binary_op(HML_OP_SUB, _tmp1650, _tmp1651));
                    hml_release_if_needed(&_tmp1650);
                    hml_release_if_needed(&_tmp1651);
                    HmlValue t1 = _tmp1649;
                    HmlValue _tmp1657 = n1;
                    hml_retain_if_needed(&_tmp1657);
                    HmlValue _tmp1658 = t1;
                    hml_retain_if_needed(&_tmp1658);
                    HmlValue _tmp1656 = hml_both_i32(_tmp1657, _tmp1658) ? hml_i32_mul(_tmp1657, _tmp1658) : (hml_both_i64(_tmp1657, _tmp1658) ? hml_i64_mul(_tmp1657, _tmp1658) : hml_binary_op(HML_OP_MUL, _tmp1657, _tmp1658));
                    hml_release_if_needed(&_tmp1657);
                    hml_release_if_needed(&_tmp1658);
                    HmlValue _tmp1659 = t1;
                    hml_retain_if_needed(&_tmp1659);
                    HmlValue _tmp1655 = hml_both_i32(_tmp1656, _tmp1659) ? hml_i32_mul(_tmp1656, _tmp1659) : (hml_both_i64(_tmp1656, _tmp1659) ? hml_i64_mul(_tmp1656, _tmp1659) : hml_binary_op(HML_OP_MUL, _tmp1656, _tmp1659));
                    hml_release_if_needed(&_tmp1656);
                    hml_release_if_needed(&_tmp1659);
                    HmlValue _tmp1660 = hml_val_f64(0.984375);
                    HmlValue _tmp1654 = hml_both_i32(_tmp1655, _tmp1660) ? hml_i32_add(_tmp1655, _tmp1660) : (hml_both_i64(_tmp1655, _tmp1660) ? hml_i64_add(_tmp1655, _tmp1660) : hml_binary_op(HML_OP_ADD, _tmp1655, _tmp1660));
                    hml_release_if_needed(&_tmp1655);
                    hml_release_if_needed(&_tmp1660);
                    HML_CALL_EXIT();
                    return _tmp1654;
                }
            }
            hml_release(&_tmp1632);
        }
        hml_release(&_tmp1615);
    }
    hml_release(&_tmp1605);
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInBounce(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1662 = hml_val_f64(1);
    HmlValue _tmp1665 = hml_val_f64(1);
    HmlValue _tmp1666 = t;
    hml_retain_if_needed(&_tmp1666);
    HmlValue _tmp1664 = hml_both_i32(_tmp1665, _tmp1666) ? hml_i32_sub(_tmp1665, _tmp1666) : (hml_both_i64(_tmp1665, _tmp1666) ? hml_i64_sub(_tmp1665, _tmp1666) : hml_binary_op(HML_OP_SUB, _tmp1665, _tmp1666));
    hml_release_if_needed(&_tmp1665);
    hml_release_if_needed(&_tmp1666);
    HmlValue _tmp1663 = _mod0_fn_EaseOutBounce(NULL, _tmp1664);
    hml_release(&_tmp1664);
    HmlValue _tmp1661 = hml_both_i32(_tmp1662, _tmp1663) ? hml_i32_sub(_tmp1662, _tmp1663) : (hml_both_i64(_tmp1662, _tmp1663) ? hml_i64_sub(_tmp1662, _tmp1663) : hml_binary_op(HML_OP_SUB, _tmp1662, _tmp1663));
    hml_release_if_needed(&_tmp1662);
    hml_release_if_needed(&_tmp1663);
    HML_CALL_EXIT();
    return _tmp1661;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutBounce(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1668 = t;
    hml_retain_if_needed(&_tmp1668);
    HmlValue _tmp1669 = hml_val_f64(0.5);
    HmlValue _tmp1667 = hml_both_i32(_tmp1668, _tmp1669) ? hml_i32_lt(_tmp1668, _tmp1669) : (hml_both_i64(_tmp1668, _tmp1669) ? hml_i64_lt(_tmp1668, _tmp1669) : hml_binary_op(HML_OP_LESS, _tmp1668, _tmp1669));
    hml_release_if_needed(&_tmp1668);
    hml_release_if_needed(&_tmp1669);
    if (hml_to_bool(_tmp1667)) {
        {
            HmlValue _tmp1671 = hml_val_f64(0.5);
            HmlValue _tmp1673 = hml_val_f64(1);
            HmlValue _tmp1676 = hml_val_f64(1);
            HmlValue _tmp1678 = hml_val_f64(2);
            HmlValue _tmp1679 = t;
            hml_retain_if_needed(&_tmp1679);
            HmlValue _tmp1677 = hml_both_i32(_tmp1678, _tmp1679) ? hml_i32_mul(_tmp1678, _tmp1679) : (hml_both_i64(_tmp1678, _tmp1679) ? hml_i64_mul(_tmp1678, _tmp1679) : hml_binary_op(HML_OP_MUL, _tmp1678, _tmp1679));
            hml_release_if_needed(&_tmp1678);
            hml_release_if_needed(&_tmp1679);
            HmlValue _tmp1675 = hml_both_i32(_tmp1676, _tmp1677) ? hml_i32_sub(_tmp1676, _tmp1677) : (hml_both_i64(_tmp1676, _tmp1677) ? hml_i64_sub(_tmp1676, _tmp1677) : hml_binary_op(HML_OP_SUB, _tmp1676, _tmp1677));
            hml_release_if_needed(&_tmp1676);
            hml_release_if_needed(&_tmp1677);
            HmlValue _tmp1674 = _mod0_fn_EaseOutBounce(NULL, _tmp1675);
            hml_release(&_tmp1675);
            HmlValue _tmp1672 = hml_both_i32(_tmp1673, _tmp1674) ? hml_i32_sub(_tmp1673, _tmp1674) : (hml_both_i64(_tmp1673, _tmp1674) ? hml_i64_sub(_tmp1673, _tmp1674) : hml_binary_op(HML_OP_SUB, _tmp1673, _tmp1674));
            hml_release_if_needed(&_tmp1673);
            hml_release_if_needed(&_tmp1674);
            HmlValue _tmp1670 = hml_both_i32(_tmp1671, _tmp1672) ? hml_i32_mul(_tmp1671, _tmp1672) : (hml_both_i64(_tmp1671, _tmp1672) ? hml_i64_mul(_tmp1671, _tmp1672) : hml_binary_op(HML_OP_MUL, _tmp1671, _tmp1672));
            hml_release_if_needed(&_tmp1671);
            hml_release_if_needed(&_tmp1672);
            HML_CALL_EXIT();
            return _tmp1670;
        }
    }
    hml_release(&_tmp1667);
    HmlValue _tmp1681 = hml_val_f64(0.5);
    HmlValue _tmp1683 = hml_val_f64(1);
    HmlValue _tmp1687 = hml_val_f64(2);
    HmlValue _tmp1688 = t;
    hml_retain_if_needed(&_tmp1688);
    HmlValue _tmp1686 = hml_both_i32(_tmp1687, _tmp1688) ? hml_i32_mul(_tmp1687, _tmp1688) : (hml_both_i64(_tmp1687, _tmp1688) ? hml_i64_mul(_tmp1687, _tmp1688) : hml_binary_op(HML_OP_MUL, _tmp1687, _tmp1688));
    hml_release_if_needed(&_tmp1687);
    hml_release_if_needed(&_tmp1688);
    HmlValue _tmp1689 = hml_val_f64(1);
    HmlValue _tmp1685 = hml_both_i32(_tmp1686, _tmp1689) ? hml_i32_sub(_tmp1686, _tmp1689) : (hml_both_i64(_tmp1686, _tmp1689) ? hml_i64_sub(_tmp1686, _tmp1689) : hml_binary_op(HML_OP_SUB, _tmp1686, _tmp1689));
    hml_release_if_needed(&_tmp1686);
    hml_release_if_needed(&_tmp1689);
    HmlValue _tmp1684 = _mod0_fn_EaseOutBounce(NULL, _tmp1685);
    hml_release(&_tmp1685);
    HmlValue _tmp1682 = hml_both_i32(_tmp1683, _tmp1684) ? hml_i32_add(_tmp1683, _tmp1684) : (hml_both_i64(_tmp1683, _tmp1684) ? hml_i64_add(_tmp1683, _tmp1684) : hml_binary_op(HML_OP_ADD, _tmp1683, _tmp1684));
    hml_release_if_needed(&_tmp1683);
    hml_release_if_needed(&_tmp1684);
    HmlValue _tmp1680 = hml_both_i32(_tmp1681, _tmp1682) ? hml_i32_mul(_tmp1681, _tmp1682) : (hml_both_i64(_tmp1681, _tmp1682) ? hml_i64_mul(_tmp1681, _tmp1682) : hml_binary_op(HML_OP_MUL, _tmp1681, _tmp1682));
    hml_release_if_needed(&_tmp1681);
    hml_release_if_needed(&_tmp1682);
    HML_CALL_EXIT();
    return _tmp1680;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInElastic(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1691 = t;
    hml_retain_if_needed(&_tmp1691);
    HmlValue _tmp1692 = hml_val_f64(0);
    HmlValue _tmp1690 = hml_both_i32(_tmp1691, _tmp1692) ? hml_i32_eq(_tmp1691, _tmp1692) : (hml_both_i64(_tmp1691, _tmp1692) ? hml_i64_eq(_tmp1691, _tmp1692) : hml_binary_op(HML_OP_EQUAL, _tmp1691, _tmp1692));
    hml_release_if_needed(&_tmp1691);
    hml_release_if_needed(&_tmp1692);
    if (hml_to_bool(_tmp1690)) {
        {
            HmlValue _tmp1693 = hml_val_f64(0);
            HML_CALL_EXIT();
            return _tmp1693;
        }
    }
    hml_release(&_tmp1690);
    HmlValue _tmp1695 = t;
    hml_retain_if_needed(&_tmp1695);
    HmlValue _tmp1696 = hml_val_f64(1);
    HmlValue _tmp1694 = hml_both_i32(_tmp1695, _tmp1696) ? hml_i32_eq(_tmp1695, _tmp1696) : (hml_both_i64(_tmp1695, _tmp1696) ? hml_i64_eq(_tmp1695, _tmp1696) : hml_binary_op(HML_OP_EQUAL, _tmp1695, _tmp1696));
    hml_release_if_needed(&_tmp1695);
    hml_release_if_needed(&_tmp1696);
    if (hml_to_bool(_tmp1694)) {
        {
            HmlValue _tmp1697 = hml_val_f64(1);
            HML_CALL_EXIT();
            return _tmp1697;
        }
    }
    hml_release(&_tmp1694);
    HmlValue _tmp1699 = hml_val_f64(6.28319);
    HmlValue _tmp1700 = hml_val_f64(3);
    HmlValue _tmp1698 = hml_binary_op(HML_OP_DIV, _tmp1699, _tmp1700);
    hml_release_if_needed(&_tmp1699);
    hml_release_if_needed(&_tmp1700);
    HmlValue c4 = _tmp1698;
    HmlValue _tmp1704 = hml_val_f64(2);
    HmlValue _tmp1707 = hml_val_f64(10);
    HmlValue _tmp1708 = t;
    hml_retain_if_needed(&_tmp1708);
    HmlValue _tmp1706 = hml_both_i32(_tmp1707, _tmp1708) ? hml_i32_mul(_tmp1707, _tmp1708) : (hml_both_i64(_tmp1707, _tmp1708) ? hml_i64_mul(_tmp1707, _tmp1708) : hml_binary_op(HML_OP_MUL, _tmp1707, _tmp1708));
    hml_release_if_needed(&_tmp1707);
    hml_release_if_needed(&_tmp1708);
    HmlValue _tmp1709 = hml_val_f64(10);
    HmlValue _tmp1705 = hml_both_i32(_tmp1706, _tmp1709) ? hml_i32_sub(_tmp1706, _tmp1709) : (hml_both_i64(_tmp1706, _tmp1709) ? hml_i64_sub(_tmp1706, _tmp1709) : hml_binary_op(HML_OP_SUB, _tmp1706, _tmp1709));
    hml_release_if_needed(&_tmp1706);
    hml_release_if_needed(&_tmp1709);
    HmlValue _tmp1703 = hml_pow(_tmp1704, _tmp1705);
    hml_release(&_tmp1704);
    hml_release(&_tmp1705);
    HmlValue _tmp1702 = hml_unary_op(HML_UNARY_NEGATE, _tmp1703);
    hml_release_if_needed(&_tmp1703);
    HmlValue _tmp1714 = t;
    hml_retain_if_needed(&_tmp1714);
    HmlValue _tmp1715 = hml_val_f64(10);
    HmlValue _tmp1713 = hml_both_i32(_tmp1714, _tmp1715) ? hml_i32_mul(_tmp1714, _tmp1715) : (hml_both_i64(_tmp1714, _tmp1715) ? hml_i64_mul(_tmp1714, _tmp1715) : hml_binary_op(HML_OP_MUL, _tmp1714, _tmp1715));
    hml_release_if_needed(&_tmp1714);
    hml_release_if_needed(&_tmp1715);
    HmlValue _tmp1716 = hml_val_f64(10.75);
    HmlValue _tmp1712 = hml_both_i32(_tmp1713, _tmp1716) ? hml_i32_sub(_tmp1713, _tmp1716) : (hml_both_i64(_tmp1713, _tmp1716) ? hml_i64_sub(_tmp1713, _tmp1716) : hml_binary_op(HML_OP_SUB, _tmp1713, _tmp1716));
    hml_release_if_needed(&_tmp1713);
    hml_release_if_needed(&_tmp1716);
    HmlValue _tmp1717 = c4;
    hml_retain_if_needed(&_tmp1717);
    HmlValue _tmp1711 = hml_both_i32(_tmp1712, _tmp1717) ? hml_i32_mul(_tmp1712, _tmp1717) : (hml_both_i64(_tmp1712, _tmp1717) ? hml_i64_mul(_tmp1712, _tmp1717) : hml_binary_op(HML_OP_MUL, _tmp1712, _tmp1717));
    hml_release_if_needed(&_tmp1712);
    hml_release_if_needed(&_tmp1717);
    HmlValue _tmp1710 = hml_sin(_tmp1711);
    hml_release(&_tmp1711);
    HmlValue _tmp1701 = hml_both_i32(_tmp1702, _tmp1710) ? hml_i32_mul(_tmp1702, _tmp1710) : (hml_both_i64(_tmp1702, _tmp1710) ? hml_i64_mul(_tmp1702, _tmp1710) : hml_binary_op(HML_OP_MUL, _tmp1702, _tmp1710));
    hml_release_if_needed(&_tmp1702);
    hml_release_if_needed(&_tmp1710);
    HML_CALL_EXIT();
    return _tmp1701;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseOutElastic(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1719 = t;
    hml_retain_if_needed(&_tmp1719);
    HmlValue _tmp1720 = hml_val_f64(0);
    HmlValue _tmp1718 = hml_both_i32(_tmp1719, _tmp1720) ? hml_i32_eq(_tmp1719, _tmp1720) : (hml_both_i64(_tmp1719, _tmp1720) ? hml_i64_eq(_tmp1719, _tmp1720) : hml_binary_op(HML_OP_EQUAL, _tmp1719, _tmp1720));
    hml_release_if_needed(&_tmp1719);
    hml_release_if_needed(&_tmp1720);
    if (hml_to_bool(_tmp1718)) {
        {
            HmlValue _tmp1721 = hml_val_f64(0);
            HML_CALL_EXIT();
            return _tmp1721;
        }
    }
    hml_release(&_tmp1718);
    HmlValue _tmp1723 = t;
    hml_retain_if_needed(&_tmp1723);
    HmlValue _tmp1724 = hml_val_f64(1);
    HmlValue _tmp1722 = hml_both_i32(_tmp1723, _tmp1724) ? hml_i32_eq(_tmp1723, _tmp1724) : (hml_both_i64(_tmp1723, _tmp1724) ? hml_i64_eq(_tmp1723, _tmp1724) : hml_binary_op(HML_OP_EQUAL, _tmp1723, _tmp1724));
    hml_release_if_needed(&_tmp1723);
    hml_release_if_needed(&_tmp1724);
    if (hml_to_bool(_tmp1722)) {
        {
            HmlValue _tmp1725 = hml_val_f64(1);
            HML_CALL_EXIT();
            return _tmp1725;
        }
    }
    hml_release(&_tmp1722);
    HmlValue _tmp1727 = hml_val_f64(6.28319);
    HmlValue _tmp1728 = hml_val_f64(3);
    HmlValue _tmp1726 = hml_binary_op(HML_OP_DIV, _tmp1727, _tmp1728);
    hml_release_if_needed(&_tmp1727);
    hml_release_if_needed(&_tmp1728);
    HmlValue c4 = _tmp1726;
    HmlValue _tmp1732 = hml_val_f64(2);
    HmlValue _tmp1735 = hml_val_f64(10);
    HmlValue _tmp1734 = hml_unary_op(HML_UNARY_NEGATE, _tmp1735);
    hml_release_if_needed(&_tmp1735);
    HmlValue _tmp1736 = t;
    hml_retain_if_needed(&_tmp1736);
    HmlValue _tmp1733 = hml_both_i32(_tmp1734, _tmp1736) ? hml_i32_mul(_tmp1734, _tmp1736) : (hml_both_i64(_tmp1734, _tmp1736) ? hml_i64_mul(_tmp1734, _tmp1736) : hml_binary_op(HML_OP_MUL, _tmp1734, _tmp1736));
    hml_release_if_needed(&_tmp1734);
    hml_release_if_needed(&_tmp1736);
    HmlValue _tmp1731 = hml_pow(_tmp1732, _tmp1733);
    hml_release(&_tmp1732);
    hml_release(&_tmp1733);
    HmlValue _tmp1741 = t;
    hml_retain_if_needed(&_tmp1741);
    HmlValue _tmp1742 = hml_val_f64(10);
    HmlValue _tmp1740 = hml_both_i32(_tmp1741, _tmp1742) ? hml_i32_mul(_tmp1741, _tmp1742) : (hml_both_i64(_tmp1741, _tmp1742) ? hml_i64_mul(_tmp1741, _tmp1742) : hml_binary_op(HML_OP_MUL, _tmp1741, _tmp1742));
    hml_release_if_needed(&_tmp1741);
    hml_release_if_needed(&_tmp1742);
    HmlValue _tmp1743 = hml_val_f64(0.75);
    HmlValue _tmp1739 = hml_both_i32(_tmp1740, _tmp1743) ? hml_i32_sub(_tmp1740, _tmp1743) : (hml_both_i64(_tmp1740, _tmp1743) ? hml_i64_sub(_tmp1740, _tmp1743) : hml_binary_op(HML_OP_SUB, _tmp1740, _tmp1743));
    hml_release_if_needed(&_tmp1740);
    hml_release_if_needed(&_tmp1743);
    HmlValue _tmp1744 = c4;
    hml_retain_if_needed(&_tmp1744);
    HmlValue _tmp1738 = hml_both_i32(_tmp1739, _tmp1744) ? hml_i32_mul(_tmp1739, _tmp1744) : (hml_both_i64(_tmp1739, _tmp1744) ? hml_i64_mul(_tmp1739, _tmp1744) : hml_binary_op(HML_OP_MUL, _tmp1739, _tmp1744));
    hml_release_if_needed(&_tmp1739);
    hml_release_if_needed(&_tmp1744);
    HmlValue _tmp1737 = hml_sin(_tmp1738);
    hml_release(&_tmp1738);
    HmlValue _tmp1730 = hml_both_i32(_tmp1731, _tmp1737) ? hml_i32_mul(_tmp1731, _tmp1737) : (hml_both_i64(_tmp1731, _tmp1737) ? hml_i64_mul(_tmp1731, _tmp1737) : hml_binary_op(HML_OP_MUL, _tmp1731, _tmp1737));
    hml_release_if_needed(&_tmp1731);
    hml_release_if_needed(&_tmp1737);
    HmlValue _tmp1745 = hml_val_f64(1);
    HmlValue _tmp1729 = hml_both_i32(_tmp1730, _tmp1745) ? hml_i32_add(_tmp1730, _tmp1745) : (hml_both_i64(_tmp1730, _tmp1745) ? hml_i64_add(_tmp1730, _tmp1745) : hml_binary_op(HML_OP_ADD, _tmp1730, _tmp1745));
    hml_release_if_needed(&_tmp1730);
    hml_release_if_needed(&_tmp1745);
    HML_CALL_EXIT();
    return _tmp1729;
    return hml_val_null();
}

HmlValue _mod0_fn_EaseInOutElastic(HmlClosureEnv *_closure_env, HmlValue t) {
    (void)_closure_env;
    HmlValue _tmp1747 = t;
    hml_retain_if_needed(&_tmp1747);
    HmlValue _tmp1748 = hml_val_f64(0);
    HmlValue _tmp1746 = hml_both_i32(_tmp1747, _tmp1748) ? hml_i32_eq(_tmp1747, _tmp1748) : (hml_both_i64(_tmp1747, _tmp1748) ? hml_i64_eq(_tmp1747, _tmp1748) : hml_binary_op(HML_OP_EQUAL, _tmp1747, _tmp1748));
    hml_release_if_needed(&_tmp1747);
    hml_release_if_needed(&_tmp1748);
    if (hml_to_bool(_tmp1746)) {
        {
            HmlValue _tmp1749 = hml_val_f64(0);
            HML_CALL_EXIT();
            return _tmp1749;
        }
    }
    hml_release(&_tmp1746);
    HmlValue _tmp1751 = t;
    hml_retain_if_needed(&_tmp1751);
    HmlValue _tmp1752 = hml_val_f64(1);
    HmlValue _tmp1750 = hml_both_i32(_tmp1751, _tmp1752) ? hml_i32_eq(_tmp1751, _tmp1752) : (hml_both_i64(_tmp1751, _tmp1752) ? hml_i64_eq(_tmp1751, _tmp1752) : hml_binary_op(HML_OP_EQUAL, _tmp1751, _tmp1752));
    hml_release_if_needed(&_tmp1751);
    hml_release_if_needed(&_tmp1752);
    if (hml_to_bool(_tmp1750)) {
        {
            HmlValue _tmp1753 = hml_val_f64(1);
            HML_CALL_EXIT();
            return _tmp1753;
        }
    }
    hml_release(&_tmp1750);
    HmlValue _tmp1755 = hml_val_f64(6.28319);
    HmlValue _tmp1756 = hml_val_f64(4.5);
    HmlValue _tmp1754 = hml_binary_op(HML_OP_DIV, _tmp1755, _tmp1756);
    hml_release_if_needed(&_tmp1755);
    hml_release_if_needed(&_tmp1756);
    HmlValue c5 = _tmp1754;
    HmlValue _tmp1758 = t;
    hml_retain_if_needed(&_tmp1758);
    HmlValue _tmp1759 = hml_val_f64(0.5);
    HmlValue _tmp1757 = hml_both_i32(_tmp1758, _tmp1759) ? hml_i32_lt(_tmp1758, _tmp1759) : (hml_both_i64(_tmp1758, _tmp1759) ? hml_i64_lt(_tmp1758, _tmp1759) : hml_binary_op(HML_OP_LESS, _tmp1758, _tmp1759));
    hml_release_if_needed(&_tmp1758);
    hml_release_if_needed(&_tmp1759);
    if (hml_to_bool(_tmp1757)) {
        {
            HmlValue _tmp1763 = hml_val_f64(0.5);
            HmlValue _tmp1762 = hml_unary_op(HML_UNARY_NEGATE, _tmp1763);
            hml_release_if_needed(&_tmp1763);
            HmlValue _tmp1765 = hml_val_f64(2);
            HmlValue _tmp1768 = hml_val_f64(20);
            HmlValue _tmp1769 = t;
            hml_retain_if_needed(&_tmp1769);
            HmlValue _tmp1767 = hml_both_i32(_tmp1768, _tmp1769) ? hml_i32_mul(_tmp1768, _tmp1769) : (hml_both_i64(_tmp1768, _tmp1769) ? hml_i64_mul(_tmp1768, _tmp1769) : hml_binary_op(HML_OP_MUL, _tmp1768, _tmp1769));
            hml_release_if_needed(&_tmp1768);
            hml_release_if_needed(&_tmp1769);
            HmlValue _tmp1770 = hml_val_f64(10);
            HmlValue _tmp1766 = hml_both_i32(_tmp1767, _tmp1770) ? hml_i32_sub(_tmp1767, _tmp1770) : (hml_both_i64(_tmp1767, _tmp1770) ? hml_i64_sub(_tmp1767, _tmp1770) : hml_binary_op(HML_OP_SUB, _tmp1767, _tmp1770));
            hml_release_if_needed(&_tmp1767);
            hml_release_if_needed(&_tmp1770);
            HmlValue _tmp1764 = hml_pow(_tmp1765, _tmp1766);
            hml_release(&_tmp1765);
            hml_release(&_tmp1766);
            HmlValue _tmp1761 = hml_both_i32(_tmp1762, _tmp1764) ? hml_i32_mul(_tmp1762, _tmp1764) : (hml_both_i64(_tmp1762, _tmp1764) ? hml_i64_mul(_tmp1762, _tmp1764) : hml_binary_op(HML_OP_MUL, _tmp1762, _tmp1764));
            hml_release_if_needed(&_tmp1762);
            hml_release_if_needed(&_tmp1764);
            HmlValue _tmp1775 = hml_val_f64(20);
            HmlValue _tmp1776 = t;
            hml_retain_if_needed(&_tmp1776);
            HmlValue _tmp1774 = hml_both_i32(_tmp1775, _tmp1776) ? hml_i32_mul(_tmp1775, _tmp1776) : (hml_both_i64(_tmp1775, _tmp1776) ? hml_i64_mul(_tmp1775, _tmp1776) : hml_binary_op(HML_OP_MUL, _tmp1775, _tmp1776));
            hml_release_if_needed(&_tmp1775);
            hml_release_if_needed(&_tmp1776);
            HmlValue _tmp1777 = hml_val_f64(11.125);
            HmlValue _tmp1773 = hml_both_i32(_tmp1774, _tmp1777) ? hml_i32_sub(_tmp1774, _tmp1777) : (hml_both_i64(_tmp1774, _tmp1777) ? hml_i64_sub(_tmp1774, _tmp1777) : hml_binary_op(HML_OP_SUB, _tmp1774, _tmp1777));
            hml_release_if_needed(&_tmp1774);
            hml_release_if_needed(&_tmp1777);
            HmlValue _tmp1778 = c5;
            hml_retain_if_needed(&_tmp1778);
            HmlValue _tmp1772 = hml_both_i32(_tmp1773, _tmp1778) ? hml_i32_mul(_tmp1773, _tmp1778) : (hml_both_i64(_tmp1773, _tmp1778) ? hml_i64_mul(_tmp1773, _tmp1778) : hml_binary_op(HML_OP_MUL, _tmp1773, _tmp1778));
            hml_release_if_needed(&_tmp1773);
            hml_release_if_needed(&_tmp1778);
            HmlValue _tmp1771 = hml_sin(_tmp1772);
            hml_release(&_tmp1772);
            HmlValue _tmp1760 = hml_both_i32(_tmp1761, _tmp1771) ? hml_i32_mul(_tmp1761, _tmp1771) : (hml_both_i64(_tmp1761, _tmp1771) ? hml_i64_mul(_tmp1761, _tmp1771) : hml_binary_op(HML_OP_MUL, _tmp1761, _tmp1771));
            hml_release_if_needed(&_tmp1761);
            hml_release_if_needed(&_tmp1771);
            HML_CALL_EXIT();
            return _tmp1760;
        }
    }
    hml_release(&_tmp1757);
    HmlValue _tmp1782 = hml_val_f64(0.5);
    HmlValue _tmp1784 = hml_val_f64(2);
    HmlValue _tmp1788 = hml_val_f64(20);
    HmlValue _tmp1787 = hml_unary_op(HML_UNARY_NEGATE, _tmp1788);
    hml_release_if_needed(&_tmp1788);
    HmlValue _tmp1789 = t;
    hml_retain_if_needed(&_tmp1789);
    HmlValue _tmp1786 = hml_both_i32(_tmp1787, _tmp1789) ? hml_i32_mul(_tmp1787, _tmp1789) : (hml_both_i64(_tmp1787, _tmp1789) ? hml_i64_mul(_tmp1787, _tmp1789) : hml_binary_op(HML_OP_MUL, _tmp1787, _tmp1789));
    hml_release_if_needed(&_tmp1787);
    hml_release_if_needed(&_tmp1789);
    HmlValue _tmp1790 = hml_val_f64(10);
    HmlValue _tmp1785 = hml_both_i32(_tmp1786, _tmp1790) ? hml_i32_add(_tmp1786, _tmp1790) : (hml_both_i64(_tmp1786, _tmp1790) ? hml_i64_add(_tmp1786, _tmp1790) : hml_binary_op(HML_OP_ADD, _tmp1786, _tmp1790));
    hml_release_if_needed(&_tmp1786);
    hml_release_if_needed(&_tmp1790);
    HmlValue _tmp1783 = hml_pow(_tmp1784, _tmp1785);
    hml_release(&_tmp1784);
    hml_release(&_tmp1785);
    HmlValue _tmp1781 = hml_both_i32(_tmp1782, _tmp1783) ? hml_i32_mul(_tmp1782, _tmp1783) : (hml_both_i64(_tmp1782, _tmp1783) ? hml_i64_mul(_tmp1782, _tmp1783) : hml_binary_op(HML_OP_MUL, _tmp1782, _tmp1783));
    hml_release_if_needed(&_tmp1782);
    hml_release_if_needed(&_tmp1783);
    HmlValue _tmp1795 = hml_val_f64(20);
    HmlValue _tmp1796 = t;
    hml_retain_if_needed(&_tmp1796);
    HmlValue _tmp1794 = hml_both_i32(_tmp1795, _tmp1796) ? hml_i32_mul(_tmp1795, _tmp1796) : (hml_both_i64(_tmp1795, _tmp1796) ? hml_i64_mul(_tmp1795, _tmp1796) : hml_binary_op(HML_OP_MUL, _tmp1795, _tmp1796));
    hml_release_if_needed(&_tmp1795);
    hml_release_if_needed(&_tmp1796);
    HmlValue _tmp1797 = hml_val_f64(11.125);
    HmlValue _tmp1793 = hml_both_i32(_tmp1794, _tmp1797) ? hml_i32_sub(_tmp1794, _tmp1797) : (hml_both_i64(_tmp1794, _tmp1797) ? hml_i64_sub(_tmp1794, _tmp1797) : hml_binary_op(HML_OP_SUB, _tmp1794, _tmp1797));
    hml_release_if_needed(&_tmp1794);
    hml_release_if_needed(&_tmp1797);
    HmlValue _tmp1798 = c5;
    hml_retain_if_needed(&_tmp1798);
    HmlValue _tmp1792 = hml_both_i32(_tmp1793, _tmp1798) ? hml_i32_mul(_tmp1793, _tmp1798) : (hml_both_i64(_tmp1793, _tmp1798) ? hml_i64_mul(_tmp1793, _tmp1798) : hml_binary_op(HML_OP_MUL, _tmp1793, _tmp1798));
    hml_release_if_needed(&_tmp1793);
    hml_release_if_needed(&_tmp1798);
    HmlValue _tmp1791 = hml_sin(_tmp1792);
    hml_release(&_tmp1792);
    HmlValue _tmp1780 = hml_both_i32(_tmp1781, _tmp1791) ? hml_i32_mul(_tmp1781, _tmp1791) : (hml_both_i64(_tmp1781, _tmp1791) ? hml_i64_mul(_tmp1781, _tmp1791) : hml_binary_op(HML_OP_MUL, _tmp1781, _tmp1791));
    hml_release_if_needed(&_tmp1781);
    hml_release_if_needed(&_tmp1791);
    HmlValue _tmp1799 = hml_val_f64(1);
    HmlValue _tmp1779 = hml_both_i32(_tmp1780, _tmp1799) ? hml_i32_add(_tmp1780, _tmp1799) : (hml_both_i64(_tmp1780, _tmp1799) ? hml_i64_add(_tmp1780, _tmp1799) : hml_binary_op(HML_OP_ADD, _tmp1780, _tmp1799));
    hml_release_if_needed(&_tmp1780);
    hml_release_if_needed(&_tmp1799);
    HML_CALL_EXIT();
    return _tmp1779;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorBlend(HmlClosureEnv *_closure_env, HmlValue color1, HmlValue color2, HmlValue factor) {
    (void)_closure_env;
    HmlValue _tmp1801 = color1;
    hml_retain_if_needed(&_tmp1801);
    HmlValue _tmp1802 = hml_val_i32(255);
    HmlValue _tmp1800 = hml_both_i32(_tmp1801, _tmp1802) ? hml_i32_bit_and(_tmp1801, _tmp1802) : (hml_both_i64(_tmp1801, _tmp1802) ? hml_i64_bit_and(_tmp1801, _tmp1802) : hml_binary_op(HML_OP_BIT_AND, _tmp1801, _tmp1802));
    hml_release_if_needed(&_tmp1801);
    hml_release_if_needed(&_tmp1802);
    HmlValue r1 = hml_convert_to_type(_tmp1800, HML_VAL_I32);
    HmlValue _tmp1805 = color1;
    hml_retain_if_needed(&_tmp1805);
    HmlValue _tmp1806 = hml_val_i32(8);
    HmlValue _tmp1804 = hml_both_i32(_tmp1805, _tmp1806) ? hml_i32_rshift(_tmp1805, _tmp1806) : (hml_both_i64(_tmp1805, _tmp1806) ? hml_i64_rshift(_tmp1805, _tmp1806) : hml_binary_op(HML_OP_RSHIFT, _tmp1805, _tmp1806));
    hml_release_if_needed(&_tmp1805);
    hml_release_if_needed(&_tmp1806);
    HmlValue _tmp1807 = hml_val_i32(255);
    HmlValue _tmp1803 = hml_both_i32(_tmp1804, _tmp1807) ? hml_i32_bit_and(_tmp1804, _tmp1807) : (hml_both_i64(_tmp1804, _tmp1807) ? hml_i64_bit_and(_tmp1804, _tmp1807) : hml_binary_op(HML_OP_BIT_AND, _tmp1804, _tmp1807));
    hml_release_if_needed(&_tmp1804);
    hml_release_if_needed(&_tmp1807);
    HmlValue g1 = hml_convert_to_type(_tmp1803, HML_VAL_I32);
    HmlValue _tmp1810 = color1;
    hml_retain_if_needed(&_tmp1810);
    HmlValue _tmp1811 = hml_val_i32(16);
    HmlValue _tmp1809 = hml_both_i32(_tmp1810, _tmp1811) ? hml_i32_rshift(_tmp1810, _tmp1811) : (hml_both_i64(_tmp1810, _tmp1811) ? hml_i64_rshift(_tmp1810, _tmp1811) : hml_binary_op(HML_OP_RSHIFT, _tmp1810, _tmp1811));
    hml_release_if_needed(&_tmp1810);
    hml_release_if_needed(&_tmp1811);
    HmlValue _tmp1812 = hml_val_i32(255);
    HmlValue _tmp1808 = hml_both_i32(_tmp1809, _tmp1812) ? hml_i32_bit_and(_tmp1809, _tmp1812) : (hml_both_i64(_tmp1809, _tmp1812) ? hml_i64_bit_and(_tmp1809, _tmp1812) : hml_binary_op(HML_OP_BIT_AND, _tmp1809, _tmp1812));
    hml_release_if_needed(&_tmp1809);
    hml_release_if_needed(&_tmp1812);
    HmlValue b1 = hml_convert_to_type(_tmp1808, HML_VAL_I32);
    HmlValue _tmp1815 = color1;
    hml_retain_if_needed(&_tmp1815);
    HmlValue _tmp1816 = hml_val_i32(24);
    HmlValue _tmp1814 = hml_both_i32(_tmp1815, _tmp1816) ? hml_i32_rshift(_tmp1815, _tmp1816) : (hml_both_i64(_tmp1815, _tmp1816) ? hml_i64_rshift(_tmp1815, _tmp1816) : hml_binary_op(HML_OP_RSHIFT, _tmp1815, _tmp1816));
    hml_release_if_needed(&_tmp1815);
    hml_release_if_needed(&_tmp1816);
    HmlValue _tmp1817 = hml_val_i32(255);
    HmlValue _tmp1813 = hml_both_i32(_tmp1814, _tmp1817) ? hml_i32_bit_and(_tmp1814, _tmp1817) : (hml_both_i64(_tmp1814, _tmp1817) ? hml_i64_bit_and(_tmp1814, _tmp1817) : hml_binary_op(HML_OP_BIT_AND, _tmp1814, _tmp1817));
    hml_release_if_needed(&_tmp1814);
    hml_release_if_needed(&_tmp1817);
    HmlValue a1 = hml_convert_to_type(_tmp1813, HML_VAL_I32);
    HmlValue _tmp1819 = color2;
    hml_retain_if_needed(&_tmp1819);
    HmlValue _tmp1820 = hml_val_i32(255);
    HmlValue _tmp1818 = hml_both_i32(_tmp1819, _tmp1820) ? hml_i32_bit_and(_tmp1819, _tmp1820) : (hml_both_i64(_tmp1819, _tmp1820) ? hml_i64_bit_and(_tmp1819, _tmp1820) : hml_binary_op(HML_OP_BIT_AND, _tmp1819, _tmp1820));
    hml_release_if_needed(&_tmp1819);
    hml_release_if_needed(&_tmp1820);
    HmlValue r2 = hml_convert_to_type(_tmp1818, HML_VAL_I32);
    HmlValue _tmp1823 = color2;
    hml_retain_if_needed(&_tmp1823);
    HmlValue _tmp1824 = hml_val_i32(8);
    HmlValue _tmp1822 = hml_both_i32(_tmp1823, _tmp1824) ? hml_i32_rshift(_tmp1823, _tmp1824) : (hml_both_i64(_tmp1823, _tmp1824) ? hml_i64_rshift(_tmp1823, _tmp1824) : hml_binary_op(HML_OP_RSHIFT, _tmp1823, _tmp1824));
    hml_release_if_needed(&_tmp1823);
    hml_release_if_needed(&_tmp1824);
    HmlValue _tmp1825 = hml_val_i32(255);
    HmlValue _tmp1821 = hml_both_i32(_tmp1822, _tmp1825) ? hml_i32_bit_and(_tmp1822, _tmp1825) : (hml_both_i64(_tmp1822, _tmp1825) ? hml_i64_bit_and(_tmp1822, _tmp1825) : hml_binary_op(HML_OP_BIT_AND, _tmp1822, _tmp1825));
    hml_release_if_needed(&_tmp1822);
    hml_release_if_needed(&_tmp1825);
    HmlValue g2 = hml_convert_to_type(_tmp1821, HML_VAL_I32);
    HmlValue _tmp1828 = color2;
    hml_retain_if_needed(&_tmp1828);
    HmlValue _tmp1829 = hml_val_i32(16);
    HmlValue _tmp1827 = hml_both_i32(_tmp1828, _tmp1829) ? hml_i32_rshift(_tmp1828, _tmp1829) : (hml_both_i64(_tmp1828, _tmp1829) ? hml_i64_rshift(_tmp1828, _tmp1829) : hml_binary_op(HML_OP_RSHIFT, _tmp1828, _tmp1829));
    hml_release_if_needed(&_tmp1828);
    hml_release_if_needed(&_tmp1829);
    HmlValue _tmp1830 = hml_val_i32(255);
    HmlValue _tmp1826 = hml_both_i32(_tmp1827, _tmp1830) ? hml_i32_bit_and(_tmp1827, _tmp1830) : (hml_both_i64(_tmp1827, _tmp1830) ? hml_i64_bit_and(_tmp1827, _tmp1830) : hml_binary_op(HML_OP_BIT_AND, _tmp1827, _tmp1830));
    hml_release_if_needed(&_tmp1827);
    hml_release_if_needed(&_tmp1830);
    HmlValue b2 = hml_convert_to_type(_tmp1826, HML_VAL_I32);
    HmlValue _tmp1833 = color2;
    hml_retain_if_needed(&_tmp1833);
    HmlValue _tmp1834 = hml_val_i32(24);
    HmlValue _tmp1832 = hml_both_i32(_tmp1833, _tmp1834) ? hml_i32_rshift(_tmp1833, _tmp1834) : (hml_both_i64(_tmp1833, _tmp1834) ? hml_i64_rshift(_tmp1833, _tmp1834) : hml_binary_op(HML_OP_RSHIFT, _tmp1833, _tmp1834));
    hml_release_if_needed(&_tmp1833);
    hml_release_if_needed(&_tmp1834);
    HmlValue _tmp1835 = hml_val_i32(255);
    HmlValue _tmp1831 = hml_both_i32(_tmp1832, _tmp1835) ? hml_i32_bit_and(_tmp1832, _tmp1835) : (hml_both_i64(_tmp1832, _tmp1835) ? hml_i64_bit_and(_tmp1832, _tmp1835) : hml_binary_op(HML_OP_BIT_AND, _tmp1832, _tmp1835));
    hml_release_if_needed(&_tmp1832);
    hml_release_if_needed(&_tmp1835);
    HmlValue a2 = hml_convert_to_type(_tmp1831, HML_VAL_I32);
    HmlValue _tmp1837 = r1;
    hml_retain_if_needed(&_tmp1837);
    HmlValue _tmp1838 = r2;
    hml_retain_if_needed(&_tmp1838);
    HmlValue _tmp1839 = factor;
    hml_retain_if_needed(&_tmp1839);
    HmlValue _tmp1836 = _mod0_fn_Lerp(NULL, _tmp1837, _tmp1838, _tmp1839);
    hml_release(&_tmp1837);
    hml_release(&_tmp1838);
    hml_release(&_tmp1839);
    HmlValue r = hml_convert_to_type(_tmp1836, HML_VAL_I32);
    HmlValue _tmp1841 = g1;
    hml_retain_if_needed(&_tmp1841);
    HmlValue _tmp1842 = g2;
    hml_retain_if_needed(&_tmp1842);
    HmlValue _tmp1843 = factor;
    hml_retain_if_needed(&_tmp1843);
    HmlValue _tmp1840 = _mod0_fn_Lerp(NULL, _tmp1841, _tmp1842, _tmp1843);
    hml_release(&_tmp1841);
    hml_release(&_tmp1842);
    hml_release(&_tmp1843);
    HmlValue g = hml_convert_to_type(_tmp1840, HML_VAL_I32);
    HmlValue _tmp1845 = b1;
    hml_retain_if_needed(&_tmp1845);
    HmlValue _tmp1846 = b2;
    hml_retain_if_needed(&_tmp1846);
    HmlValue _tmp1847 = factor;
    hml_retain_if_needed(&_tmp1847);
    HmlValue _tmp1844 = _mod0_fn_Lerp(NULL, _tmp1845, _tmp1846, _tmp1847);
    hml_release(&_tmp1845);
    hml_release(&_tmp1846);
    hml_release(&_tmp1847);
    HmlValue b = hml_convert_to_type(_tmp1844, HML_VAL_I32);
    HmlValue _tmp1849 = a1;
    hml_retain_if_needed(&_tmp1849);
    HmlValue _tmp1850 = a2;
    hml_retain_if_needed(&_tmp1850);
    HmlValue _tmp1851 = factor;
    hml_retain_if_needed(&_tmp1851);
    HmlValue _tmp1848 = _mod0_fn_Lerp(NULL, _tmp1849, _tmp1850, _tmp1851);
    hml_release(&_tmp1849);
    hml_release(&_tmp1850);
    hml_release(&_tmp1851);
    HmlValue a = hml_convert_to_type(_tmp1848, HML_VAL_I32);
    HmlValue _tmp1853 = r;
    hml_retain_if_needed(&_tmp1853);
    HmlValue _tmp1854 = g;
    hml_retain_if_needed(&_tmp1854);
    HmlValue _tmp1855 = b;
    hml_retain_if_needed(&_tmp1855);
    HmlValue _tmp1856 = a;
    hml_retain_if_needed(&_tmp1856);
    HmlValue _tmp1852 = _mod0_fn_Color(NULL, _tmp1853, _tmp1854, _tmp1855, _tmp1856);
    hml_release(&_tmp1853);
    hml_release(&_tmp1854);
    hml_release(&_tmp1855);
    hml_release(&_tmp1856);
    HML_CALL_EXIT();
    return _tmp1852;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorInvert(HmlClosureEnv *_closure_env, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp1858 = hml_val_i32(255);
    HmlValue _tmp1860 = color;
    hml_retain_if_needed(&_tmp1860);
    HmlValue _tmp1859 = _mod0_fn_ColorGetR(NULL, _tmp1860);
    hml_release(&_tmp1860);
    HmlValue _tmp1857 = hml_both_i32(_tmp1858, _tmp1859) ? hml_i32_sub(_tmp1858, _tmp1859) : (hml_both_i64(_tmp1858, _tmp1859) ? hml_i64_sub(_tmp1858, _tmp1859) : hml_binary_op(HML_OP_SUB, _tmp1858, _tmp1859));
    hml_release_if_needed(&_tmp1858);
    hml_release_if_needed(&_tmp1859);
    HmlValue r = hml_convert_to_type(_tmp1857, HML_VAL_U8);
    HmlValue _tmp1862 = hml_val_i32(255);
    HmlValue _tmp1864 = color;
    hml_retain_if_needed(&_tmp1864);
    HmlValue _tmp1863 = _mod0_fn_ColorGetG(NULL, _tmp1864);
    hml_release(&_tmp1864);
    HmlValue _tmp1861 = hml_both_i32(_tmp1862, _tmp1863) ? hml_i32_sub(_tmp1862, _tmp1863) : (hml_both_i64(_tmp1862, _tmp1863) ? hml_i64_sub(_tmp1862, _tmp1863) : hml_binary_op(HML_OP_SUB, _tmp1862, _tmp1863));
    hml_release_if_needed(&_tmp1862);
    hml_release_if_needed(&_tmp1863);
    HmlValue g = hml_convert_to_type(_tmp1861, HML_VAL_U8);
    HmlValue _tmp1866 = hml_val_i32(255);
    HmlValue _tmp1868 = color;
    hml_retain_if_needed(&_tmp1868);
    HmlValue _tmp1867 = _mod0_fn_ColorGetB(NULL, _tmp1868);
    hml_release(&_tmp1868);
    HmlValue _tmp1865 = hml_both_i32(_tmp1866, _tmp1867) ? hml_i32_sub(_tmp1866, _tmp1867) : (hml_both_i64(_tmp1866, _tmp1867) ? hml_i64_sub(_tmp1866, _tmp1867) : hml_binary_op(HML_OP_SUB, _tmp1866, _tmp1867));
    hml_release_if_needed(&_tmp1866);
    hml_release_if_needed(&_tmp1867);
    HmlValue b = hml_convert_to_type(_tmp1865, HML_VAL_U8);
    HmlValue _tmp1870 = color;
    hml_retain_if_needed(&_tmp1870);
    HmlValue _tmp1869 = _mod0_fn_ColorGetA(NULL, _tmp1870);
    hml_release(&_tmp1870);
    HmlValue a = hml_convert_to_type(_tmp1869, HML_VAL_U8);
    HmlValue _tmp1872 = r;
    hml_retain_if_needed(&_tmp1872);
    HmlValue _tmp1873 = g;
    hml_retain_if_needed(&_tmp1873);
    HmlValue _tmp1874 = b;
    hml_retain_if_needed(&_tmp1874);
    HmlValue _tmp1875 = a;
    hml_retain_if_needed(&_tmp1875);
    HmlValue _tmp1871 = _mod0_fn_Color(NULL, _tmp1872, _tmp1873, _tmp1874, _tmp1875);
    hml_release(&_tmp1872);
    hml_release(&_tmp1873);
    hml_release(&_tmp1874);
    hml_release(&_tmp1875);
    HML_CALL_EXIT();
    return _tmp1871;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorToGrayscale(HmlClosureEnv *_closure_env, HmlValue color) {
    (void)_closure_env;
    HmlValue _tmp1877 = color;
    hml_retain_if_needed(&_tmp1877);
    HmlValue _tmp1876 = _mod0_fn_ColorGetR(NULL, _tmp1877);
    hml_release(&_tmp1877);
    HmlValue r = hml_convert_to_type(_tmp1876, HML_VAL_I32);
    HmlValue _tmp1879 = color;
    hml_retain_if_needed(&_tmp1879);
    HmlValue _tmp1878 = _mod0_fn_ColorGetG(NULL, _tmp1879);
    hml_release(&_tmp1879);
    HmlValue g = hml_convert_to_type(_tmp1878, HML_VAL_I32);
    HmlValue _tmp1881 = color;
    hml_retain_if_needed(&_tmp1881);
    HmlValue _tmp1880 = _mod0_fn_ColorGetB(NULL, _tmp1881);
    hml_release(&_tmp1881);
    HmlValue b = hml_convert_to_type(_tmp1880, HML_VAL_I32);
    HmlValue _tmp1883 = color;
    hml_retain_if_needed(&_tmp1883);
    HmlValue _tmp1882 = _mod0_fn_ColorGetA(NULL, _tmp1883);
    hml_release(&_tmp1883);
    HmlValue a = hml_convert_to_type(_tmp1882, HML_VAL_U8);
    HmlValue _tmp1888 = r;
    hml_retain_if_needed(&_tmp1888);
    HmlValue _tmp1889 = hml_val_i32(299);
    HmlValue _tmp1887 = hml_both_i32(_tmp1888, _tmp1889) ? hml_i32_mul(_tmp1888, _tmp1889) : (hml_both_i64(_tmp1888, _tmp1889) ? hml_i64_mul(_tmp1888, _tmp1889) : hml_binary_op(HML_OP_MUL, _tmp1888, _tmp1889));
    hml_release_if_needed(&_tmp1888);
    hml_release_if_needed(&_tmp1889);
    HmlValue _tmp1891 = g;
    hml_retain_if_needed(&_tmp1891);
    HmlValue _tmp1892 = hml_val_i32(587);
    HmlValue _tmp1890 = hml_both_i32(_tmp1891, _tmp1892) ? hml_i32_mul(_tmp1891, _tmp1892) : (hml_both_i64(_tmp1891, _tmp1892) ? hml_i64_mul(_tmp1891, _tmp1892) : hml_binary_op(HML_OP_MUL, _tmp1891, _tmp1892));
    hml_release_if_needed(&_tmp1891);
    hml_release_if_needed(&_tmp1892);
    HmlValue _tmp1886 = hml_both_i32(_tmp1887, _tmp1890) ? hml_i32_add(_tmp1887, _tmp1890) : (hml_both_i64(_tmp1887, _tmp1890) ? hml_i64_add(_tmp1887, _tmp1890) : hml_binary_op(HML_OP_ADD, _tmp1887, _tmp1890));
    hml_release_if_needed(&_tmp1887);
    hml_release_if_needed(&_tmp1890);
    HmlValue _tmp1894 = b;
    hml_retain_if_needed(&_tmp1894);
    HmlValue _tmp1895 = hml_val_i32(114);
    HmlValue _tmp1893 = hml_both_i32(_tmp1894, _tmp1895) ? hml_i32_mul(_tmp1894, _tmp1895) : (hml_both_i64(_tmp1894, _tmp1895) ? hml_i64_mul(_tmp1894, _tmp1895) : hml_binary_op(HML_OP_MUL, _tmp1894, _tmp1895));
    hml_release_if_needed(&_tmp1894);
    hml_release_if_needed(&_tmp1895);
    HmlValue _tmp1885 = hml_both_i32(_tmp1886, _tmp1893) ? hml_i32_add(_tmp1886, _tmp1893) : (hml_both_i64(_tmp1886, _tmp1893) ? hml_i64_add(_tmp1886, _tmp1893) : hml_binary_op(HML_OP_ADD, _tmp1886, _tmp1893));
    hml_release_if_needed(&_tmp1886);
    hml_release_if_needed(&_tmp1893);
    HmlValue _tmp1896 = hml_val_i32(1000);
    HmlValue _tmp1884 = hml_divi(_tmp1885, _tmp1896);
    hml_release(&_tmp1885);
    hml_release(&_tmp1896);
    HmlValue gray = hml_convert_to_type(_tmp1884, HML_VAL_I32);
    HmlValue _tmp1898 = gray;
    hml_retain_if_needed(&_tmp1898);
    HmlValue _tmp1899 = gray;
    hml_retain_if_needed(&_tmp1899);
    HmlValue _tmp1900 = gray;
    hml_retain_if_needed(&_tmp1900);
    HmlValue _tmp1901 = a;
    hml_retain_if_needed(&_tmp1901);
    HmlValue _tmp1897 = _mod0_fn_Color(NULL, _tmp1898, _tmp1899, _tmp1900, _tmp1901);
    hml_release(&_tmp1898);
    hml_release(&_tmp1899);
    hml_release(&_tmp1900);
    hml_release(&_tmp1901);
    HML_CALL_EXIT();
    return _tmp1897;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorTint(HmlClosureEnv *_closure_env, HmlValue color, HmlValue tint) {
    (void)_closure_env;
    HmlValue _tmp1903 = color;
    hml_retain_if_needed(&_tmp1903);
    HmlValue _tmp1902 = _mod0_fn_ColorGetR(NULL, _tmp1903);
    hml_release(&_tmp1903);
    HmlValue r1 = hml_convert_to_type(_tmp1902, HML_VAL_I32);
    HmlValue _tmp1905 = color;
    hml_retain_if_needed(&_tmp1905);
    HmlValue _tmp1904 = _mod0_fn_ColorGetG(NULL, _tmp1905);
    hml_release(&_tmp1905);
    HmlValue g1 = hml_convert_to_type(_tmp1904, HML_VAL_I32);
    HmlValue _tmp1907 = color;
    hml_retain_if_needed(&_tmp1907);
    HmlValue _tmp1906 = _mod0_fn_ColorGetB(NULL, _tmp1907);
    hml_release(&_tmp1907);
    HmlValue b1 = hml_convert_to_type(_tmp1906, HML_VAL_I32);
    HmlValue _tmp1909 = color;
    hml_retain_if_needed(&_tmp1909);
    HmlValue _tmp1908 = _mod0_fn_ColorGetA(NULL, _tmp1909);
    hml_release(&_tmp1909);
    HmlValue a1 = hml_convert_to_type(_tmp1908, HML_VAL_U8);
    HmlValue _tmp1911 = tint;
    hml_retain_if_needed(&_tmp1911);
    HmlValue _tmp1910 = _mod0_fn_ColorGetR(NULL, _tmp1911);
    hml_release(&_tmp1911);
    HmlValue r2 = hml_convert_to_type(_tmp1910, HML_VAL_I32);
    HmlValue _tmp1913 = tint;
    hml_retain_if_needed(&_tmp1913);
    HmlValue _tmp1912 = _mod0_fn_ColorGetG(NULL, _tmp1913);
    hml_release(&_tmp1913);
    HmlValue g2 = hml_convert_to_type(_tmp1912, HML_VAL_I32);
    HmlValue _tmp1915 = tint;
    hml_retain_if_needed(&_tmp1915);
    HmlValue _tmp1914 = _mod0_fn_ColorGetB(NULL, _tmp1915);
    hml_release(&_tmp1915);
    HmlValue b2 = hml_convert_to_type(_tmp1914, HML_VAL_I32);
    HmlValue _tmp1918 = r1;
    hml_retain_if_needed(&_tmp1918);
    HmlValue _tmp1919 = r2;
    hml_retain_if_needed(&_tmp1919);
    HmlValue _tmp1917 = hml_both_i32(_tmp1918, _tmp1919) ? hml_i32_mul(_tmp1918, _tmp1919) : (hml_both_i64(_tmp1918, _tmp1919) ? hml_i64_mul(_tmp1918, _tmp1919) : hml_binary_op(HML_OP_MUL, _tmp1918, _tmp1919));
    hml_release_if_needed(&_tmp1918);
    hml_release_if_needed(&_tmp1919);
    HmlValue _tmp1920 = hml_val_i32(255);
    HmlValue _tmp1916 = hml_divi(_tmp1917, _tmp1920);
    hml_release(&_tmp1917);
    hml_release(&_tmp1920);
    HmlValue r = hml_convert_to_type(_tmp1916, HML_VAL_I32);
    HmlValue _tmp1923 = g1;
    hml_retain_if_needed(&_tmp1923);
    HmlValue _tmp1924 = g2;
    hml_retain_if_needed(&_tmp1924);
    HmlValue _tmp1922 = hml_both_i32(_tmp1923, _tmp1924) ? hml_i32_mul(_tmp1923, _tmp1924) : (hml_both_i64(_tmp1923, _tmp1924) ? hml_i64_mul(_tmp1923, _tmp1924) : hml_binary_op(HML_OP_MUL, _tmp1923, _tmp1924));
    hml_release_if_needed(&_tmp1923);
    hml_release_if_needed(&_tmp1924);
    HmlValue _tmp1925 = hml_val_i32(255);
    HmlValue _tmp1921 = hml_divi(_tmp1922, _tmp1925);
    hml_release(&_tmp1922);
    hml_release(&_tmp1925);
    HmlValue g = hml_convert_to_type(_tmp1921, HML_VAL_I32);
    HmlValue _tmp1928 = b1;
    hml_retain_if_needed(&_tmp1928);
    HmlValue _tmp1929 = b2;
    hml_retain_if_needed(&_tmp1929);
    HmlValue _tmp1927 = hml_both_i32(_tmp1928, _tmp1929) ? hml_i32_mul(_tmp1928, _tmp1929) : (hml_both_i64(_tmp1928, _tmp1929) ? hml_i64_mul(_tmp1928, _tmp1929) : hml_binary_op(HML_OP_MUL, _tmp1928, _tmp1929));
    hml_release_if_needed(&_tmp1928);
    hml_release_if_needed(&_tmp1929);
    HmlValue _tmp1930 = hml_val_i32(255);
    HmlValue _tmp1926 = hml_divi(_tmp1927, _tmp1930);
    hml_release(&_tmp1927);
    hml_release(&_tmp1930);
    HmlValue b = hml_convert_to_type(_tmp1926, HML_VAL_I32);
    HmlValue _tmp1932 = r;
    hml_retain_if_needed(&_tmp1932);
    HmlValue _tmp1933 = g;
    hml_retain_if_needed(&_tmp1933);
    HmlValue _tmp1934 = b;
    hml_retain_if_needed(&_tmp1934);
    HmlValue _tmp1935 = a1;
    hml_retain_if_needed(&_tmp1935);
    HmlValue _tmp1931 = _mod0_fn_Color(NULL, _tmp1932, _tmp1933, _tmp1934, _tmp1935);
    hml_release(&_tmp1932);
    hml_release(&_tmp1933);
    hml_release(&_tmp1934);
    hml_release(&_tmp1935);
    HML_CALL_EXIT();
    return _tmp1931;
    return hml_val_null();
}

HmlValue _mod0_fn_ColorContrast(HmlClosureEnv *_closure_env, HmlValue color, HmlValue contrast) {
    (void)_closure_env;
    HmlValue _tmp1937 = color;
    hml_retain_if_needed(&_tmp1937);
    HmlValue _tmp1936 = _mod0_fn_ColorGetR(NULL, _tmp1937);
    hml_release(&_tmp1937);
    HmlValue r = hml_convert_to_type(_tmp1936, HML_VAL_F32);
    HmlValue _tmp1939 = color;
    hml_retain_if_needed(&_tmp1939);
    HmlValue _tmp1938 = _mod0_fn_ColorGetG(NULL, _tmp1939);
    hml_release(&_tmp1939);
    HmlValue g = hml_convert_to_type(_tmp1938, HML_VAL_F32);
    HmlValue _tmp1941 = color;
    hml_retain_if_needed(&_tmp1941);
    HmlValue _tmp1940 = _mod0_fn_ColorGetB(NULL, _tmp1941);
    hml_release(&_tmp1941);
    HmlValue b = hml_convert_to_type(_tmp1940, HML_VAL_F32);
    HmlValue _tmp1943 = color;
    hml_retain_if_needed(&_tmp1943);
    HmlValue _tmp1942 = _mod0_fn_ColorGetA(NULL, _tmp1943);
    hml_release(&_tmp1943);
    HmlValue a = hml_convert_to_type(_tmp1942, HML_VAL_U8);
    HmlValue _tmp1946 = hml_val_f64(1);
    HmlValue _tmp1947 = contrast;
    hml_retain_if_needed(&_tmp1947);
    HmlValue _tmp1945 = hml_both_i32(_tmp1946, _tmp1947) ? hml_i32_add(_tmp1946, _tmp1947) : (hml_both_i64(_tmp1946, _tmp1947) ? hml_i64_add(_tmp1946, _tmp1947) : hml_binary_op(HML_OP_ADD, _tmp1946, _tmp1947));
    hml_release_if_needed(&_tmp1946);
    hml_release_if_needed(&_tmp1947);
    HmlValue _tmp1949 = hml_val_f64(1);
    HmlValue _tmp1950 = contrast;
    hml_retain_if_needed(&_tmp1950);
    HmlValue _tmp1948 = hml_both_i32(_tmp1949, _tmp1950) ? hml_i32_sub(_tmp1949, _tmp1950) : (hml_both_i64(_tmp1949, _tmp1950) ? hml_i64_sub(_tmp1949, _tmp1950) : hml_binary_op(HML_OP_SUB, _tmp1949, _tmp1950));
    hml_release_if_needed(&_tmp1949);
    hml_release_if_needed(&_tmp1950);
    HmlValue _tmp1944 = hml_binary_op(HML_OP_DIV, _tmp1945, _tmp1948);
    hml_release_if_needed(&_tmp1945);
    hml_release_if_needed(&_tmp1948);
    HmlValue factor = _tmp1944;
    HmlValue _tmp1956 = r;
    hml_retain_if_needed(&_tmp1956);
    HmlValue _tmp1957 = hml_val_f64(255);
    HmlValue _tmp1955 = hml_binary_op(HML_OP_DIV, _tmp1956, _tmp1957);
    hml_release_if_needed(&_tmp1956);
    hml_release_if_needed(&_tmp1957);
    HmlValue _tmp1958 = hml_val_f64(0.5);
    HmlValue _tmp1954 = hml_both_i32(_tmp1955, _tmp1958) ? hml_i32_sub(_tmp1955, _tmp1958) : (hml_both_i64(_tmp1955, _tmp1958) ? hml_i64_sub(_tmp1955, _tmp1958) : hml_binary_op(HML_OP_SUB, _tmp1955, _tmp1958));
    hml_release_if_needed(&_tmp1955);
    hml_release_if_needed(&_tmp1958);
    HmlValue _tmp1959 = factor;
    hml_retain_if_needed(&_tmp1959);
    HmlValue _tmp1953 = hml_both_i32(_tmp1954, _tmp1959) ? hml_i32_mul(_tmp1954, _tmp1959) : (hml_both_i64(_tmp1954, _tmp1959) ? hml_i64_mul(_tmp1954, _tmp1959) : hml_binary_op(HML_OP_MUL, _tmp1954, _tmp1959));
    hml_release_if_needed(&_tmp1954);
    hml_release_if_needed(&_tmp1959);
    HmlValue _tmp1960 = hml_val_f64(0.5);
    HmlValue _tmp1952 = hml_both_i32(_tmp1953, _tmp1960) ? hml_i32_add(_tmp1953, _tmp1960) : (hml_both_i64(_tmp1953, _tmp1960) ? hml_i64_add(_tmp1953, _tmp1960) : hml_binary_op(HML_OP_ADD, _tmp1953, _tmp1960));
    hml_release_if_needed(&_tmp1953);
    hml_release_if_needed(&_tmp1960);
    hml_release(&r);
    r = _tmp1952;
    hml_retain(&r);
    HmlValue _tmp1951 = r;
    hml_retain(&_tmp1951);
    hml_release(&_tmp1951);
    HmlValue _tmp1966 = g;
    hml_retain_if_needed(&_tmp1966);
    HmlValue _tmp1967 = hml_val_f64(255);
    HmlValue _tmp1965 = hml_binary_op(HML_OP_DIV, _tmp1966, _tmp1967);
    hml_release_if_needed(&_tmp1966);
    hml_release_if_needed(&_tmp1967);
    HmlValue _tmp1968 = hml_val_f64(0.5);
    HmlValue _tmp1964 = hml_both_i32(_tmp1965, _tmp1968) ? hml_i32_sub(_tmp1965, _tmp1968) : (hml_both_i64(_tmp1965, _tmp1968) ? hml_i64_sub(_tmp1965, _tmp1968) : hml_binary_op(HML_OP_SUB, _tmp1965, _tmp1968));
    hml_release_if_needed(&_tmp1965);
    hml_release_if_needed(&_tmp1968);
    HmlValue _tmp1969 = factor;
    hml_retain_if_needed(&_tmp1969);
    HmlValue _tmp1963 = hml_both_i32(_tmp1964, _tmp1969) ? hml_i32_mul(_tmp1964, _tmp1969) : (hml_both_i64(_tmp1964, _tmp1969) ? hml_i64_mul(_tmp1964, _tmp1969) : hml_binary_op(HML_OP_MUL, _tmp1964, _tmp1969));
    hml_release_if_needed(&_tmp1964);
    hml_release_if_needed(&_tmp1969);
    HmlValue _tmp1970 = hml_val_f64(0.5);
    HmlValue _tmp1962 = hml_both_i32(_tmp1963, _tmp1970) ? hml_i32_add(_tmp1963, _tmp1970) : (hml_both_i64(_tmp1963, _tmp1970) ? hml_i64_add(_tmp1963, _tmp1970) : hml_binary_op(HML_OP_ADD, _tmp1963, _tmp1970));
    hml_release_if_needed(&_tmp1963);
    hml_release_if_needed(&_tmp1970);
    hml_release(&g);
    g = _tmp1962;
    hml_retain(&g);
    HmlValue _tmp1961 = g;
    hml_retain(&_tmp1961);
    hml_release(&_tmp1961);
    HmlValue _tmp1976 = b;
    hml_retain_if_needed(&_tmp1976);
    HmlValue _tmp1977 = hml_val_f64(255);
    HmlValue _tmp1975 = hml_binary_op(HML_OP_DIV, _tmp1976, _tmp1977);
    hml_release_if_needed(&_tmp1976);
    hml_release_if_needed(&_tmp1977);
    HmlValue _tmp1978 = hml_val_f64(0.5);
    HmlValue _tmp1974 = hml_both_i32(_tmp1975, _tmp1978) ? hml_i32_sub(_tmp1975, _tmp1978) : (hml_both_i64(_tmp1975, _tmp1978) ? hml_i64_sub(_tmp1975, _tmp1978) : hml_binary_op(HML_OP_SUB, _tmp1975, _tmp1978));
    hml_release_if_needed(&_tmp1975);
    hml_release_if_needed(&_tmp1978);
    HmlValue _tmp1979 = factor;
    hml_retain_if_needed(&_tmp1979);
    HmlValue _tmp1973 = hml_both_i32(_tmp1974, _tmp1979) ? hml_i32_mul(_tmp1974, _tmp1979) : (hml_both_i64(_tmp1974, _tmp1979) ? hml_i64_mul(_tmp1974, _tmp1979) : hml_binary_op(HML_OP_MUL, _tmp1974, _tmp1979));
    hml_release_if_needed(&_tmp1974);
    hml_release_if_needed(&_tmp1979);
    HmlValue _tmp1980 = hml_val_f64(0.5);
    HmlValue _tmp1972 = hml_both_i32(_tmp1973, _tmp1980) ? hml_i32_add(_tmp1973, _tmp1980) : (hml_both_i64(_tmp1973, _tmp1980) ? hml_i64_add(_tmp1973, _tmp1980) : hml_binary_op(HML_OP_ADD, _tmp1973, _tmp1980));
    hml_release_if_needed(&_tmp1973);
    hml_release_if_needed(&_tmp1980);
    hml_release(&b);
    b = _tmp1972;
    hml_retain(&b);
    HmlValue _tmp1971 = b;
    hml_retain(&_tmp1971);
    hml_release(&_tmp1971);
    HmlValue _tmp1983 = r;
    hml_retain_if_needed(&_tmp1983);
    HmlValue _tmp1984 = hml_val_f64(255);
    HmlValue _tmp1982 = hml_both_i32(_tmp1983, _tmp1984) ? hml_i32_mul(_tmp1983, _tmp1984) : (hml_both_i64(_tmp1983, _tmp1984) ? hml_i64_mul(_tmp1983, _tmp1984) : hml_binary_op(HML_OP_MUL, _tmp1983, _tmp1984));
    hml_release_if_needed(&_tmp1983);
    hml_release_if_needed(&_tmp1984);
    HmlValue _tmp1985 = hml_val_f64(0);
    HmlValue _tmp1986 = hml_val_f64(255);
    HmlValue _tmp1981 = _mod0_fn_Clamp(NULL, _tmp1982, _tmp1985, _tmp1986);
    hml_release(&_tmp1982);
    hml_release(&_tmp1985);
    hml_release(&_tmp1986);
    HmlValue ri = hml_convert_to_type(_tmp1981, HML_VAL_I32);
    HmlValue _tmp1989 = g;
    hml_retain_if_needed(&_tmp1989);
    HmlValue _tmp1990 = hml_val_f64(255);
    HmlValue _tmp1988 = hml_both_i32(_tmp1989, _tmp1990) ? hml_i32_mul(_tmp1989, _tmp1990) : (hml_both_i64(_tmp1989, _tmp1990) ? hml_i64_mul(_tmp1989, _tmp1990) : hml_binary_op(HML_OP_MUL, _tmp1989, _tmp1990));
    hml_release_if_needed(&_tmp1989);
    hml_release_if_needed(&_tmp1990);
    HmlValue _tmp1991 = hml_val_f64(0);
    HmlValue _tmp1992 = hml_val_f64(255);
    HmlValue _tmp1987 = _mod0_fn_Clamp(NULL, _tmp1988, _tmp1991, _tmp1992);
    hml_release(&_tmp1988);
    hml_release(&_tmp1991);
    hml_release(&_tmp1992);
    HmlValue gi = hml_convert_to_type(_tmp1987, HML_VAL_I32);
    HmlValue _tmp1995 = b;
    hml_retain_if_needed(&_tmp1995);
    HmlValue _tmp1996 = hml_val_f64(255);
    HmlValue _tmp1994 = hml_both_i32(_tmp1995, _tmp1996) ? hml_i32_mul(_tmp1995, _tmp1996) : (hml_both_i64(_tmp1995, _tmp1996) ? hml_i64_mul(_tmp1995, _tmp1996) : hml_binary_op(HML_OP_MUL, _tmp1995, _tmp1996));
    hml_release_if_needed(&_tmp1995);
    hml_release_if_needed(&_tmp1996);
    HmlValue _tmp1997 = hml_val_f64(0);
    HmlValue _tmp1998 = hml_val_f64(255);
    HmlValue _tmp1993 = _mod0_fn_Clamp(NULL, _tmp1994, _tmp1997, _tmp1998);
    hml_release(&_tmp1994);
    hml_release(&_tmp1997);
    hml_release(&_tmp1998);
    HmlValue bi = hml_convert_to_type(_tmp1993, HML_VAL_I32);
    HmlValue _tmp2000 = ri;
    hml_retain_if_needed(&_tmp2000);
    HmlValue _tmp2001 = gi;
    hml_retain_if_needed(&_tmp2001);
    HmlValue _tmp2002 = bi;
    hml_retain_if_needed(&_tmp2002);
    HmlValue _tmp2003 = a;
    hml_retain_if_needed(&_tmp2003);
    HmlValue _tmp1999 = _mod0_fn_Color(NULL, _tmp2000, _tmp2001, _tmp2002, _tmp2003);
    hml_release(&_tmp2000);
    hml_release(&_tmp2001);
    hml_release(&_tmp2002);
    hml_release(&_tmp2003);
    HML_CALL_EXIT();
    return _tmp1999;
    return hml_val_null();
}

// Module init functions
// Module init: /home/user/raylock/src/raylib_loader.hml
static int _mod1_init_done = 0;
static void _mod1_init(void) {
    if (_mod1_init_done) return;
    _mod1_init_done = 1;
    
    
    HmlValue _tmp2063 = hml_platform();
    _mod1__platform = _tmp2063;
    HmlValue _tmp2065 = _mod1__platform;
    hml_retain_if_needed(&_tmp2065);
    HmlValue _tmp2066 = hml_val_string("macos");
    HmlValue _tmp2064 = hml_both_i32(_tmp2065, _tmp2066) ? hml_i32_eq(_tmp2065, _tmp2066) : (hml_both_i64(_tmp2065, _tmp2066) ? hml_i64_eq(_tmp2065, _tmp2066) : hml_binary_op(HML_OP_EQUAL, _tmp2065, _tmp2066));
    hml_release_if_needed(&_tmp2065);
    hml_release_if_needed(&_tmp2066);
    if (hml_to_bool(_tmp2064)) {
        {
            {
                HmlExceptionContext *_ex_ctx = hml_exception_push();
                if (setjmp(_ex_ctx->exception_buf) == 0) {
                    {
                        _ffi_lib = hml_ffi_load("/opt/homebrew/opt/raylib/lib/libraylib.dylib");
                    }
                } else {
                    HmlValue e = hml_exception_get_value();
                    {
                        {
                            HmlExceptionContext *_ex_ctx = hml_exception_push();
                            if (setjmp(_ex_ctx->exception_buf) == 0) {
                                {
                                    _ffi_lib = hml_ffi_load("/opt/homebrew/Cellar/raylib/5.5/lib/libraylib.dylib");
                                }
                            } else {
                                HmlValue e2 = hml_exception_get_value();
                                {
                                    {
                                        HmlExceptionContext *_ex_ctx = hml_exception_push();
                                        if (setjmp(_ex_ctx->exception_buf) == 0) {
                                            {
                                                _ffi_lib = hml_ffi_load("/usr/local/lib/libraylib.dylib");
                                            }
                                        } else {
                                            HmlValue e3 = hml_exception_get_value();
                                            {
                                                HmlValue _tmp2067 = hml_val_string("Failed to load raylib on macOS. Install with: brew install raylib");
                                                hml_throw(_tmp2067);
                                            }
                                            hml_release(&e3);
                                        }
                                        hml_exception_pop();
                                    }
                                }
                                hml_release(&e2);
                            }
                            hml_exception_pop();
                        }
                    }
                    hml_release(&e);
                }
                hml_exception_pop();
            }
        }
    } else {
        HmlValue _tmp2069 = _mod1__platform;
        hml_retain_if_needed(&_tmp2069);
        HmlValue _tmp2070 = hml_val_string("linux");
        HmlValue _tmp2068 = hml_both_i32(_tmp2069, _tmp2070) ? hml_i32_eq(_tmp2069, _tmp2070) : (hml_both_i64(_tmp2069, _tmp2070) ? hml_i64_eq(_tmp2069, _tmp2070) : hml_binary_op(HML_OP_EQUAL, _tmp2069, _tmp2070));
        hml_release_if_needed(&_tmp2069);
        hml_release_if_needed(&_tmp2070);
        if (hml_to_bool(_tmp2068)) {
            {
                {
                    HmlExceptionContext *_ex_ctx = hml_exception_push();
                    if (setjmp(_ex_ctx->exception_buf) == 0) {
                        {
                            _ffi_lib = hml_ffi_load("/usr/lib/libraylib.so");
                        }
                    } else {
                        HmlValue e = hml_exception_get_value();
                        {
                            {
                                HmlExceptionContext *_ex_ctx = hml_exception_push();
                                if (setjmp(_ex_ctx->exception_buf) == 0) {
                                    {
                                        _ffi_lib = hml_ffi_load("/usr/local/lib/libraylib.so");
                                    }
                                } else {
                                    HmlValue e2 = hml_exception_get_value();
                                    {
                                        {
                                            HmlExceptionContext *_ex_ctx = hml_exception_push();
                                            if (setjmp(_ex_ctx->exception_buf) == 0) {
                                                {
                                                    _ffi_lib = hml_ffi_load("/usr/lib/x86_64-linux-gnu/libraylib.so");
                                                }
                                            } else {
                                                HmlValue e3 = hml_exception_get_value();
                                                {
                                                    HmlValue _tmp2071 = hml_val_string("Failed to load raylib on Linux. Install raylib and ensure libraylib.so is in your library path.");
                                                    hml_throw(_tmp2071);
                                                }
                                                hml_release(&e3);
                                            }
                                            hml_exception_pop();
                                        }
                                    }
                                    hml_release(&e2);
                                }
                                hml_exception_pop();
                            }
                        }
                        hml_release(&e);
                    }
                    hml_exception_pop();
                }
            }
        } else {
            {
                HmlValue _tmp2073 = hml_val_string("Unsupported platform: ");
                HmlValue _tmp2074 = _mod1__platform;
                hml_retain_if_needed(&_tmp2074);
                HmlValue _tmp2075 = hml_val_string(". raylib-hemlock supports macOS and Linux.");
                HmlValue _tmp2072 = hml_string_concat3(_tmp2073, _tmp2074, _tmp2075);
                hml_release_if_needed(&_tmp2073);
                hml_release_if_needed(&_tmp2074);
                hml_release_if_needed(&_tmp2075);
                hml_throw(_tmp2072);
            }
        }
        hml_release(&_tmp2068);
    }
    hml_release(&_tmp2064);
    HmlValue _tmp2076 = hml_val_bool(1);
    _mod1_RAYLIB_LOADED = _tmp2076;
}

// Module init: /home/user/raylock/src/raylib.hml
static int _mod0_init_done = 0;
static void _mod0_init(void) {
    if (_mod0_init_done) return;
    _mod0_init_done = 1;
    
    _mod1_init();
    
    // Import from "./raylib_loader.hml"
    HmlValue RAYLIB_LOADED = _mod1_RAYLIB_LOADED;
    {
        HmlTypeField _type_fields_Vector2[2];
        _type_fields_Vector2[0].name = "x";
        _type_fields_Vector2[0].type_kind = HML_VAL_F32;
        _type_fields_Vector2[0].is_optional = 0;
        _type_fields_Vector2[0].default_value = hml_val_null();
        _type_fields_Vector2[1].name = "y";
        _type_fields_Vector2[1].type_kind = HML_VAL_F32;
        _type_fields_Vector2[1].is_optional = 0;
        _type_fields_Vector2[1].default_value = hml_val_null();
        hml_register_type("Vector2", _type_fields_Vector2, 2);
    }
    {
        HmlTypeField _type_fields_Vector3[3];
        _type_fields_Vector3[0].name = "x";
        _type_fields_Vector3[0].type_kind = HML_VAL_F32;
        _type_fields_Vector3[0].is_optional = 0;
        _type_fields_Vector3[0].default_value = hml_val_null();
        _type_fields_Vector3[1].name = "y";
        _type_fields_Vector3[1].type_kind = HML_VAL_F32;
        _type_fields_Vector3[1].is_optional = 0;
        _type_fields_Vector3[1].default_value = hml_val_null();
        _type_fields_Vector3[2].name = "z";
        _type_fields_Vector3[2].type_kind = HML_VAL_F32;
        _type_fields_Vector3[2].is_optional = 0;
        _type_fields_Vector3[2].default_value = hml_val_null();
        hml_register_type("Vector3", _type_fields_Vector3, 3);
    }
    {
        HmlTypeField _type_fields_Vector4[4];
        _type_fields_Vector4[0].name = "x";
        _type_fields_Vector4[0].type_kind = HML_VAL_F32;
        _type_fields_Vector4[0].is_optional = 0;
        _type_fields_Vector4[0].default_value = hml_val_null();
        _type_fields_Vector4[1].name = "y";
        _type_fields_Vector4[1].type_kind = HML_VAL_F32;
        _type_fields_Vector4[1].is_optional = 0;
        _type_fields_Vector4[1].default_value = hml_val_null();
        _type_fields_Vector4[2].name = "z";
        _type_fields_Vector4[2].type_kind = HML_VAL_F32;
        _type_fields_Vector4[2].is_optional = 0;
        _type_fields_Vector4[2].default_value = hml_val_null();
        _type_fields_Vector4[3].name = "w";
        _type_fields_Vector4[3].type_kind = HML_VAL_F32;
        _type_fields_Vector4[3].is_optional = 0;
        _type_fields_Vector4[3].default_value = hml_val_null();
        hml_register_type("Vector4", _type_fields_Vector4, 4);
    }
    {
        HmlTypeField _type_fields_ColorStruct[4];
        _type_fields_ColorStruct[0].name = "r";
        _type_fields_ColorStruct[0].type_kind = HML_VAL_U8;
        _type_fields_ColorStruct[0].is_optional = 0;
        _type_fields_ColorStruct[0].default_value = hml_val_null();
        _type_fields_ColorStruct[1].name = "g";
        _type_fields_ColorStruct[1].type_kind = HML_VAL_U8;
        _type_fields_ColorStruct[1].is_optional = 0;
        _type_fields_ColorStruct[1].default_value = hml_val_null();
        _type_fields_ColorStruct[2].name = "b";
        _type_fields_ColorStruct[2].type_kind = HML_VAL_U8;
        _type_fields_ColorStruct[2].is_optional = 0;
        _type_fields_ColorStruct[2].default_value = hml_val_null();
        _type_fields_ColorStruct[3].name = "a";
        _type_fields_ColorStruct[3].type_kind = HML_VAL_U8;
        _type_fields_ColorStruct[3].is_optional = 0;
        _type_fields_ColorStruct[3].default_value = hml_val_null();
        hml_register_type("ColorStruct", _type_fields_ColorStruct, 4);
    }
    {
        HmlTypeField _type_fields_Rectangle[4];
        _type_fields_Rectangle[0].name = "x";
        _type_fields_Rectangle[0].type_kind = HML_VAL_F32;
        _type_fields_Rectangle[0].is_optional = 0;
        _type_fields_Rectangle[0].default_value = hml_val_null();
        _type_fields_Rectangle[1].name = "y";
        _type_fields_Rectangle[1].type_kind = HML_VAL_F32;
        _type_fields_Rectangle[1].is_optional = 0;
        _type_fields_Rectangle[1].default_value = hml_val_null();
        _type_fields_Rectangle[2].name = "width";
        _type_fields_Rectangle[2].type_kind = HML_VAL_F32;
        _type_fields_Rectangle[2].is_optional = 0;
        _type_fields_Rectangle[2].default_value = hml_val_null();
        _type_fields_Rectangle[3].name = "height";
        _type_fields_Rectangle[3].type_kind = HML_VAL_F32;
        _type_fields_Rectangle[3].is_optional = 0;
        _type_fields_Rectangle[3].default_value = hml_val_null();
        hml_register_type("Rectangle", _type_fields_Rectangle, 4);
    }
    {
        HmlTypeField _type_fields_Texture2D[5];
        _type_fields_Texture2D[0].name = "id";
        _type_fields_Texture2D[0].type_kind = HML_VAL_U32;
        _type_fields_Texture2D[0].is_optional = 0;
        _type_fields_Texture2D[0].default_value = hml_val_null();
        _type_fields_Texture2D[1].name = "width";
        _type_fields_Texture2D[1].type_kind = HML_VAL_I32;
        _type_fields_Texture2D[1].is_optional = 0;
        _type_fields_Texture2D[1].default_value = hml_val_null();
        _type_fields_Texture2D[2].name = "height";
        _type_fields_Texture2D[2].type_kind = HML_VAL_I32;
        _type_fields_Texture2D[2].is_optional = 0;
        _type_fields_Texture2D[2].default_value = hml_val_null();
        _type_fields_Texture2D[3].name = "mipmaps";
        _type_fields_Texture2D[3].type_kind = HML_VAL_I32;
        _type_fields_Texture2D[3].is_optional = 0;
        _type_fields_Texture2D[3].default_value = hml_val_null();
        _type_fields_Texture2D[4].name = "format";
        _type_fields_Texture2D[4].type_kind = HML_VAL_I32;
        _type_fields_Texture2D[4].is_optional = 0;
        _type_fields_Texture2D[4].default_value = hml_val_null();
        hml_register_type("Texture2D", _type_fields_Texture2D, 5);
    }
    {
        HmlTypeField _type_fields_RenderTexture2D[3];
        _type_fields_RenderTexture2D[0].name = "id";
        _type_fields_RenderTexture2D[0].type_kind = HML_VAL_U32;
        _type_fields_RenderTexture2D[0].is_optional = 0;
        _type_fields_RenderTexture2D[0].default_value = hml_val_null();
        _type_fields_RenderTexture2D[1].name = "texture";
        _type_fields_RenderTexture2D[1].type_kind = -1;
        _type_fields_RenderTexture2D[1].is_optional = 0;
        _type_fields_RenderTexture2D[1].default_value = hml_val_null();
        _type_fields_RenderTexture2D[2].name = "depth";
        _type_fields_RenderTexture2D[2].type_kind = -1;
        _type_fields_RenderTexture2D[2].is_optional = 0;
        _type_fields_RenderTexture2D[2].default_value = hml_val_null();
        hml_register_type("RenderTexture2D", _type_fields_RenderTexture2D, 3);
    }
    {
        HmlTypeField _type_fields_Image[5];
        _type_fields_Image[0].name = "data";
        _type_fields_Image[0].type_kind = HML_VAL_PTR;
        _type_fields_Image[0].is_optional = 0;
        _type_fields_Image[0].default_value = hml_val_null();
        _type_fields_Image[1].name = "width";
        _type_fields_Image[1].type_kind = HML_VAL_I32;
        _type_fields_Image[1].is_optional = 0;
        _type_fields_Image[1].default_value = hml_val_null();
        _type_fields_Image[2].name = "height";
        _type_fields_Image[2].type_kind = HML_VAL_I32;
        _type_fields_Image[2].is_optional = 0;
        _type_fields_Image[2].default_value = hml_val_null();
        _type_fields_Image[3].name = "mipmaps";
        _type_fields_Image[3].type_kind = HML_VAL_I32;
        _type_fields_Image[3].is_optional = 0;
        _type_fields_Image[3].default_value = hml_val_null();
        _type_fields_Image[4].name = "format";
        _type_fields_Image[4].type_kind = HML_VAL_I32;
        _type_fields_Image[4].is_optional = 0;
        _type_fields_Image[4].default_value = hml_val_null();
        hml_register_type("Image", _type_fields_Image, 5);
    }
    {
        HmlTypeField _type_fields_Camera2D[4];
        _type_fields_Camera2D[0].name = "offset";
        _type_fields_Camera2D[0].type_kind = -1;
        _type_fields_Camera2D[0].is_optional = 0;
        _type_fields_Camera2D[0].default_value = hml_val_null();
        _type_fields_Camera2D[1].name = "target";
        _type_fields_Camera2D[1].type_kind = -1;
        _type_fields_Camera2D[1].is_optional = 0;
        _type_fields_Camera2D[1].default_value = hml_val_null();
        _type_fields_Camera2D[2].name = "rotation";
        _type_fields_Camera2D[2].type_kind = HML_VAL_F32;
        _type_fields_Camera2D[2].is_optional = 0;
        _type_fields_Camera2D[2].default_value = hml_val_null();
        _type_fields_Camera2D[3].name = "zoom";
        _type_fields_Camera2D[3].type_kind = HML_VAL_F32;
        _type_fields_Camera2D[3].is_optional = 0;
        _type_fields_Camera2D[3].default_value = hml_val_null();
        hml_register_type("Camera2D", _type_fields_Camera2D, 4);
    }
    {
        HmlTypeField _type_fields_Sound[6];
        _type_fields_Sound[0].name = "stream_buffer";
        _type_fields_Sound[0].type_kind = HML_VAL_PTR;
        _type_fields_Sound[0].is_optional = 0;
        _type_fields_Sound[0].default_value = hml_val_null();
        _type_fields_Sound[1].name = "stream_processor";
        _type_fields_Sound[1].type_kind = HML_VAL_PTR;
        _type_fields_Sound[1].is_optional = 0;
        _type_fields_Sound[1].default_value = hml_val_null();
        _type_fields_Sound[2].name = "stream_sampleRate";
        _type_fields_Sound[2].type_kind = HML_VAL_U32;
        _type_fields_Sound[2].is_optional = 0;
        _type_fields_Sound[2].default_value = hml_val_null();
        _type_fields_Sound[3].name = "stream_sampleSize";
        _type_fields_Sound[3].type_kind = HML_VAL_U32;
        _type_fields_Sound[3].is_optional = 0;
        _type_fields_Sound[3].default_value = hml_val_null();
        _type_fields_Sound[4].name = "stream_channels";
        _type_fields_Sound[4].type_kind = HML_VAL_U32;
        _type_fields_Sound[4].is_optional = 0;
        _type_fields_Sound[4].default_value = hml_val_null();
        _type_fields_Sound[5].name = "frameCount";
        _type_fields_Sound[5].type_kind = HML_VAL_U32;
        _type_fields_Sound[5].is_optional = 0;
        _type_fields_Sound[5].default_value = hml_val_null();
        hml_register_type("Sound", _type_fields_Sound, 6);
    }
    {
        HmlTypeField _type_fields_Music[9];
        _type_fields_Music[0].name = "stream_buffer";
        _type_fields_Music[0].type_kind = HML_VAL_PTR;
        _type_fields_Music[0].is_optional = 0;
        _type_fields_Music[0].default_value = hml_val_null();
        _type_fields_Music[1].name = "stream_processor";
        _type_fields_Music[1].type_kind = HML_VAL_PTR;
        _type_fields_Music[1].is_optional = 0;
        _type_fields_Music[1].default_value = hml_val_null();
        _type_fields_Music[2].name = "stream_sampleRate";
        _type_fields_Music[2].type_kind = HML_VAL_U32;
        _type_fields_Music[2].is_optional = 0;
        _type_fields_Music[2].default_value = hml_val_null();
        _type_fields_Music[3].name = "stream_sampleSize";
        _type_fields_Music[3].type_kind = HML_VAL_U32;
        _type_fields_Music[3].is_optional = 0;
        _type_fields_Music[3].default_value = hml_val_null();
        _type_fields_Music[4].name = "stream_channels";
        _type_fields_Music[4].type_kind = HML_VAL_U32;
        _type_fields_Music[4].is_optional = 0;
        _type_fields_Music[4].default_value = hml_val_null();
        _type_fields_Music[5].name = "frameCount";
        _type_fields_Music[5].type_kind = HML_VAL_U32;
        _type_fields_Music[5].is_optional = 0;
        _type_fields_Music[5].default_value = hml_val_null();
        _type_fields_Music[6].name = "looping";
        _type_fields_Music[6].type_kind = HML_VAL_I32;
        _type_fields_Music[6].is_optional = 0;
        _type_fields_Music[6].default_value = hml_val_null();
        _type_fields_Music[7].name = "ctxType";
        _type_fields_Music[7].type_kind = HML_VAL_I32;
        _type_fields_Music[7].is_optional = 0;
        _type_fields_Music[7].default_value = hml_val_null();
        _type_fields_Music[8].name = "ctxData";
        _type_fields_Music[8].type_kind = HML_VAL_PTR;
        _type_fields_Music[8].is_optional = 0;
        _type_fields_Music[8].default_value = hml_val_null();
        hml_register_type("Music", _type_fields_Music, 9);
    }
    {
        HmlTypeField _type_fields_GlyphInfo[5];
        _type_fields_GlyphInfo[0].name = "value";
        _type_fields_GlyphInfo[0].type_kind = HML_VAL_I32;
        _type_fields_GlyphInfo[0].is_optional = 0;
        _type_fields_GlyphInfo[0].default_value = hml_val_null();
        _type_fields_GlyphInfo[1].name = "offsetX";
        _type_fields_GlyphInfo[1].type_kind = HML_VAL_I32;
        _type_fields_GlyphInfo[1].is_optional = 0;
        _type_fields_GlyphInfo[1].default_value = hml_val_null();
        _type_fields_GlyphInfo[2].name = "offsetY";
        _type_fields_GlyphInfo[2].type_kind = HML_VAL_I32;
        _type_fields_GlyphInfo[2].is_optional = 0;
        _type_fields_GlyphInfo[2].default_value = hml_val_null();
        _type_fields_GlyphInfo[3].name = "advanceX";
        _type_fields_GlyphInfo[3].type_kind = HML_VAL_I32;
        _type_fields_GlyphInfo[3].is_optional = 0;
        _type_fields_GlyphInfo[3].default_value = hml_val_null();
        _type_fields_GlyphInfo[4].name = "image";
        _type_fields_GlyphInfo[4].type_kind = -1;
        _type_fields_GlyphInfo[4].is_optional = 0;
        _type_fields_GlyphInfo[4].default_value = hml_val_null();
        hml_register_type("GlyphInfo", _type_fields_GlyphInfo, 5);
    }
    {
        HmlTypeField _type_fields_Font[6];
        _type_fields_Font[0].name = "baseSize";
        _type_fields_Font[0].type_kind = HML_VAL_I32;
        _type_fields_Font[0].is_optional = 0;
        _type_fields_Font[0].default_value = hml_val_null();
        _type_fields_Font[1].name = "glyphCount";
        _type_fields_Font[1].type_kind = HML_VAL_I32;
        _type_fields_Font[1].is_optional = 0;
        _type_fields_Font[1].default_value = hml_val_null();
        _type_fields_Font[2].name = "glyphPadding";
        _type_fields_Font[2].type_kind = HML_VAL_I32;
        _type_fields_Font[2].is_optional = 0;
        _type_fields_Font[2].default_value = hml_val_null();
        _type_fields_Font[3].name = "texture";
        _type_fields_Font[3].type_kind = -1;
        _type_fields_Font[3].is_optional = 0;
        _type_fields_Font[3].default_value = hml_val_null();
        _type_fields_Font[4].name = "recs";
        _type_fields_Font[4].type_kind = HML_VAL_PTR;
        _type_fields_Font[4].is_optional = 0;
        _type_fields_Font[4].default_value = hml_val_null();
        _type_fields_Font[5].name = "glyphs";
        _type_fields_Font[5].type_kind = HML_VAL_PTR;
        _type_fields_Font[5].is_optional = 0;
        _type_fields_Font[5].default_value = hml_val_null();
        hml_register_type("Font", _type_fields_Font, 6);
    }
    _mod0_InitWindow = hml_val_function((void*)hml_fn_InitWindow, 3, 3, 0);
    _mod0_CloseWindow = hml_val_function((void*)hml_fn_CloseWindow, 0, 0, 0);
    _mod0_WindowShouldClose = hml_val_function((void*)hml_fn_WindowShouldClose, 0, 0, 0);
    _mod0_IsWindowReady = hml_val_function((void*)hml_fn_IsWindowReady, 0, 0, 0);
    _mod0_IsWindowFullscreen = hml_val_function((void*)hml_fn_IsWindowFullscreen, 0, 0, 0);
    _mod0_IsWindowHidden = hml_val_function((void*)hml_fn_IsWindowHidden, 0, 0, 0);
    _mod0_IsWindowMinimized = hml_val_function((void*)hml_fn_IsWindowMinimized, 0, 0, 0);
    _mod0_IsWindowMaximized = hml_val_function((void*)hml_fn_IsWindowMaximized, 0, 0, 0);
    _mod0_IsWindowFocused = hml_val_function((void*)hml_fn_IsWindowFocused, 0, 0, 0);
    _mod0_IsWindowResized = hml_val_function((void*)hml_fn_IsWindowResized, 0, 0, 0);
    _mod0_IsWindowState = hml_val_function((void*)hml_fn_IsWindowState, 1, 1, 0);
    _mod0_SetWindowState = hml_val_function((void*)hml_fn_SetWindowState, 1, 1, 0);
    _mod0_ClearWindowState = hml_val_function((void*)hml_fn_ClearWindowState, 1, 1, 0);
    _mod0_SetWindowTitle = hml_val_function((void*)hml_fn_SetWindowTitle, 1, 1, 0);
    _mod0_SetWindowPosition = hml_val_function((void*)hml_fn_SetWindowPosition, 2, 2, 0);
    _mod0_SetWindowSize = hml_val_function((void*)hml_fn_SetWindowSize, 2, 2, 0);
    _mod0_SetWindowMinSize = hml_val_function((void*)hml_fn_SetWindowMinSize, 2, 2, 0);
    _mod0_SetWindowMaxSize = hml_val_function((void*)hml_fn_SetWindowMaxSize, 2, 2, 0);
    _mod0_GetScreenWidth = hml_val_function((void*)hml_fn_GetScreenWidth, 0, 0, 0);
    _mod0_GetScreenHeight = hml_val_function((void*)hml_fn_GetScreenHeight, 0, 0, 0);
    _mod0_GetRenderWidth = hml_val_function((void*)hml_fn_GetRenderWidth, 0, 0, 0);
    _mod0_GetRenderHeight = hml_val_function((void*)hml_fn_GetRenderHeight, 0, 0, 0);
    _mod0_GetMonitorCount = hml_val_function((void*)hml_fn_GetMonitorCount, 0, 0, 0);
    _mod0_GetCurrentMonitor = hml_val_function((void*)hml_fn_GetCurrentMonitor, 0, 0, 0);
    _mod0_GetMonitorWidth = hml_val_function((void*)hml_fn_GetMonitorWidth, 1, 1, 0);
    _mod0_GetMonitorHeight = hml_val_function((void*)hml_fn_GetMonitorHeight, 1, 1, 0);
    _mod0_GetMonitorRefreshRate = hml_val_function((void*)hml_fn_GetMonitorRefreshRate, 1, 1, 0);
    _mod0_GetMonitorPhysicalWidth = hml_val_function((void*)hml_fn_GetMonitorPhysicalWidth, 1, 1, 0);
    _mod0_GetMonitorPhysicalHeight = hml_val_function((void*)hml_fn_GetMonitorPhysicalHeight, 1, 1, 0);
    _mod0_GetMonitorName = hml_val_function((void*)hml_fn_GetMonitorName, 1, 1, 0);
    _mod0_ToggleFullscreen = hml_val_function((void*)hml_fn_ToggleFullscreen, 0, 0, 0);
    _mod0_ToggleBorderlessWindowed = hml_val_function((void*)hml_fn_ToggleBorderlessWindowed, 0, 0, 0);
    _mod0_MaximizeWindow = hml_val_function((void*)hml_fn_MaximizeWindow, 0, 0, 0);
    _mod0_MinimizeWindow = hml_val_function((void*)hml_fn_MinimizeWindow, 0, 0, 0);
    _mod0_RestoreWindow = hml_val_function((void*)hml_fn_RestoreWindow, 0, 0, 0);
    _mod0_SetWindowOpacity = hml_val_function((void*)hml_fn_SetWindowOpacity, 1, 1, 0);
    _mod0_SetWindowFocused = hml_val_function((void*)hml_fn_SetWindowFocused, 0, 0, 0);
    _mod0_SetWindowIcon = hml_val_function((void*)hml_fn_SetWindowIcon, 1, 1, 0);
    _mod0_SetTargetFPS = hml_val_function((void*)hml_fn_SetTargetFPS, 1, 1, 0);
    _mod0_GetFPS = hml_val_function((void*)hml_fn_GetFPS, 0, 0, 0);
    _mod0_GetFrameTime = hml_val_function((void*)hml_fn_GetFrameTime, 0, 0, 0);
    _mod0_GetTime = hml_val_function((void*)hml_fn_GetTime, 0, 0, 0);
    _mod0_ClearBackground = hml_val_function((void*)hml_fn_ClearBackground, 1, 1, 0);
    _mod0_BeginDrawing = hml_val_function((void*)hml_fn_BeginDrawing, 0, 0, 0);
    _mod0_EndDrawing = hml_val_function((void*)hml_fn_EndDrawing, 0, 0, 0);
    _mod0_BeginBlendMode = hml_val_function((void*)hml_fn_BeginBlendMode, 1, 1, 0);
    _mod0_EndBlendMode = hml_val_function((void*)hml_fn_EndBlendMode, 0, 0, 0);
    _mod0_BeginScissorMode = hml_val_function((void*)hml_fn_BeginScissorMode, 4, 4, 0);
    _mod0_EndScissorMode = hml_val_function((void*)hml_fn_EndScissorMode, 0, 0, 0);
    _mod0_rlBegin = hml_val_function((void*)hml_fn_rlBegin, 1, 1, 0);
    _mod0_rlEnd = hml_val_function((void*)hml_fn_rlEnd, 0, 0, 0);
    _mod0_rlVertex2f = hml_val_function((void*)hml_fn_rlVertex2f, 2, 2, 0);
    _mod0_rlVertex2i = hml_val_function((void*)hml_fn_rlVertex2i, 2, 2, 0);
    _mod0_rlColor4ub = hml_val_function((void*)hml_fn_rlColor4ub, 4, 4, 0);
    HmlValue _tmp2077 = hml_val_i32(1);
    _mod0_RL_LINES = _tmp2077;
    HmlValue _tmp2078 = hml_val_i32(4);
    _mod0_RL_TRIANGLES = _tmp2078;
    HmlValue _tmp2079 = hml_val_i32(7);
    _mod0_RL_QUADS = _tmp2079;
    _mod0_IsKeyPressed = hml_val_function((void*)hml_fn_IsKeyPressed, 1, 1, 0);
    _mod0_IsKeyPressedRepeat = hml_val_function((void*)hml_fn_IsKeyPressedRepeat, 1, 1, 0);
    _mod0_IsKeyDown = hml_val_function((void*)hml_fn_IsKeyDown, 1, 1, 0);
    _mod0_IsKeyReleased = hml_val_function((void*)hml_fn_IsKeyReleased, 1, 1, 0);
    _mod0_IsKeyUp = hml_val_function((void*)hml_fn_IsKeyUp, 1, 1, 0);
    _mod0_GetKeyPressed = hml_val_function((void*)hml_fn_GetKeyPressed, 0, 0, 0);
    _mod0_GetCharPressed = hml_val_function((void*)hml_fn_GetCharPressed, 0, 0, 0);
    _mod0_GetKeyName = hml_val_function((void*)hml_fn_GetKeyName, 1, 1, 0);
    _mod0_SetExitKey = hml_val_function((void*)hml_fn_SetExitKey, 1, 1, 0);
    _mod0_IsMouseButtonPressed = hml_val_function((void*)hml_fn_IsMouseButtonPressed, 1, 1, 0);
    _mod0_IsMouseButtonDown = hml_val_function((void*)hml_fn_IsMouseButtonDown, 1, 1, 0);
    _mod0_IsMouseButtonReleased = hml_val_function((void*)hml_fn_IsMouseButtonReleased, 1, 1, 0);
    _mod0_IsMouseButtonUp = hml_val_function((void*)hml_fn_IsMouseButtonUp, 1, 1, 0);
    _mod0_GetMouseX = hml_val_function((void*)hml_fn_GetMouseX, 0, 0, 0);
    _mod0_GetMouseY = hml_val_function((void*)hml_fn_GetMouseY, 0, 0, 0);
    _mod0_GetMousePosition = hml_val_function((void*)hml_fn_GetMousePosition, 0, 0, 0);
    _mod0_GetMouseDelta = hml_val_function((void*)hml_fn_GetMouseDelta, 0, 0, 0);
    _mod0_GetMouseWheelMove = hml_val_function((void*)hml_fn_GetMouseWheelMove, 0, 0, 0);
    _mod0_GetMouseWheelMoveV = hml_val_function((void*)hml_fn_GetMouseWheelMoveV, 0, 0, 0);
    _mod0_SetMousePosition = hml_val_function((void*)hml_fn_SetMousePosition, 2, 2, 0);
    _mod0_SetMouseOffset = hml_val_function((void*)hml_fn_SetMouseOffset, 2, 2, 0);
    _mod0_SetMouseScale = hml_val_function((void*)hml_fn_SetMouseScale, 2, 2, 0);
    _mod0_SetMouseCursor = hml_val_function((void*)hml_fn_SetMouseCursor, 1, 1, 0);
    _mod0_ShowCursor = hml_val_function((void*)hml_fn_ShowCursor, 0, 0, 0);
    _mod0_HideCursor = hml_val_function((void*)hml_fn_HideCursor, 0, 0, 0);
    _mod0_IsCursorHidden = hml_val_function((void*)hml_fn_IsCursorHidden, 0, 0, 0);
    _mod0_EnableCursor = hml_val_function((void*)hml_fn_EnableCursor, 0, 0, 0);
    _mod0_DisableCursor = hml_val_function((void*)hml_fn_DisableCursor, 0, 0, 0);
    _mod0_IsCursorOnScreen = hml_val_function((void*)hml_fn_IsCursorOnScreen, 0, 0, 0);
    _mod0_IsGamepadAvailable = hml_val_function((void*)hml_fn_IsGamepadAvailable, 1, 1, 0);
    _mod0_GetGamepadName = hml_val_function((void*)hml_fn_GetGamepadName, 1, 1, 0);
    _mod0_IsGamepadButtonPressed = hml_val_function((void*)hml_fn_IsGamepadButtonPressed, 2, 2, 0);
    _mod0_IsGamepadButtonDown = hml_val_function((void*)hml_fn_IsGamepadButtonDown, 2, 2, 0);
    _mod0_IsGamepadButtonReleased = hml_val_function((void*)hml_fn_IsGamepadButtonReleased, 2, 2, 0);
    _mod0_IsGamepadButtonUp = hml_val_function((void*)hml_fn_IsGamepadButtonUp, 2, 2, 0);
    _mod0_GetGamepadButtonPressed = hml_val_function((void*)hml_fn_GetGamepadButtonPressed, 0, 0, 0);
    _mod0_GetGamepadAxisCount = hml_val_function((void*)hml_fn_GetGamepadAxisCount, 1, 1, 0);
    _mod0_GetGamepadAxisMovement = hml_val_function((void*)hml_fn_GetGamepadAxisMovement, 2, 2, 0);
    _mod0_SetGamepadMappings = hml_val_function((void*)hml_fn_SetGamepadMappings, 1, 1, 0);
    _mod0_SetGamepadVibration = hml_val_function((void*)hml_fn_SetGamepadVibration, 4, 4, 0);
    _mod0_GetTouchX = hml_val_function((void*)hml_fn_GetTouchX, 0, 0, 0);
    _mod0_GetTouchY = hml_val_function((void*)hml_fn_GetTouchY, 0, 0, 0);
    _mod0_GetTouchPosition = hml_val_function((void*)hml_fn_GetTouchPosition, 1, 1, 0);
    _mod0_GetTouchPointId = hml_val_function((void*)hml_fn_GetTouchPointId, 1, 1, 0);
    _mod0_GetTouchPointCount = hml_val_function((void*)hml_fn_GetTouchPointCount, 0, 0, 0);
    _mod0_SetGesturesEnabled = hml_val_function((void*)hml_fn_SetGesturesEnabled, 1, 1, 0);
    _mod0_IsGestureDetected = hml_val_function((void*)hml_fn_IsGestureDetected, 1, 1, 0);
    _mod0_GetGestureDetected = hml_val_function((void*)hml_fn_GetGestureDetected, 0, 0, 0);
    _mod0_GetGestureHoldDuration = hml_val_function((void*)hml_fn_GetGestureHoldDuration, 0, 0, 0);
    _mod0_GetGestureDragAngle = hml_val_function((void*)hml_fn_GetGestureDragAngle, 0, 0, 0);
    _mod0_GetGesturePinchAngle = hml_val_function((void*)hml_fn_GetGesturePinchAngle, 0, 0, 0);
    _mod0_TraceLog = hml_val_function((void*)hml_fn_TraceLog, 2, 2, 0);
    _mod0_SetTraceLogLevel = hml_val_function((void*)hml_fn_SetTraceLogLevel, 1, 1, 0);
    _mod0_DrawPixel = hml_val_function((void*)hml_fn_DrawPixel, 3, 3, 0);
    _mod0_DrawPixelV = hml_val_function((void*)hml_fn_DrawPixelV, 2, 2, 0);
    _mod0_DrawLine = hml_val_function((void*)hml_fn_DrawLine, 5, 5, 0);
    _mod0_DrawLineV = hml_val_function((void*)hml_fn_DrawLineV, 3, 3, 0);
    _mod0_DrawLineEx = hml_val_function((void*)hml_fn_DrawLineEx, 4, 4, 0);
    _mod0_DrawLineStrip = hml_val_function((void*)hml_fn_DrawLineStrip, 3, 3, 0);
    _mod0_DrawLineBezier = hml_val_function((void*)hml_fn_DrawLineBezier, 4, 4, 0);
    _mod0_DrawCircle = hml_val_function((void*)hml_fn_DrawCircle, 4, 4, 0);
    _mod0_DrawCircleV = hml_val_function((void*)hml_fn_DrawCircleV, 3, 3, 0);
    _mod0_DrawCircleGradient = hml_val_function((void*)hml_fn_DrawCircleGradient, 5, 5, 0);
    _mod0_DrawCircleLines = hml_val_function((void*)hml_fn_DrawCircleLines, 4, 4, 0);
    _mod0_DrawCircleLinesV = hml_val_function((void*)hml_fn_DrawCircleLinesV, 3, 3, 0);
    _mod0_DrawCircleSector = hml_val_function((void*)hml_fn_DrawCircleSector, 6, 6, 0);
    _mod0_DrawCircleSectorLines = hml_val_function((void*)hml_fn_DrawCircleSectorLines, 6, 6, 0);
    _mod0_DrawRing = hml_val_function((void*)hml_fn_DrawRing, 7, 7, 0);
    _mod0_DrawRingLines = hml_val_function((void*)hml_fn_DrawRingLines, 7, 7, 0);
    _mod0_DrawEllipse = hml_val_function((void*)hml_fn_DrawEllipse, 5, 5, 0);
    _mod0_DrawEllipseLines = hml_val_function((void*)hml_fn_DrawEllipseLines, 5, 5, 0);
    _mod0_DrawRectangle = hml_val_function((void*)hml_fn_DrawRectangle, 5, 5, 0);
    _mod0_DrawRectangleV = hml_val_function((void*)hml_fn_DrawRectangleV, 3, 3, 0);
    _mod0_DrawRectangleRec = hml_val_function((void*)hml_fn_DrawRectangleRec, 2, 2, 0);
    _mod0_DrawRectanglePro = hml_val_function((void*)hml_fn_DrawRectanglePro, 4, 4, 0);
    _mod0_DrawRectangleGradientV = hml_val_function((void*)hml_fn_DrawRectangleGradientV, 6, 6, 0);
    _mod0_DrawRectangleGradientH = hml_val_function((void*)hml_fn_DrawRectangleGradientH, 6, 6, 0);
    _mod0_DrawRectangleGradientEx = hml_val_function((void*)hml_fn_DrawRectangleGradientEx, 5, 5, 0);
    _mod0_DrawRectangleLines = hml_val_function((void*)hml_fn_DrawRectangleLines, 5, 5, 0);
    _mod0_DrawRectangleLinesEx = hml_val_function((void*)hml_fn_DrawRectangleLinesEx, 3, 3, 0);
    _mod0_DrawRectangleRounded = hml_val_function((void*)hml_fn_DrawRectangleRounded, 4, 4, 0);
    _mod0_DrawRectangleRoundedLines = hml_val_function((void*)hml_fn_DrawRectangleRoundedLines, 4, 4, 0);
    _mod0_DrawRectangleRoundedLinesEx = hml_val_function((void*)hml_fn_DrawRectangleRoundedLinesEx, 5, 5, 0);
    _mod0_DrawTriangle = hml_val_function((void*)hml_fn_DrawTriangle, 4, 4, 0);
    _mod0_DrawTriangleLines = hml_val_function((void*)hml_fn_DrawTriangleLines, 4, 4, 0);
    _mod0_DrawTriangleFan = hml_val_function((void*)hml_fn_DrawTriangleFan, 3, 3, 0);
    _mod0_DrawTriangleStrip = hml_val_function((void*)hml_fn_DrawTriangleStrip, 3, 3, 0);
    _mod0_DrawPoly = hml_val_function((void*)hml_fn_DrawPoly, 5, 5, 0);
    _mod0_DrawPolyLines = hml_val_function((void*)hml_fn_DrawPolyLines, 5, 5, 0);
    _mod0_DrawPolyLinesEx = hml_val_function((void*)hml_fn_DrawPolyLinesEx, 6, 6, 0);
    _mod0_DrawText = hml_val_function((void*)hml_fn_DrawText, 5, 5, 0);
    _mod0_MeasureText = hml_val_function((void*)hml_fn_MeasureText, 2, 2, 0);
    _mod0_WaitTime = hml_val_function((void*)hml_fn_WaitTime, 1, 1, 0);
    _mod0_GetRandomValue = hml_val_function((void*)hml_fn_GetRandomValue, 2, 2, 0);
    _mod0_SetRandomSeed = hml_val_function((void*)hml_fn_SetRandomSeed, 1, 1, 0);
    _mod0_TakeScreenshot = hml_val_function((void*)hml_fn_TakeScreenshot, 1, 1, 0);
    _mod0_SetConfigFlags = hml_val_function((void*)hml_fn_SetConfigFlags, 1, 1, 0);
    _mod0_OpenURL = hml_val_function((void*)hml_fn_OpenURL, 1, 1, 0);
    _mod0_SetClipboardText = hml_val_function((void*)hml_fn_SetClipboardText, 1, 1, 0);
    _mod0_GetClipboardText = hml_val_function((void*)hml_fn_GetClipboardText, 0, 0, 0);
    _mod0_CheckCollisionRecs = hml_val_function((void*)hml_fn_CheckCollisionRecs, 2, 2, 0);
    _mod0_CheckCollisionCircles = hml_val_function((void*)hml_fn_CheckCollisionCircles, 4, 4, 0);
    _mod0_CheckCollisionCircleRec = hml_val_function((void*)hml_fn_CheckCollisionCircleRec, 3, 3, 0);
    _mod0_CheckCollisionPointRec = hml_val_function((void*)hml_fn_CheckCollisionPointRec, 2, 2, 0);
    _mod0_CheckCollisionPointCircle = hml_val_function((void*)hml_fn_CheckCollisionPointCircle, 3, 3, 0);
    _mod0_CheckCollisionPointTriangle = hml_val_function((void*)hml_fn_CheckCollisionPointTriangle, 4, 4, 0);
    _mod0_CheckCollisionPointLine = hml_val_function((void*)hml_fn_CheckCollisionPointLine, 4, 4, 0);
    _mod0_CheckCollisionLines = hml_val_function((void*)hml_fn_CheckCollisionLines, 5, 5, 0);
    _mod0_GetCollisionRec = hml_val_function((void*)hml_fn_GetCollisionRec, 2, 2, 0);
    _mod0_DrawFPS = hml_val_function((void*)hml_fn_DrawFPS, 2, 2, 0);
    _mod0_InitAudioDevice = hml_val_function((void*)hml_fn_InitAudioDevice, 0, 0, 0);
    _mod0_CloseAudioDevice = hml_val_function((void*)hml_fn_CloseAudioDevice, 0, 0, 0);
    _mod0_IsAudioDeviceReady = hml_val_function((void*)hml_fn_IsAudioDeviceReady, 0, 0, 0);
    _mod0_SetMasterVolume = hml_val_function((void*)hml_fn_SetMasterVolume, 1, 1, 0);
    _mod0_GetMasterVolume = hml_val_function((void*)hml_fn_GetMasterVolume, 0, 0, 0);
    _mod0_LoadTexture = hml_val_function((void*)hml_fn_LoadTexture, 1, 1, 0);
    _mod0_LoadTextureFromImage = hml_val_function((void*)hml_fn_LoadTextureFromImage, 1, 1, 0);
    _mod0_UnloadTexture = hml_val_function((void*)hml_fn_UnloadTexture, 1, 1, 0);
    _mod0_IsTextureValid = hml_val_function((void*)hml_fn_IsTextureValid, 1, 1, 0);
    _mod0_UpdateTexture = hml_val_function((void*)hml_fn_UpdateTexture, 2, 2, 0);
    _mod0_DrawTexture = hml_val_function((void*)hml_fn_DrawTexture, 4, 4, 0);
    _mod0_DrawTextureV = hml_val_function((void*)hml_fn_DrawTextureV, 3, 3, 0);
    _mod0_DrawTextureEx = hml_val_function((void*)hml_fn_DrawTextureEx, 5, 5, 0);
    _mod0_DrawTextureRec = hml_val_function((void*)hml_fn_DrawTextureRec, 4, 4, 0);
    _mod0_DrawTexturePro = hml_val_function((void*)hml_fn_DrawTexturePro, 6, 6, 0);
    _mod0_SetTextureFilter = hml_val_function((void*)hml_fn_SetTextureFilter, 2, 2, 0);
    _mod0_SetTextureWrap = hml_val_function((void*)hml_fn_SetTextureWrap, 2, 2, 0);
    _mod0_LoadRenderTexture = hml_val_function((void*)hml_fn_LoadRenderTexture, 2, 2, 0);
    _mod0_UnloadRenderTexture = hml_val_function((void*)hml_fn_UnloadRenderTexture, 1, 1, 0);
    _mod0_IsRenderTextureValid = hml_val_function((void*)hml_fn_IsRenderTextureValid, 1, 1, 0);
    _mod0_BeginTextureMode = hml_val_function((void*)hml_fn_BeginTextureMode, 1, 1, 0);
    _mod0_EndTextureMode = hml_val_function((void*)hml_fn_EndTextureMode, 0, 0, 0);
    _mod0_LoadSound = hml_val_function((void*)hml_fn_LoadSound, 1, 1, 0);
    _mod0_UnloadSound = hml_val_function((void*)hml_fn_UnloadSound, 1, 1, 0);
    _mod0_IsSoundValid = hml_val_function((void*)hml_fn_IsSoundValid, 1, 1, 0);
    _mod0_PlaySound = hml_val_function((void*)hml_fn_PlaySound, 1, 1, 0);
    _mod0_StopSound = hml_val_function((void*)hml_fn_StopSound, 1, 1, 0);
    _mod0_PauseSound = hml_val_function((void*)hml_fn_PauseSound, 1, 1, 0);
    _mod0_ResumeSound = hml_val_function((void*)hml_fn_ResumeSound, 1, 1, 0);
    _mod0_IsSoundPlaying = hml_val_function((void*)hml_fn_IsSoundPlaying, 1, 1, 0);
    _mod0_SetSoundVolume = hml_val_function((void*)hml_fn_SetSoundVolume, 2, 2, 0);
    _mod0_SetSoundPitch = hml_val_function((void*)hml_fn_SetSoundPitch, 2, 2, 0);
    _mod0_SetSoundPan = hml_val_function((void*)hml_fn_SetSoundPan, 2, 2, 0);
    _mod0_LoadMusicStream = hml_val_function((void*)hml_fn_LoadMusicStream, 1, 1, 0);
    _mod0_UnloadMusicStream = hml_val_function((void*)hml_fn_UnloadMusicStream, 1, 1, 0);
    _mod0_IsMusicValid = hml_val_function((void*)hml_fn_IsMusicValid, 1, 1, 0);
    _mod0_PlayMusicStream = hml_val_function((void*)hml_fn_PlayMusicStream, 1, 1, 0);
    _mod0_StopMusicStream = hml_val_function((void*)hml_fn_StopMusicStream, 1, 1, 0);
    _mod0_PauseMusicStream = hml_val_function((void*)hml_fn_PauseMusicStream, 1, 1, 0);
    _mod0_ResumeMusicStream = hml_val_function((void*)hml_fn_ResumeMusicStream, 1, 1, 0);
    _mod0_UpdateMusicStream = hml_val_function((void*)hml_fn_UpdateMusicStream, 1, 1, 0);
    _mod0_IsMusicStreamPlaying = hml_val_function((void*)hml_fn_IsMusicStreamPlaying, 1, 1, 0);
    _mod0_SetMusicVolume = hml_val_function((void*)hml_fn_SetMusicVolume, 2, 2, 0);
    _mod0_SetMusicPitch = hml_val_function((void*)hml_fn_SetMusicPitch, 2, 2, 0);
    _mod0_SetMusicPan = hml_val_function((void*)hml_fn_SetMusicPan, 2, 2, 0);
    _mod0_GetMusicTimeLength = hml_val_function((void*)hml_fn_GetMusicTimeLength, 1, 1, 0);
    _mod0_GetMusicTimePlayed = hml_val_function((void*)hml_fn_GetMusicTimePlayed, 1, 1, 0);
    _mod0_SeekMusicStream = hml_val_function((void*)hml_fn_SeekMusicStream, 2, 2, 0);
    _mod0_SetMusicLooping = hml_val_function((void*)hml_fn_SetMusicLooping, 2, 2, 0);
    _mod0_LoadFont = hml_val_function((void*)hml_fn_LoadFont, 1, 1, 0);
    _mod0_LoadFontEx = hml_val_function((void*)hml_fn_LoadFontEx, 4, 4, 0);
    _mod0_UnloadFont = hml_val_function((void*)hml_fn_UnloadFont, 1, 1, 0);
    _mod0_IsFontValid = hml_val_function((void*)hml_fn_IsFontValid, 1, 1, 0);
    _mod0_GetFontDefault = hml_val_function((void*)hml_fn_GetFontDefault, 0, 0, 0);
    _mod0_DrawTextEx = hml_val_function((void*)hml_fn_DrawTextEx, 6, 6, 0);
    _mod0_DrawTextPro = hml_val_function((void*)hml_fn_DrawTextPro, 8, 8, 0);
    _mod0_MeasureTextEx = hml_val_function((void*)hml_fn_MeasureTextEx, 4, 4, 0);
    _mod0_LoadImage = hml_val_function((void*)hml_fn_LoadImage, 1, 1, 0);
    _mod0_LoadImageRaw = hml_val_function((void*)hml_fn_LoadImageRaw, 5, 5, 0);
    _mod0_LoadImageFromMemory = hml_val_function((void*)hml_fn_LoadImageFromMemory, 3, 3, 0);
    _mod0_UnloadImage = hml_val_function((void*)hml_fn_UnloadImage, 1, 1, 0);
    _mod0_IsImageValid = hml_val_function((void*)hml_fn_IsImageValid, 1, 1, 0);
    _mod0_ExportImage = hml_val_function((void*)hml_fn_ExportImage, 2, 2, 0);
    _mod0_GenImageColor = hml_val_function((void*)hml_fn_GenImageColor, 3, 3, 0);
    _mod0_GenImageGradientLinear = hml_val_function((void*)hml_fn_GenImageGradientLinear, 5, 5, 0);
    _mod0_GenImageGradientRadial = hml_val_function((void*)hml_fn_GenImageGradientRadial, 5, 5, 0);
    _mod0_GenImageChecked = hml_val_function((void*)hml_fn_GenImageChecked, 6, 6, 0);
    _mod0_GenImageWhiteNoise = hml_val_function((void*)hml_fn_GenImageWhiteNoise, 3, 3, 0);
    _mod0_GenImagePerlinNoise = hml_val_function((void*)hml_fn_GenImagePerlinNoise, 5, 5, 0);
    _mod0_ImageCopy = hml_val_function((void*)hml_fn_ImageCopy, 1, 1, 0);
    _mod0_ImageFromImage = hml_val_function((void*)hml_fn_ImageFromImage, 2, 2, 0);
    _mod0_ImageResize = hml_val_function((void*)hml_fn_ImageResize, 3, 3, 0);
    _mod0_ImageResizeNN = hml_val_function((void*)hml_fn_ImageResizeNN, 3, 3, 0);
    _mod0_ImageCrop = hml_val_function((void*)hml_fn_ImageCrop, 2, 2, 0);
    _mod0_ImageFlipVertical = hml_val_function((void*)hml_fn_ImageFlipVertical, 1, 1, 0);
    _mod0_ImageFlipHorizontal = hml_val_function((void*)hml_fn_ImageFlipHorizontal, 1, 1, 0);
    _mod0_ImageRotate = hml_val_function((void*)hml_fn_ImageRotate, 2, 2, 0);
    _mod0_ImageRotateCW = hml_val_function((void*)hml_fn_ImageRotateCW, 1, 1, 0);
    _mod0_ImageRotateCCW = hml_val_function((void*)hml_fn_ImageRotateCCW, 1, 1, 0);
    _mod0_ImageColorTint = hml_val_function((void*)hml_fn_ImageColorTint, 2, 2, 0);
    _mod0_ImageColorInvert = hml_val_function((void*)hml_fn_ImageColorInvert, 1, 1, 0);
    _mod0_ImageColorGrayscale = hml_val_function((void*)hml_fn_ImageColorGrayscale, 1, 1, 0);
    _mod0_ImageColorContrast = hml_val_function((void*)hml_fn_ImageColorContrast, 2, 2, 0);
    _mod0_ImageColorBrightness = hml_val_function((void*)hml_fn_ImageColorBrightness, 2, 2, 0);
    _mod0_ImageClearBackground = hml_val_function((void*)hml_fn_ImageClearBackground, 2, 2, 0);
    _mod0_ImageDrawPixel = hml_val_function((void*)hml_fn_ImageDrawPixel, 4, 4, 0);
    _mod0_ImageDrawPixelV = hml_val_function((void*)hml_fn_ImageDrawPixelV, 3, 3, 0);
    _mod0_ImageDrawLine = hml_val_function((void*)hml_fn_ImageDrawLine, 6, 6, 0);
    _mod0_ImageDrawLineV = hml_val_function((void*)hml_fn_ImageDrawLineV, 4, 4, 0);
    _mod0_ImageDrawCircle = hml_val_function((void*)hml_fn_ImageDrawCircle, 5, 5, 0);
    _mod0_ImageDrawCircleV = hml_val_function((void*)hml_fn_ImageDrawCircleV, 4, 4, 0);
    _mod0_ImageDrawRectangle = hml_val_function((void*)hml_fn_ImageDrawRectangle, 6, 6, 0);
    _mod0_ImageDrawRectangleV = hml_val_function((void*)hml_fn_ImageDrawRectangleV, 4, 4, 0);
    _mod0_ImageDrawRectangleRec = hml_val_function((void*)hml_fn_ImageDrawRectangleRec, 3, 3, 0);
    _mod0_ImageDrawText = hml_val_function((void*)hml_fn_ImageDrawText, 6, 6, 0);
    _mod0_ImageDrawTextEx = hml_val_function((void*)hml_fn_ImageDrawTextEx, 7, 7, 0);
    _mod0_FileExists = hml_val_function((void*)hml_fn_FileExists, 1, 1, 0);
    _mod0_DirectoryExists = hml_val_function((void*)hml_fn_DirectoryExists, 1, 1, 0);
    _mod0_IsFileExtension = hml_val_function((void*)hml_fn_IsFileExtension, 2, 2, 0);
    _mod0_GetFileExtension = hml_val_function((void*)hml_fn_GetFileExtension, 1, 1, 0);
    _mod0_GetFileName = hml_val_function((void*)hml_fn_GetFileName, 1, 1, 0);
    _mod0_GetFileNameWithoutExt = hml_val_function((void*)hml_fn_GetFileNameWithoutExt, 1, 1, 0);
    _mod0_GetDirectoryPath = hml_val_function((void*)hml_fn_GetDirectoryPath, 1, 1, 0);
    _mod0_GetPrevDirectoryPath = hml_val_function((void*)hml_fn_GetPrevDirectoryPath, 1, 1, 0);
    _mod0_GetWorkingDirectory = hml_val_function((void*)hml_fn_GetWorkingDirectory, 0, 0, 0);
    _mod0_ChangeDirectory = hml_val_function((void*)hml_fn_ChangeDirectory, 1, 1, 0);
    _mod0_GetFileLength = hml_val_function((void*)hml_fn_GetFileLength, 1, 1, 0);
    _mod0_GetFileModTime = hml_val_function((void*)hml_fn_GetFileModTime, 1, 1, 0);
    _mod0_IsPathFile = hml_val_function((void*)hml_fn_IsPathFile, 1, 1, 0);
    _mod0_GetApplicationDirectory = hml_val_function((void*)hml_fn_GetApplicationDirectory, 0, 0, 0);
    _mod0_LoadFileText = hml_val_function((void*)hml_fn_LoadFileText, 1, 1, 0);
    _mod0_UnloadFileText = hml_val_function((void*)hml_fn_UnloadFileText, 1, 1, 0);
    _mod0_SaveFileText = hml_val_function((void*)hml_fn_SaveFileText, 2, 2, 0);
    HmlValue _tmp2080 = hml_val_i32(0);
    _mod0_TEXTURE_FILTER_POINT = _tmp2080;
    HmlValue _tmp2081 = hml_val_i32(1);
    _mod0_TEXTURE_FILTER_BILINEAR = _tmp2081;
    HmlValue _tmp2082 = hml_val_i32(2);
    _mod0_TEXTURE_FILTER_TRILINEAR = _tmp2082;
    HmlValue _tmp2083 = hml_val_i32(3);
    _mod0_TEXTURE_FILTER_ANISOTROPIC_4X = _tmp2083;
    HmlValue _tmp2084 = hml_val_i32(4);
    _mod0_TEXTURE_FILTER_ANISOTROPIC_8X = _tmp2084;
    HmlValue _tmp2085 = hml_val_i32(5);
    _mod0_TEXTURE_FILTER_ANISOTROPIC_16X = _tmp2085;
    HmlValue _tmp2086 = hml_val_i32(0);
    _mod0_TEXTURE_WRAP_REPEAT = _tmp2086;
    HmlValue _tmp2087 = hml_val_i32(1);
    _mod0_TEXTURE_WRAP_CLAMP = _tmp2087;
    HmlValue _tmp2088 = hml_val_i32(2);
    _mod0_TEXTURE_WRAP_MIRROR_REPEAT = _tmp2088;
    HmlValue _tmp2089 = hml_val_i32(3);
    _mod0_TEXTURE_WRAP_MIRROR_CLAMP = _tmp2089;
    HmlValue _tmp2090 = hml_val_i32(1);
    _mod0_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = _tmp2090;
    HmlValue _tmp2091 = hml_val_i32(2);
    _mod0_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = _tmp2091;
    HmlValue _tmp2092 = hml_val_i32(3);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = _tmp2092;
    HmlValue _tmp2093 = hml_val_i32(4);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = _tmp2093;
    HmlValue _tmp2094 = hml_val_i32(5);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = _tmp2094;
    HmlValue _tmp2095 = hml_val_i32(6);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = _tmp2095;
    HmlValue _tmp2096 = hml_val_i32(7);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = _tmp2096;
    HmlValue _tmp2097 = hml_val_i32(8);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R32 = _tmp2097;
    HmlValue _tmp2098 = hml_val_i32(9);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = _tmp2098;
    HmlValue _tmp2099 = hml_val_i32(10);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = _tmp2099;
    HmlValue _tmp2100 = hml_val_i32(11);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R16 = _tmp2100;
    HmlValue _tmp2101 = hml_val_i32(12);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = _tmp2101;
    HmlValue _tmp2102 = hml_val_i32(13);
    _mod0_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = _tmp2102;
    _mod0_Color = hml_val_function((void*)_mod0_fn_Color, 4, 4, 0);
    _mod0_ColorAlpha = hml_val_function((void*)_mod0_fn_ColorAlpha, 2, 2, 0);
    _mod0_ColorBrightness = hml_val_function((void*)_mod0_fn_ColorBrightness, 2, 2, 0);
    _mod0_ColorGetR = hml_val_function((void*)_mod0_fn_ColorGetR, 1, 1, 0);
    _mod0_ColorGetG = hml_val_function((void*)_mod0_fn_ColorGetG, 1, 1, 0);
    _mod0_ColorGetB = hml_val_function((void*)_mod0_fn_ColorGetB, 1, 1, 0);
    _mod0_ColorGetA = hml_val_function((void*)_mod0_fn_ColorGetA, 1, 1, 0);
    _mod0_DrawCircleFill = hml_val_function((void*)_mod0_fn_DrawCircleFill, 4, 4, 0);
    _mod0_DrawCircleOutline = hml_val_function((void*)_mod0_fn_DrawCircleOutline, 4, 4, 0);
    _mod0_DrawTriangleFill = hml_val_function((void*)_mod0_fn_DrawTriangleFill, 7, 7, 0);
    _mod0_DrawTriangleOutline = hml_val_function((void*)_mod0_fn_DrawTriangleOutline, 7, 7, 0);
    HmlValue _tmp2104 = hml_val_i32(200);
    HmlValue _tmp2105 = hml_val_i32(200);
    HmlValue _tmp2106 = hml_val_i32(200);
    HmlValue _tmp2107 = hml_val_i32(255);
    HmlValue _tmp2103 = _mod0_fn_Color(NULL, _tmp2104, _tmp2105, _tmp2106, _tmp2107);
    hml_release(&_tmp2104);
    hml_release(&_tmp2105);
    hml_release(&_tmp2106);
    hml_release(&_tmp2107);
    _mod0_LIGHTGRAY = _tmp2103;
    HmlValue _tmp2109 = hml_val_i32(130);
    HmlValue _tmp2110 = hml_val_i32(130);
    HmlValue _tmp2111 = hml_val_i32(130);
    HmlValue _tmp2112 = hml_val_i32(255);
    HmlValue _tmp2108 = _mod0_fn_Color(NULL, _tmp2109, _tmp2110, _tmp2111, _tmp2112);
    hml_release(&_tmp2109);
    hml_release(&_tmp2110);
    hml_release(&_tmp2111);
    hml_release(&_tmp2112);
    _mod0_GRAY = _tmp2108;
    HmlValue _tmp2114 = hml_val_i32(80);
    HmlValue _tmp2115 = hml_val_i32(80);
    HmlValue _tmp2116 = hml_val_i32(80);
    HmlValue _tmp2117 = hml_val_i32(255);
    HmlValue _tmp2113 = _mod0_fn_Color(NULL, _tmp2114, _tmp2115, _tmp2116, _tmp2117);
    hml_release(&_tmp2114);
    hml_release(&_tmp2115);
    hml_release(&_tmp2116);
    hml_release(&_tmp2117);
    _mod0_DARKGRAY = _tmp2113;
    HmlValue _tmp2119 = hml_val_i32(253);
    HmlValue _tmp2120 = hml_val_i32(249);
    HmlValue _tmp2121 = hml_val_i32(0);
    HmlValue _tmp2122 = hml_val_i32(255);
    HmlValue _tmp2118 = _mod0_fn_Color(NULL, _tmp2119, _tmp2120, _tmp2121, _tmp2122);
    hml_release(&_tmp2119);
    hml_release(&_tmp2120);
    hml_release(&_tmp2121);
    hml_release(&_tmp2122);
    _mod0_YELLOW = _tmp2118;
    HmlValue _tmp2124 = hml_val_i32(255);
    HmlValue _tmp2125 = hml_val_i32(203);
    HmlValue _tmp2126 = hml_val_i32(0);
    HmlValue _tmp2127 = hml_val_i32(255);
    HmlValue _tmp2123 = _mod0_fn_Color(NULL, _tmp2124, _tmp2125, _tmp2126, _tmp2127);
    hml_release(&_tmp2124);
    hml_release(&_tmp2125);
    hml_release(&_tmp2126);
    hml_release(&_tmp2127);
    _mod0_GOLD = _tmp2123;
    HmlValue _tmp2129 = hml_val_i32(255);
    HmlValue _tmp2130 = hml_val_i32(161);
    HmlValue _tmp2131 = hml_val_i32(0);
    HmlValue _tmp2132 = hml_val_i32(255);
    HmlValue _tmp2128 = _mod0_fn_Color(NULL, _tmp2129, _tmp2130, _tmp2131, _tmp2132);
    hml_release(&_tmp2129);
    hml_release(&_tmp2130);
    hml_release(&_tmp2131);
    hml_release(&_tmp2132);
    _mod0_ORANGE = _tmp2128;
    HmlValue _tmp2134 = hml_val_i32(255);
    HmlValue _tmp2135 = hml_val_i32(109);
    HmlValue _tmp2136 = hml_val_i32(194);
    HmlValue _tmp2137 = hml_val_i32(255);
    HmlValue _tmp2133 = _mod0_fn_Color(NULL, _tmp2134, _tmp2135, _tmp2136, _tmp2137);
    hml_release(&_tmp2134);
    hml_release(&_tmp2135);
    hml_release(&_tmp2136);
    hml_release(&_tmp2137);
    _mod0_PINK = _tmp2133;
    HmlValue _tmp2139 = hml_val_i32(230);
    HmlValue _tmp2140 = hml_val_i32(41);
    HmlValue _tmp2141 = hml_val_i32(55);
    HmlValue _tmp2142 = hml_val_i32(255);
    HmlValue _tmp2138 = _mod0_fn_Color(NULL, _tmp2139, _tmp2140, _tmp2141, _tmp2142);
    hml_release(&_tmp2139);
    hml_release(&_tmp2140);
    hml_release(&_tmp2141);
    hml_release(&_tmp2142);
    _mod0_RED = _tmp2138;
    HmlValue _tmp2144 = hml_val_i32(190);
    HmlValue _tmp2145 = hml_val_i32(33);
    HmlValue _tmp2146 = hml_val_i32(55);
    HmlValue _tmp2147 = hml_val_i32(255);
    HmlValue _tmp2143 = _mod0_fn_Color(NULL, _tmp2144, _tmp2145, _tmp2146, _tmp2147);
    hml_release(&_tmp2144);
    hml_release(&_tmp2145);
    hml_release(&_tmp2146);
    hml_release(&_tmp2147);
    _mod0_MAROON = _tmp2143;
    HmlValue _tmp2149 = hml_val_i32(0);
    HmlValue _tmp2150 = hml_val_i32(228);
    HmlValue _tmp2151 = hml_val_i32(48);
    HmlValue _tmp2152 = hml_val_i32(255);
    HmlValue _tmp2148 = _mod0_fn_Color(NULL, _tmp2149, _tmp2150, _tmp2151, _tmp2152);
    hml_release(&_tmp2149);
    hml_release(&_tmp2150);
    hml_release(&_tmp2151);
    hml_release(&_tmp2152);
    _mod0_GREEN = _tmp2148;
    HmlValue _tmp2154 = hml_val_i32(0);
    HmlValue _tmp2155 = hml_val_i32(158);
    HmlValue _tmp2156 = hml_val_i32(47);
    HmlValue _tmp2157 = hml_val_i32(255);
    HmlValue _tmp2153 = _mod0_fn_Color(NULL, _tmp2154, _tmp2155, _tmp2156, _tmp2157);
    hml_release(&_tmp2154);
    hml_release(&_tmp2155);
    hml_release(&_tmp2156);
    hml_release(&_tmp2157);
    _mod0_LIME = _tmp2153;
    HmlValue _tmp2159 = hml_val_i32(0);
    HmlValue _tmp2160 = hml_val_i32(117);
    HmlValue _tmp2161 = hml_val_i32(44);
    HmlValue _tmp2162 = hml_val_i32(255);
    HmlValue _tmp2158 = _mod0_fn_Color(NULL, _tmp2159, _tmp2160, _tmp2161, _tmp2162);
    hml_release(&_tmp2159);
    hml_release(&_tmp2160);
    hml_release(&_tmp2161);
    hml_release(&_tmp2162);
    _mod0_DARKGREEN = _tmp2158;
    HmlValue _tmp2164 = hml_val_i32(102);
    HmlValue _tmp2165 = hml_val_i32(191);
    HmlValue _tmp2166 = hml_val_i32(255);
    HmlValue _tmp2167 = hml_val_i32(255);
    HmlValue _tmp2163 = _mod0_fn_Color(NULL, _tmp2164, _tmp2165, _tmp2166, _tmp2167);
    hml_release(&_tmp2164);
    hml_release(&_tmp2165);
    hml_release(&_tmp2166);
    hml_release(&_tmp2167);
    _mod0_SKYBLUE = _tmp2163;
    HmlValue _tmp2169 = hml_val_i32(0);
    HmlValue _tmp2170 = hml_val_i32(121);
    HmlValue _tmp2171 = hml_val_i32(241);
    HmlValue _tmp2172 = hml_val_i32(255);
    HmlValue _tmp2168 = _mod0_fn_Color(NULL, _tmp2169, _tmp2170, _tmp2171, _tmp2172);
    hml_release(&_tmp2169);
    hml_release(&_tmp2170);
    hml_release(&_tmp2171);
    hml_release(&_tmp2172);
    _mod0_BLUE = _tmp2168;
    HmlValue _tmp2174 = hml_val_i32(0);
    HmlValue _tmp2175 = hml_val_i32(82);
    HmlValue _tmp2176 = hml_val_i32(172);
    HmlValue _tmp2177 = hml_val_i32(255);
    HmlValue _tmp2173 = _mod0_fn_Color(NULL, _tmp2174, _tmp2175, _tmp2176, _tmp2177);
    hml_release(&_tmp2174);
    hml_release(&_tmp2175);
    hml_release(&_tmp2176);
    hml_release(&_tmp2177);
    _mod0_DARKBLUE = _tmp2173;
    HmlValue _tmp2179 = hml_val_i32(200);
    HmlValue _tmp2180 = hml_val_i32(122);
    HmlValue _tmp2181 = hml_val_i32(255);
    HmlValue _tmp2182 = hml_val_i32(255);
    HmlValue _tmp2178 = _mod0_fn_Color(NULL, _tmp2179, _tmp2180, _tmp2181, _tmp2182);
    hml_release(&_tmp2179);
    hml_release(&_tmp2180);
    hml_release(&_tmp2181);
    hml_release(&_tmp2182);
    _mod0_PURPLE = _tmp2178;
    HmlValue _tmp2184 = hml_val_i32(135);
    HmlValue _tmp2185 = hml_val_i32(60);
    HmlValue _tmp2186 = hml_val_i32(190);
    HmlValue _tmp2187 = hml_val_i32(255);
    HmlValue _tmp2183 = _mod0_fn_Color(NULL, _tmp2184, _tmp2185, _tmp2186, _tmp2187);
    hml_release(&_tmp2184);
    hml_release(&_tmp2185);
    hml_release(&_tmp2186);
    hml_release(&_tmp2187);
    _mod0_VIOLET = _tmp2183;
    HmlValue _tmp2189 = hml_val_i32(112);
    HmlValue _tmp2190 = hml_val_i32(31);
    HmlValue _tmp2191 = hml_val_i32(126);
    HmlValue _tmp2192 = hml_val_i32(255);
    HmlValue _tmp2188 = _mod0_fn_Color(NULL, _tmp2189, _tmp2190, _tmp2191, _tmp2192);
    hml_release(&_tmp2189);
    hml_release(&_tmp2190);
    hml_release(&_tmp2191);
    hml_release(&_tmp2192);
    _mod0_DARKPURPLE = _tmp2188;
    HmlValue _tmp2194 = hml_val_i32(211);
    HmlValue _tmp2195 = hml_val_i32(176);
    HmlValue _tmp2196 = hml_val_i32(131);
    HmlValue _tmp2197 = hml_val_i32(255);
    HmlValue _tmp2193 = _mod0_fn_Color(NULL, _tmp2194, _tmp2195, _tmp2196, _tmp2197);
    hml_release(&_tmp2194);
    hml_release(&_tmp2195);
    hml_release(&_tmp2196);
    hml_release(&_tmp2197);
    _mod0_BEIGE = _tmp2193;
    HmlValue _tmp2199 = hml_val_i32(127);
    HmlValue _tmp2200 = hml_val_i32(106);
    HmlValue _tmp2201 = hml_val_i32(79);
    HmlValue _tmp2202 = hml_val_i32(255);
    HmlValue _tmp2198 = _mod0_fn_Color(NULL, _tmp2199, _tmp2200, _tmp2201, _tmp2202);
    hml_release(&_tmp2199);
    hml_release(&_tmp2200);
    hml_release(&_tmp2201);
    hml_release(&_tmp2202);
    _mod0_BROWN = _tmp2198;
    HmlValue _tmp2204 = hml_val_i32(76);
    HmlValue _tmp2205 = hml_val_i32(63);
    HmlValue _tmp2206 = hml_val_i32(47);
    HmlValue _tmp2207 = hml_val_i32(255);
    HmlValue _tmp2203 = _mod0_fn_Color(NULL, _tmp2204, _tmp2205, _tmp2206, _tmp2207);
    hml_release(&_tmp2204);
    hml_release(&_tmp2205);
    hml_release(&_tmp2206);
    hml_release(&_tmp2207);
    _mod0_DARKBROWN = _tmp2203;
    HmlValue _tmp2209 = hml_val_i32(255);
    HmlValue _tmp2210 = hml_val_i32(255);
    HmlValue _tmp2211 = hml_val_i32(255);
    HmlValue _tmp2212 = hml_val_i32(255);
    HmlValue _tmp2208 = _mod0_fn_Color(NULL, _tmp2209, _tmp2210, _tmp2211, _tmp2212);
    hml_release(&_tmp2209);
    hml_release(&_tmp2210);
    hml_release(&_tmp2211);
    hml_release(&_tmp2212);
    _mod0_WHITE = _tmp2208;
    HmlValue _tmp2214 = hml_val_i32(0);
    HmlValue _tmp2215 = hml_val_i32(0);
    HmlValue _tmp2216 = hml_val_i32(0);
    HmlValue _tmp2217 = hml_val_i32(255);
    HmlValue _tmp2213 = _mod0_fn_Color(NULL, _tmp2214, _tmp2215, _tmp2216, _tmp2217);
    hml_release(&_tmp2214);
    hml_release(&_tmp2215);
    hml_release(&_tmp2216);
    hml_release(&_tmp2217);
    _mod0_BLACK = _tmp2213;
    HmlValue _tmp2219 = hml_val_i32(0);
    HmlValue _tmp2220 = hml_val_i32(0);
    HmlValue _tmp2221 = hml_val_i32(0);
    HmlValue _tmp2222 = hml_val_i32(0);
    HmlValue _tmp2218 = _mod0_fn_Color(NULL, _tmp2219, _tmp2220, _tmp2221, _tmp2222);
    hml_release(&_tmp2219);
    hml_release(&_tmp2220);
    hml_release(&_tmp2221);
    hml_release(&_tmp2222);
    _mod0_BLANK = _tmp2218;
    HmlValue _tmp2224 = hml_val_i32(255);
    HmlValue _tmp2225 = hml_val_i32(0);
    HmlValue _tmp2226 = hml_val_i32(255);
    HmlValue _tmp2227 = hml_val_i32(255);
    HmlValue _tmp2223 = _mod0_fn_Color(NULL, _tmp2224, _tmp2225, _tmp2226, _tmp2227);
    hml_release(&_tmp2224);
    hml_release(&_tmp2225);
    hml_release(&_tmp2226);
    hml_release(&_tmp2227);
    _mod0_MAGENTA = _tmp2223;
    HmlValue _tmp2229 = hml_val_i32(245);
    HmlValue _tmp2230 = hml_val_i32(245);
    HmlValue _tmp2231 = hml_val_i32(245);
    HmlValue _tmp2232 = hml_val_i32(255);
    HmlValue _tmp2228 = _mod0_fn_Color(NULL, _tmp2229, _tmp2230, _tmp2231, _tmp2232);
    hml_release(&_tmp2229);
    hml_release(&_tmp2230);
    hml_release(&_tmp2231);
    hml_release(&_tmp2232);
    _mod0_RAYWHITE = _tmp2228;
    HmlValue _tmp2233 = hml_val_i32(0);
    _mod0_KEY_NULL = _tmp2233;
    HmlValue _tmp2234 = hml_val_i32(39);
    _mod0_KEY_APOSTROPHE = _tmp2234;
    HmlValue _tmp2235 = hml_val_i32(44);
    _mod0_KEY_COMMA = _tmp2235;
    HmlValue _tmp2236 = hml_val_i32(45);
    _mod0_KEY_MINUS = _tmp2236;
    HmlValue _tmp2237 = hml_val_i32(46);
    _mod0_KEY_PERIOD = _tmp2237;
    HmlValue _tmp2238 = hml_val_i32(47);
    _mod0_KEY_SLASH = _tmp2238;
    HmlValue _tmp2239 = hml_val_i32(48);
    _mod0_KEY_ZERO = _tmp2239;
    HmlValue _tmp2240 = hml_val_i32(49);
    _mod0_KEY_ONE = _tmp2240;
    HmlValue _tmp2241 = hml_val_i32(50);
    _mod0_KEY_TWO = _tmp2241;
    HmlValue _tmp2242 = hml_val_i32(51);
    _mod0_KEY_THREE = _tmp2242;
    HmlValue _tmp2243 = hml_val_i32(52);
    _mod0_KEY_FOUR = _tmp2243;
    HmlValue _tmp2244 = hml_val_i32(53);
    _mod0_KEY_FIVE = _tmp2244;
    HmlValue _tmp2245 = hml_val_i32(54);
    _mod0_KEY_SIX = _tmp2245;
    HmlValue _tmp2246 = hml_val_i32(55);
    _mod0_KEY_SEVEN = _tmp2246;
    HmlValue _tmp2247 = hml_val_i32(56);
    _mod0_KEY_EIGHT = _tmp2247;
    HmlValue _tmp2248 = hml_val_i32(57);
    _mod0_KEY_NINE = _tmp2248;
    HmlValue _tmp2249 = hml_val_i32(59);
    _mod0_KEY_SEMICOLON = _tmp2249;
    HmlValue _tmp2250 = hml_val_i32(61);
    _mod0_KEY_EQUAL = _tmp2250;
    HmlValue _tmp2251 = hml_val_i32(65);
    _mod0_KEY_A = _tmp2251;
    HmlValue _tmp2252 = hml_val_i32(66);
    _mod0_KEY_B = _tmp2252;
    HmlValue _tmp2253 = hml_val_i32(67);
    _mod0_KEY_C = _tmp2253;
    HmlValue _tmp2254 = hml_val_i32(68);
    _mod0_KEY_D = _tmp2254;
    HmlValue _tmp2255 = hml_val_i32(69);
    _mod0_KEY_E = _tmp2255;
    HmlValue _tmp2256 = hml_val_i32(70);
    _mod0_KEY_F = _tmp2256;
    HmlValue _tmp2257 = hml_val_i32(71);
    _mod0_KEY_G = _tmp2257;
    HmlValue _tmp2258 = hml_val_i32(72);
    _mod0_KEY_H = _tmp2258;
    HmlValue _tmp2259 = hml_val_i32(73);
    _mod0_KEY_I = _tmp2259;
    HmlValue _tmp2260 = hml_val_i32(74);
    _mod0_KEY_J = _tmp2260;
    HmlValue _tmp2261 = hml_val_i32(75);
    _mod0_KEY_K = _tmp2261;
    HmlValue _tmp2262 = hml_val_i32(76);
    _mod0_KEY_L = _tmp2262;
    HmlValue _tmp2263 = hml_val_i32(77);
    _mod0_KEY_M = _tmp2263;
    HmlValue _tmp2264 = hml_val_i32(78);
    _mod0_KEY_N = _tmp2264;
    HmlValue _tmp2265 = hml_val_i32(79);
    _mod0_KEY_O = _tmp2265;
    HmlValue _tmp2266 = hml_val_i32(80);
    _mod0_KEY_P = _tmp2266;
    HmlValue _tmp2267 = hml_val_i32(81);
    _mod0_KEY_Q = _tmp2267;
    HmlValue _tmp2268 = hml_val_i32(82);
    _mod0_KEY_R = _tmp2268;
    HmlValue _tmp2269 = hml_val_i32(83);
    _mod0_KEY_S = _tmp2269;
    HmlValue _tmp2270 = hml_val_i32(84);
    _mod0_KEY_T = _tmp2270;
    HmlValue _tmp2271 = hml_val_i32(85);
    _mod0_KEY_U = _tmp2271;
    HmlValue _tmp2272 = hml_val_i32(86);
    _mod0_KEY_V = _tmp2272;
    HmlValue _tmp2273 = hml_val_i32(87);
    _mod0_KEY_W = _tmp2273;
    HmlValue _tmp2274 = hml_val_i32(88);
    _mod0_KEY_X = _tmp2274;
    HmlValue _tmp2275 = hml_val_i32(89);
    _mod0_KEY_Y = _tmp2275;
    HmlValue _tmp2276 = hml_val_i32(90);
    _mod0_KEY_Z = _tmp2276;
    HmlValue _tmp2277 = hml_val_i32(91);
    _mod0_KEY_LEFT_BRACKET = _tmp2277;
    HmlValue _tmp2278 = hml_val_i32(92);
    _mod0_KEY_BACKSLASH = _tmp2278;
    HmlValue _tmp2279 = hml_val_i32(93);
    _mod0_KEY_RIGHT_BRACKET = _tmp2279;
    HmlValue _tmp2280 = hml_val_i32(96);
    _mod0_KEY_GRAVE = _tmp2280;
    HmlValue _tmp2281 = hml_val_i32(32);
    _mod0_KEY_SPACE = _tmp2281;
    HmlValue _tmp2282 = hml_val_i32(256);
    _mod0_KEY_ESCAPE = _tmp2282;
    HmlValue _tmp2283 = hml_val_i32(257);
    _mod0_KEY_ENTER = _tmp2283;
    HmlValue _tmp2284 = hml_val_i32(258);
    _mod0_KEY_TAB = _tmp2284;
    HmlValue _tmp2285 = hml_val_i32(259);
    _mod0_KEY_BACKSPACE = _tmp2285;
    HmlValue _tmp2286 = hml_val_i32(260);
    _mod0_KEY_INSERT = _tmp2286;
    HmlValue _tmp2287 = hml_val_i32(261);
    _mod0_KEY_DELETE = _tmp2287;
    HmlValue _tmp2288 = hml_val_i32(262);
    _mod0_KEY_RIGHT = _tmp2288;
    HmlValue _tmp2289 = hml_val_i32(263);
    _mod0_KEY_LEFT = _tmp2289;
    HmlValue _tmp2290 = hml_val_i32(264);
    _mod0_KEY_DOWN = _tmp2290;
    HmlValue _tmp2291 = hml_val_i32(265);
    _mod0_KEY_UP = _tmp2291;
    HmlValue _tmp2292 = hml_val_i32(266);
    _mod0_KEY_PAGE_UP = _tmp2292;
    HmlValue _tmp2293 = hml_val_i32(267);
    _mod0_KEY_PAGE_DOWN = _tmp2293;
    HmlValue _tmp2294 = hml_val_i32(268);
    _mod0_KEY_HOME = _tmp2294;
    HmlValue _tmp2295 = hml_val_i32(269);
    _mod0_KEY_END = _tmp2295;
    HmlValue _tmp2296 = hml_val_i32(280);
    _mod0_KEY_CAPS_LOCK = _tmp2296;
    HmlValue _tmp2297 = hml_val_i32(281);
    _mod0_KEY_SCROLL_LOCK = _tmp2297;
    HmlValue _tmp2298 = hml_val_i32(282);
    _mod0_KEY_NUM_LOCK = _tmp2298;
    HmlValue _tmp2299 = hml_val_i32(283);
    _mod0_KEY_PRINT_SCREEN = _tmp2299;
    HmlValue _tmp2300 = hml_val_i32(284);
    _mod0_KEY_PAUSE = _tmp2300;
    HmlValue _tmp2301 = hml_val_i32(290);
    _mod0_KEY_F1 = _tmp2301;
    HmlValue _tmp2302 = hml_val_i32(291);
    _mod0_KEY_F2 = _tmp2302;
    HmlValue _tmp2303 = hml_val_i32(292);
    _mod0_KEY_F3 = _tmp2303;
    HmlValue _tmp2304 = hml_val_i32(293);
    _mod0_KEY_F4 = _tmp2304;
    HmlValue _tmp2305 = hml_val_i32(294);
    _mod0_KEY_F5 = _tmp2305;
    HmlValue _tmp2306 = hml_val_i32(295);
    _mod0_KEY_F6 = _tmp2306;
    HmlValue _tmp2307 = hml_val_i32(296);
    _mod0_KEY_F7 = _tmp2307;
    HmlValue _tmp2308 = hml_val_i32(297);
    _mod0_KEY_F8 = _tmp2308;
    HmlValue _tmp2309 = hml_val_i32(298);
    _mod0_KEY_F9 = _tmp2309;
    HmlValue _tmp2310 = hml_val_i32(299);
    _mod0_KEY_F10 = _tmp2310;
    HmlValue _tmp2311 = hml_val_i32(300);
    _mod0_KEY_F11 = _tmp2311;
    HmlValue _tmp2312 = hml_val_i32(301);
    _mod0_KEY_F12 = _tmp2312;
    HmlValue _tmp2313 = hml_val_i32(340);
    _mod0_KEY_LEFT_SHIFT = _tmp2313;
    HmlValue _tmp2314 = hml_val_i32(341);
    _mod0_KEY_LEFT_CONTROL = _tmp2314;
    HmlValue _tmp2315 = hml_val_i32(342);
    _mod0_KEY_LEFT_ALT = _tmp2315;
    HmlValue _tmp2316 = hml_val_i32(343);
    _mod0_KEY_LEFT_SUPER = _tmp2316;
    HmlValue _tmp2317 = hml_val_i32(344);
    _mod0_KEY_RIGHT_SHIFT = _tmp2317;
    HmlValue _tmp2318 = hml_val_i32(345);
    _mod0_KEY_RIGHT_CONTROL = _tmp2318;
    HmlValue _tmp2319 = hml_val_i32(346);
    _mod0_KEY_RIGHT_ALT = _tmp2319;
    HmlValue _tmp2320 = hml_val_i32(347);
    _mod0_KEY_RIGHT_SUPER = _tmp2320;
    HmlValue _tmp2321 = hml_val_i32(348);
    _mod0_KEY_KB_MENU = _tmp2321;
    HmlValue _tmp2322 = hml_val_i32(320);
    _mod0_KEY_KP_0 = _tmp2322;
    HmlValue _tmp2323 = hml_val_i32(321);
    _mod0_KEY_KP_1 = _tmp2323;
    HmlValue _tmp2324 = hml_val_i32(322);
    _mod0_KEY_KP_2 = _tmp2324;
    HmlValue _tmp2325 = hml_val_i32(323);
    _mod0_KEY_KP_3 = _tmp2325;
    HmlValue _tmp2326 = hml_val_i32(324);
    _mod0_KEY_KP_4 = _tmp2326;
    HmlValue _tmp2327 = hml_val_i32(325);
    _mod0_KEY_KP_5 = _tmp2327;
    HmlValue _tmp2328 = hml_val_i32(326);
    _mod0_KEY_KP_6 = _tmp2328;
    HmlValue _tmp2329 = hml_val_i32(327);
    _mod0_KEY_KP_7 = _tmp2329;
    HmlValue _tmp2330 = hml_val_i32(328);
    _mod0_KEY_KP_8 = _tmp2330;
    HmlValue _tmp2331 = hml_val_i32(329);
    _mod0_KEY_KP_9 = _tmp2331;
    HmlValue _tmp2332 = hml_val_i32(330);
    _mod0_KEY_KP_DECIMAL = _tmp2332;
    HmlValue _tmp2333 = hml_val_i32(331);
    _mod0_KEY_KP_DIVIDE = _tmp2333;
    HmlValue _tmp2334 = hml_val_i32(332);
    _mod0_KEY_KP_MULTIPLY = _tmp2334;
    HmlValue _tmp2335 = hml_val_i32(333);
    _mod0_KEY_KP_SUBTRACT = _tmp2335;
    HmlValue _tmp2336 = hml_val_i32(334);
    _mod0_KEY_KP_ADD = _tmp2336;
    HmlValue _tmp2337 = hml_val_i32(335);
    _mod0_KEY_KP_ENTER = _tmp2337;
    HmlValue _tmp2338 = hml_val_i32(336);
    _mod0_KEY_KP_EQUAL = _tmp2338;
    HmlValue _tmp2339 = hml_val_i32(0);
    _mod0_MOUSE_BUTTON_LEFT = _tmp2339;
    HmlValue _tmp2340 = hml_val_i32(1);
    _mod0_MOUSE_BUTTON_RIGHT = _tmp2340;
    HmlValue _tmp2341 = hml_val_i32(2);
    _mod0_MOUSE_BUTTON_MIDDLE = _tmp2341;
    HmlValue _tmp2342 = hml_val_i32(3);
    _mod0_MOUSE_BUTTON_SIDE = _tmp2342;
    HmlValue _tmp2343 = hml_val_i32(4);
    _mod0_MOUSE_BUTTON_EXTRA = _tmp2343;
    HmlValue _tmp2344 = hml_val_i32(5);
    _mod0_MOUSE_BUTTON_FORWARD = _tmp2344;
    HmlValue _tmp2345 = hml_val_i32(6);
    _mod0_MOUSE_BUTTON_BACK = _tmp2345;
    HmlValue _tmp2346 = hml_val_i32(0);
    _mod0_MOUSE_CURSOR_DEFAULT = _tmp2346;
    HmlValue _tmp2347 = hml_val_i32(1);
    _mod0_MOUSE_CURSOR_ARROW = _tmp2347;
    HmlValue _tmp2348 = hml_val_i32(2);
    _mod0_MOUSE_CURSOR_IBEAM = _tmp2348;
    HmlValue _tmp2349 = hml_val_i32(3);
    _mod0_MOUSE_CURSOR_CROSSHAIR = _tmp2349;
    HmlValue _tmp2350 = hml_val_i32(4);
    _mod0_MOUSE_CURSOR_POINTING_HAND = _tmp2350;
    HmlValue _tmp2351 = hml_val_i32(5);
    _mod0_MOUSE_CURSOR_RESIZE_EW = _tmp2351;
    HmlValue _tmp2352 = hml_val_i32(6);
    _mod0_MOUSE_CURSOR_RESIZE_NS = _tmp2352;
    HmlValue _tmp2353 = hml_val_i32(7);
    _mod0_MOUSE_CURSOR_RESIZE_NWSE = _tmp2353;
    HmlValue _tmp2354 = hml_val_i32(8);
    _mod0_MOUSE_CURSOR_RESIZE_NESW = _tmp2354;
    HmlValue _tmp2355 = hml_val_i32(9);
    _mod0_MOUSE_CURSOR_RESIZE_ALL = _tmp2355;
    HmlValue _tmp2356 = hml_val_i32(10);
    _mod0_MOUSE_CURSOR_NOT_ALLOWED = _tmp2356;
    HmlValue _tmp2357 = hml_val_i32(0);
    _mod0_GAMEPAD_BUTTON_UNKNOWN = _tmp2357;
    HmlValue _tmp2358 = hml_val_i32(1);
    _mod0_GAMEPAD_BUTTON_LEFT_FACE_UP = _tmp2358;
    HmlValue _tmp2359 = hml_val_i32(2);
    _mod0_GAMEPAD_BUTTON_LEFT_FACE_RIGHT = _tmp2359;
    HmlValue _tmp2360 = hml_val_i32(3);
    _mod0_GAMEPAD_BUTTON_LEFT_FACE_DOWN = _tmp2360;
    HmlValue _tmp2361 = hml_val_i32(4);
    _mod0_GAMEPAD_BUTTON_LEFT_FACE_LEFT = _tmp2361;
    HmlValue _tmp2362 = hml_val_i32(5);
    _mod0_GAMEPAD_BUTTON_RIGHT_FACE_UP = _tmp2362;
    HmlValue _tmp2363 = hml_val_i32(6);
    _mod0_GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = _tmp2363;
    HmlValue _tmp2364 = hml_val_i32(7);
    _mod0_GAMEPAD_BUTTON_RIGHT_FACE_DOWN = _tmp2364;
    HmlValue _tmp2365 = hml_val_i32(8);
    _mod0_GAMEPAD_BUTTON_RIGHT_FACE_LEFT = _tmp2365;
    HmlValue _tmp2366 = hml_val_i32(9);
    _mod0_GAMEPAD_BUTTON_LEFT_TRIGGER_1 = _tmp2366;
    HmlValue _tmp2367 = hml_val_i32(10);
    _mod0_GAMEPAD_BUTTON_LEFT_TRIGGER_2 = _tmp2367;
    HmlValue _tmp2368 = hml_val_i32(11);
    _mod0_GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = _tmp2368;
    HmlValue _tmp2369 = hml_val_i32(12);
    _mod0_GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = _tmp2369;
    HmlValue _tmp2370 = hml_val_i32(13);
    _mod0_GAMEPAD_BUTTON_MIDDLE_LEFT = _tmp2370;
    HmlValue _tmp2371 = hml_val_i32(14);
    _mod0_GAMEPAD_BUTTON_MIDDLE = _tmp2371;
    HmlValue _tmp2372 = hml_val_i32(15);
    _mod0_GAMEPAD_BUTTON_MIDDLE_RIGHT = _tmp2372;
    HmlValue _tmp2373 = hml_val_i32(16);
    _mod0_GAMEPAD_BUTTON_LEFT_THUMB = _tmp2373;
    HmlValue _tmp2374 = hml_val_i32(17);
    _mod0_GAMEPAD_BUTTON_RIGHT_THUMB = _tmp2374;
    HmlValue _tmp2375 = hml_val_i32(0);
    _mod0_GAMEPAD_AXIS_LEFT_X = _tmp2375;
    HmlValue _tmp2376 = hml_val_i32(1);
    _mod0_GAMEPAD_AXIS_LEFT_Y = _tmp2376;
    HmlValue _tmp2377 = hml_val_i32(2);
    _mod0_GAMEPAD_AXIS_RIGHT_X = _tmp2377;
    HmlValue _tmp2378 = hml_val_i32(3);
    _mod0_GAMEPAD_AXIS_RIGHT_Y = _tmp2378;
    HmlValue _tmp2379 = hml_val_i32(4);
    _mod0_GAMEPAD_AXIS_LEFT_TRIGGER = _tmp2379;
    HmlValue _tmp2380 = hml_val_i32(5);
    _mod0_GAMEPAD_AXIS_RIGHT_TRIGGER = _tmp2380;
    HmlValue _tmp2381 = hml_val_i32(0);
    _mod0_GESTURE_NONE = _tmp2381;
    HmlValue _tmp2382 = hml_val_i32(1);
    _mod0_GESTURE_TAP = _tmp2382;
    HmlValue _tmp2383 = hml_val_i32(2);
    _mod0_GESTURE_DOUBLETAP = _tmp2383;
    HmlValue _tmp2384 = hml_val_i32(4);
    _mod0_GESTURE_HOLD = _tmp2384;
    HmlValue _tmp2385 = hml_val_i32(8);
    _mod0_GESTURE_DRAG = _tmp2385;
    HmlValue _tmp2386 = hml_val_i32(16);
    _mod0_GESTURE_SWIPE_RIGHT = _tmp2386;
    HmlValue _tmp2387 = hml_val_i32(32);
    _mod0_GESTURE_SWIPE_LEFT = _tmp2387;
    HmlValue _tmp2388 = hml_val_i32(64);
    _mod0_GESTURE_SWIPE_UP = _tmp2388;
    HmlValue _tmp2389 = hml_val_i32(128);
    _mod0_GESTURE_SWIPE_DOWN = _tmp2389;
    HmlValue _tmp2390 = hml_val_i32(256);
    _mod0_GESTURE_PINCH_IN = _tmp2390;
    HmlValue _tmp2391 = hml_val_i32(512);
    _mod0_GESTURE_PINCH_OUT = _tmp2391;
    HmlValue _tmp2392 = hml_val_i32(0);
    _mod0_BLEND_ALPHA = _tmp2392;
    HmlValue _tmp2393 = hml_val_i32(1);
    _mod0_BLEND_ADDITIVE = _tmp2393;
    HmlValue _tmp2394 = hml_val_i32(2);
    _mod0_BLEND_MULTIPLIED = _tmp2394;
    HmlValue _tmp2395 = hml_val_i32(3);
    _mod0_BLEND_ADD_COLORS = _tmp2395;
    HmlValue _tmp2396 = hml_val_i32(4);
    _mod0_BLEND_SUBTRACT_COLORS = _tmp2396;
    HmlValue _tmp2397 = hml_val_i32(5);
    _mod0_BLEND_ALPHA_PREMULTIPLY = _tmp2397;
    HmlValue _tmp2398 = hml_val_i32(6);
    _mod0_BLEND_CUSTOM = _tmp2398;
    HmlValue _tmp2399 = hml_val_i32(7);
    _mod0_BLEND_CUSTOM_SEPARATE = _tmp2399;
    HmlValue _tmp2400 = hml_val_i32(64);
    _mod0_FLAG_VSYNC_HINT = _tmp2400;
    HmlValue _tmp2401 = hml_val_i32(2);
    _mod0_FLAG_FULLSCREEN_MODE = _tmp2401;
    HmlValue _tmp2402 = hml_val_i32(4);
    _mod0_FLAG_WINDOW_RESIZABLE = _tmp2402;
    HmlValue _tmp2403 = hml_val_i32(8);
    _mod0_FLAG_WINDOW_UNDECORATED = _tmp2403;
    HmlValue _tmp2404 = hml_val_i32(128);
    _mod0_FLAG_WINDOW_HIDDEN = _tmp2404;
    HmlValue _tmp2405 = hml_val_i32(512);
    _mod0_FLAG_WINDOW_MINIMIZED = _tmp2405;
    HmlValue _tmp2406 = hml_val_i32(1024);
    _mod0_FLAG_WINDOW_MAXIMIZED = _tmp2406;
    HmlValue _tmp2407 = hml_val_i32(2048);
    _mod0_FLAG_WINDOW_UNFOCUSED = _tmp2407;
    HmlValue _tmp2408 = hml_val_i32(4096);
    _mod0_FLAG_WINDOW_TOPMOST = _tmp2408;
    HmlValue _tmp2409 = hml_val_i32(256);
    _mod0_FLAG_WINDOW_ALWAYS_RUN = _tmp2409;
    HmlValue _tmp2410 = hml_val_i32(16);
    _mod0_FLAG_WINDOW_TRANSPARENT = _tmp2410;
    HmlValue _tmp2411 = hml_val_i32(8192);
    _mod0_FLAG_WINDOW_HIGHDPI = _tmp2411;
    HmlValue _tmp2412 = hml_val_i32(16384);
    _mod0_FLAG_WINDOW_MOUSE_PASSTHROUGH = _tmp2412;
    HmlValue _tmp2413 = hml_val_i32(32768);
    _mod0_FLAG_BORDERLESS_WINDOWED_MODE = _tmp2413;
    HmlValue _tmp2414 = hml_val_i32(32);
    _mod0_FLAG_MSAA_4X_HINT = _tmp2414;
    HmlValue _tmp2415 = hml_val_i32(65536);
    _mod0_FLAG_INTERLACED_HINT = _tmp2415;
    HmlValue _tmp2416 = hml_val_i32(0);
    _mod0_LOG_ALL = _tmp2416;
    HmlValue _tmp2417 = hml_val_i32(1);
    _mod0_LOG_TRACE = _tmp2417;
    HmlValue _tmp2418 = hml_val_i32(2);
    _mod0_LOG_DEBUG = _tmp2418;
    HmlValue _tmp2419 = hml_val_i32(3);
    _mod0_LOG_INFO = _tmp2419;
    HmlValue _tmp2420 = hml_val_i32(4);
    _mod0_LOG_WARNING = _tmp2420;
    HmlValue _tmp2421 = hml_val_i32(5);
    _mod0_LOG_ERROR = _tmp2421;
    HmlValue _tmp2422 = hml_val_i32(6);
    _mod0_LOG_FATAL = _tmp2422;
    HmlValue _tmp2423 = hml_val_i32(7);
    _mod0_LOG_NONE = _tmp2423;
    _mod0_CheckCollisionCirclesXY = hml_val_function((void*)_mod0_fn_CheckCollisionCirclesXY, 6, 6, 0);
    _mod0_CheckCollisionRectsXY = hml_val_function((void*)_mod0_fn_CheckCollisionRectsXY, 8, 8, 0);
    _mod0_CheckCollisionPointRectXY = hml_val_function((void*)_mod0_fn_CheckCollisionPointRectXY, 6, 6, 0);
    _mod0_CheckCollisionPointCircleXY = hml_val_function((void*)_mod0_fn_CheckCollisionPointCircleXY, 5, 5, 0);
    _mod0_CheckCollisionCircleRecXY = hml_val_function((void*)_mod0_fn_CheckCollisionCircleRecXY, 7, 7, 0);
    _mod0_Vector2Distance = hml_val_function((void*)_mod0_fn_Vector2Distance, 4, 4, 0);
    _mod0_Vector2Length = hml_val_function((void*)_mod0_fn_Vector2Length, 2, 2, 0);
    _mod0_Vector2Dot = hml_val_function((void*)_mod0_fn_Vector2Dot, 4, 4, 0);
    _mod0_Lerp = hml_val_function((void*)_mod0_fn_Lerp, 3, 3, 0);
    _mod0_Clamp = hml_val_function((void*)_mod0_fn_Clamp, 3, 3, 0);
    _mod0_ClampInt = hml_val_function((void*)_mod0_fn_ClampInt, 3, 3, 0);
    _mod0_Remap = hml_val_function((void*)_mod0_fn_Remap, 5, 5, 0);
    _mod0_Wrap = hml_val_function((void*)_mod0_fn_Wrap, 3, 3, 0);
    _mod0_NormalizeAngle = hml_val_function((void*)_mod0_fn_NormalizeAngle, 1, 1, 0);
    _mod0_Deg2Rad = hml_val_function((void*)_mod0_fn_Deg2Rad, 1, 1, 0);
    _mod0_Rad2Deg = hml_val_function((void*)_mod0_fn_Rad2Deg, 1, 1, 0);
    _mod0_Sign = hml_val_function((void*)_mod0_fn_Sign, 1, 1, 0);
    _mod0_SignInt = hml_val_function((void*)_mod0_fn_SignInt, 1, 1, 0);
    _mod0_Abs = hml_val_function((void*)_mod0_fn_Abs, 1, 1, 0);
    _mod0_AbsInt = hml_val_function((void*)_mod0_fn_AbsInt, 1, 1, 0);
    _mod0_Min = hml_val_function((void*)_mod0_fn_Min, 2, 2, 0);
    _mod0_Max = hml_val_function((void*)_mod0_fn_Max, 2, 2, 0);
    _mod0_MinInt = hml_val_function((void*)_mod0_fn_MinInt, 2, 2, 0);
    _mod0_MaxInt = hml_val_function((void*)_mod0_fn_MaxInt, 2, 2, 0);
    _mod0_FloorInt = hml_val_function((void*)_mod0_fn_FloorInt, 1, 1, 0);
    _mod0_CeilInt = hml_val_function((void*)_mod0_fn_CeilInt, 1, 1, 0);
    _mod0_RoundInt = hml_val_function((void*)_mod0_fn_RoundInt, 1, 1, 0);
    _mod0_SmoothStep = hml_val_function((void*)_mod0_fn_SmoothStep, 3, 3, 0);
    _mod0_InverseLerp = hml_val_function((void*)_mod0_fn_InverseLerp, 3, 3, 0);
    _mod0_MoveTowards = hml_val_function((void*)_mod0_fn_MoveTowards, 3, 3, 0);
    _mod0_MoveTowardsInt = hml_val_function((void*)_mod0_fn_MoveTowardsInt, 3, 3, 0);
    _mod0_Approximately = hml_val_function((void*)_mod0_fn_Approximately, 3, 3, 0);
    _mod0_InRange = hml_val_function((void*)_mod0_fn_InRange, 3, 3, 0);
    _mod0_InRangeInt = hml_val_function((void*)_mod0_fn_InRangeInt, 3, 3, 0);
    _mod0_WrapInt = hml_val_function((void*)_mod0_fn_WrapInt, 3, 3, 0);
    _mod0_Vector2LengthSq = hml_val_function((void*)_mod0_fn_Vector2LengthSq, 2, 2, 0);
    _mod0_Vector2NormalizeGetLength = hml_val_function((void*)_mod0_fn_Vector2NormalizeGetLength, 2, 2, 0);
    _mod0_Vector2ScaleX = hml_val_function((void*)_mod0_fn_Vector2ScaleX, 2, 2, 0);
    _mod0_Vector2ScaleY = hml_val_function((void*)_mod0_fn_Vector2ScaleY, 2, 2, 0);
    _mod0_Vector2AddX = hml_val_function((void*)_mod0_fn_Vector2AddX, 2, 2, 0);
    _mod0_Vector2AddY = hml_val_function((void*)_mod0_fn_Vector2AddY, 2, 2, 0);
    _mod0_Vector2SubtractX = hml_val_function((void*)_mod0_fn_Vector2SubtractX, 2, 2, 0);
    _mod0_Vector2SubtractY = hml_val_function((void*)_mod0_fn_Vector2SubtractY, 2, 2, 0);
    _mod0_Vector2NegateX = hml_val_function((void*)_mod0_fn_Vector2NegateX, 1, 1, 0);
    _mod0_Vector2NegateY = hml_val_function((void*)_mod0_fn_Vector2NegateY, 1, 1, 0);
    _mod0_Vector2RotateX = hml_val_function((void*)_mod0_fn_Vector2RotateX, 3, 3, 0);
    _mod0_Vector2RotateY = hml_val_function((void*)_mod0_fn_Vector2RotateY, 3, 3, 0);
    _mod0_Vector2LerpX = hml_val_function((void*)_mod0_fn_Vector2LerpX, 3, 3, 0);
    _mod0_Vector2LerpY = hml_val_function((void*)_mod0_fn_Vector2LerpY, 3, 3, 0);
    _mod0_Vector2ReflectX = hml_val_function((void*)_mod0_fn_Vector2ReflectX, 4, 4, 0);
    _mod0_Vector2ReflectY = hml_val_function((void*)_mod0_fn_Vector2ReflectY, 4, 4, 0);
    _mod0_Vector2Angle = hml_val_function((void*)_mod0_fn_Vector2Angle, 4, 4, 0);
    _mod0_Vector2AngleFromX = hml_val_function((void*)_mod0_fn_Vector2AngleFromX, 2, 2, 0);
    _mod0_Vector2MoveTowardsX = hml_val_function((void*)_mod0_fn_Vector2MoveTowardsX, 5, 5, 0);
    _mod0_Vector2MoveTowardsY = hml_val_function((void*)_mod0_fn_Vector2MoveTowardsY, 5, 5, 0);
    _mod0_CheckCollisionLinesXY = hml_val_function((void*)_mod0_fn_CheckCollisionLinesXY, 8, 8, 0);
    _mod0_CheckCollisionPointTriangleXY = hml_val_function((void*)_mod0_fn_CheckCollisionPointTriangleXY, 8, 8, 0);
    _mod0_CheckCollisionPointLineXY = hml_val_function((void*)_mod0_fn_CheckCollisionPointLineXY, 7, 7, 0);
    _mod0_EaseLinear = hml_val_function((void*)_mod0_fn_EaseLinear, 1, 1, 0);
    _mod0_EaseInQuad = hml_val_function((void*)_mod0_fn_EaseInQuad, 1, 1, 0);
    _mod0_EaseOutQuad = hml_val_function((void*)_mod0_fn_EaseOutQuad, 1, 1, 0);
    _mod0_EaseInOutQuad = hml_val_function((void*)_mod0_fn_EaseInOutQuad, 1, 1, 0);
    _mod0_EaseInCubic = hml_val_function((void*)_mod0_fn_EaseInCubic, 1, 1, 0);
    _mod0_EaseOutCubic = hml_val_function((void*)_mod0_fn_EaseOutCubic, 1, 1, 0);
    _mod0_EaseInOutCubic = hml_val_function((void*)_mod0_fn_EaseInOutCubic, 1, 1, 0);
    _mod0_EaseInQuart = hml_val_function((void*)_mod0_fn_EaseInQuart, 1, 1, 0);
    _mod0_EaseOutQuart = hml_val_function((void*)_mod0_fn_EaseOutQuart, 1, 1, 0);
    _mod0_EaseInOutQuart = hml_val_function((void*)_mod0_fn_EaseInOutQuart, 1, 1, 0);
    _mod0_EaseInQuint = hml_val_function((void*)_mod0_fn_EaseInQuint, 1, 1, 0);
    _mod0_EaseOutQuint = hml_val_function((void*)_mod0_fn_EaseOutQuint, 1, 1, 0);
    _mod0_EaseInOutQuint = hml_val_function((void*)_mod0_fn_EaseInOutQuint, 1, 1, 0);
    _mod0_EaseInSine = hml_val_function((void*)_mod0_fn_EaseInSine, 1, 1, 0);
    _mod0_EaseOutSine = hml_val_function((void*)_mod0_fn_EaseOutSine, 1, 1, 0);
    _mod0_EaseInOutSine = hml_val_function((void*)_mod0_fn_EaseInOutSine, 1, 1, 0);
    _mod0_EaseInExpo = hml_val_function((void*)_mod0_fn_EaseInExpo, 1, 1, 0);
    _mod0_EaseOutExpo = hml_val_function((void*)_mod0_fn_EaseOutExpo, 1, 1, 0);
    _mod0_EaseInOutExpo = hml_val_function((void*)_mod0_fn_EaseInOutExpo, 1, 1, 0);
    _mod0_EaseInCirc = hml_val_function((void*)_mod0_fn_EaseInCirc, 1, 1, 0);
    _mod0_EaseOutCirc = hml_val_function((void*)_mod0_fn_EaseOutCirc, 1, 1, 0);
    _mod0_EaseInOutCirc = hml_val_function((void*)_mod0_fn_EaseInOutCirc, 1, 1, 0);
    _mod0_EaseInBack = hml_val_function((void*)_mod0_fn_EaseInBack, 1, 1, 0);
    _mod0_EaseOutBack = hml_val_function((void*)_mod0_fn_EaseOutBack, 1, 1, 0);
    _mod0_EaseInOutBack = hml_val_function((void*)_mod0_fn_EaseInOutBack, 1, 1, 0);
    _mod0_EaseOutBounce = hml_val_function((void*)_mod0_fn_EaseOutBounce, 1, 1, 0);
    _mod0_EaseInBounce = hml_val_function((void*)_mod0_fn_EaseInBounce, 1, 1, 0);
    _mod0_EaseInOutBounce = hml_val_function((void*)_mod0_fn_EaseInOutBounce, 1, 1, 0);
    _mod0_EaseInElastic = hml_val_function((void*)_mod0_fn_EaseInElastic, 1, 1, 0);
    _mod0_EaseOutElastic = hml_val_function((void*)_mod0_fn_EaseOutElastic, 1, 1, 0);
    _mod0_EaseInOutElastic = hml_val_function((void*)_mod0_fn_EaseInOutElastic, 1, 1, 0);
    _mod0_ColorBlend = hml_val_function((void*)_mod0_fn_ColorBlend, 3, 3, 0);
    _mod0_ColorInvert = hml_val_function((void*)_mod0_fn_ColorInvert, 1, 1, 0);
    _mod0_ColorToGrayscale = hml_val_function((void*)_mod0_fn_ColorToGrayscale, 1, 1, 0);
    _mod0_ColorTint = hml_val_function((void*)_mod0_fn_ColorTint, 2, 2, 0);
    _mod0_ColorContrast = hml_val_function((void*)_mod0_fn_ColorContrast, 2, 2, 0);
}

// Named function implementations
int main(int argc, char **argv) {
    hml_runtime_init(argc, argv);
    
    _main_args = hml_get_args();
    
    _mod0_init();
    
    
    // Import from "../src/raylib.hml"
    HmlValue InitWindow = _mod0_InitWindow;
    HmlValue CloseWindow = _mod0_CloseWindow;
    HmlValue WindowShouldClose = _mod0_WindowShouldClose;
    HmlValue SetTargetFPS = _mod0_SetTargetFPS;
    HmlValue GetFPS = _mod0_GetFPS;
    HmlValue BeginDrawing = _mod0_BeginDrawing;
    HmlValue EndDrawing = _mod0_EndDrawing;
    HmlValue ClearBackground = _mod0_ClearBackground;
    HmlValue DrawRectangle = _mod0_DrawRectangle;
    HmlValue DrawCircle = _mod0_DrawCircle;
    HmlValue DrawText = _mod0_DrawText;
    HmlValue IsKeyPressed = _mod0_IsKeyPressed;
    HmlValue RAYWHITE = _mod0_RAYWHITE;
    HmlValue RED = _mod0_RED;
    HmlValue GREEN = _mod0_GREEN;
    HmlValue BLUE = _mod0_BLUE;
    HmlValue BLACK = _mod0_BLACK;
    HmlValue KEY_ESCAPE = _mod0_KEY_ESCAPE;
    HmlValue _tmp2004 = hml_val_i32(800);
    _main_screenWidth = _tmp2004;
    HmlValue _tmp2005 = hml_val_i32(450);
    _main_screenHeight = _tmp2005;
    HmlValue _tmp2007 = _main_screenWidth;
    hml_retain_if_needed(&_tmp2007);
    HmlValue _tmp2008 = _main_screenHeight;
    hml_retain_if_needed(&_tmp2008);
    HmlValue _tmp2009 = hml_val_string("Hemlock + Raylib - Hello Window");
    HmlValue _tmp2006 = hml_fn_InitWindow(NULL, _tmp2007, _tmp2008, _tmp2009);
    hml_release(&_tmp2007);
    hml_release(&_tmp2008);
    hml_release(&_tmp2009);
    hml_release(&_tmp2006);
    HmlValue _tmp2011 = hml_val_i32(60);
    HmlValue _tmp2010 = hml_fn_SetTargetFPS(NULL, _tmp2011);
    hml_release(&_tmp2011);
    hml_release(&_tmp2010);
    while (1) {
        HmlValue _tmp2013 = hml_fn_WindowShouldClose(NULL);
        HmlValue _tmp2014 = hml_val_i32(0);
        HmlValue _tmp2012 = hml_both_i32(_tmp2013, _tmp2014) ? hml_i32_eq(_tmp2013, _tmp2014) : (hml_both_i64(_tmp2013, _tmp2014) ? hml_i64_eq(_tmp2013, _tmp2014) : hml_binary_op(HML_OP_EQUAL, _tmp2013, _tmp2014));
        hml_release_if_needed(&_tmp2013);
        hml_release_if_needed(&_tmp2014);
        if (!hml_to_bool(_tmp2012)) { hml_release(&_tmp2012); break; }
        hml_release(&_tmp2012);
        {
            HmlValue _tmp2017 = KEY_ESCAPE;
            hml_retain_if_needed(&_tmp2017);
            HmlValue _tmp2016 = hml_fn_IsKeyPressed(NULL, _tmp2017);
            hml_release(&_tmp2017);
            HmlValue _tmp2018 = hml_val_i32(0);
            HmlValue _tmp2015 = hml_both_i32(_tmp2016, _tmp2018) ? hml_i32_ne(_tmp2016, _tmp2018) : (hml_both_i64(_tmp2016, _tmp2018) ? hml_i64_ne(_tmp2016, _tmp2018) : hml_binary_op(HML_OP_NOT_EQUAL, _tmp2016, _tmp2018));
            hml_release_if_needed(&_tmp2016);
            hml_release_if_needed(&_tmp2018);
            if (hml_to_bool(_tmp2015)) {
                {
                    break;
                }
            }
            hml_release(&_tmp2015);
            HmlValue _tmp2019 = hml_fn_BeginDrawing(NULL);
            hml_release(&_tmp2019);
            HmlValue _tmp2021 = RAYWHITE;
            hml_retain_if_needed(&_tmp2021);
            HmlValue _tmp2020 = hml_fn_ClearBackground(NULL, _tmp2021);
            hml_release(&_tmp2021);
            hml_release(&_tmp2020);
            HmlValue _tmp2023 = hml_val_i32(100);
            HmlValue _tmp2024 = hml_val_i32(100);
            HmlValue _tmp2025 = hml_val_i32(200);
            HmlValue _tmp2026 = hml_val_i32(100);
            HmlValue _tmp2027 = RED;
            hml_retain_if_needed(&_tmp2027);
            HmlValue _tmp2022 = hml_fn_DrawRectangle(NULL, _tmp2023, _tmp2024, _tmp2025, _tmp2026, _tmp2027);
            hml_release(&_tmp2023);
            hml_release(&_tmp2024);
            hml_release(&_tmp2025);
            hml_release(&_tmp2026);
            hml_release(&_tmp2027);
            hml_release(&_tmp2022);
            HmlValue _tmp2029 = hml_val_i32(500);
            HmlValue _tmp2030 = hml_val_i32(100);
            HmlValue _tmp2031 = hml_val_i32(200);
            HmlValue _tmp2032 = hml_val_i32(100);
            HmlValue _tmp2033 = GREEN;
            hml_retain_if_needed(&_tmp2033);
            HmlValue _tmp2028 = hml_fn_DrawRectangle(NULL, _tmp2029, _tmp2030, _tmp2031, _tmp2032, _tmp2033);
            hml_release(&_tmp2029);
            hml_release(&_tmp2030);
            hml_release(&_tmp2031);
            hml_release(&_tmp2032);
            hml_release(&_tmp2033);
            hml_release(&_tmp2028);
            HmlValue _tmp2035 = hml_val_i32(400);
            HmlValue _tmp2036 = hml_val_i32(300);
            HmlValue _tmp2037 = hml_val_f64(50);
            HmlValue _tmp2038 = BLUE;
            hml_retain_if_needed(&_tmp2038);
            HmlValue _tmp2034 = hml_fn_DrawCircle(NULL, _tmp2035, _tmp2036, _tmp2037, _tmp2038);
            hml_release(&_tmp2035);
            hml_release(&_tmp2036);
            hml_release(&_tmp2037);
            hml_release(&_tmp2038);
            hml_release(&_tmp2034);
            HmlValue _tmp2040 = hml_val_string("Hello from Hemlock + Raylib!");
            HmlValue _tmp2041 = hml_val_i32(240);
            HmlValue _tmp2042 = hml_val_i32(20);
            HmlValue _tmp2043 = hml_val_i32(20);
            HmlValue _tmp2044 = BLACK;
            hml_retain_if_needed(&_tmp2044);
            HmlValue _tmp2039 = hml_fn_DrawText(NULL, _tmp2040, _tmp2041, _tmp2042, _tmp2043, _tmp2044);
            hml_release(&_tmp2040);
            hml_release(&_tmp2041);
            hml_release(&_tmp2042);
            hml_release(&_tmp2043);
            hml_release(&_tmp2044);
            hml_release(&_tmp2039);
            HmlValue _tmp2047 = hml_val_string("FPS: ");
            HmlValue _tmp2048 = hml_fn_GetFPS(NULL);
            HmlValue _tmp2046 = hml_both_i32(_tmp2047, _tmp2048) ? hml_i32_add(_tmp2047, _tmp2048) : (hml_both_i64(_tmp2047, _tmp2048) ? hml_i64_add(_tmp2047, _tmp2048) : hml_binary_op(HML_OP_ADD, _tmp2047, _tmp2048));
            hml_release_if_needed(&_tmp2047);
            hml_release_if_needed(&_tmp2048);
            HmlValue _tmp2049 = hml_val_i32(10);
            HmlValue _tmp2050 = hml_val_i32(10);
            HmlValue _tmp2051 = hml_val_i32(20);
            HmlValue _tmp2052 = BLACK;
            hml_retain_if_needed(&_tmp2052);
            HmlValue _tmp2045 = hml_fn_DrawText(NULL, _tmp2046, _tmp2049, _tmp2050, _tmp2051, _tmp2052);
            hml_release(&_tmp2046);
            hml_release(&_tmp2049);
            hml_release(&_tmp2050);
            hml_release(&_tmp2051);
            hml_release(&_tmp2052);
            hml_release(&_tmp2045);
            HmlValue _tmp2054 = hml_val_string("Press ESC to exit");
            HmlValue _tmp2055 = hml_val_i32(10);
            HmlValue _tmp2056 = hml_val_i32(420);
            HmlValue _tmp2057 = hml_val_i32(16);
            HmlValue _tmp2058 = BLACK;
            hml_retain_if_needed(&_tmp2058);
            HmlValue _tmp2053 = hml_fn_DrawText(NULL, _tmp2054, _tmp2055, _tmp2056, _tmp2057, _tmp2058);
            hml_release(&_tmp2054);
            hml_release(&_tmp2055);
            hml_release(&_tmp2056);
            hml_release(&_tmp2057);
            hml_release(&_tmp2058);
            hml_release(&_tmp2053);
            HmlValue _tmp2059 = hml_fn_EndDrawing(NULL);
            hml_release(&_tmp2059);
        }
    }
    HmlValue _tmp2060 = hml_fn_CloseWindow(NULL);
    hml_release(&_tmp2060);
    HmlValue _tmp2062 = hml_val_string("Window closed!");
    hml_print(_tmp2062);
    hml_release(&_tmp2062);
    HmlValue _tmp2061 = hml_val_null();
    hml_release(&_tmp2061);
    
    hml_runtime_cleanup();
    return 0;
}
