// @stdlib/hash - Hashing and checksum utilities
//
// Provides both non-cryptographic hashes (for hash tables, checksums)
// and cryptographic hashes (SHA-256, SHA-512, MD5 via built-in OpenSSL).
//
// Usage:
//   import { djb2, fnv1a, murmur3, sha256, sha512, md5, file_checksum } from "@stdlib/hash";

// ============================================================================
// NON-CRYPTOGRAPHIC HASH FUNCTIONS
// ============================================================================

// DJB2 Hash Algorithm
// Fast, simple hash function with good distribution
// Commonly used in hash tables (as seen in HashMap implementation)
export fn djb2(input: string): u32 {
    if (typeof(input) != "string") {
        throw "djb2() requires string argument";
    }

    let h: u32 = 5381;
    let i = 0;
    while (i < input.byte_length) {
        let byte_val = input.byte_at(i);
        // h = h * 33 + byte_val (using bit shift: h * 33 = h * 32 + h)
        // Mask to 32 bits to ensure proper wraparound
        h = (((h << 5) + h) + byte_val) & 4294967295;
        i = i + 1;
    }

    return h;
}

// FNV-1a Hash Algorithm (32-bit version)
// Fowler-Noll-Vo hash with good avalanche properties
// Better distribution than DJB2 for certain data patterns
export fn fnv1a(input: string): u32 {
    if (typeof(input) != "string") {
        throw "fnv1a() requires string argument";
    }

    // FNV-1a constants (32-bit)
    let FNV_OFFSET_BASIS: u32 = 2166136261;  // 0x811c9dc5
    let FNV_PRIME: u32 = 16777619;            // 0x01000193

    let h: u32 = FNV_OFFSET_BASIS;
    let i = 0;
    while (i < input.byte_length) {
        let byte_val = input.byte_at(i);
        h = (h ^ byte_val) & 4294967295;  // XOR with byte
        h = (h * FNV_PRIME) & 4294967295;  // Multiply by FNV prime, mask to 32 bits
        i = i + 1;
    }

    return h;
}

// MurmurHash3 (32-bit version, simplified)
// Fast, non-cryptographic hash with excellent distribution
// Widely used in production hash tables (Redis, Hadoop, etc.)
export fn murmur3(input: string, seed?: 0): u32 {
    if (typeof(input) != "string") {
        throw "murmur3() requires string argument";
    }

    let bytes = input.bytes();
    let len = bytes.length;
    let h: u32 = seed & 4294967295;

    // Constants (as u32)
    let c1: u32 = 3432918353;  // 0xcc9e2d51
    let c2: u32 = 461845907;   // 0x1b873593
    let r1 = 15;
    let r2 = 13;
    let m: u32 = 5;
    let n: u32 = 3864292196;   // 0xe6546b64

    // Process 4-byte chunks
    let i = 0;
    let chunks = len / 4;
    let full_chunks: i32 = chunks;

    i = 0;
    while (i < full_chunks) {
        // Read 4 bytes as little-endian u32
        let k: u32 = (bytes[i * 4]
            | (bytes[i * 4 + 1] << 8)
            | (bytes[i * 4 + 2] << 16)
            | (bytes[i * 4 + 3] << 24)) & 4294967295;

        k = (k * c1) & 4294967295;
        k = ((k << r1) | ((k >> (32 - r1)) & 4294967295)) & 4294967295;  // rotl32
        k = (k * c2) & 4294967295;

        h = (h ^ k) & 4294967295;
        h = ((h << r2) | ((h >> (32 - r2)) & 4294967295)) & 4294967295;  // rotl32
        h = ((h * m) + n) & 4294967295;

        i = i + 1;
    }

    // Process remaining bytes
    let k1: u32 = 0;
    let tail_start = full_chunks * 4;

    if (len % 4 == 3) {
        k1 = (k1 ^ (bytes[tail_start + 2] << 16)) & 4294967295;
    }
    if (len % 4 >= 2) {
        k1 = (k1 ^ (bytes[tail_start + 1] << 8)) & 4294967295;
    }
    if (len % 4 >= 1) {
        k1 = (k1 ^ bytes[tail_start]) & 4294967295;
        k1 = (k1 * c1) & 4294967295;
        k1 = ((k1 << r1) | ((k1 >> (32 - r1)) & 4294967295)) & 4294967295;
        k1 = (k1 * c2) & 4294967295;
        h = (h ^ k1) & 4294967295;
    }

    // Finalization mix
    h = (h ^ len) & 4294967295;
    h = (h ^ ((h >> 16) & 4294967295)) & 4294967295;
    h = (h * 2246822507) & 4294967295;  // 0x85ebca6b
    h = (h ^ ((h >> 13) & 4294967295)) & 4294967295;
    h = (h * 3266489909) & 4294967295;  // 0xc2b2ae35
    h = (h ^ ((h >> 16) & 4294967295)) & 4294967295;

    return h;
}

// ============================================================================
// CRYPTOGRAPHIC HASH FUNCTIONS (built-in, using OpenSSL)
// ============================================================================

// SHA-256 hash (256-bit / 32-byte output)
// Returns hexadecimal string representation
export fn sha256(input: string): string {
    if (typeof(input) != "string") {
        throw "sha256() requires string argument";
    }
    return __sha256(input);
}

// SHA-512 hash (512-bit / 64-byte output)
// Returns hexadecimal string representation
export fn sha512(input: string): string {
    if (typeof(input) != "string") {
        throw "sha512() requires string argument";
    }
    return __sha512(input);
}

// MD5 hash (128-bit / 16-byte output)
// WARNING: MD5 is cryptographically broken, use only for legacy compatibility
// Returns hexadecimal string representation
export fn md5(input: string): string {
    if (typeof(input) != "string") {
        throw "md5() requires string argument";
    }
    return __md5(input);
}

// ============================================================================
// FILE CHECKSUM FUNCTIONS
// ============================================================================

// Compute hash of file contents
// hash_fn: one of djb2, fnv1a, murmur3, sha256, sha512, md5
export fn file_checksum(path: string, hash_fn): string {
    if (typeof(path) != "string") {
        throw "file_checksum() requires string path";
    }
    if (typeof(hash_fn) != "function") {
        throw "file_checksum() requires hash function as second argument";
    }

    // Open and read file
    let file = open(path, "r");
    defer file.close();

    let content = file.read();

    // Compute hash
    let hash_result = hash_fn(content);

    // Convert to string - typeof() returns a string representation of any value
    return "" + typeof(hash_result);
}

// Convenience functions for specific file checksums

export fn file_sha256(path: string): string {
    return file_checksum(path, sha256);
}

export fn file_sha512(path: string): string {
    return file_checksum(path, sha512);
}

export fn file_md5(path: string): string {
    return file_checksum(path, md5);
}

export fn file_djb2(path: string): string {
    return file_checksum(path, djb2);
}

export fn file_fnv1a(path: string): string {
    return file_checksum(path, fnv1a);
}

export fn file_murmur3(path: string): string {
    return file_checksum(path, murmur3);
}
