// @stdlib/http - HTTP client using libwebsockets (statically linked)
// Production-ready HTTP/HTTPS client
// Requires: libwebsockets-dev package (sudo apt-get install libwebsockets-dev)

// Note: libwebsockets functions are now built into hemlock as __lws_* builtins
// No FFI import needed - functions are available directly

// ========== HTTP CLIENT IMPLEMENTATION ==========

fn http_request(method, url, body, headers) {
    return http_request_with_redirects(method, url, body, headers, 0);
}

fn http_request_with_redirects(method, url, body, headers, redirect_count) {
    // Limit redirects to prevent infinite loops
    if (redirect_count > 10) {
        throw "Too many redirects: " + url;
    }

    let resp_ptr = null;

    if (method == "GET") {
        resp_ptr = __lws_http_get(url);
    } else if (method == "POST") {
        let content_type = "application/x-www-form-urlencoded";

        // Check if headers contain Content-Type
        if (headers != null && headers.length > 0) {
            let i = 0;
            while (i < headers.length) {
                if (headers[i].starts_with("Content-Type:")) {
                    content_type = headers[i].substr(14, headers[i].length - 14).trim();
                }
                i = i + 1;
            }
        }

        resp_ptr = __lws_http_post(url, body, content_type);
    } else {
        throw "HTTP method not supported: " + method;
    }

    if (resp_ptr == null) {
        throw "HTTP request failed: " + method + " " + url;
    }

    // Extract response data
    let status = __lws_response_status(resp_ptr);
    let redirect_url = __lws_response_redirect(resp_ptr);
    let response_body = __lws_response_body(resp_ptr);
    let response_headers = __lws_response_headers(resp_ptr);

    // Free C response structure
    __lws_response_free(resp_ptr);

    // Handle redirects (3xx status codes)
    if (status >= 300 && status < 400 && redirect_url != null) {
        // If redirect URL is relative, make it absolute
        if (redirect_url.starts_with("/")) {
            // Extract scheme and host from original URL
            let scheme_end = url.index_of("://");
            if (scheme_end >= 0) {
                let host_start = scheme_end + 3;
                let host_end = url.index_of("/", host_start);
                if (host_end < 0) {
                    host_end = url.length;
                }
                let base = url.substr(0, host_end);
                redirect_url = base + redirect_url;
            }
        }
        // Follow redirect (use GET for 301/302/303)
        return http_request_with_redirects("GET", redirect_url, "", headers, redirect_count + 1);
    }

    return {
        status_code: status,
        headers: response_headers,
        body: response_body,
    };
}

// ========== BINARY HTTP REQUEST (for file downloads) ==========

fn http_request_binary(method, url, headers) {
    return http_request_binary_with_redirects(method, url, headers, 0);
}

fn http_request_binary_with_redirects(method, url, headers, redirect_count) {
    // Limit redirects to prevent infinite loops
    if (redirect_count > 10) {
        throw "Too many redirects: " + url;
    }

    let resp_ptr = null;

    if (method == "GET") {
        resp_ptr = __lws_http_get(url);
    } else {
        throw "Binary download only supports GET method";
    }

    if (resp_ptr == null) {
        throw "HTTP request failed: " + method + " " + url;
    }

    // Extract response data
    let status = __lws_response_status(resp_ptr);
    let redirect_url = __lws_response_redirect(resp_ptr);

    // Handle redirects (3xx status codes) BEFORE getting body
    if (status >= 300 && status < 400 && redirect_url != null) {
        // Free response before following redirect
        __lws_response_free(resp_ptr);

        // If redirect URL is relative, make it absolute
        if (redirect_url.starts_with("/")) {
            let scheme_end = url.index_of("://");
            if (scheme_end >= 0) {
                let host_start = scheme_end + 3;
                let host_end = url.index_of("/", host_start);
                if (host_end < 0) {
                    host_end = url.length;
                }
                let base = url.substr(0, host_end);
                redirect_url = base + redirect_url;
            }
        }
        // Follow redirect
        return http_request_binary_with_redirects("GET", redirect_url, headers, redirect_count + 1);
    }

    // Get body as binary buffer (preserves null bytes)
    let response_body = __lws_response_body_binary(resp_ptr);
    let response_headers = __lws_response_headers(resp_ptr);

    // Free C response structure
    __lws_response_free(resp_ptr);

    return {
        status_code: status,
        headers: response_headers,
        body: response_body,
    };
}

// ========== PUBLIC API ==========

export fn get(url, headers) {
    if (headers == null) {
        headers = [];
    }
    return http_request("GET", url, "", headers);
}

// Get binary data (for file downloads - returns buffer instead of string)
export fn get_binary(url, headers) {
    if (headers == null) {
        headers = [];
    }
    return http_request_binary("GET", url, headers);
}

export fn post(url, body, headers) {
    if (body == null) {
        body = "";
    }
    if (headers == null) {
        headers = [];
    }
    return http_request("POST", url, body, headers);
}

export fn put(url, body, headers) {
    if (body == null) {
        body = "";
    }
    if (headers == null) {
        headers = [];
    }
    // PUT not implemented in C wrapper yet - use POST
    return http_request("POST", url, body, headers);
}

export fn delete(url, headers) {
    if (headers == null) {
        headers = [];
    }
    // DELETE not implemented in C wrapper yet - use GET
    return http_request("GET", url, "", headers);
}

export fn request(method, url, body, headers) {
    if (body == null) {
        body = "";
    }
    if (headers == null) {
        headers = [];
    }
    return http_request(method, url, body, headers);
}

// ========== CONVENIENCE FUNCTIONS ==========

export fn fetch(url) {
    let response = get(url, null);
    return response.body;
}

export fn post_json(url, data) {
    let json = data.serialize();
    let headers = ["Content-Type: application/json"];
    return post(url, json, headers);
}

export fn get_json(url) {
    let response = get(url, null);
    return response.body.deserialize();
}

export fn download(url, output_path) {
    let response = get(url, null);

    // Would need file write support
    // For now, just return success based on status
    return response.status_code >= 200 && response.status_code < 300;
}

// ========== STATUS CODE HELPERS ==========

export fn is_success(status_code) {
    return status_code >= 200 && status_code < 300;
}

export fn is_redirect(status_code) {
    return status_code >= 300 && status_code < 400;
}

export fn is_client_error(status_code) {
    return status_code >= 400 && status_code < 500;
}

export fn is_server_error(status_code) {
    return status_code >= 500 && status_code < 600;
}

// ========== URL HELPERS ==========

export fn url_encode(str) {
    let result = str;
    result = result.replace_all(" ", "%20");
    result = result.replace_all("!", "%21");
    result = result.replace_all("#", "%23");
    result = result.replace_all("$", "%24");
    result = result.replace_all("&", "%26");
    result = result.replace_all("'", "%27");
    result = result.replace_all("(", "%28");
    result = result.replace_all(")", "%29");
    result = result.replace_all("+", "%2B");
    return result;
}

// ========== NOTES ==========
//
// This module uses libwebsockets via FFI for production HTTP/HTTPS support.
//
// Features:
// - Native HTTP and HTTPS support
// - SSL/TLS via libwebsockets
// - No dependency on curl binary
// - Production performance
//
// Requirements:
// - libwebsockets-dev package installed
// - Compiled lws_wrapper.so (run: make stdlib)
//
// Current limitations:
// - PUT and DELETE use POST/GET (C wrapper needs implementation)
// - Custom headers partially supported (Content-Type works)
// - Response headers not yet parsed (returns empty string)
// - download() only checks status, doesn't write to file (needs file I/O)
// - url_encode() only encodes common characters (not RFC 3986 compliant)
//
