// stdlib/fs.hml
// Filesystem operations module

// FFI declarations for filesystem operations
import "libc.so.6";

extern fn mkdir(path: ptr, mode: u32): i32;
extern fn rmdir(path: ptr): i32;
extern fn stat(path: ptr, buf: ptr): i32;
extern fn opendir(path: ptr): ptr;
extern fn readdir(dir: ptr): ptr;
extern fn closedir(dir: ptr): i32;
extern fn unlink(path: ptr): i32;
extern fn __c_rename(oldpath: ptr, newpath: ptr): i32;
extern fn getcwd(buf: ptr, size: u32): ptr;
extern fn __c_chdir(path: ptr): i32;
extern fn realpath(path: ptr, resolved: ptr): ptr;

/**
 * Checks if a file or directory exists.
 */
export fn exists(path: string): bool {
    return __file_exists(path);
}

/**
 * Reads entire file contents as string.
 */
export fn read_file(path: string): string {
    let f = open(path, "r");
    try {
        return f.read();
    } finally {
        f.close();
    }
}

/**
 * Writes string to file (overwrites if exists).
 */
export fn write_file(path: string, content: string) {
    let f = open(path, "w");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

/**
 * Appends string to file.
 */
export fn append_file(path: string, content: string) {
    let f = open(path, "a");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

/**
 * Creates a directory.
 * Default permissions: 0755 (rwxr-xr-x)
 */
export fn make_dir(path: string, mode: u32) {
    let path_cstr = __string_to_cstr(path);
    let result = mkdir(path_cstr, mode);
    free(path_cstr);

    if (result != 0) {
        throw "Failed to create directory: " + path;
    }
}

/**
 * Removes an empty directory.
 */
export fn remove_dir(path: string) {
    let path_cstr = __string_to_cstr(path);
    let result = rmdir(path_cstr);
    free(path_cstr);

    if (result != 0) {
        throw "Failed to remove directory: " + path;
    }
}

/**
 * Lists files and directories in a directory.
 * Returns array of filenames (not full paths).
 */
export fn list_dir(path: string): array {
    let path_cstr = __string_to_cstr(path);
    let dir = opendir(path_cstr);
    free(path_cstr);

    if (dir == null) {
        throw "Failed to open directory: " + path;
    }

    let files = [];
    while (true) {
        let entry = readdir(dir);
        if (entry == null) {
            break;
        }
        let name = __dirent_name(entry);
        if (name != "." && name != "..") {
            files.push(name);
        }
    }

    closedir(dir);
    return files;
}

/**
 * Checks if path is a regular file.
 */
export fn is_file(path: string): bool {
    let path_cstr = __string_to_cstr(path);
    let stat_buf = alloc(144);  // sizeof(struct stat) on Linux x86_64
    let result = stat(path_cstr, stat_buf);
    free(path_cstr);

    if (result != 0) {
        free(stat_buf);
        return false;
    }

    let mode = __read_u32(stat_buf + 24);  // st_mode offset
    free(stat_buf);

    return (mode & 0o170000) == 0o100000;  // S_ISREG
}

/**
 * Checks if path is a directory.
 */
export fn is_dir(path: string): bool {
    let path_cstr = __string_to_cstr(path);
    let stat_buf = alloc(144);
    let result = stat(path_cstr, stat_buf);
    free(path_cstr);

    if (result != 0) {
        free(stat_buf);
        return false;
    }

    let mode = __read_u32(stat_buf + 24);
    free(stat_buf);

    return (mode & 0o170000) == 0o040000;  // S_ISDIR
}

/**
 * Gets file information.
 * Returns object with: size, atime, mtime, ctime, mode, is_file, is_dir
 */
export fn file_stat(path: string): object {
    let path_cstr = __string_to_cstr(path);
    let stat_buf = alloc(144);
    let result = stat(path_cstr, stat_buf);
    free(path_cstr);

    if (result != 0) {
        free(stat_buf);
        throw "Failed to stat file: " + path;
    }

    // Extract fields from struct stat (x86_64 Linux offsets)
    // Note: Using __read_u32 for all fields due to lack of u64 support
    let size = __read_u32(stat_buf + 48);     // st_size (truncated)
    let atime = __read_u32(stat_buf + 72);    // st_atime (truncated)
    let mtime = __read_u32(stat_buf + 88);    // st_mtime (truncated)
    let ctime = __read_u32(stat_buf + 104);   // st_ctime (truncated)
    let mode = __read_u32(stat_buf + 24);     // st_mode

    free(stat_buf);

    return {
        size: size,
        atime: atime,
        mtime: mtime,
        ctime: ctime,
        mode: mode,
        is_file: (mode & 0o170000) == 0o100000,
        is_dir: (mode & 0o170000) == 0o040000,
    };
}

/**
 * Deletes a file.
 */
export fn remove_file(path: string) {
    let path_cstr = __string_to_cstr(path);
    let result = unlink(path_cstr);
    free(path_cstr);

    if (result != 0) {
        throw "Failed to remove file '" + path + "': " + __strerror();
    }
}

/**
 * Renames or moves a file/directory.
 */
export fn rename(old_path: string, new_path: string) {
    let old_cstr = __string_to_cstr(old_path);
    let new_cstr = __string_to_cstr(new_path);
    let result = __c_rename(old_cstr, new_cstr);
    free(old_cstr);
    free(new_cstr);

    if (result != 0) {
        throw "Failed to rename '" + old_path + "' to '" + new_path + "': " + __strerror();
    }
}

/**
 * Copies a file (reads source and writes to destination).
 */
export fn copy_file(src: string, dest: string) {
    let f_src = open(src, "r");
    try {
        let f_dest = open(dest, "w");
        try {
            // Copy in 4KB chunks
            while (true) {
                let chunk = f_src.read(4096);
                if (chunk.length == 0) {
                    break;
                }
                f_dest.write(chunk);
            }
        } finally {
            f_dest.close();
        }
    } finally {
        f_src.close();
    }
}

/**
 * Gets the current working directory.
 */
export fn cwd(): string {
    let buf = alloc(4096);
    let result = getcwd(buf, 4096);

    if (result == null) {
        free(buf);
        throw "Failed to get current directory: " + __strerror();
    }

    let path = __cstr_to_string(result);
    free(buf);
    return path;
}

/**
 * Changes the current working directory.
 */
export fn chdir(path: string) {
    let path_cstr = __string_to_cstr(path);
    let result = __c_chdir(path_cstr);
    free(path_cstr);

    if (result != 0) {
        throw "Failed to change directory to '" + path + "': " + __strerror();
    }
}

/**
 * Gets the absolute path of a file or directory.
 */
export fn absolute_path(path: string): string {
    let path_cstr = __string_to_cstr(path);
    let resolved = alloc(4096);
    let result = realpath(path_cstr, resolved);
    free(path_cstr);

    if (result == null) {
        free(resolved);
        throw "Failed to resolve path '" + path + "': " + __strerror();
    }

    let abs_path = __cstr_to_string(result);
    free(resolved);
    return abs_path;
}
