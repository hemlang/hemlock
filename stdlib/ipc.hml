// @stdlib/ipc - Inter-Process Communication
//
// Provides facilities for communication between processes.
// Uses file-based mechanisms for simplicity and portability.
//
// Usage:
//   import { MessageQueue, Semaphore, SharedData } from "@stdlib/ipc";
//   let mq = MessageQueue("/tmp/my_queue");
//   mq.send("hello");

import { exists, read_file, write_file, append_file, remove_file, make_dir, list_dir, is_dir } from "@stdlib/fs";
import { join } from "@stdlib/path";
import { v4 } from "@stdlib/uuid";
import { time_ms, sleep } from "@stdlib/time";

// ============================================================================
// Message Queue
// ============================================================================

// Create a file-based message queue
// Parameters:
//   path: string - Directory path for the queue
// Returns: MessageQueue object
export fn MessageQueue(path): object {
    // Create queue directory if needed
    if (!exists(path)) {
        make_dir(path);
    }

    return {
        _path: path,
        _read_idx: 0,

        // Send a message to the queue
        // Parameters:
        //   message: string - Message to send
        send: fn(message) {
            let id = v4();
            let ts = time_ms();
            let filename = ts + "_" + id + ".msg";
            let filepath = join(self._path, filename);
            write_file(filepath, message);
        },

        // Receive a message from the queue (blocking with timeout)
        // Parameters:
        //   timeout_ms: i32 - Timeout in milliseconds (default: 5000)
        // Returns: string|null - Message or null if timeout
        recv: fn(timeout_ms?: 5000) {
            let start = time_ms();

            while (true) {
                // List messages
                let files = list_dir(self._path);
                let msg_files: array = [];

                let i = 0;
                while (i < files.length) {
                    if (files[i].ends_with(".msg")) {
                        msg_files.push(files[i]);
                    }
                    i = i + 1;
                }

                // Sort by name (which is timestamp-based)
                msg_files = sort_strings(msg_files);

                // Get first message
                if (msg_files.length > 0) {
                    let filepath = join(self._path, msg_files[0]);
                    let content = read_file(filepath);
                    remove_file(filepath);
                    return content;
                }

                // Check timeout
                if (time_ms() - start > timeout_ms) {
                    return null;
                }

                // Sleep briefly before retry
                sleep(0.01);
            }
        },

        // Try to receive without blocking
        // Returns: string|null - Message or null if empty
        try_recv: fn() {
            let files = list_dir(self._path);
            let msg_files: array = [];

            let i = 0;
            while (i < files.length) {
                if (files[i].ends_with(".msg")) {
                    msg_files.push(files[i]);
                }
                i = i + 1;
            }

            if (msg_files.length == 0) {
                return null;
            }

            msg_files = sort_strings(msg_files);
            let filepath = join(self._path, msg_files[0]);
            let content = read_file(filepath);
            remove_file(filepath);
            return content;
        },

        // Check if queue is empty
        // Returns: bool
        is_empty: fn(): bool {
            let files = list_dir(self._path);
            let i = 0;
            while (i < files.length) {
                if (files[i].ends_with(".msg")) {
                    return false;
                }
                i = i + 1;
            }
            return true;
        },

        // Get number of messages in queue
        // Returns: i32
        count: fn(): i32 {
            let files = list_dir(self._path);
            let count = 0;
            let i = 0;
            while (i < files.length) {
                if (files[i].ends_with(".msg")) {
                    count = count + 1;
                }
                i = i + 1;
            }
            return count;
        },

        // Clear all messages from the queue
        clear: fn() {
            let files = list_dir(self._path);
            let i = 0;
            while (i < files.length) {
                if (files[i].ends_with(".msg")) {
                    let filepath = join(self._path, files[i]);
                    remove_file(filepath);
                }
                i = i + 1;
            }
        },

        // Destroy the queue (remove directory)
        destroy: fn() {
            self.clear();
            // Note: remove_dir might fail if not empty
            try {
                remove_dir(self._path);
            } catch (e) {
                // Ignore - might have new messages
            }
        }
    };
}

// ============================================================================
// Semaphore
// ============================================================================

// Create a file-based semaphore
// Parameters:
//   path: string - File path for the semaphore
//   initial: i32 - Initial value (default: 1)
// Returns: Semaphore object
export fn Semaphore(path, initial?: 1): object {
    // Initialize semaphore file
    if (!exists(path)) {
        write_file(path, "" + initial);
    }

    return {
        _path: path,

        // Acquire the semaphore (decrement, block if zero)
        // Parameters:
        //   timeout_ms: i32 - Timeout in milliseconds (default: 5000)
        // Returns: bool - True if acquired, false if timeout
        acquire: fn(timeout_ms?: 5000): bool {
            let start = time_ms();

            while (true) {
                // Try to decrement
                let val = self._read_val();
                if (val > 0) {
                    self._write_val(val - 1);
                    return true;
                }

                // Check timeout
                if (time_ms() - start > timeout_ms) {
                    return false;
                }

                // Sleep briefly
                sleep(0.01);
            }
        },

        // Try to acquire without blocking
        // Returns: bool - True if acquired
        try_acquire: fn(): bool {
            let val = self._read_val();
            if (val > 0) {
                self._write_val(val - 1);
                return true;
            }
            return false;
        },

        // Release the semaphore (increment)
        release: fn() {
            let val = self._read_val();
            self._write_val(val + 1);
        },

        // Get current value
        // Returns: i32
        value: fn(): i32 {
            return self._read_val();
        },

        // Internal: Read value from file
        _read_val: fn(): i32 {
            let content = read_file(self._path);
            return parse_int_str(content.trim());
        },

        // Internal: Write value to file
        _write_val: fn(val) {
            write_file(self._path, "" + val);
        }
    };
}

// ============================================================================
// Mutex (Binary Semaphore)
// ============================================================================

// Create a file-based mutex
// Parameters:
//   path: string - File path for the mutex
// Returns: Mutex object
export fn Mutex(path): object {
    let sem = Semaphore(path, 1);

    return {
        _sem: sem,

        // Lock the mutex
        // Parameters:
        //   timeout_ms: i32 - Timeout in milliseconds (default: 5000)
        // Returns: bool - True if locked, false if timeout
        lock: fn(timeout_ms?: 5000): bool {
            return self._sem.acquire(timeout_ms);
        },

        // Try to lock without blocking
        // Returns: bool - True if locked
        try_lock: fn(): bool {
            return self._sem.try_acquire();
        },

        // Unlock the mutex
        unlock: fn() {
            self._sem.release();
        },

        // Check if locked
        // Returns: bool
        is_locked: fn(): bool {
            return self._sem.value() == 0;
        }
    };
}

// ============================================================================
// Shared Data
// ============================================================================

// Create a shared data store (file-based key-value)
// Parameters:
//   path: string - File path for the data
// Returns: SharedData object
export fn SharedData(path): object {
    // Initialize file if needed
    if (!exists(path)) {
        write_file(path, "{}");
    }

    return {
        _path: path,
        _lock: Mutex(path + ".lock"),

        // Get a value
        // Parameters:
        //   key: string - Key to get
        // Returns: value or null
        get: fn(key) {
            let data = self._read_data();
            return data[key];
        },

        // Set a value
        // Parameters:
        //   key: string - Key to set
        //   value: any - Value to store
        set: fn(key, value) {
            self._lock.lock();
            try {
                let data = self._read_data();
                data[key] = value;
                self._write_data(data);
            } catch (e) {
                self._lock.unlock();
                throw e;
            }
            self._lock.unlock();
        },

        // Delete a key
        // Parameters:
        //   key: string - Key to delete
        delete: fn(key) {
            self._lock.lock();
            try {
                let data = self._read_data();
                // Can't delete properties, so set to null
                data[key] = null;
                self._write_data(data);
            } catch (e) {
                self._lock.unlock();
                throw e;
            }
            self._lock.unlock();
        },

        // Get all keys
        // Returns: array<string>
        keys: fn(): array {
            let data = self._read_data();
            let result: array = [];
            // Note: Object iteration would be needed
            // This is a simplified implementation
            return result;
        },

        // Clear all data
        clear: fn() {
            self._lock.lock();
            try {
                self._write_data({});
            } catch (e) {
                self._lock.unlock();
                throw e;
            }
            self._lock.unlock();
        },

        // Internal: Read data from file
        _read_data: fn(): object {
            let content = read_file(self._path);
            return content.deserialize();
        },

        // Internal: Write data to file
        _write_data: fn(data) {
            let content = data.serialize();
            write_file(self._path, content);
        }
    };
}

// ============================================================================
// PID File
// ============================================================================

// Create a PID file for process identification
// Parameters:
//   path: string - Path for the PID file
// Returns: PidFile object
export fn PidFile(path): object {
    let pid = get_pid();

    return {
        _path: path,
        _pid: pid,

        // Create/write the PID file
        // Returns: bool - True if created, false if already exists
        create: fn(): bool {
            if (exists(self._path)) {
                // Check if process is still running
                let existing = self.read();
                if (existing != null && is_process_alive(existing)) {
                    return false;  // Already running
                }
                // Stale PID file, overwrite
            }
            write_file(self._path, "" + self._pid);
            return true;
        },

        // Read the PID from file
        // Returns: i32|null - PID or null if not exists
        read: fn() {
            if (!exists(self._path)) {
                return null;
            }
            let content = read_file(self._path);
            return parse_int_str(content.trim());
        },

        // Remove the PID file
        remove: fn() {
            if (exists(self._path)) {
                remove_file(self._path);
            }
        },

        // Check if the file's PID matches current process
        // Returns: bool
        is_owner: fn(): bool {
            let stored = self.read();
            return stored == self._pid;
        }
    };
}

// ============================================================================
// Helper Functions
// ============================================================================

// Sort an array of strings
fn sort_strings(arr): array {
    // Simple bubble sort for small arrays
    let result = arr.slice(0, arr.length);
    let n = result.length;

    let i = 0;
    while (i < n - 1) {
        let j = 0;
        while (j < n - i - 1) {
            if (result[j] > result[j + 1]) {
                let temp = result[j];
                result[j] = result[j + 1];
                result[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }

    return result;
}

// Parse integer from string
fn parse_int_str(s): i32 {
    return i32(s);
}

// Check if a process is alive
fn is_process_alive(pid): bool {
    // Try to send signal 0 (no-op) to check if process exists
    try {
        kill(pid, 0);
        return true;
    } catch (e) {
        return false;
    }
}

// Re-export process functions for convenience
import { get_pid, kill } from "@stdlib/process";

// ============================================================================
// Event File (simple notification)
// ============================================================================

// Create an event file for simple signaling between processes
// Parameters:
//   path: string - Path for the event file
// Returns: Event object
export fn Event(path): object {
    return {
        _path: path,

        // Set the event (signal)
        set: fn() {
            write_file(self._path, "" + time_ms());
        },

        // Clear the event
        clear: fn() {
            if (exists(self._path)) {
                remove_file(self._path);
            }
        },

        // Check if event is set
        // Returns: bool
        is_set: fn(): bool {
            return exists(self._path);
        },

        // Wait for the event to be set
        // Parameters:
        //   timeout_ms: i32 - Timeout in milliseconds (default: 5000)
        // Returns: bool - True if event was set, false if timeout
        wait: fn(timeout_ms?: 5000): bool {
            let start = time_ms();

            while (true) {
                if (exists(self._path)) {
                    return true;
                }

                if (time_ms() - start > timeout_ms) {
                    return false;
                }

                sleep(0.01);
            }
        }
    };
}

// ============================================================================
// Remove Directory Helper
// ============================================================================

// Import from fs for remove_dir
fn remove_dir(path) {
    // Use __remove_dir builtin
    __remove_dir(path);
}
