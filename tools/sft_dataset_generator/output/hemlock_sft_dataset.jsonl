{"instruction": "How does command chaining work in Hemlock?", "output": "**With ; (sequence):**\n\n```hemlock\nlet r = exec(\"command1; command2\");\n// Runs both regardless of success/failure\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does free work in Hemlock?", "output": "```hemlock\nfree(ptr: ptr | buffer): null\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "**`to_bytes()`** - Convert to buffer for low-level access:\n\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // Returns buffer with UTF-8 bytes\nprint(buf.length);              // 5\nfree(buf);                      // Remember to free\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does udpsocket work in Hemlock?", "output": "Sets receive timeout in seconds.\n\n```hemlock\nsock.set_timeout(2.0);  // 2 second timeout\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does write_files_parallel work in Hemlock?", "output": "```hemlock\nwrite_files_parallel(files: array<object>): null\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does maybe add (under discussion) work in Hemlock?", "output": "**1. `defer` for cleanup**\n\n```hemlock\nlet f = open(\"file.txt\");\ndefer f.close();  // Explicit, not automatic\n// ... use file\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does i/o signals work in Hemlock?", "output": "```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport {\n    async_read_file,\n    async_write_file,\n    read_files_parallel,\n    shutdown_async_fs\n} from \"@stdlib/async_fs\";\n\n// Process multiple config files in parallel\nlet config_files = [\"app.json\", \"db.json\", \"cache.json\"];\nlet configs = read_files_parallel(config_files);\n\nprint(\"Loaded \" + configs.length + \" config files\");\n\n// Process configs and write results\nlet i = 0;\nlet futures = [];\nwhile (i < configs.length) {\n    let processed = \"Processed: \" + configs[i];\n    futures.push(async_write_file(\"output_\" + i + \".txt\", processed));\n    i = i + 1;\n}\n\n// Wait for all writes\ni = 0;\nwhile (i < futures.length) {\n    futures[i].get();\n    i = i + 1;\n}\n\nprint(\"All processing complete\");\n\n// Cleanup\nshutdown_async_fs();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does built-in functions work in Hemlock?", "output": "```hemlock\nasync fn background_work() {\n    // Long-running background task\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // Task runs independently, cannot join\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does exception handling patterns work in Hemlock?", "output": "**Pattern 3: Detached tasks with exceptions**\n\n```hemlock\nasync fn detached_task() {\n    try {\n        // work\n    } catch (e) {\n        // Must handle internally - cannot propagate\n        print(\"Error: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // Cannot catch exceptions from detached tasks\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How do you convert between types in Hemlock?", "output": "```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;\nprint(c);\n\nlet x: i32 = 5;\nlet y: f64 = 3.14;\nlet z = x + y;\nprint(z);\n\nlet p: u8 = 100;\nlet q: u16 = 200;\nlet r = p + q;\nprint(r);\n\nlet m: f32 = 2.5;\nlet n: f64 = 1.5;\nlet o = m + n;\nprint(o);\n```", "category": "examples", "source": "examples/conversions.hml"}
{"instruction": "How does low-level builtins work in Hemlock?", "output": "Convert Unix timestamp to UTC time components.\n\n```hemlock\nimport { gmtime } from \"@stdlib/datetime\";\n\nlet utc_components = gmtime(1737037845);\nprint(\"UTC hour: \" + typeof(utc_components.hour));\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does import statements work in Hemlock?", "output": "```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does `exec(command: string): object` work in Hemlock?", "output": "- `exit_code` (i32) - Command's exit status\n\n```hemlock\nlet result = exec(\"echo 'Hello World'\");\nprint(result.output);        // \"Hello World\\n\"\nprint(result.exit_code);     // 0\n\n// Check exit code\nlet result2 = exec(\"grep pattern file.txt\");\nif (result2.exit_code == 0) {\n    print(\"Found: \" + result2.output);\n} else {\n    print(\"Pattern not found\");\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does stack operations work in Hemlock?", "output": "**`pop()`** - Remove and return last element:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // Returns 5, arr is now [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does comparison methods work in Hemlock?", "output": "Check if this DateTime is after another.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 20, 0, 0, 0);\nlet dt2 = from_date(2025, 1, 15, 0, 0, 0);\n\nif (dt1.is_after(dt2)) {\n    print(\"dt1 is after dt2\");  // This will print\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does array manipulation work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does test organization work in Hemlock?", "output": "2. **Descriptive suite names:**\n\n```hemlock\ndescribe(\"HashMap.set() method\", fn() { ... });\ndescribe(\"TcpListener connection handling\", fn() { ... });\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does basic syntax work in Hemlock?", "output": "```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test time builtins\n\n// now() returns a timestamp\nlet t = now();\nprint(t > 0);\n\n// time_ms() returns milliseconds\nlet ms = time_ms();\nprint(ms > 0);\n\n// clock() returns CPU time\nlet c = clock();\nprint(c >= 0.0);\n\n// Test sleep with tiny duration (0.001 seconds = 1ms)\nlet before = time_ms();\nsleep(0.001);\nlet after = time_ms();\n// After should be >= before (sleep may wake up early)\nprint(after >= before);\n\nprint(\"done\");\n```", "output": "true\ntrue\ntrue\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/time_builtins.hml"}
{"instruction": "How does writing work in Hemlock?", "output": "**Returns:** Number of bytes written (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Create binary data\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Wrote \" + typeof(bytes) + \" bytes\");\n\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does memory leaks work in Hemlock?", "output": "**Prevention:** Always pair `alloc()` with `free()`:\n\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... use p\n    } finally {\n        free(p);  // Always freed\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does round(x) work in Hemlock?", "output": "**Returns:** `f64` - Rounded value\n\n```hemlock\nimport { round } from \"@stdlib/math\";\n\nlet result = round(3.5);   // 4.0\nlet result2 = round(3.4);  // 3.0\nlet result3 = round(-2.5); // -3.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does prefix & suffix work in Hemlock?", "output": "```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does try/catch/finally work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n} finally {\n    // cleanup\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does declare external function work in Hemlock?", "output": "```hemlock\nextern fn function_name(param: type): return_type;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show an example of example: adding a new operator in Hemlock.", "output": "```hemlock\n**4. Parser (parser.c):**\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does terminal dashboard work in Hemlock?", "output": "```hemlock\nimport { clear, move_to, color, GREEN, YELLOW, RED, size } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nfn dashboard(): null {\n    let running = true;\n    let counter = 0;\n\n    while (running && counter < 50) {\n        clear();\n\n        let term = size();\n\n        // Title\n        exec(\"printf '\" + move_to(1, 1) + \"'\");\n        print(color(\"=== System Dashboard ===\", GREEN));\n\n        // Stats\n        print(\"\");\n        print(\"Counter: \" + typeof(counter));\n        print(\"Terminal: \" + typeof(term.rows) + \"x\" + typeof(term.cols));\n\n        // Status indicators\n        if (counter % 2 == 0) {\n            print(color(\"â— Service A: Running\", GREEN));\n        } else {\n            print(color(\"â— Service A: Idle\", YELLOW));\n        }\n\n        if (counter % 3 == 0) {\n            print(color(\"â— Service B: Active\", GREEN));\n        } else {\n            print(color(\"â— Service B: Waiting\", RED));\n        }\n\n        sleep(0.5);\n        counter = counter + 1;\n    }\n\n    return null;\n}\n\ndashboard();\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does dot notation work in Hemlock?", "output": "```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// Read field\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// Modify field\nperson.age = 31;\nprint(person.age);           // 31\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does dynamic field addition work in Hemlock?", "output": "Add new fields at runtime:\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// Add new field\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does seeking work in Hemlock?", "output": "```hemlock\nfile.seek(position: i32): i32\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does try/finally work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} finally {\n    // always runs\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does expected output methods work in Hemlock?", "output": "**Method 1: Inline comments (recommended for simple tests)**\n\n```hemlock\nprint(\"hello\");  // Expect: hello\nprint(42);       // Expect: 42\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How do you use pattern: safe buffer usage in Hemlock?", "output": "Prefer buffers for bounds-checked access:\n\n```hemlock\nlet buf = buffer(256);\n\n// Safe iteration\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "What is the Hemlock syntax for demonstrate all Hemlock types?", "output": "```hemlock\nlet a: i8 = -128;\nlet b: i16 = 30000;\nlet c: i32 = 2000000;\nlet d: u8 = 255;\nlet e: u16 = 65535;\nlet f: u32 = 100000;\nlet g: f32 = 3.14;\nlet h: f64 = 2.71828;\n\nprint(a);\nprint(b);\nprint(c);\nprint(d);\nprint(e);\nprint(f);\nprint(g);\nprint(h);\n```", "category": "examples", "source": "examples/alltypes.hml"}
{"instruction": "How does spawn work in Hemlock?", "output": "```hemlock\nspawn(async_fn: function, ...args): task\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does safe pattern work in Hemlock?", "output": "```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... process content ...\n} catch (e) {\n    print(\"Error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does is_alnum(str) work in Hemlock?", "output": "**Common use case - validating identifiers:**\n\n```hemlock\nimport { is_alnum } from \"@stdlib/strings\";\n\nfn is_valid_identifier(name: string): bool {\n    if (name.length == 0) {\n        return false;\n    }\n    // First char must be alpha, rest can be alnum\n    let first = name.slice(0, 1);\n    if (!is_alpha(first)) {\n        return false;\n    }\n    return is_alnum(name);\n}\n\nprint(is_valid_identifier(\"myVar123\"));  // true\nprint(is_valid_identifier(\"123var\"));    // false\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test logical operators\nprint(true && true);\nprint(true && false);\nprint(false && true);\nprint(false && false);\n\nprint(true || true);\nprint(true || false);\nprint(false || true);\nprint(false || false);\n\nprint(!true);\nprint(!false);\n\n// Combined\nlet x = 10;\nlet y = 5;\nprint(x > 5 && y < 10);\nprint(x < 5 || y < 10);\n```", "output": "true\nfalse\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue", "category": "tests/compiler", "source": "tests/compiler/logical.hml"}
{"instruction": "How does repetition work in Hemlock?", "output": "**`repeat(count)`** - Repeat string n times:\n\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does throw work in Hemlock?", "output": "```hemlock\nif (x < 0) {\n    throw \"x must be positive\";\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does shared libraries work in Hemlock?", "output": "**Linux:** `.so` files\n\n```hemlock\nlibexample.so\n/usr/lib/libm.so\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does numeric comparisons work in Hemlock?", "output": "Check if actual >= or <= value.\n\n```hemlock\ntest(\"comparisons\", fn() {\n    expect(10).to_be_greater_than_or_equal(10);\n    expect(10).to_be_greater_than_or_equal(5);\n\n    expect(5).to_be_less_than_or_equal(5);\n    expect(5).to_be_less_than_or_equal(10);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does periodic task execution work in Hemlock?", "output": "```hemlock\nimport { now, sleep } from \"@stdlib/time\";\n\nfn run_periodic(task: function, interval_seconds: i32, duration_seconds: i32): null {\n    let start_time = now();\n    let next_run = start_time;\n\n    while (now() - start_time < duration_seconds) {\n        if (now() >= next_run) {\n            task();\n            next_run = next_run + interval_seconds;\n        }\n        sleep(0.1);  // Check every 100ms\n    }\n\n    return null;\n}\n\n// Run task every 5 seconds for 30 seconds\nrun_periodic(fn() {\n    print(\"Task executed at \" + typeof(now()));\n}, 5, 30);\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does cpu_count() work in Hemlock?", "output": "- System resource reporting\n\n```hemlock\nimport { cpu_count } from \"@stdlib/os\";\n\nlet cores = cpu_count();\nprint(\"CPU cores: \" + typeof(cores));  // e.g., 8\n\n// Size thread pool based on available cores\nlet worker_count = cores - 1;  // Leave one for main thread\nif (worker_count < 1) {\n    worker_count = 1;\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does typeof work in Hemlock?", "output": "```hemlock\ntypeof(value: any): string\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does `logger.close()` work in Hemlock?", "output": "**Best Practice:** Always close file loggers to prevent resource leaks:\n\n```hemlock\nlet logger = Logger({ output: \"app.log\" });\ndefer logger.close();  // Automatic cleanup\n\n// ... use logger ...\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does seeking work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0 (at start)\n\nf.read(100);\nprint(f.tell());        // 100 (after reading)\n\nf.seek(50);\nprint(f.tell());        // 50 (after seeking)\n\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does `waitpid(pid: i32, options: i32): object` work in Hemlock?", "output": "**Returns:** Same as `wait()`\n\n```hemlock\nlet child_pid = fork();\n\nif (child_pid == 0) {\n    // Child work\n    exit(0);\n} else {\n    // Wait for specific child\n    let result = waitpid(child_pid, 0);\n    print(\"Child exited: \" + typeof(result.status));\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does simple timer class work in Hemlock?", "output": "```hemlock\nimport { time_ms } from \"@stdlib/time\";\n\nfn Timer() {\n    let start_time = 0;\n    let is_running = false;\n\n    return {\n        start: fn() {\n            start_time = time_ms();\n            is_running = true;\n            return null;\n        },\n\n        stop: fn(): i64 {\n            if (!is_running) {\n                return 0;\n            }\n            let elapsed = time_ms() - start_time;\n            is_running = false;\n            return elapsed;\n        },\n\n        elapsed: fn(): i64 {\n            if (!is_running) {\n                return 0;\n            }\n            return time_ms() - start_time;\n        },\n\n        reset: fn() {\n            start_time = time_ms();\n            return null;\n        }\n    };\n}\n\n// Usage\nlet timer = Timer();\ntimer.start();\n\n// ... do work ...\n\nprint(\"Elapsed so far: \" + typeof(timer.elapsed()) + \"ms\");\n\n// ... more work ...\n\nlet total = timer.stop();\nprint(\"Total time: \" + typeof(total) + \"ms\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does pattern: memoization work in Hemlock?", "output": "```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // Much faster with caching\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does v0.2 - compiler backend work in Hemlock?", "output": "**Planned architecture:**\n\n```hemlock\nHemlock Source â†’ Lexer â†’ Parser â†’ AST â†’ C Code Generator â†’ C Compiler â†’ Binary\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "How does print_color(text, code) work in Hemlock?", "output": "```hemlock\nimport { print_color, RED, GREEN, BLUE } from \"@stdlib/terminal\";\n\nprint_color(\"Error message\", RED);\nprint_color(\"Success!\", GREEN);\nprint_color(\"Information\", BLUE);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does concatenation work in Hemlock?", "output": "```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + 'âœ“';      // \"Textâœ“\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Show how to manipulate strings in Hemlock.", "output": "```hemlock\nlet name = \"alice\";\nprint(name);\nprint(name.length);\n\nname[0] = 65;\nprint(name);\n\nlet i = 0;\nwhile (i < name.length) {\n    print(name[i]);\n    i = i + 1;\n}\n```", "category": "examples", "source": "examples/string_manip.hml"}
{"instruction": "How does sending messages work in Hemlock?", "output": "```hemlock\nlet data = buffer(10);\ndata[0] = 72;  // 'H'\ndata[1] = 105; // 'i'\n\nlet success = ws.send_binary(data);\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does resolve work in Hemlock?", "output": "Resolves hostname to IPv4 address.\n\n```hemlock\nimport { resolve } from \"@stdlib/net\";\n\nlet ip = resolve(\"localhost\");      // \"127.0.0.1\"\nlet ip2 = resolve(\"example.com\");   // \"93.184.216.34\"\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does âŒ don't hide complexity work in Hemlock?", "output": "```hemlock\n// BAD: Magic behind-the-scenes optimization\nlet arr = [1, 2, 3]  // Is this stack or heap? User should know!\n\n// BAD: Automatic reference counting\nlet p = create_thing()  // Does this increment a refcount? NO!\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does pattern: reduce (fold) work in Hemlock?", "output": "```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does tarreader(data) -> object work in Hemlock?", "output": "```hemlock\nimport { TarReader, TAR_TYPE_FILE, TAR_TYPE_DIRECTORY } from \"@stdlib/compression\";\n\n// Read tar file\nlet f = open(\"archive.tar\", \"r\");\nlet content = f.read();\nf.close();\n\n// Convert to buffer\nlet bytes = content.bytes();\nlet buf = buffer(bytes.length);\nlet i = 0;\nwhile (i < bytes.length) {\n    buf[i] = bytes[i];\n    i = i + 1;\n}\n\n// Parse archive\nlet reader = TarReader(buf);\n\n// List contents\nprint(\"Files in archive:\");\nlet names = reader.list();\ni = 0;\nwhile (i < names.length) {\n    print(\"  \" + names[i]);\n    i = i + 1;\n}\n\n// Get specific file\nlet readme = reader.get(\"myproject/README.md\");\nif (readme != null) {\n    print(\"README content:\");\n    print(readme.content);\n}\n\n// Iterate all entries\nlet entries = reader.entries();\ni = 0;\nwhile (i < entries.length) {\n    let entry = entries[i];\n    if (entry.type == TAR_TYPE_FILE) {\n        print(\"File: \" + entry.name + \" (\" + typeof(entry.size) + \" bytes)\");\n    } else if (entry.type == TAR_TYPE_DIRECTORY) {\n        print(\"Dir: \" + entry.name);\n    }\n    i = i + 1;\n}\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does binary bitwise work in Hemlock?", "output": "```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does pattern: multiple error types work in Hemlock?", "output": "Use error objects to distinguish error types:\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Data is null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Expected array\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array is empty\" };\n    }\n\n    // ... process\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"No data provided\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Wrong data type: \" + e.message);\n    } else {\n        print(\"Error: \" + e.message);\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does re-throwing work in Hemlock?", "output": "Catch and re-throw errors:\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logging error: \" + e);\n        throw e;  // Re-throw to caller\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Caught in main: \" + e);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does optional fields work in Hemlock?", "output": "Fields can be optional with default values:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Optional with default value\n    nickname?: string,   // Optional, defaults to null\n}\n\n// Object with only required fields\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (default applied)\nprint(typed_p.nickname);  // null (no default)\n\n// Can override optional fields\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (overridden)\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does buffer (safe buffer) work in Hemlock?", "output": "```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Bounds checked\nprint(b.length);        // 64\nfree(b);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does what reference counting handles work in Hemlock?", "output": "2. **Scopes exit** - local variables are released:\n\n```hemlock\nfn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // arr released when function returns\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does c code style work in Hemlock?", "output": "char * string;  // Avoid\n\n```hemlock\n**Naming conventions:**\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does 4. help message work in Hemlock?", "output": "```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show this help message\");\n    print(\"  -v, --verbose  Enable verbose output\");\n} else {\n    // Process normally\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does async_remove_dir work in Hemlock?", "output": "```hemlock\nasync_remove_dir(path: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does append_file(path, content) work in Hemlock?", "output": "**Throws:** Exception if file cannot be written\n\n```hemlock\nimport { append_file } from \"@stdlib/fs\";\n\ntry {\n    append_file(\"log.txt\", \"New log entry\\n\");\n    append_file(\"log.txt\", \"Another entry\\n\");\n    print(\"Log entries appended\");\n} catch (e) {\n    print(\"Error appending to file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does array literals work in Hemlock?", "output": "```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];\nlet empty = [];\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does pitfall: recursion depth work in Hemlock?", "output": "```hemlock\n// Deep recursion may cause stack overflow\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // May crash with stack overflow\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does command substitution work in Hemlock?", "output": "```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // Current date\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does parse_address work in Hemlock?", "output": "**Note:** Current implementation returns placeholder port value. Future versions will properly parse port numbers.\n\n```hemlock\nimport { parse_address } from \"@stdlib/net\";\n\nlet parts = parse_address(\"example.com:8080\");\nif (parts != null) {\n    print(\"Host: \" + parts.host);\n    print(\"Port: \" + typeof(parts.port));\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does print_styled(text, style) work in Hemlock?", "output": "```hemlock\nimport { print_styled, BOLD, UNDERLINE, ITALIC } from \"@stdlib/terminal\";\n\nprint_styled(\"Important!\", BOLD);\nprint_styled(\"Emphasized\", UNDERLINE);\nprint_styled(\"Note\", ITALIC);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does is_macos() work in Hemlock?", "output": "**Returns:** `bool` - `true` if on macOS, `false` otherwise\n\n```hemlock\nimport { is_macos } from \"@stdlib/os\";\n\nif (is_macos()) {\n    print(\"macOS-specific code here\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does async functions work in Hemlock?", "output": "```hemlock\nasync fn function_name(params): return_type {\n    // body\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does copy_files_parallel work in Hemlock?", "output": "```hemlock\nimport { copy_files_parallel } from \"@stdlib/async_fs\";\n\nlet copies = [\n    { src: \"file1.txt\", dst: \"backup/file1.txt\" },\n    { src: \"file2.txt\", dst: \"backup/file2.txt\" },\n    { src: \"file3.txt\", dst: \"backup/file3.txt\" }\n];\n\ncopy_files_parallel(copies);\nprint(\"All files copied\");\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does talloc work in Hemlock?", "output": "```hemlock\ntalloc(type, count: i32): ptr\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does inf work in Hemlock?", "output": "Positive infinity (IEEE 754 floating point infinity)\n\n```hemlock\nimport { INF } from \"@stdlib/math\";\nlet max_value = INF;\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does menu system work in Hemlock?", "output": "```hemlock\nimport { clear, print_at, color, GREEN, YELLOW, RESET } from \"@stdlib/terminal\";\n\nfn show_menu(options: array, selected: i32): null {\n    clear();\n\n    print(\"=== Menu ===\");\n    print(\"\");\n\n    let i = 0;\n    while (i < options.length) {\n        if (i == selected) {\n            print(GREEN + \"> \" + options[i] + RESET);\n        } else {\n            print(\"  \" + options[i]);\n        }\n        i = i + 1;\n    }\n\n    return null;\n}\n\nlet menu_items = [\"Start\", \"Settings\", \"About\", \"Exit\"];\nshow_menu(menu_items, 1);  // Highlight \"Settings\"\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does async_write_file work in Hemlock?", "output": "```hemlock\nimport { async_write_file } from \"@stdlib/async_fs\";\n\nlet future = async_write_file(\"output.txt\", \"Hello, World!\");\nfuture.get();  // Wait for write to complete\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test arithmetic operations\nlet a = 10;\nlet b = 3;\n\nprint(a + b);\nprint(a - b);\nprint(a * b);\nprint(a / b);\n\n// Negative numbers\nprint(-5 + 2);\nprint(10 - 15);\n\n// Complex expressions\nprint((a + b) * 2);\nprint(a + b * 2);\n```", "output": "13\n7\n30\n3.33333\n-3\n-5\n26\n16", "category": "tests/compiler", "source": "tests/compiler/arithmetic.hml"}
{"instruction": "How does future: project manifests work in Hemlock?", "output": "A future release may introduce optional project manifests for version constraints:\n\n```hemlock\n// Hypothetical project.hml\ndefine Project {\n    name: \"my-app\",\n    version: \"1.0.0\",\n    hemlock: \">=1.1.0\"\n}\n```", "category": "docs", "source": "docs/versioning.md"}
{"instruction": "How does multi-byte utf-8 characters work in Hemlock?", "output": "Runes can represent any Unicode character:\n\n```hemlock\n// Emoji\nlet rocket = 'ðŸš€';      // Emoji (U+1F680)\nlet heart = 'â¤';        // Heart (U+2764)\nlet smile = 'ðŸ˜€';       // Grinning face (U+1F600)\n\n// CJK characters\nlet chinese = 'ä¸­';     // Chinese (U+4E2D)\nlet japanese = 'ã‚';    // Hiragana (U+3042)\nlet korean = 'í•œ';      // Hangul (U+D55C)\n\n// Symbols\nlet check = 'âœ“';        // Checkmark (U+2713)\nlet arrow = 'â†’';        // Rightwards arrow (U+2192)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "What is the Hemlock syntax for test type operations?", "output": "```hemlock\nlet a: i32 = 42;\nlet b: u8 = 255;\nlet c: byte = 65;\nlet d: f64 = 3.14159;\nlet e: number = 2.71828;\nlet f: integer = 100;\n\nprint(a);\nprint(b);\nprint(c);\nprint(d);\nprint(e);\nprint(f);\n```", "category": "examples", "source": "examples/types_test.hml"}
{"instruction": "How does memory_info() work in Hemlock?", "output": "**Returns:** `object` - Object with total, free, and used memory in bytes\n\n```hemlock\nimport { memory_info, format_bytes } from \"@stdlib/os\";\n\nlet mem = memory_info();\n\nprint(\"Total: \" + format_bytes(mem.total));\nprint(\"Free: \" + format_bytes(mem.free));\nprint(\"Used: \" + format_bytes(mem.used));\n\n// Calculate usage percentage\nlet usage = (mem.used * 100) / mem.total;\nprint(\"Usage: \" + typeof(usage) + \"%\");\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does numeric types work in Hemlock?", "output": "```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// Type alias\nlet x: number = 2.718;  // Same as f64\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "**`find(needle)`** - Find first occurrence:\n\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6 (index of first occurrence)\nlet pos2 = s.find(\"foo\");       // -1 (not found)\nlet pos3 = s.find(\"l\");         // 2 (first 'l')\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does convenience functions work in Hemlock?", "output": "```hemlock\nimport { debug, info, warn, error, log } from \"@stdlib/logging\";\nimport { DEBUG } from \"@stdlib/logging\";\n\n// These use the default logger internally\ndebug(\"Debug message\");\ninfo(\"Info message\");\nwarn(\"Warning message\");\nerror(\"Error message\");\nlog(DEBUG, \"Custom level\");\n\n// With structured data\ninfo(\"User action\", { action: \"click\", button: \"submit\" });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test objects\n\nlet obj = { name: \"Alice\", age: 30 };\nprint(obj.name);\nprint(obj.age);\n\n// Modification\nobj.age = 31;\nprint(obj.age);\n\n// Add new field\nobj.city = \"NYC\";\nprint(obj.city);\n\n// Nested objects\nlet data = {\n    user: {\n        profile: {\n            email: \"test@example.com\"\n        }\n    }\n};\nprint(data.user.profile.email);\n\n// Object with method\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n        return self.count;\n    }\n};\n\nprint(counter.increment());\nprint(counter.increment());\nprint(counter.count);\n\nprint(\"done\");\n```", "output": "Alice\n30\n31\nNYC\ntest@example.com\n1\n2\n2\ndone", "category": "parity/language", "source": "tests/parity/language/objects.hml"}
{"instruction": "How does preserve cursor position work in Hemlock?", "output": "```hemlock\nimport { SAVE_CURSOR, RESTORE_CURSOR } from \"@stdlib/terminal\";\n\nexec(\"printf '\" + SAVE_CURSOR + \"'\");\n\n// ... print status at specific location ...\n\nexec(\"printf '\" + RESTORE_CURSOR + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does seeking work in Hemlock?", "output": "**Example - Measuring read amount:**\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet start = f.tell();\nlet content = f.read();\nlet end = f.tell();\n\nlet bytes_read = end - start;\nprint(\"Read \" + typeof(bytes_read) + \" bytes\");\n\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does pitfall: forgetting cleanup work in Hemlock?", "output": "```hemlock\n// BAD: File may not be closed on error\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // May throw\n    file.close();  // Never reached if error\n}\n\n// GOOD: Use finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does container assertions work in Hemlock?", "output": "Check if array or string contains value.\n\n```hemlock\ntest(\"contain checks\", fn() {\n    // Arrays\n    expect([1, 2, 3]).to_contain(2);\n    expect([1, 2, 3]).not_to_contain(5);\n\n    // Strings\n    expect(\"hello world\").to_contain(\"world\");\n    expect(\"hello\").not_to_contain(\"goodbye\");\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does `wait(): object` work in Hemlock?", "output": "- `status` (i32) - Exit status of the child\n\n```hemlock\nlet result = wait();\nprint(\"Child \" + typeof(result.pid) + \" exited with status: \" + typeof(result.status));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does websocketmessage work in Hemlock?", "output": "```hemlock\n{\n    type: string,      // Message type\n    data: string,      // Text data (or null)\n    binary: buffer,    // Binary data (or null)\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does if statements work in Hemlock?", "output": "```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "```hemlock\nstring.contains(needle: string): bool\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does boolean type work in Hemlock?", "output": "```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"working\");\n}\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does while loops work in Hemlock?", "output": "```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(\"Count: \" + typeof(count));\n    count = count + 1;\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does compress(data, level?) -> buffer work in Hemlock?", "output": "```hemlock\nimport { compress, decompress } from \"@stdlib/compression\";\n\nlet original = \"Hello, World! This is a test string to compress.\";\nlet compressed = compress(original);\nprint(\"Compressed size: \" + typeof(compressed.length));\n\nlet restored = decompress(compressed);\nprint(restored);  // \"Hello, World! This is a test string to compress.\"\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does low-level builtins work in Hemlock?", "output": "Convert time components to Unix timestamp.\n\n```hemlock\nimport { mktime } from \"@stdlib/datetime\";\n\nlet components = {\n    year: 2025,\n    month: 1,\n    day: 15,\n    hour: 12,\n    minute: 30,\n    second: 45\n};\n\nlet timestamp = mktime(components);\nprint(\"Timestamp: \" + typeof(timestamp));\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does 4. status reporting work in Hemlock?", "output": "```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" requests handled\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// From shell: kill -USR1 <pid>\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Show an example of complete example: verify file integrity in Hemlock.", "output": "```hemlock\nimport { file_sha256 } from \"@stdlib/hash\";\n\n// Compute checksum of downloaded file\nlet downloaded_file = \"download.zip\";\nlet expected_checksum = \"a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3\";\n\nlet actual_checksum = file_sha256(downloaded_file);\n\nif (actual_checksum == expected_checksum) {\n    print(\"âœ“ File integrity verified!\");\n} else {\n    print(\"âœ— File corrupted or tampered!\");\n    print(\"Expected: \" + expected_checksum);\n    print(\"Actual:   \" + actual_checksum);\n}\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test assert builtin\n\nassert(true);\nassert(1 == 1);\nassert(5 > 3);\nassert(\"hello\" == \"hello\");\n\nlet x = 10;\nassert(x == 10);\n\nprint(\"all assertions passed\");\nprint(\"done\");\n```", "output": "all assertions passed\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/assert.hml"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test channel operations\n\n// Basic channel creation\nlet ch = channel(5);\nprint(typeof(ch));\n\n// Send and receive\nch.send(42);\nch.send(\"hello\");\nch.send(true);\n\nprint(ch.recv());\nprint(ch.recv());\nprint(ch.recv());\n\n// Channel with capacity\nlet bounded = channel(2);\nbounded.send(1);\nbounded.send(2);\nprint(bounded.recv());\nbounded.send(3);\nprint(bounded.recv());\nprint(bounded.recv());\n\n// Channel close\nlet closeable = channel(3);\ncloseable.send(10);\ncloseable.send(20);\ncloseable.close();\nprint(closeable.recv());\nprint(closeable.recv());\n\n// Try recv on closed empty channel\nlet result = closeable.recv();\nprint(result == null ? \"null received\" : result);\n\n// Channel with async\nasync fn producer(ch, count) {\n    for (let i = 0; i < count; i = i + 1) {\n        ch.send(i);\n    }\n    ch.close();\n}\n\nasync fn consumer(ch) {\n    let sum = 0;\n    let val = ch.recv();\n    while (val != null) {\n        sum = sum + val;\n        val = ch.recv();\n    }\n    return sum;\n}\n\nlet commCh = channel(10);\nlet prod = spawn(producer, commCh, 5);\nlet cons = spawn(consumer, commCh);\n\nawait prod;\nlet total = await cons;\nprint(total);\n\n// Multiple values\nlet multi = channel(10);\nfor (let i = 1; i <= 5; i = i + 1) {\n    multi.send(i * 10);\n}\n\nfor (let i = 0; i < 5; i = i + 1) {\n    print(multi.recv());\n}\n\nprint(\"done\");\n```", "output": "channel\n42\nhello\ntrue\n1\n2\n3\n10\n20\nnull received\n10\n10\n20\n30\n40\n50\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/channels.hml"}
{"instruction": "How does return without value work in Hemlock?", "output": "`return;` without a value returns `null`:\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // Returns null\n    }\n    return value * 2;\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All functions include comprehensive error checking:\n\n```hemlock\nimport { base64_encode, base64_decode, hex_decode, url_decode } from \"@stdlib/encoding\";\n\n// Type checking\ntry {\n    base64_encode(123);  // ERROR: not a string\n} catch (e) {\n    print(\"Error: \" + e);  // \"base64_encode() requires string argument\"\n}\n\n// Invalid Base64\ntry {\n    base64_decode(\"ABC\");  // ERROR: not multiple of 4\n} catch (e) {\n    print(\"Error: \" + e);  // \"Invalid Base64 string: length must be multiple of 4\"\n}\n\n// Invalid hex\ntry {\n    hex_decode(\"XYZ\");  // ERROR: invalid characters\n} catch (e) {\n    print(\"Error: \" + e);  // \"Invalid hex string: invalid character\"\n}\n\n// Invalid URL encoding\ntry {\n    url_decode(\"Hello%2\");  // ERROR: incomplete percent sequence\n} catch (e) {\n    print(\"Error: \" + e);  // \"Invalid URL encoding: incomplete percent sequence\"\n}\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test: Basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(e);\n}\n```", "output": "error message", "category": "tests/exceptions", "source": "tests/exceptions/basic_try_catch.hml"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test type mismatch when assigning to typed array\n\nlet arr: array<i32> = [10, 20, 30];\narr[0] = \"wrong\";  // Should error: type mismatch\n```", "output": "Runtime error: Type mismatch in typed array - expected element of specific type", "category": "tests/typed_arrays", "source": "tests/typed_arrays/type_mismatch_assignment_error.hml"}
{"instruction": "How does function composition work in Hemlock?", "output": "```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does progressbar.increment() work in Hemlock?", "output": "Increment progress by one step.\n\n```hemlock\nimport { ProgressBar } from \"@stdlib/terminal\";\n\nlet bar = ProgressBar(10);\nlet i = 0;\nwhile (i < 10) {\n    // ... process item ...\n    bar.increment();\n    i = i + 1;\n}\nbar.finish();\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does array combination work in Hemlock?", "output": "```hemlock\narray.concat(other: array): array\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does logical operators work in Hemlock?", "output": "```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Short-circuit\nif (x != 0 && (10 / x) > 2) {\n    print(\"safe\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"safe\");\n}\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does string type work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (codepoints)\nprint(s.byte_length);   // 5 (bytes)\n\nlet emoji = \"ðŸš€\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nfn compute() {\n    return 42 * 42;\n}\n\nlet future = pool.submit(compute);\nlet result = future.get();  // 1764\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does i/o work in Hemlock?", "output": "```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interrupt detected\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Termination requested\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does formatting methods work in Hemlock?", "output": "Format as \"YYYY-MM-DD\".\n\n```hemlock\nlet dt = from_date(2025, 3, 15, 14, 30, 45);\nprint(dt.to_date_string());  // \"2025-03-15\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Provide a Hemlock example that demonstrates create a WebSocket server.", "output": "```hemlock\n// WebSocket Echo Server Example (libwebsockets version)\n// Demonstrates @stdlib/websocket server with async handling\n// Requires: libwebsockets-dev and compiled lws_wrapper.so (make stdlib)\n\nimport { WebSocketServer } from \"@stdlib/websocket\";\n\nprint(\"=== Hemlock WebSocket Echo Server (libwebsockets) ===\");\nprint(\"\");\n\n// Handler for each client connection\nasync fn handle_client(conn, client_id) {\n    defer conn.close();\n\n    print(\"[Client \" + typeof(client_id) + \"] Connected\");\n\n    let message_count = 0;\n\n    while (true) {\n        // Wait for message (10 second timeout)\n        let msg = conn.recv(10000);\n\n        if (msg == null) {\n            print(\"[Client \" + typeof(client_id) + \"] Timeout or connection closed\");\n            break;\n        }\n\n        if (msg.type == \"close\") {\n            print(\"[Client \" + typeof(client_id) + \"] Close frame received\");\n            break;\n        }\n\n        if (msg.type == \"text\") {\n            message_count = message_count + 1;\n            print(\"[Client \" + typeof(client_id) + \"] Message #\" + typeof(message_count) + \": \" + msg.data);\n\n            // Echo back\n            let echo = \"Echo: \" + msg.data;\n            conn.send_text(echo);\n            print(\"[Client \" + typeof(client_id) + \"] Sent: \" + echo);\n        }\n    }\n\n    print(\"[Client \" + typeof(client_id) + \"] Disconnected (handled \" + typeof(message_count) + \" messages)\");\n}\n\n// Main server\ntry {\n    let host = \"0.0.0.0\";\n    let port = 8080;\n\n    print(\"Starting WebSocket server on \" + host + \":\" + typeof(port));\n    print(\"\");\n\n    let server = WebSocketServer(host, port);\n    defer server.close();\n\n    print(\"âœ“ Server listening!\");\n    print(\"  Connect with: ws://localhost:8080\");\n    print(\"  Press Ctrl+C to stop\");\n    print(\"\");\n\n    let client_id = 0;\n\n    while (true) {\n        print(\"Waiting for client connection...\");\n\n        // Accept new client (blocking)\n        let conn = server.accept(-1);\n\n        if (conn != null) {\n            client_id = client_id + 1;\n            print(\"New client connected! Spawning handler...\");\n\n            // Handle client in separate task\n            spawn(handle_client, conn, client_id);\n        }\n    }\n\n} catch (e) {\n    print(\"\");\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"  - Port 8080 already in use\");\n    print(\"  - lws_wrapper.so not found: Run 'make stdlib'\");\n    print(\"  - libwebsockets not installed: Run 'sudo apt-get install libwebsockets-dev'\");\n    print(\"  - Permission denied (use port > 1024)\");\n}\n\nprint(\"\");\nprint(\"Server stopped\");\n```", "category": "examples", "source": "examples/websocket_server_lws.hml"}
{"instruction": "How does compilation flags work in Hemlock?", "output": "```hemlock\nimport { compile, REG_EXTENDED, REG_ICASE, REG_NEWLINE } from \"@stdlib/regex\";\n\n// Multiple flags using bitwise OR\nlet flags = REG_EXTENDED | REG_ICASE | REG_NEWLINE;\nlet pattern = compile(\"^hello\", flags);\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does format_bytes(bytes) work in Hemlock?", "output": "**Returns:** `string` - Human-readable string (e.g., `\"1024 KB\"`, `\"2 GB\"`)\n\n```hemlock\nimport { format_bytes } from \"@stdlib/os\";\n\nprint(format_bytes(1024));           // \"1 KB\"\nprint(format_bytes(1048576));        // \"1 MB\"\nprint(format_bytes(1073741824));     // \"1 GB\"\nprint(format_bytes(1099511627776));  // \"1 TB\"\nprint(format_bytes(500));            // \"500 B\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does type definitions work in Hemlock?", "output": "```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does loading spinner work in Hemlock?", "output": "```hemlock\nimport { Spinner, SPINNER_DOTS } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nfn load_data(): null {\n    let spinner = Spinner(SPINNER_DOTS());\n\n    let i = 0;\n    while (i < 100) {\n        spinner.spin();\n        sleep(0.05);\n        // ... actual loading work ...\n        i = i + 1;\n    }\n\n    spinner.finish(\"Data loaded successfully!\");\n    return null;\n}\n\nload_data();\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does always present work in Hemlock?", "output": "`args` is a global array available in **all** Hemlock programs:\n\n```hemlock\n// No need to declare or import\nprint(args.length);  // Works immediately\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test JSON serialization and deserialization\n\n// Basic object serialization\nlet obj = { x: 10, y: 20 };\nlet json = obj.serialize();\nprint(json);\n\n// Deserialize back\nlet restored = json.deserialize();\nprint(restored.x);\nprint(restored.y);\n\n// Nested object\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nlet json2 = nested.serialize();\nprint(json2);\n\n// Object with array\nlet with_arr = { items: [1, 2, 3] };\nprint(with_arr.serialize());\n\n// Round-trip\nlet data = { name: \"test\", values: [1, 2, 3] };\nlet roundtrip = data.serialize().deserialize();\nprint(roundtrip.name);\nprint(roundtrip.values[1]);\n\nprint(\"done\");\n```", "output": "{\"x\":10,\"y\":20}\n10\n20\n{\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n{\"items\":[1,2,3]}\ntest\n2\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/serialization.hml"}
{"instruction": "How does alloc work in Hemlock?", "output": "```hemlock\nlet p = alloc(1024);        // Allocate 1KB\nmemset(p, 0, 1024);         // Initialize to zero\nfree(p);                    // Free when done\n\n// Allocate for structure\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does path access work in Hemlock?", "output": "Check if path exists in object.\n\n```hemlock\nimport { has } from \"@stdlib/json\";\n\nlet doc = { user: { name: \"Alice\", age: 30 } };\n\nprint(has(doc, \"user.name\"));  // true\nprint(has(doc, \"user.email\"));  // false\nprint(has(doc, \"items\"));  // false\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does array transformation work in Hemlock?", "output": "```hemlock\n// Filter (manual)\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// Map (manual)\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "**2. Interactive commands:**\n\n```hemlock\n// Bad - cannot provide input\nlet r = exec(\"ssh user@host\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does complex expressions work in Hemlock?", "output": "```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// Evaluation: b * c â†’ f64(60.0)\n//             a + f64(60.0) â†’ f64(70.0)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does utility operations work in Hemlock?", "output": "**`clear()`** - Remove all elements:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does pitfall: reference equality work in Hemlock?", "output": "```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// Same reference: true\narr.contains(obj);  // true\n\n// Different reference: false\narr.contains({ x: 10 });  // false (different object)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Show an example of complete aes example in Hemlock.", "output": "```hemlock\nKey: f3a8b2c7d4e1f9... (64 hex chars)\nIV:  9e4d3c2b1a0f8e... (32 hex chars)\nEncrypted (32 bytes): 7a2f4c8d3b1e...\nDecrypted: This is a secret message!\nâœ“ Encryption/decryption successful!\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test string methods\n\nlet s = \"hello world\";\n\n// Length\nprint(s.length);\n\n// Substring and slice\nprint(s.substr(0, 5));\nprint(s.slice(6, 11));\n\n// Find and contains\nprint(s.find(\"world\"));\nprint(s.contains(\"hello\"));\nprint(s.contains(\"xyz\"));\n\n// Case conversion\nprint(s.to_upper());\nprint(s.to_lower());\n\n// Trim\nlet padded = \"  trimmed  \";\nprint(padded.trim());\n\n// Split\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");\nprint(parts[0]);\nprint(parts[1]);\nprint(parts[2]);\nprint(parts.length);\n\n// Starts/ends with\nprint(s.starts_with(\"hello\"));\nprint(s.ends_with(\"world\"));\n\n// Replace\nprint(s.replace(\"world\", \"there\"));\nprint(\"foo foo foo\".replace_all(\"foo\", \"bar\"));\n\n// Repeat\nprint(\"ab\".repeat(3));\n\nprint(\"done\");\n```", "output": "11\nhello\nworld\n6\ntrue\nfalse\nHELLO WORLD\nhello world\ntrimmed\na\nb\nc\n3\ntrue\ntrue\nhello there\nbar bar bar\nababab\ndone", "category": "parity/methods", "source": "tests/parity/methods/string_methods.hml"}
{"instruction": "How does convenience functions work in Hemlock?", "output": "Pre-configured file checksum functions for common use cases:\n\n```hemlock\nimport {\n    file_sha256,\n    file_sha512,\n    file_md5,\n    file_djb2,\n    file_fnv1a,\n    file_murmur3\n} from \"@stdlib/hash\";\n\n// Cryptographic checksums\nlet sha256_sum = file_sha256(\"data.txt\");\nlet sha512_sum = file_sha512(\"important.pdf\");\nlet md5_sum = file_md5(\"legacy.zip\");  // Legacy only!\n\n// Fast non-crypto checksums\nlet fast_sum = file_djb2(\"config.json\");\nlet better_sum = file_murmur3(\"database.db\");\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does closure scope work in Hemlock?", "output": "Closures capture variables from enclosing scope:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Captures 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does byte access work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// UTF-8 example\nlet emoji = \"ðŸš€\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Show an example of example 7: custom format in Hemlock.", "output": "```hemlock\nimport { Logger } from \"@stdlib/logging\";\n\nlet logger = Logger({\n    format: \"[{level}] {message}\",\n    include_timestamp: false\n});\n\nlogger.info(\"Clean output without timestamp\");\n// Output: [INFO] Clean output without timestamp\n\nlet logger2 = Logger({\n    format: \"{level}: {message}\"\n});\n\nlogger2.warn(\"Custom separator\");\n// Output: WARN: Custom separator\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test optional chaining\n\n// Test with null object\nlet obj = null;\nlet result = obj?.name;\nprint(result);\n\n// Test with non-null object\nlet person = { name: \"Alice\", age: 30 };\nlet name = person?.name;\nprint(name);\n\n// Test chained optional access\nlet data = { user: { profile: { email: \"test@example.com\" } } };\nlet email = data?.user?.profile?.email;\nprint(email);\n\n// Test optional chaining returning null for missing property\nlet empty = {};\nlet missing = empty?.nonexistent;\nprint(missing);\n\n// Test optional indexing with array\nlet arr = [1, 2, 3];\nlet first = arr?.[0];\nprint(first);\n\n// Test optional indexing with null\nlet nullArr = null;\nlet nullResult = nullArr?.[0];\nprint(nullResult);\n\n// Test null coalesce with optional chaining\nlet user = null;\nlet defaultName = user?.name ?? \"default\";\nprint(defaultName);\n\nprint(\"done\");\n```", "output": "null\nAlice\ntest@example.com\nnull\n1\nnull\ndefault\ndone", "category": "tests/compiler", "source": "tests/compiler/optional_chaining.hml"}
{"instruction": "How does .closed work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does retry with exponential backoff work in Hemlock?", "output": "```hemlock\nimport { sleep } from \"@stdlib/time\";\n\nfn retry_with_backoff(operation: function, max_attempts: i32): bool {\n    let attempt = 0;\n    let delay = 0.1;  // Start with 100ms\n\n    while (attempt < max_attempts) {\n        try {\n            operation();\n            return true;  // Success\n        } catch (e) {\n            print(\"Attempt \" + typeof(attempt + 1) + \" failed: \" + e);\n            if (attempt < max_attempts - 1) {\n                print(\"Retrying in \" + typeof(delay) + \"s...\");\n                sleep(delay);\n                delay = delay * 2.0;  // Double delay each time\n            }\n        }\n        attempt = attempt + 1;\n    }\n\n    return false;  // All attempts failed\n}\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does value arguments work in Hemlock?", "output": "```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // Would need to parse string to int\n        }\n    }\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Show an example of example: sorting (bubble sort) in Hemlock.", "output": "```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // Modifies in-place\nprint(numbers);  // [1, 2, 5, 8, 9]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does random access read work in Hemlock?", "output": "```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does nested if statements work in Hemlock?", "output": "```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"single digit positive\");\n    } else {\n        print(\"multi-digit positive\");\n    }\n} else {\n    print(\"non-positive\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does phone number validation work in Hemlock?", "output": "```hemlock\nimport { compile } from \"@stdlib/regex\";\n\nfn validate_phone(phone: string): bool {\n    // Match formats: 555-123-4567 or (555) 123-4567\n    let pattern = compile(\"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\");\n    let valid = pattern.test(phone);\n    pattern.free();\n    return valid;\n}\n\nprint(validate_phone(\"555-123-4567\"));    // true\nprint(validate_phone(\"(555) 123-4567\"));  // true\nprint(validate_phone(\"555.123.4567\"));    // false\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does debugging failed tests work in Hemlock?", "output": "Or add temporary print statements:\n\n```hemlock\ntest(\"complex calculation\", fn() {\n    let x = calculate_something();\n    print(\"x = \" + typeof(x));  // Debug output\n    expect(x).to_equal(expected);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Show an example of example 3: worker pool controller in Hemlock.", "output": "```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Shutting down...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Main loop adjusts worker pool based on worker_count\nwhile (!should_exit) {\n    // Manage workers based on worker_count\n    // ...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test enum comparison\n\nenum Status {\n    OK,\n    ERROR,\n    PENDING\n}\n\nlet status = Status.OK;\n\nif (status == Status.OK) {\n    print(\"Status is OK\");\n}\n\nif (status != Status.ERROR) {\n    print(\"Status is not ERROR\");\n}\n\nlet error = Status.ERROR;\nif (error == Status.ERROR) {\n    print(\"Error status\");\n}\n```", "output": "Status is OK\nStatus is not ERROR\nError status", "category": "tests/enums", "source": "tests/enums/comparison.hml"}
{"instruction": "How does implicit type promotion work in Hemlock?", "output": "```hemlock\nu8 + i32  â†’ i32\ni32 + i64 â†’ i64\nu32 + u64 â†’ u64\ni32 + f32 â†’ f32\ni64 + f64 â†’ f64\ni8 + f64  â†’ f64\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "**4. Real-time streaming:**\n\n```hemlock\n// Bad - cannot process output incrementally\nlet r = exec(\"tail -f /var/log/app.log\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does url helpers work in Hemlock?", "output": "Encode a string for use in URLs.\n\n```hemlock\nimport { url_encode } from \"@stdlib/http\";\n\nlet encoded = url_encode(\"hello world!\");  // \"hello%20world%21\"\nlet url = \"https://api.example.com/search?q=\" + url_encode(\"foo & bar\");\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "**Bitwise AND (`&`)**\n\n```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\nprint(a & b);   // 8 (1000)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does indentation work in Hemlock?", "output": "Hemlock doesn't enforce specific indentation, but 4 spaces is recommended:\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indented\");\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does what reference counting handles work in Hemlock?", "output": "1. **Variables are reassigned** - the old value is released:\n\n```hemlock\nlet x = \"first\";   // ref_count = 1\n   x = \"second\";      // \"first\" released internally, \"second\" ref_count = 1\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does reading lines work in Hemlock?", "output": "```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does username() work in Hemlock?", "output": "- Multi-user applications\n\n```hemlock\nimport { username } from \"@stdlib/os\";\n\nlet user = username();\nprint(\"Current user: \" + user);  // e.g., \"john\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does convenience functions work in Hemlock?", "output": "Fetch a URL and return just the body as a string.\n\n```hemlock\nimport { fetch } from \"@stdlib/http\";\n\nlet html = fetch(\"https://example.com\");\nprint(html);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does 4. use descriptive variable names work in Hemlock?", "output": "```hemlock\n// Good\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// Bad\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does insertion & removal work in Hemlock?", "output": "```hemlock\narray.insert(index: i32, value: any): null\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Show an example of example: nested error handling in Hemlock.", "output": "```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Failed to process user: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Processed: \" + typeof(success_count) + \" success, \" + typeof(error_count) + \" errors\");\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does rgb(r, g, b) work in Hemlock?", "output": "**Returns:** `string` - RGB color code\n\n```hemlock\nimport { rgb, RESET } from \"@stdlib/terminal\";\n\nprint(rgb(255, 100, 50) + \"Custom orange\" + RESET);\nprint(rgb(75, 0, 130) + \"Indigo text\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does methods and `self` work in Hemlock?", "output": "```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does environment-based feature flags work in Hemlock?", "output": "```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nfn is_enabled(feature_name: string): bool {\n    let env_var = \"ENABLE_\" + feature_name.to_upper();\n    let value = getenv(env_var);\n\n    if (value == null) {\n        return false;\n    }\n\n    // Check for truthy values\n    return value == \"1\" || value == \"true\" || value == \"yes\";\n}\n\nif (is_enabled(\"NEW_UI\")) {\n    print(\"Using new UI\");\n} else {\n    print(\"Using legacy UI\");\n}\n\nif (is_enabled(\"BETA_FEATURES\")) {\n    print(\"Beta features enabled\");\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does 3. validate arguments work in Hemlock?", "output": "```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Error: Missing required argument\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Error: Empty argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // exit or show usage\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Show an example of complete client example in Hemlock.", "output": "```hemlock\nimport { WebSocket } from \"@stdlib/websocket\";\n\ntry {\n    let ws = WebSocket(\"wss://secure.example.com/socket\");\n    defer ws.close();\n\n    // Send message\n    ws.send_text(\"Hello!\");\n\n    // Receive response\n    let msg = ws.recv(5000);\n    if (msg != null && msg.type == \"text\") {\n        print(\"Server said: \" + msg.data);\n    }\n\n} catch (e) {\n    print(\"Error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test named imports\nimport { add, multiply, PI } from \"./helper.hml\";\n\n// Test imported function\nlet sum = add(2, 3);\nprint(sum);\n\n// Test another imported function\nlet product = multiply(4, 5);\nprint(product);\n\n// Test imported constant\nprint(PI);\n```", "output": "5\n20\n3.14159", "category": "parity/modules", "source": "tests/parity/modules/named_import.hml"}
{"instruction": "How does is_alpha(str) work in Hemlock?", "output": "**Returns:** `bool` - True if all characters are alphabetic\n\n```hemlock\nimport { is_alpha } from \"@stdlib/strings\";\n\nprint(is_alpha(\"hello\"));         // true\nprint(is_alpha(\"HELLO\"));         // true\nprint(is_alpha(\"HelloWorld\"));    // true\n\nprint(is_alpha(\"hello123\"));      // false\nprint(is_alpha(\"hello world\"));   // false (space)\nprint(is_alpha(\"hello!\"));        // false\nprint(is_alpha(\"\"));              // false (empty)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does pitfall: string byte indexing work in Hemlock?", "output": "```hemlock\n// DON'T: Assume byte indexing\nlet s = \"ðŸš€\";\nlet byte = s.byte_at(0);    // 240 (first UTF-8 byte, not complete char)\n\n// DO: Use codepoint indexing\nlet s = \"ðŸš€\";\nlet rune = s[0];            // 'ðŸš€' (complete character)\nlet rune2 = s.char_at(0);   // 'ðŸš€' (explicit method)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\npool.shutdown(): null\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does array manipulation work in Hemlock?", "output": "```hemlock\narray.reverse(): null\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does pattern: error recovery work in Hemlock?", "output": "Provide fallback on error:\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division by zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Error: \" + e);\n        return null;  // Fallback value\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does join work in Hemlock?", "output": "```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How do you allocate memory in Hemlock?", "output": "Hemlock provides manual memory management:\n\n```hemlock\n// Raw pointer allocation\nlet p = alloc(64);       // allocate 64 bytes\nmemset(p, 0, 64);        // initialize to zero\nfree(p);                 // must free manually\n\n// Safe buffer (bounds checked)\nlet b = buffer(64);\nb[0] = 42;               // bounds checked access\nfree(b);\n\n// Typed allocation\nlet nums = talloc(i32, 10);  // 10 i32 values\nfree(nums);\n```", "category": "concepts/memory", "source": "CLAUDE.md"}
{"instruction": "How does formatting methods work in Hemlock?", "output": "Format as \"HH:MM:SS\".\n\n```hemlock\nlet dt = from_date(2025, 3, 15, 14, 30, 45);\nprint(dt.to_time_string());  // \"14:30:45\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { now, time_ms, sleep, clock } from \"@stdlib/time\";\n\nlet start = time_ms();\n// ... do work ...\nlet elapsed = time_ms() - start;\nprint(\"Elapsed: \" + typeof(elapsed) + \"ms\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does 3. use appropriate modes work in Hemlock?", "output": "```hemlock\n// Reading only? Use \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// Completely replacing? Use \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// Adding to end? Use \"a\"\nlet f = open(\"log.txt\", \"a\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does common leak sources work in Hemlock?", "output": "```hemlock\n**3. Exception paths:**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does known acceptable leaks work in Hemlock?", "output": "**Global built-ins:**\n\n```hemlock\n// Built-in functions, FFI types, and constants are allocated at startup\n// and not freed at exit (typically ~200 bytes)\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does basic pattern work in Hemlock?", "output": "Always close files explicitly:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does unix/linux vs windows work in Hemlock?", "output": "**Cross-platform patterns:**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nfn get_home_directory(): string {\n    // Try Unix first\n    let home = getenv(\"HOME\");\n    if (home != null) {\n        return home;\n    }\n\n    // Fall back to Windows\n    let userprofile = getenv(\"USERPROFILE\");\n    if (userprofile != null) {\n        return userprofile;\n    }\n\n    return \"/tmp\";  // Last resort\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does numeric types work in Hemlock?", "output": "```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Type alias\nlet x: integer = 42;  // Same as i32\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does safe buffer pattern work in Hemlock?", "output": "```hemlock\n// Allocate buffer\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"buffer allocation failed\");\n}\n\n// Use with bounds checking\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Free\nfree(buf);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does core principles work in Hemlock?", "output": "Test both success and failure cases:\n\n```hemlock\n// Success case\nlet x: u8 = 255;  // Should work\n\n// Failure case\nlet y: u8 = 256;  // Should error\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does binary file copy work in Hemlock?", "output": "```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does reading characters work in Hemlock?", "output": "Indexing returns a `rune` (Unicode codepoint):\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H' (rune)\nlet last = s[4];       // 'o' (rune)\n\n// UTF-8 example\nlet emoji = \"HiðŸš€!\";\nlet rocket = emoji[2];  // 'ðŸš€' (rune at codepoint index 2)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does division (always float) work in Hemlock?", "output": "The `/` operator **always returns a float** (f64), regardless of operand types:\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does numeric comparisons work in Hemlock?", "output": "Check if actual > value.\n\n```hemlock\ntest(\"greater than\", fn() {\n    expect(10).to_be_greater_than(5);\n    expect(3.14).to_be_greater_than(3.0);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does range checking work in Hemlock?", "output": "**Valid Assignments:**\n\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does lines(str) work in Hemlock?", "output": "**Use case - processing multi-line input:**\n\n```hemlock\nimport { lines } from \"@stdlib/strings\";\n\nlet text = \"Alice\\nBob\\nCarol\\nDave\";\nlet names = lines(text);\n\nlet i = 0;\nwhile (i < names.length) {\n    print(\"User \" + typeof(i + 1) + \": \" + names[i]);\n    i = i + 1;\n}\n// Output:\n// User 1: Alice\n// User 2: Bob\n// User 3: Carol\n// User 4: Dave\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Explain what this Hemlock code does:\n\n```hemlock\n// Example: Command-line argument handling in Hemlock\n//\n// Usage: ./hemlock examples/cli_args.hml [arguments...]\n//\n// This demonstrates accessing command-line arguments via the 'args' array.\n// args[0] is always the script name, args[1+] are the actual arguments.\n\nprint(\"Hemlock Command-Line Arguments Demo\");\nprint(\"====================================\");\nprint(\"\");\n\n// Convert length to string for concatenation\nlet len_str = \"\";\nif (args.length == 0) { len_str = \"0\"; }\nif (args.length == 1) { len_str = \"1\"; }\nif (args.length == 2) { len_str = \"2\"; }\nif (args.length == 3) { len_str = \"3\"; }\nif (args.length == 4) { len_str = \"4\"; }\nif (args.length == 5) { len_str = \"5\"; }\nif (args.length >= 6) { len_str = \"6+\"; }\nprint(\"Total arguments: \" + len_str);\nprint(\"Script name: \" + args[0]);\nprint(\"\");\n\nif (args.length == 1) {\n    print(\"No command-line arguments provided.\");\n    print(\"Try running: ./hemlock examples/cli_args.hml arg1 arg2 arg3\");\n} else {\n    print(\"Arguments provided:\");\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        i = i + 1;\n    }\n}\n```", "output": "This program handle command-line arguments. Example: Command-line argument handling in Hemlock  Usage: ./hemlock examples/cli_args.hml [arguments...]  This demonstrates accessing command-line arguments via the 'args' array. args[0] is always the script name, args[1+] are the actual arguments.", "category": "examples/explanation", "source": "examples/cli_args.hml"}
{"instruction": "How does http methods work in Hemlock?", "output": "Perform a generic HTTP request with any method.\n\n```hemlock\nlet response = request(\"PATCH\", \"https://api.example.com/users/1\", '{\"name\":\"Charlie\"}', null);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test string interpolation with backticks\n\nlet name = \"Alice\";\nlet age = 30;\n\n// Basic interpolation\nprint(`Hello, ${name}!`);\n\n// Multiple interpolations\nprint(`${name} is ${age} years old.`);\n\n// Expressions\nlet x = 10;\nlet y = 20;\nprint(`Sum: ${x + y}`);\nprint(`Product: ${x * y}`);\n\n// Array access in interpolation\nlet arr = [1, 2, 3];\nprint(`First: ${arr[0]}, Last: ${arr[2]}`);\nprint(`Length: ${arr.length}`);\n\n// Escape sequences\nprint(`Price: \\$100`);\n\nprint(\"done\");\n```", "output": "Hello, Alice!\nAlice is 30 years old.\nSum: 30\nProduct: 200\nFirst: 1, Last: 3\nLength: 3\nPrice: $100\ndone", "category": "parity/language", "source": "tests/parity/language/string_interpolation.hml"}
{"instruction": "How does substring & slicing work in Hemlock?", "output": "**`substr(start, length)`** - Extract substring by position and length:\n\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\" (start at 6, length 5)\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 example\nlet text = \"HiðŸš€!\";\nlet emoji = text.substr(2, 1);  // \"ðŸš€\" (position 2, length 1)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does hide cursor during animations work in Hemlock?", "output": "```hemlock\nimport { HIDE_CURSOR, SHOW_CURSOR, Spinner } from \"@stdlib/terminal\";\n\nexec(\"printf '\" + HIDE_CURSOR + \"'\");\nlet spinner = Spinner();\n\n// ... animation loop ...\n\nspinner.finish();\nexec(\"printf '\" + SHOW_CURSOR + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does export statements work in Hemlock?", "output": "**Inline Named Exports:**\n\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does handling clients work in Hemlock?", "output": "```hemlock\nasync fn handle_client(conn) {\n    defer conn.close();\n\n    while (true) {\n        let msg = conn.recv(30000);  // 30s timeout\n\n        if (msg == null || msg.type == \"close\") {\n            break;\n        }\n\n        if (msg.type == \"text\") {\n            // Echo back\n            conn.send_text(\"Echo: \" + msg.data);\n        }\n    }\n\n    print(\"Client disconnected\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does pitfall: `self` in non-method calls work in Hemlock?", "output": "```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// Works: Called as method\nprint(obj.method());  // 10\n\n// ERROR: Called as function\nlet f = obj.method;\nprint(f());  // ERROR: self is not defined\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does read entire file work in Hemlock?", "output": "```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does basic get request work in Hemlock?", "output": "```hemlock\nimport { get } from \"@stdlib/http\";\n\nlet response = get(\"https://httpbin.org/get\", null);\nprint(\"Status: \" + typeof(response.status_code));\nprint(\"Body: \" + response.body);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "Explain what this Hemlock code does:\n\n```hemlock\n// WebSocket Echo Server Example (libwebsockets version)\n// Demonstrates @stdlib/websocket server with async handling\n// Requires: libwebsockets-dev and compiled lws_wrapper.so (make stdlib)\n\nimport { WebSocketServer } from \"@stdlib/websocket\";\n\nprint(\"=== Hemlock WebSocket Echo Server (libwebsockets) ===\");\nprint(\"\");\n\n// Handler for each client connection\nasync fn handle_client(conn, client_id) {\n    defer conn.close();\n\n    print(\"[Client \" + typeof(client_id) + \"] Connected\");\n\n    let message_count = 0;\n\n    while (true) {\n        // Wait for message (10 second timeout)\n        let msg = conn.recv(10000);\n\n        if (msg == null) {\n            print(\"[Client \" + typeof(client_id) + \"] Timeout or connection closed\");\n            break;\n        }\n\n        if (msg.type == \"close\") {\n            print(\"[Client \" + typeof(client_id) + \"] Close frame received\");\n            break;\n        }\n\n        if (msg.type == \"text\") {\n            message_count = message_count + 1;\n            print(\"[Client \" + typeof(client_id) + \"] Message #\" + typeof(message_count) + \": \" + msg.data);\n\n            // Echo back\n            let echo = \"Echo: \" + msg.data;\n            conn.send_text(echo);\n            print(\"[Client \" + typeof(client_id) + \"] Sent: \" + echo);\n        }\n    }\n\n    print(\"[Client \" + typeof(client_id) + \"] Disconnected (handled \" + typeof(message_count) + \" messages)\");\n}\n\n// Main server\ntry {\n    let host = \"0.0.0.0\";\n    let port = 8080;\n\n    print(\"Starting WebSocket server on \" + host + \":\" + typeof(port));\n    print(\"\");\n\n    let server = WebSocketServer(host, port);\n    defer server.close();\n\n    print(\"âœ“ Server listening!\");\n    print(\"  Connect with: ws://localhost:8080\");\n    print(\"  Press Ctrl+C to stop\");\n    print(\"\");\n\n    let client_id = 0;\n\n    while (true) {\n        print(\"Waiting for client connection...\");\n\n        // Accept new client (blocking)\n        let conn = server.accept(-1);\n\n        if (conn != null) {\n            client_id = client_id + 1;\n            print(\"New client connected! Spawning handler...\");\n\n            // Handle client in separate task\n            spawn(handle_client, conn, client_id);\n        }\n    }\n\n} catch (e) {\n    print(\"\");\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"  - Port 8080 already in use\");\n    print(\"  - lws_wrapper.so not found: Run 'make stdlib'\");\n    print(\"  - libwebsockets not installed: Run 'sudo apt-get install libwebsockets-dev'\");\n    print(\"  - Permission denied (use port > 1024)\");\n}\n\nprint(\"\");\nprint(\"Server stopped\");\n```", "output": "This program create a WebSocket server. WebSocket Echo Server Example (libwebsockets version) Demonstrates @stdlib/websocket server with async handling Requires: libwebsockets-dev and compiled lws_wrapper.so (make stdlib)", "category": "examples/explanation", "source": "examples/websocket_server_lws.hml"}
{"instruction": "How does insertion and removal work in Hemlock?", "output": "**`insert(index, value)`** - Insert element at index:\n\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // Insert 3 at index 2: [1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // Insert at beginning: [0, 1, 2, 3, 4, 5]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does is_unix() work in Hemlock?", "output": "**Returns:** `bool` - `true` if on Linux or macOS, `false` otherwise\n\n```hemlock\nimport { is_unix } from \"@stdlib/os\";\n\nif (is_unix()) {\n    // Use Unix-style paths and commands\n    let config_dir = homedir() + \"/.config/myapp\";\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does lexical scoping work in Hemlock?", "output": "Functions can **read** (not write) outer scope variables:\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // Can read global and outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does convenience constructors work in Hemlock?", "output": "Create a DateTime object for the current time.\n\n```hemlock\nimport { now } from \"@stdlib/datetime\";\n\nlet current = now();\nprint(\"Current time: \" + current.to_string());\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does range checking work in Hemlock?", "output": "Type annotations enforce range checks at assignment:\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // ERROR: out of range for u8\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // ERROR: out of range for i8\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // ERROR: u64 cannot be negative\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does array manipulation work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does safe practices work in Hemlock?", "output": "**2. Use allowlists, not denylists:**\n\n```hemlock\n// Good - strict allowlist\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Invalid command\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does export statements work in Hemlock?", "output": "```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does extraction operations work in Hemlock?", "output": "**`slice(start, end)`** - Extract subarray (end exclusive):\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (indices 1, 2, 3)\nlet first = arr.slice(0, 2); // [1, 2]\n\n// Original unchanged\nprint(arr);                  // [1, 2, 3, 4, 5]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does explicit type conversion work in Hemlock?", "output": "```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32 â†’ f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64 â†’ i32 (3, truncated)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does remove_file(path) work in Hemlock?", "output": "**Throws:** Exception if file doesn't exist or cannot be deleted\n\n```hemlock\nimport { remove_file, exists } from \"@stdlib/fs\";\n\ntry {\n    if (exists(\"temp.txt\")) {\n        remove_file(\"temp.txt\");\n        print(\"File deleted\");\n    }\n} catch (e) {\n    print(\"Error deleting file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does api work in Hemlock?", "output": "```hemlock\nlet map = HashMap();\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test ternary conditional operator\n\n// Basic ternary\nprint(true ? \"yes\" : \"no\");\nprint(false ? \"yes\" : \"no\");\n\n// With variables\nlet a = 10;\nlet b = 5;\nprint(a > b ? \"a is bigger\" : \"b is bigger\");\nprint(a < b ? \"a is smaller\" : \"b is smaller or equal\");\n\n// Nested ternary\nlet x = 5;\nprint(x > 10 ? \"big\" : x > 5 ? \"medium\" : \"small\");\n\nlet y = 15;\nprint(y > 10 ? \"big\" : y > 5 ? \"medium\" : \"small\");\n\n// Ternary with expressions\nlet c = 3;\nlet d = 4;\nprint(c + d > 5 ? c * d : c + d);\n\n// Ternary returning different types\nlet flag = true;\nprint(flag ? 42 : \"not a number\");\n\nlet flag2 = false;\nprint(flag2 ? 42 : \"not a number\");\n\n// Ternary in assignment\nlet result = a > b ? a : b;\nprint(result);\n\n// Ternary with function calls\nfn double(n) { return n * 2; }\nfn triple(n) { return n * 3; }\n\nlet val = 5;\nprint((val > 3 ? double : triple)(val));\n\n// Ternary with null\nlet obj = null;\nprint(obj == null ? \"is null\" : \"not null\");\n\nlet obj2 = { name: \"test\" };\nprint(obj2 == null ? \"is null\" : \"not null\");\n\n// Chained comparisons in ternary\nlet score = 85;\nprint(score >= 90 ? \"A\" : score >= 80 ? \"B\" : score >= 70 ? \"C\" : \"F\");\n\nprint(\"done\");\n```", "output": "yes\nno\na is bigger\nb is smaller or equal\nsmall\nbig\n12\n42\nnot a number\n10\n10\nis null\nnot null\nB\ndone", "category": "parity/language", "source": "tests/parity/language/ternary.hml"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "**Named vs. Anonymous:**\n\n```hemlock\n// These are equivalent:\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does queue operations work in Hemlock?", "output": "```hemlock\narray.unshift(value: any): null\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does operator precedence (complete) work in Hemlock?", "output": "**Use parentheses for clarity:**\n\n```hemlock\n// Unclear\nif (a || b && c) { }\n\n// Clear\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does string methods work in Hemlock?", "output": "```hemlock\nlet text = \"  Hello, World!  \";\n\n// Case conversion\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// Trimming\nprint(text.trim());      // \"Hello, World!\"\n\n// Substring extraction\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// Searching\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// Splitting\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// Replacement\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does character types work in Hemlock?", "output": "**Type Conversions:**\n\n```hemlock\n// Integer to rune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // ðŸš€\n\n// Rune to integer\nlet value: i32 = 'Z';       // 90\n\n// Rune to string\nlet s: string = 'H';        // \"H\"\n\n// u8 to rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does equality assertions work in Hemlock?", "output": "Reference/primitive equality (uses `==` operator).\n\n```hemlock\ntest(\"to_be\", fn() {\n    let x = 10;\n    expect(x).to_be(10);\n\n    let arr = [1, 2, 3];\n    expect(arr).to_be(arr);  // Same reference\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does 1. system libraries work in Hemlock?", "output": "**Memory allocation:**\n\n```hemlock\n// Call malloc/free from libc\nlet ptr = malloc(1024);\nfree(ptr);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does double-free work in Hemlock?", "output": "**Allowed but will crash:**\n\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: Double-free detected\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does arithmetic operators work in Hemlock?", "output": "```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - Addition\nprint(a - b);   // 7  - Subtraction\nprint(a * b);   // 30 - Multiplication\nprint(a / b);   // 3  - Division (integer)\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does pattern: early exit work in Hemlock?", "output": "```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Early exit\n        }\n    }\n    return -1;  // Not found\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does performance testing work in Hemlock?", "output": "Measure execution time:\n\n```hemlock\nimport { time_ms } from \"@stdlib/time\";\n\ntest(\"operation is fast\", fn() {\n    let start = time_ms();\n    expensive_operation();\n    let elapsed = time_ms() - start;\n\n    expect(elapsed).to_be_less_than(1000);  // < 1 second\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does always reset styles work in Hemlock?", "output": "```hemlock\nimport { RED, BOLD, RESET } from \"@stdlib/terminal\";\n\n// Good\nprint(RED + \"Error\" + RESET);\n\n// Bad (affects all subsequent output)\nprint(RED + \"Error\");\nprint(\"This is red too!\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does core functions work in Hemlock?", "output": "Serialize value and write to file (compact format).\n\n```hemlock\nimport { stringify_file } from \"@stdlib/json\";\n\nlet data = { users: [{ name: \"Alice\" }, { name: \"Bob\" }] };\nstringify_file(\"output.json\", data);\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does `fork(): i32` work in Hemlock?", "output": "- Child's PID in the parent process\n\n```hemlock\nlet pid = fork();\n\nif (pid == 0) {\n    // Child process\n    print(\"I'm the child!\");\n    exit(0);\n} else {\n    // Parent process\n    print(\"Child PID: \" + typeof(pid));\n    let result = waitpid(pid, 0);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does multiple requests work in Hemlock?", "output": "```hemlock\nimport { get_json } from \"@stdlib/http\";\n\n// Fetch multiple users\nlet i = 1;\nwhile (i <= 3) {\n    let user = get_json(\"https://jsonplaceholder.typicode.com/users/\" + typeof(i));\n    print(typeof(i) + \". \" + user.name + \" (\" + user.email + \")\");\n    i = i + 1;\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does queue operations work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does tcplistener work in Hemlock?", "output": "Blocks until a client connects, returns TcpStream for the connection.\n\n```hemlock\nlet stream = listener.accept();\ndefer stream.close();\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does acos(x) work in Hemlock?", "output": "**Returns:** `f64` - Arc cosine in range [0, Ï€]\n\n```hemlock\nimport { acos, PI } from \"@stdlib/math\";\n\nlet angle = acos(0.0);   // Ï€/2\nlet angle2 = acos(1.0);  // 0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does memory management work in Hemlock?", "output": "```hemlock\n// Safe buffer (recommended)\nlet buf = buffer(64);\nbuf[0] = 65;\nfree(buf);\n\n// Raw pointer (for experts)\nlet ptr = alloc(64);\nmemset(ptr, 0, 64);\nfree(ptr);\n```", "category": "docs", "source": "docs/README.md"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "**`char_at(index)`** - Get Unicode codepoint at index (returns rune):\n\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h' (rune)\n\n// UTF-8 example\nlet emoji = \"ðŸš€\";\nlet rocket = emoji.char_at(0);  // Returns rune U+1F680\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does configuration reload on signal work in Hemlock?", "output": "```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Reloading configuration...\");\n    config = load_config();\n    print(\"Configuration reloaded\");\n}\n\nsignal(SIGHUP, reload_config);  // Reload on SIGHUP\n\n// Send SIGHUP to process to reload config\n// From shell: kill -HUP <pid>\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does async_append_file work in Hemlock?", "output": "```hemlock\nasync_append_file(path: string, content: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does buffer work in Hemlock?", "output": "```hemlock\nbuffer(size: i32): buffer\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Show an example of example 4: using parentheses in Hemlock.", "output": "```hemlock\n// Without parentheses\nlet a = 2 + 3 * 4;        // 14\n\n// With parentheses\nlet b = (2 + 3) * 4;      // 20\n\n// Complex expression\nlet c = (a + b) * (a - b);\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does float literals work in Hemlock?", "output": "```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;  // Not yet supported\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does type annotations work in Hemlock?", "output": "While types are inferred by default, you can be explicit:\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Show an example of example 1: interrupt handler with cleanup in Hemlock.", "output": "```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// Register handlers\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// Simulate some work\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // Trigger SIGUSR1 every 10 iterations\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet future = pool.submit2(add, 10, 20);\nlet result = future.get();  // 30\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does alloc work in Hemlock?", "output": "```hemlock\nalloc(size: i32): ptr\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does list_dir(path) work in Hemlock?", "output": "**Throws:** Exception if directory doesn't exist or cannot be read\n\n```hemlock\nimport { list_dir } from \"@stdlib/fs\";\n\ntry {\n    let entries = list_dir(\".\");\n    print(\"Files in current directory:\");\n\n    let i = 0;\n    while (i < entries.length) {\n        print(\"  \" + entries[i]);\n        i = i + 1;\n    }\n} catch (e) {\n    print(\"Error listing directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does json serialization work in Hemlock?", "output": "```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// Object to JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON to Object\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does transformation operations work in Hemlock?", "output": "**`reverse()`** - Reverse array in-place:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1] (modified)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does resetting to default behavior work in Hemlock?", "output": "Pass `null` as the handler to reset to default behavior:\n\n```hemlock\n// Register custom handler\nsignal(SIGINT, my_handler);\n\n// Later, reset to default (terminate on SIGINT)\nsignal(SIGINT, null);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does check if process exists work in Hemlock?", "output": "```hemlock\nfn process_exists(pid: i32) {\n    try {\n        kill(pid, 0);  // Signal 0 doesn't actually send a signal\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\nif (process_exists(1234)) {\n    print(\"Process 1234 is running\");\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test type definitions and duck typing\n\ndefine Person {\n    name: string,\n    age: i32\n}\n\n// Create object and assign to typed variable\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.name);\nprint(typed_p.age);\nprint(typeof(typed_p));\n\n// Extra fields are allowed\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\nprint(p2.name);\nprint(p2.city);\n\nprint(\"done\");\n```", "output": "Alice\n30\nPerson\nBob\nNYC\ndone", "category": "parity/language", "source": "tests/parity/language/type_definitions.hml"}
{"instruction": "How does generate_iv(): buffer work in Hemlock?", "output": "Generate a secure 128-bit (16-byte) initialization vector (IV).\n\n```hemlock\nimport { generate_iv } from \"@stdlib/crypto\";\n\nlet iv = generate_iv();\nprint(iv.length);  // 16 bytes\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does writing work in Hemlock?", "output": "**Returns:** Number of bytes written (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote \" + typeof(written) + \" bytes\");  // \"Wrote 14 bytes\"\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Show an example of example in Hemlock.", "output": "```hemlock\nimport { Queue } from \"@stdlib/collections\";\n\nlet q = Queue();\n\n// Enqueue items\nq.enqueue(\"first\");\nq.enqueue(\"second\");\nq.enqueue(\"third\");\n\n// Peek at front\nprint(q.peek());  // \"first\"\n\n// Dequeue items (FIFO order)\nprint(q.dequeue());  // \"first\"\nprint(q.dequeue());  // \"second\"\nprint(q.dequeue());  // \"third\"\n\n// Check if empty\nif (q.is_empty()) {\n    print(\"Queue is empty\");\n}\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does finally block work in Hemlock?", "output": "The finally block **always executes**:\n\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"error\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");  // Always runs\n}\nprint(\"4: after\");\n\n// Output: 1: try, 2: catch, 3: finally, 4: after\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does function call operator work in Hemlock?", "output": "```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Method call\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Builtin call\nprint(\"message\");\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Show an example of example: adding a new operator in Hemlock.", "output": "// print(10 % 0);  // Division by zero\n\n```hemlock\n**7. Documentation (CLAUDE.md):**\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "What is the difference between `/` and `div()` in Hemlock?", "output": "The `/` operator always returns a float, while `div()` (or `divi()`) performs floor division:\n\n```hemlock\nprint(7 / 2);      // 3.5 (float division)\nprint(div(7, 2));  // 3 (floor division)\nprint(7 % 2);      // 1 (remainder)\n```\n\nThis differs from C where `/` on integers gives integer division.", "category": "concepts/operators", "source": "CLAUDE.md"}
{"instruction": "How does best practices for safe signal handling work in Hemlock?", "output": "**2. Minimize Shared State**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // Only modify this one variable\n    interrupt_count = interrupt_count + 1;\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does raw pointers (advanced) work in Hemlock?", "output": "```hemlock\n// Allocate raw memory\nlet ptr = alloc(100);\n\n// Fill with zeros\nmemset(ptr, 0, 100);\n\n// Copy data\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// Free both\nfree(src);\nfree(ptr);\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does api response processing work in Hemlock?", "output": "```hemlock\nimport { parse, get, is_array } from \"@stdlib/json\";\n\nlet response = parse(http_response_body);\n\n// Extract data safely\nlet users = get(response, \"data.users\", []);\n\nif (is_array(users)) {\n    print(\"Found \" + typeof(users.length) + \" users\");\n\n    let i = 0;\n    while (i < users.length) {\n        let name = get(users[i], \"name\", \"Unknown\");\n        let email = get(users[i], \"email\", \"N/A\");\n        print(name + \" <\" + email + \">\");\n        i = i + 1;\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does quick start work in Hemlock?", "output": "```hemlock\nimport { describe, test, expect, run } from \"@stdlib/testing\";\n\ndescribe(\"Math operations\", fn() {\n    test(\"addition works\", fn() {\n        expect(2 + 2).to_equal(4);\n    });\n\n    test(\"subtraction works\", fn() {\n        expect(10 - 5).to_equal(5);\n    });\n});\n\ndescribe(\"String operations\", fn() {\n    test(\"concatenation works\", fn() {\n        expect(\"hello\" + \" world\").to_equal(\"hello world\");\n    });\n\n    test(\"length is correct\", fn() {\n        expect(\"test\".length).to_equal(4);\n    });\n});\n\n// Run all tests\nlet results = run();\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does write text file work in Hemlock?", "output": "```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does other type inference work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does shutdown_async_fs work in Hemlock?", "output": "```hemlock\nimport { async_read_file, shutdown_async_fs } from \"@stdlib/async_fs\";\n\n// Use async file operations...\nlet content = async_read_file(\"data.txt\").get();\n\n// Cleanup when done\nshutdown_async_fs();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does buffer_to_hex(buf: buffer): string work in Hemlock?", "output": "Convert buffer to hexadecimal string representation.\n\n```hemlock\nimport { buffer_to_hex } from \"@stdlib/crypto\";\n\nlet bytes = random_bytes(16);\nlet hex = buffer_to_hex(bytes);\nprint(hex);  // \"3a7f2c9e4d1b8f6a...\"\nprint(hex.length);  // 32 (2 hex chars per byte)\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does split & join work in Hemlock?", "output": "```hemlock\nstring.trim(): string\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does compilation errors work in Hemlock?", "output": "```hemlock\n3. On Linux, try using GCC:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does default logger instance work in Hemlock?", "output": "```hemlock\nimport { default_logger } from \"@stdlib/logging\";\n\ndefault_logger.info(\"Quick log message\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does putting it all together work in Hemlock?", "output": "Let's build a simple word counter program:\n\n```hemlock\n// wordcount.hml - Count words in a file\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // Split by whitespace and count\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Error reading file: \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// Main program\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(\"Word count: \" + typeof(words));\n    }\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Show an example of combined example: tar.gz archives in Hemlock.", "output": "```hemlock\nimport { gzip, gunzip, TarWriter, TarReader } from \"@stdlib/compression\";\n\n// Create compressed archive\nfn create_tarball(output_path: string, files: array) {\n    let writer = TarWriter();\n\n    let i = 0;\n    while (i < files.length) {\n        let file = files[i];\n        writer.add_file(file.name, file.content);\n        i = i + 1;\n    }\n\n    let tar_data = writer.build();\n\n    // Convert buffer to string for gzip\n    let tar_str = \"\";\n    i = 0;\n    while (i < tar_data.length) {\n        let ch: rune = tar_data[i];\n        tar_str = tar_str + ch;\n        i = i + 1;\n    }\n\n    let compressed = gzip(tar_str, 9);\n\n    let f = open(output_path, \"w\");\n    f.write_bytes(compressed);\n    f.close();\n\n    free(tar_data);\n    free(compressed);\n}\n\n// Extract compressed archive\nfn extract_tarball(input_path: string): array {\n    let f = open(input_path, \"r\");\n    let content = f.read();\n    f.close();\n\n    // Convert to buffer\n    let bytes = content.bytes();\n    let compressed = buffer(bytes.length);\n    let i = 0;\n    while (i < bytes.length) {\n        compressed[i] = bytes[i];\n        i = i + 1;\n    }\n\n    // Decompress\n    let tar_str = gunzip(compressed);\n\n    // Convert to buffer\n    let tar_bytes = tar_str.bytes();\n    let tar_data = buffer(tar_bytes.length);\n    i = 0;\n    while (i < tar_bytes.length) {\n        tar_data[i] = tar_bytes[i];\n        i = i + 1;\n    }\n\n    // Parse tar\n    let reader = TarReader(tar_data);\n    let entries = reader.entries();\n\n    free(compressed);\n    free(tar_data);\n\n    return entries;\n}\n\n// Usage\nlet files = [\n    { name: \"hello.txt\", content: \"Hello, World!\" },\n    { name: \"data.json\", content: \"{\\\"key\\\": \\\"value\\\"}\" },\n];\n\ncreate_tarball(\"archive.tar.gz\", files);\n\nlet extracted = extract_tarball(\"archive.tar.gz\");\nprint(\"Extracted \" + typeof(extracted.length) + \" files\");\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does count signal calls work in Hemlock?", "output": "```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler call #\" + typeof(handler_calls));\n\n    // Your handler logic...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does hello world work in Hemlock?", "output": "Let's start with the traditional first program:\n\n```hemlock\nprint(\"Hello, World!\");\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does named functions work in Hemlock?", "output": "```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "**Appending to a file:**\n\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // Creates if doesn't exist\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does safe execution pattern work in Hemlock?", "output": "```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warning: Command failed with code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Error executing command: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does catch block work in Hemlock?", "output": "**What you can do in catch:**\n\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // Log the error\n    print(\"Error: \" + e);\n\n    // Re-throw same error\n    throw e;\n\n    // Throw different error\n    throw \"different error\";\n\n    // Return a default value\n    return null;\n\n    // Handle and continue\n    // (no re-throw)\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test type promotion with modulo\n\n// i8 + i32 -> i32\nlet a: i8 = 10;\nlet b: i32 = 3;\nlet c = a % b;\nprint(typeof(c));  // i32\nprint(c);  // 1\n\n// u8 + u16 -> u16\nlet d: u8 = 20;\nlet e: u16 = 7;\nlet f = d % e;\nprint(typeof(f));  // u16\nprint(f);  // 6\n\n// i32 + i64 -> i64\nlet g: i32 = 100;\nlet h: i64 = 13;\nlet i = g % h;\nprint(typeof(i));  // i64\nprint(i);  // 9\n```", "output": "i32\n1\nu16\n6\ni64\n9", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_type_promotion.hml"}
{"instruction": "How does core allocation work in Hemlock?", "output": "**`alloc(bytes)` - Allocate raw memory**\n\n```hemlock\nlet p = alloc(1024);  // Allocate 1KB, returns ptr\n// ... use memory\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does handling failures work in Hemlock?", "output": "```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // Note: stderr not captured\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does `getegid(): i32` work in Hemlock?", "output": "Get the effective group ID of the current process.\n\n```hemlock\nlet egid = getegid();\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does talloc work in Hemlock?", "output": "```hemlock\nlet arr = talloc(i32, 100);      // Array of 100 i32s (400 bytes)\nlet floats = talloc(f64, 50);    // Array of 50 f64s (400 bytes)\nlet bytes = talloc(u8, 1024);    // Array of 1024 bytes\n\n// Always check for allocation failure\nif (arr == null) {\n    panic(\"allocation failed\");\n}\n\n// Use the allocated memory\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does threading architecture work in Hemlock?", "output": "Hemlock uses **1:1 threading** with POSIX threads (pthreads):\n\n```hemlock\nUser Task          OS Thread          CPU Core\n---------          ---------          --------\nspawn(f1) ------>  pthread_create --> Core 0\nspawn(f2) ------>  pthread_create --> Core 1\nspawn(f3) ------>  pthread_create --> Core 2\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "How does explicit conversions work in Hemlock?", "output": "```hemlock\n// Integer to float\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Float to integer (truncates)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Integer to rune\nlet code: rune = 65;    // 'A'\n\n// Rune to integer\nlet value: i32 = 'Z';   // 90\n\n// Rune to string\nlet s: string = 'H';    // \"H\"\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does move_to(row, col) work in Hemlock?", "output": "**Returns:** `string` - ANSI escape sequence\n\n```hemlock\nimport { move_to } from \"@stdlib/terminal\";\n\nexec(\"printf '\" + move_to(10, 20) + \"Hello'\");  // Print at row 10, col 20\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does comments work in Hemlock?", "output": "```hemlock\n// This is a single-line comment\n\n/*\n   This is a\n   multi-line comment\n*/\n\nlet x = 42;  // Inline comment\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does performance tips work in Hemlock?", "output": "4. **Stat caching:** Cache `file_stat()` results if checking multiple attributes\n\n```hemlock\nimport { file_stat } from \"@stdlib/fs\";\n\n// Good: Single stat call\nlet info = file_stat(\"large_file.dat\");\nif (info.size > 1000000 && info.is_file) {\n    // Process large file\n}\n\n// Bad: Multiple stat calls\nif (is_file(\"large_file.dat\")) {\n    let info = file_stat(\"large_file.dat\");\n    if (info.size > 1000000) {\n        // Stat called twice\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does panic (unrecoverable errors) work in Hemlock?", "output": "```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x must be non-negative\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // Program exits with: panic: x must be non-negative\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does basic switch work in Hemlock?", "output": "```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does async_list_dir work in Hemlock?", "output": "```hemlock\nimport { async_list_dir } from \"@stdlib/async_fs\";\n\nlet future = async_list_dir(\"./src\");\nlet files = future.get();\nfor (file in files) {\n    print(file);\n}\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does switch statements work in Hemlock?", "output": "```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does system requirements check work in Hemlock?", "output": "```hemlock\nimport * as os from \"@stdlib/os\";\n\nfn check_requirements(): bool {\n    let errors = [];\n\n    // Check platform\n    if (!os.is_linux() && !os.is_macos()) {\n        errors.push(\"This application requires Linux or macOS\");\n    }\n\n    // Check CPU cores\n    let cores = os.cpu_count();\n    if (cores < 2) {\n        errors.push(\"At least 2 CPU cores required, found \" + typeof(cores));\n    }\n\n    // Check memory (require at least 2 GB)\n    let min_memory: i64 = 2147483648;  // 2 GB in bytes\n    let total = os.total_memory();\n    if (total < min_memory) {\n        errors.push(\"At least 2 GB RAM required, found \" + os.format_bytes(total));\n    }\n\n    // Report results\n    if (errors.length > 0) {\n        print(\"System requirements not met:\");\n        let i = 0;\n        while (i < errors.length) {\n            print(\"  - \" + errors[i]);\n            i = i + 1;\n        }\n        return false;\n    }\n\n    print(\"System requirements satisfied\");\n    return true;\n}\n\ncheck_requirements();\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does creating a server work in Hemlock?", "output": "```hemlock\nimport { WebSocketServer } from \"@stdlib/websocket\";\n\nlet server = WebSocketServer(\"0.0.0.0\", 8080);\ndefer server.close();\n\nprint(\"Server listening on :8080\");\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does level hierarchy work in Hemlock?", "output": "Log levels form a hierarchy where higher levels are more severe:\n\n```hemlock\nDEBUG < INFO < WARN < ERROR\n  0      1      2      3\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does fan-out, fan-in work in Hemlock?", "output": "```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // Process value\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// Fan-out: Multiple workers\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// Send work\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// Fan-in: Collect all results\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// Wait for all workers\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All functions throw exceptions for invalid input:\n\n```hemlock\nimport { pad_left, is_alpha, reverse } from \"@stdlib/strings\";\n\n// Invalid fill character length\ntry {\n    pad_left(\"test\", 10, \"ab\");  // Must be single character\n} catch (e) {\n    print(\"Error: \" + e);  // \"pad_left() fill must be single character\"\n}\n\n// Invalid type\ntry {\n    is_alpha(123);  // Must be string\n} catch (e) {\n    print(\"Error: \" + e);  // \"is_alpha() requires string argument\"\n}\n\n// Invalid type\ntry {\n    reverse(null);\n} catch (e) {\n    print(\"Error: \" + e);  // \"reverse() requires string argument\"\n}\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does slicing & extraction work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// Empty slice\nlet empty = arr.slice(2, 2); // []\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\nfor (let item in array) {\n    // body\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does c-style for work in Hemlock?", "output": "```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i not accessible here (loop-scoped)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does while loops work in Hemlock?", "output": "```hemlock\nwhile (condition) {\n    // body\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does common errors work in Hemlock?", "output": "**Writing to read-only file:**\n\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does difference methods work in Hemlock?", "output": "Get the difference in days.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 1, 0, 0, 0);\nlet dt2 = from_date(2025, 1, 11, 0, 0, 0);\n\nlet diff = dt2.diff_days(dt1);\nprint(diff);  // 10\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How do you use using valgrind in Hemlock?", "output": "==12345== All heap blocks were freed -- no leaks are possible\n\n```hemlock\n**Example output (with leak):**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does best practices for safe signal handling work in Hemlock?", "output": "**3. Defer Complex Operations**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // Just set flag\n}\n\nsignal(SIGHUP, signal_reload);\n\n// In main loop:\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // Do complex work here\n        pending_reload = false;\n    }\n\n    // Normal work...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does import statements work in Hemlock?", "output": "```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does exit(code?) work in Hemlock?", "output": "**Example - Configuration validation:**\n\n```hemlock\nimport { getenv, exit } from \"@stdlib/env\";\n\nfn validate_config(): null {\n    let required_vars = [\"API_KEY\", \"DATABASE_URL\", \"PORT\"];\n\n    let i = 0;\n    while (i < required_vars.length) {\n        let var_name = required_vars[i];\n        let value = getenv(var_name);\n\n        if (value == null) {\n            print(\"Error: Required environment variable \" + var_name + \" is not set\");\n            exit(1);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Configuration valid\");\n    return null;\n}\n\nvalidate_config();\n// Program continues only if all variables are set\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does running programs work in Hemlock?", "output": "./hemlock program.hml\n\n```hemlock\nWith command-line arguments:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does async_list_dir work in Hemlock?", "output": "```hemlock\nasync_list_dir(path: string): Future<array<string>>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does implicit conversions work in Hemlock?", "output": "```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result is i32 (promoted)\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does pointer types work in Hemlock?", "output": "```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Bounds checked\nprint(b.length);        // 64\nfree(b);\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does utf-8 behavior work in Hemlock?", "output": "**Multi-byte characters count as one:**\n\n```hemlock\n\"Hello\".length;      // 5\n\"ðŸš€\".length;         // 1 (one emoji)\n\"ä½ å¥½\".length;       // 2 (two Chinese characters)\n\"cafÃ©\".length;       // 4 (Ã© is one codepoint)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does seeking work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Jump to byte 100\nf.seek(100);\n\n// Read from that position\nlet chunk = f.read(50);\n\n// Reset to beginning\nf.seek(0);\n\n// Read from start\nlet all = f.read();\n\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does what is panic? work in Hemlock?", "output": "`panic()` is for **unrecoverable errors** that should immediately terminate the program:\n\n```hemlock\npanic();                    // Default message: \"panic!\"\npanic(\"custom message\");    // Custom message\npanic(42);                  // Non-string values are printed\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Show an example of example: retry logic in Hemlock.", "output": "```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // Success!\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation failed after \" + typeof(max_attempts) + \" attempts: \" + e;\n            }\n            print(\"Attempt \" + typeof(attempt) + \" failed, retrying...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // Simulated unreliable operation\n    if (random() < 0.7) {\n        throw \"Operation failed\";\n    }\n    return \"Success\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"All retries failed: \" + e);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does convenience constructors work in Hemlock?", "output": "Create a DateTime object from UTC date/time components.\n\n```hemlock\nimport { from_utc } from \"@stdlib/datetime\";\n\nlet utc_dt = from_utc(2025, 1, 1, 0, 0, 0);\nprint(utc_dt.to_string());\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does result object work in Hemlock?", "output": "The object returned by `exec()` has the following structure:\n\n```hemlock\n{\n    output: string,      // Command stdout (captured output)\n    exit_code: i32       // Process exit status (0 = success)\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test different typed array types\n\n// i32 array\nlet ints: array<i32> = [1, 2, 3, 4, 5];\nprint(ints[0]);\nints.push(6);\nprint(ints.length);\n\n// string array\nlet strings: array<string> = [\"foo\", \"bar\", \"baz\"];\nprint(strings[1]);\nstrings.push(\"qux\");\nprint(strings.length);\n\n// bool array\nlet bools: array<bool> = [true, false, true];\nprint(bools[2]);\nbools.push(false);\nprint(bools.length);\n```", "output": "1\n6\nbar\n4\ntrue\n4", "category": "tests/typed_arrays", "source": "tests/typed_arrays/different_types.hml"}
{"instruction": "How does queue operations work in Hemlock?", "output": "**`shift()`** - Remove and return first element:\n\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // Returns 1, arr is now [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How do you define a function in Hemlock?", "output": "Functions use the `fn` keyword:\n\n```hemlock\n// Basic function\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Optional parameters with defaults\nfn greet(name: string, msg?: \"Hello\") {\n    print(msg + \" \" + name);\n}\n\n// Anonymous function / closure\nlet double = fn(x) { return x * 2; };\n\n// Usage\nprint(add(2, 3));     // 5\ngreet(\"Alice\");       // Hello Alice\nprint(double(5));     // 10\n```", "category": "concepts/functions", "source": "CLAUDE.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test map() - transform each element\n\n// Basic map - double each number\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) {\n    return x * 2;\n});\nprint(doubled[0]);  // 2\nprint(doubled[1]);  // 4\nprint(doubled[2]);  // 6\nprint(doubled[3]);  // 8\nprint(doubled[4]);  // 10\nprint(doubled.length);  // 5\n\n// Map to different type - numbers to strings\nlet strs = nums.map(fn(x) {\n    return \"num_\" + typeof(x);\n});\nprint(strs[0]);  // num_1\nprint(strs[1]);  // num_2\nprint(strs[2]);  // num_3\n\n// Map with empty array\nlet empty = [];\nlet empty_result = empty.map(fn(x) {\n    return x * 2;\n});\nprint(empty_result.length);  // 0\n\n// Map with strings\nlet words = [\"hello\", \"world\"];\nlet upper = words.map(fn(s) {\n    return s.to_upper();\n});\nprint(upper[0]);  // HELLO\nprint(upper[1]);  // WORLD\n\n// Map preserves original array\nlet original = [10, 20, 30];\nlet transformed = original.map(fn(x) {\n    return x + 1;\n});\nprint(original[0]);  // 10 (unchanged)\nprint(original[1]);  // 20 (unchanged)\nprint(transformed[0]);  // 11\nprint(transformed[1]);  // 21\n\n// Map with closure\nlet multiplier = 3;\nlet tripled = [1, 2, 3].map(fn(x) {\n    return x * multiplier;\n});\nprint(tripled[0]);  // 3\nprint(tripled[1]);  // 6\nprint(tripled[2]);  // 9\n\n// Complex transformation\nlet objects = [1, 2, 3].map(fn(n) {\n    return n * n;\n});\nprint(objects[0]);  // 1\nprint(objects[1]);  // 4\nprint(objects[2]);  // 9\n```", "output": "2\n4\n6\n8\n10\n5\nnum_1\nnum_2\nnum_3\n0\nHELLO\nWORLD\n10\n20\n11\n21\n3\n6\n9\n1\n4\n9", "category": "tests/arrays", "source": "tests/arrays/map.hml"}
{"instruction": "How does path separators work in Hemlock?", "output": "- **Windows:** `\\` (backslash) or `/` (also supported)\n\n```hemlock\n// Cross-platform path construction\nlet path = \"dir\" + \"/\" + \"file.txt\";  // Works on both Unix and Windows\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does `ptr` - raw pointer (dangerous) work in Hemlock?", "output": "Raw pointers are **just addresses** with minimal safety guarantees:\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // You must remember to free\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does bg_color_256(n) work in Hemlock?", "output": "**Returns:** `string` - 256-color background code\n\n```hemlock\nimport { bg_color_256, color_256, RESET } from \"@stdlib/terminal\";\n\nprint(color_256(16) + bg_color_256(226) + \" Black on yellow \" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does `logger.log(level, message, data?)` work in Hemlock?", "output": "```hemlock\nimport { DEBUG } from \"@stdlib/logging\";\n\nlet severity = DEBUG;\nlogger.log(severity, \"Custom level logging\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does working directory changes work in Hemlock?", "output": "```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does aes_encrypt(plaintext: string, key: buffer, iv: buffer): buffer work in Hemlock?", "output": "Encrypt plaintext using AES-256-CBC with PKCS#7 padding.\n\n```hemlock\nimport { generate_aes_key, generate_iv, aes_encrypt } from \"@stdlib/crypto\";\n\nlet plaintext = \"Secret message!\";\nlet key = generate_aes_key();\nlet iv = generate_iv();\n\nlet ciphertext = aes_encrypt(plaintext, key, iv);\nprint(\"Encrypted \" + typeof(plaintext.length) + \" bytes to \" + typeof(ciphertext.length));\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does repetition work in Hemlock?", "output": "```hemlock\nstring.repeat(count: i32): string\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does channel methods work in Hemlock?", "output": "```hemlock\nchannel.close(): null\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does realloc work in Hemlock?", "output": "```hemlock\nlet p = alloc(100);\n// ... use memory ...\n\n// Need more space\np = realloc(p, 200);        // Now 200 bytes\n// ... use expanded memory ...\n\nfree(p);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does integer types work in Hemlock?", "output": "**Unsigned integers:**\n\n```hemlock\nlet byte: u8 = 255;              // 8-bit  (0 to 255)\nlet word: u16 = 65535;           // 16-bit (0 to 65535)\nlet dword: u32 = 4294967295;     // 32-bit (0 to 4294967295)\nlet qword: u64 = 18446744073709551615;  // 64-bit\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does sin(x) work in Hemlock?", "output": "**Returns:** `f64` - Sine of x in range [-1, 1]\n\n```hemlock\nimport { sin, PI } from \"@stdlib/math\";\n\nlet result = sin(0.0);        // 0.0\nlet result2 = sin(PI / 2.0);  // 1.0\nlet result3 = sin(PI);        // ~0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does braces are required work in Hemlock?", "output": "```hemlock\n// âŒ ERROR: Missing braces\nif (x > 0)\n    print(\"positive\");\n\n// âœ… CORRECT\nif (x > 0) {\n    print(\"positive\");\n}\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test: Re-throwing exceptions\ntry {\n    try {\n        throw \"inner error\";\n    } catch (e) {\n        print(\"Inner caught: \" + e);\n        throw e;\n    }\n} catch (e) {\n    print(\"Outer caught: \" + e);\n}\n```", "output": "Inner caught: inner error\nOuter caught: inner error", "category": "tests/exceptions", "source": "tests/exceptions/rethrow.hml"}
{"instruction": "How does pitfall: byte vs. codepoint confusion work in Hemlock?", "output": "```hemlock\nlet emoji = \"ðŸš€\";\nprint(emoji.length);        // 1 (codepoint)\nprint(emoji.byte_length);   // 4 (bytes)\n\n// Don't mix byte and codepoint operations\nlet byte = emoji.byte_at(0);  // 240 (first byte)\nlet char = emoji.char_at(0);  // 'ðŸš€' (full codepoint)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test: Memory leak detection with many spawn/join cycles\n// Spawns and joins many tasks to verify no memory leaks\n\nasync fn simple_task(id: i32): i32 {\n    return id * 2;\n}\n\n// Run multiple batches of tasks\nlet num_batches = 50;\nlet tasks_per_batch = 20;\nlet batch = 0;\nlet total_sum = 0;\n\nwhile (batch < num_batches) {\n    let tasks = [];\n    let i = 0;\n\n    // Spawn batch of tasks\n    while (i < tasks_per_batch) {\n        tasks.push(spawn(simple_task, batch * tasks_per_batch + i));\n        i = i + 1;\n    }\n\n    // Join all tasks in this batch\n    i = 0;\n    while (i < tasks.length) {\n        let result = join(tasks[i]);\n        total_sum = total_sum + result;\n        i = i + 1;\n    }\n\n    batch = batch + 1;\n}\n\nprint(\"Batches:\");\nprint(num_batches);\nprint(\"Tasks per batch:\");\nprint(tasks_per_batch);\nprint(\"Total tasks:\");\nprint(num_batches * tasks_per_batch);\nprint(\"Total sum:\");\nprint(total_sum);\n```", "output": "Batches:\n50\nTasks per batch:\n20\nTotal tasks:\n1000\nTotal sum:\n999000", "category": "tests/async", "source": "tests/async/stress_memory_leak.hml"}
{"instruction": "How does throw work in Hemlock?", "output": "```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does write_files_parallel work in Hemlock?", "output": "```hemlock\nimport { write_files_parallel } from \"@stdlib/async_fs\";\n\nlet files = [\n    { path: \"output1.txt\", content: \"Content 1\" },\n    { path: \"output2.txt\", content: \"Content 2\" },\n    { path: \"output3.txt\", content: \"Content 3\" }\n];\n\nwrite_files_parallel(files);\nprint(\"All files written\");\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport { ThreadPool } from \"@stdlib/async\";\n\n// CPU-bound work function\nfn fibonacci(n) {\n    if (n <= 1) { return n; }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Create thread pool\nlet pool = ThreadPool(4);\n\n// Submit multiple tasks\nlet futures = [];\nlet i = 30;\nwhile (i <= 35) {\n    futures.push(pool.submit1(fibonacci, i));\n    i = i + 1;\n}\n\n// Collect results\nprint(\"Computing fibonacci numbers...\");\ni = 0;\nlet n = 30;\nwhile (i < futures.length) {\n    let result = futures[i].get();\n    print(\"fib(\" + n + \") = \" + result);\n    i = i + 1;\n    n = n + 1;\n}\n\n// Cleanup\npool.shutdown();\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does cursor visibility work in Hemlock?", "output": "```hemlock\nimport { HIDE_CURSOR, SHOW_CURSOR } from \"@stdlib/terminal\";\n\n// Hide cursor (useful for animations)\nexec(\"printf '\" + HIDE_CURSOR + \"'\");\n\n// ... do animation ...\n\n// Show cursor again\nexec(\"printf '\" + SHOW_CURSOR + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Show how to create an HTTP client in Hemlock.", "output": "```hemlock\n// Example: Using @stdlib/http module\n// Demonstrates production-ready HTTP/HTTPS client using curl\n\nimport { get, post_json, fetch, get_json, is_success } from \"@stdlib/http\";\n\nprint(\"=== Hemlock HTTP Client Example ===\\n\");\n\n// Example 1: Simple HTTPS GET request\nprint(\"Example 1: HTTPS GET request\");\nprint(\"-----------------------------\");\ntry {\n    let response = get(\"https://httpbin.org/get\", null);\n\n    if (is_success(response.status_code)) {\n        print(\"Status: \" + typeof(response.status_code));\n        print(\"Body (first 100 chars): \" + response.body.substr(0, 100));\n    } else {\n        print(\"Request failed with status: \" + typeof(response.status_code));\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    print(\"(Requires curl to be installed and network access)\");\n}\n\nprint(\"\\n\");\n\n// Example 2: Fetch JSON API\nprint(\"Example 2: Fetch and Parse JSON\");\nprint(\"--------------------------------\");\ntry {\n    let user = get_json(\"https://jsonplaceholder.typicode.com/users/1\");\n    print(\"Name: \" + user.name);\n    print(\"Email: \" + user.email);\n    print(\"Company: \" + user.company.name);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 3: POST JSON data\nprint(\"Example 3: POST JSON\");\nprint(\"--------------------\");\ntry {\n    let data = {\n        title: \"Buy groceries\",\n        completed: false,\n        userId: 1\n    };\n\n    let response = post_json(\"https://jsonplaceholder.typicode.com/todos\", data);\n    print(\"Response (first 100 chars): \" + response.body.substr(0, 100));\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 4: Custom headers with authentication\nprint(\"Example 4: Custom Headers\");\nprint(\"-------------------------\");\ntry {\n    let headers = [\n        \"User-Agent: Hemlock-HTTP/1.0\",\n        \"Accept: application/json\",\n        \"X-Custom-Header: test-value\"\n    ];\n\n    let response = get(\"https://httpbin.org/headers\", headers);\n    print(\"Response received (check headers were sent)\");\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 5: Error handling\nprint(\"Example 5: Error Handling\");\nprint(\"-------------------------\");\ntry {\n    let response = get(\"https://httpbin.org/status/404\", null);\n    if (is_success(response.status_code)) {\n        print(\"Success!\");\n    } else {\n        print(\"Got error status: \" + typeof(response.status_code));\n    }\n} catch (e) {\n    print(\"Request failed: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 6: Simple fetch\nprint(\"Example 6: Simple Fetch\");\nprint(\"-----------------------\");\ntry {\n    let html = fetch(\"https://example.com\");\n    print(\"Fetched \" + typeof(html.length) + \" bytes from example.com\");\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n=== Examples Complete ===\");\n\nprint(\"\\nNOTE: This module uses curl for HTTP/HTTPS support.\");\nprint(\"Ensure curl is installed: which curl\");\n```", "category": "examples", "source": "examples/http_example.hml"}
{"instruction": "How does type checking work in Hemlock?", "output": "```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // Type checking happens here\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\" (original is still anonymous)\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does planned features work in Hemlock?", "output": "**3. Function Pointer Callbacks** âœ… (Implemented!)\n\n```hemlock\n// Pass Hemlock functions to C as callbacks\nfn my_compare(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    return va - vb;\n}\n\n// Create a C-callable function pointer\nlet cmp = callback(my_compare, [\"ptr\", \"ptr\"], \"i32\");\n\n// Use with qsort or any C function expecting a callback\nqsort(arr, count, elem_size, cmp);\n\n// Clean up when done\ncallback_free(cmp);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How do you range error in Hemlock?", "output": "```hemlock\nlet x: u8 = 256;\n```", "category": "examples", "source": "examples/range_error.hml"}
{"instruction": "How does assert_eq(actual, expected) work in Hemlock?", "output": "Assert deep equality.\n\n```hemlock\ntest(\"simple equality\", fn() {\n    assert_eq(2 + 2, 4);\n    assert_eq(\"hello\", \"hello\");\n    assert_eq([1, 2, 3], [1, 2, 3]);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test nested closures and complex capture scenarios\n\n// Double nested closure\nfn outer(a) {\n    return fn(b) {\n        return fn(c) {\n            return a + b + c;\n        };\n    };\n}\n\nlet f1 = outer(1);\nlet f2 = f1(2);\nprint(f2(3));\n\n// Closure capturing loop variable\nfn makeCounters() {\n    let counters = [];\n    for (let i = 0; i < 3; i = i + 1) {\n        let val = i;\n        counters.push(fn() { return val; });\n    }\n    return counters;\n}\n\nlet ctrs = makeCounters();\nprint(ctrs[0]());\nprint(ctrs[1]());\nprint(ctrs[2]());\n\n// Closure with mutation\nfn makeCounter() {\n    let count = 0;\n    return {\n        inc: fn() { count = count + 1; return count; },\n        dec: fn() { count = count - 1; return count; },\n        get: fn() { return count; }\n    };\n}\n\nlet counter = makeCounter();\nprint(counter.get());\nprint(counter.inc());\nprint(counter.inc());\nprint(counter.dec());\nprint(counter.get());\n\n// Multiple closures sharing state\nfn makeShared() {\n    let shared = 0;\n    let adder = fn(n) { shared = shared + n; };\n    let getter = fn() { return shared; };\n    return { add: adder, get: getter };\n}\n\nlet s = makeShared();\ns.add(10);\ns.add(5);\nprint(s.get());\n\n// Closure capturing closure\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nlet double = fn(x) { return x * 2; };\nlet addOne = fn(x) { return x + 1; };\nlet composed = compose(double, addOne);\nprint(composed(5));\n\n// Recursive closure (via object)\nlet fib = {\n    calc: fn(n) {\n        if (n <= 1) { return n; }\n        return fib.calc(n - 1) + fib.calc(n - 2);\n    }\n};\nprint(fib.calc(10));\n\nprint(\"done\");\n```", "output": "6\n2\n2\n2\n0\n1\n2\n1\n1\n15\n12\n55\ndone", "category": "parity/language", "source": "tests/parity/language/nested_closures.hml"}
{"instruction": "How does gzip(data, level?) -> buffer work in Hemlock?", "output": "```hemlock\nimport { gzip, gunzip } from \"@stdlib/compression\";\n\nlet data = \"Some text data to compress with gzip format.\";\nlet compressed = gzip(data, 9);  // Best compression\n\n// Verify gzip magic bytes\nprint(compressed[0]);  // 31 (0x1f)\nprint(compressed[1]);  // 139 (0x8b)\n\nlet restored = gunzip(compressed);\nprint(restored);  // Original string\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test arrays\n\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);\nprint(arr[4]);\nprint(arr.length);\n\n// Modification\narr[0] = 10;\nprint(arr[0]);\n\n// For-in loop\nlet sum = 0;\nfor (let x in [1, 2, 3]) {\n    sum = sum + x;\n}\nprint(sum);\n\n// Nested arrays\nlet nested = [[1, 2], [3, 4]];\nprint(nested[0][0]);\nprint(nested[1][1]);\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed[1]);\n\nprint(\"done\");\n```", "output": "1\n5\n5\n10\n6\n1\n4\nhello\ndone", "category": "parity/language", "source": "tests/parity/language/arrays.hml"}
{"instruction": "How does maybe add (under discussion) work in Hemlock?", "output": "**3. Error types (`Result<T, E>`)**\n\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"division by zero\");\n    }\n    return Ok(a / b);\n}\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "**Reading an existing file:**\n\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// or simply:\nlet f = open(\"config.json\");  // \"r\" is default\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does floor division (div / divi) work in Hemlock?", "output": "For floor division (like integer division in other languages), use the `div()` and `divi()` functions:\n\n```hemlock\n// div(a, b) - floor division returning float\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- floors toward -infinity\n\n// divi(a, b) - floor division returning integer\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does mixed positional and named arguments work in Hemlock?", "output": "```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // Treat as positional argument\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// Assign positional arguments\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Show an example of example 2: batch file processor in Hemlock.", "output": "```hemlock\n// Usage: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Processing: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // Process content...\n            print(\"    \" + typeof(content.length) + \" bytes\");\n        } catch (e) {\n            print(\"    Error: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Done!\");\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test command execution\n\n// Simple echo command\nlet r = exec(\"echo hello\");\nprint(r.output);\nprint(r.exit_code);\n\n// Command with exit code\nlet r2 = exec(\"true\");\nprint(r2.exit_code);\n\nlet r3 = exec(\"false\");\nprint(r3.exit_code);\n\n// Multiple words\nlet r4 = exec(\"echo one two three\");\nprint(r4.output);\n\nprint(\"done\");\n```", "output": "hello\n\n0\n0\n1\none two three\n\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/exec.hml"}
{"instruction": "How does memcpy work in Hemlock?", "output": "```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Initialize source\nmemset(src, 65, 100);\n\n// Copy to destination\nmemcpy(dest, src, 100);\n\n// dest now contains same data as src\n\nfree(src);\nfree(dest);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does unary arithmetic work in Hemlock?", "output": "```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (no change)\n\nlet x = -3.14;         // -3.14\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does function return type annotations work in Hemlock?", "output": "```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does directory organization work in Hemlock?", "output": "```hemlock\ntests/\nâ”œâ”€â”€ run_tests.sh          # Main test runner script\nâ”œâ”€â”€ primitives/           # Type system tests\nâ”‚   â”œâ”€â”€ integers.hml\nâ”‚   â”œâ”€â”€ floats.hml\nâ”‚   â”œâ”€â”€ booleans.hml\nâ”‚   â”œâ”€â”€ i64.hml\nâ”‚   â””â”€â”€ u64.hml\nâ”œâ”€â”€ conversions/          # Type conversion tests\nâ”‚   â”œâ”€â”€ int_to_float.hml\nâ”‚   â”œâ”€â”€ promotion.hml\nâ”‚   â””â”€â”€ rune_conversions.hml\nâ”œâ”€â”€ memory/               # Pointer/buffer tests\nâ”‚   â”œâ”€â”€ alloc.hml\nâ”‚   â”œâ”€â”€ buffer.hml\nâ”‚   â””â”€â”€ memcpy.hml\nâ”œâ”€â”€ strings/              # String operation tests\nâ”‚   â”œâ”€â”€ concat.hml\nâ”‚   â”œâ”€â”€ methods.hml\nâ”‚   â”œâ”€â”€ utf8.hml\nâ”‚   â””â”€â”€ runes.hml\nâ”œâ”€â”€ control/              # Control flow tests\nâ”‚   â”œâ”€â”€ if.hml\nâ”‚   â”œâ”€â”€ switch.hml\nâ”‚   â””â”€â”€ while.hml\nâ”œâ”€â”€ functions/            # Function and closure tests\nâ”‚   â”œâ”€â”€ basics.hml\nâ”‚   â”œâ”€â”€ closures.hml\nâ”‚   â””â”€â”€ recursion.hml\nâ”œâ”€â”€ objects/              # Object tests\nâ”‚   â”œâ”€â”€ literals.hml\nâ”‚   â”œâ”€â”€ methods.hml\nâ”‚   â”œâ”€â”€ duck_typing.hml\nâ”‚   â””â”€â”€ serialization.hml\nâ”œâ”€â”€ arrays/               # Array operation tests\nâ”‚   â”œâ”€â”€ basics.hml\nâ”‚   â”œâ”€â”€ methods.hml\nâ”‚   â””â”€â”€ slicing.hml\nâ”œâ”€â”€ loops/                # Loop tests\nâ”‚   â”œâ”€â”€ for.hml\nâ”‚   â”œâ”€â”€ while.hml\nâ”‚   â”œâ”€â”€ break.hml\nâ”‚   â””â”€â”€ continue.hml\nâ”œâ”€â”€ exceptions/           # Error handling tests\nâ”‚   â”œâ”€â”€ try_catch.hml\nâ”‚   â”œâ”€â”€ finally.hml\nâ”‚   â””â”€â”€ throw.hml\nâ”œâ”€â”€ io/                   # File I/O tests\nâ”‚   â”œâ”€â”€ file_object.hml\nâ”‚   â”œâ”€â”€ read_write.hml\nâ”‚   â””â”€â”€ seek.hml\nâ”œâ”€â”€ async/                # Concurrency tests\nâ”‚   â”œâ”€â”€ spawn_join.hml\nâ”‚   â”œâ”€â”€ channels.hml\nâ”‚   â””â”€â”€ exceptions.hml\nâ”œâ”€â”€ ffi/                  # FFI tests\nâ”‚   â”œâ”€â”€ basic_call.hml\nâ”‚   â”œâ”€â”€ types.hml\nâ”‚   â””â”€â”€ dlopen.hml\nâ”œâ”€â”€ signals/              # Signal handling tests\nâ”‚   â”œâ”€â”€ basic.hml\nâ”‚   â”œâ”€â”€ handlers.hml\nâ”‚   â””â”€â”€ raise.hml\nâ””â”€â”€ args/                 # Command-line args tests\n    â””â”€â”€ basic.hml\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does prefix & suffix work in Hemlock?", "output": "```hemlock\nstring.ends_with(suffix: string): bool\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Show an example of example: adding a new operator in Hemlock.", "output": "```hemlock\n**5. Runtime (runtime.c):**\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does lines(str) work in Hemlock?", "output": "- Returns array with one element (the string itself) if no newlines\n\n```hemlock\nimport { lines } from \"@stdlib/strings\";\n\n// Basic line splitting\nlet l1 = lines(\"hello\\nworld\");\nprint(l1.length);   // 2\nprint(l1[0]);       // \"hello\"\nprint(l1[1]);       // \"world\"\n\n// Multiple lines\nlet l2 = lines(\"line1\\nline2\\nline3\");\nprint(l2.length);   // 3\n\n// Empty lines are preserved\nlet l3 = lines(\"a\\n\\nb\");\nprint(l3.length);   // 3\nprint(l3[1]);       // \"\" (empty line)\n\n// Single line (no newline)\nlet l4 = lines(\"hello\");\nprint(l4.length);   // 1\nprint(l4[0]);       // \"hello\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does asin(x) work in Hemlock?", "output": "**Returns:** `f64` - Arc sine in range [-Ï€/2, Ï€/2]\n\n```hemlock\nimport { asin, PI } from \"@stdlib/math\";\n\nlet angle = asin(1.0);   // Ï€/2\nlet angle2 = asin(0.5);  // Ï€/6\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does exp(x) work in Hemlock?", "output": "**Returns:** `f64` - e^x\n\n```hemlock\nimport { exp } from \"@stdlib/math\";\n\nlet result = exp(0.0);  // 1.0\nlet result2 = exp(1.0); // 2.718281... (e)\nlet result3 = exp(2.0); // 7.389056...\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test OS info builtins\n\n// Test platform() - should return \"linux\", \"macos\", or \"windows\"\nlet plat = platform();\nprint(typeof(plat) == \"string\");  // true\n\n// Test arch() - should return architecture like \"x86_64\"\nlet cpu_arch = arch();\nprint(typeof(cpu_arch) == \"string\");  // true\nprint(cpu_arch.length > 0);  // true\n\n// Test hostname()\nlet host = hostname();\nprint(typeof(host) == \"string\");  // true\nprint(host.length > 0);  // true\n\n// Test username()\nlet user = username();\nprint(typeof(user) == \"string\");  // true\nprint(user.length > 0);  // true\n\n// Test homedir()\nlet home = homedir();\nprint(typeof(home) == \"string\");  // true\nprint(home.length > 0);  // true\n\n// Test cpu_count() - should return positive integer\nlet cpus = cpu_count();\nprint(cpus >= 1);  // true\n\n// Test total_memory() - should return positive i64\nlet total_mem = total_memory();\nprint(total_mem > 0);  // true\n\n// Test free_memory() - should return positive i64\nlet free_mem = free_memory();\nprint(free_mem > 0);  // true\nprint(free_mem <= total_mem);  // true\n\n// Test os_version()\nlet version = os_version();\nprint(typeof(version) == \"string\");  // true\nprint(version.length > 0);  // true\n\n// Test os_name()\nlet name = os_name();\nprint(typeof(name) == \"string\");  // true\nprint(name.length > 0);  // true\n\n// Test tmpdir()\nlet tmp = tmpdir();\nprint(typeof(tmp) == \"string\");  // true\nprint(tmp.length > 0);  // true\n\n// Test uptime() - should return positive i64 (seconds)\nlet up = uptime();\nprint(up > 0);  // true\n\nprint(\"All OS info tests passed!\");\n```", "output": "true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nAll OS info tests passed!", "category": "tests/compiler", "source": "tests/compiler/os_info.hml"}
{"instruction": "How does receiving messages work in Hemlock?", "output": "**Receive with timeout:**\n\n```hemlock\nlet msg = ws.recv(5000);  // 5 second timeout\nif (msg == null) {\n    print(\"Timeout or connection closed\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does object literals work in Hemlock?", "output": "```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does floating-point types work in Hemlock?", "output": "```hemlock\nlet f: f32 = 3.14159;        // 32-bit float\nlet d: f64 = 2.718281828;    // 64-bit float (default)\nlet n: number = 1.618;       // Alias for f64\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show how to validate ranges in Hemlock.", "output": "```hemlock\nlet a: u8 = 255;\nprint(a);\n\nlet b: u8 = 0;\nprint(b);\n\nlet c: i8 = 127;\nprint(c);\n\nlet d: i8 = -128;\nprint(d);\n```", "category": "examples", "source": "examples/range_check.hml"}
{"instruction": "How does exception assertions work in Hemlock?", "output": "Check that function does not throw.\n\n```hemlock\ntest(\"safe function\", fn() {\n    expect(fn() {\n        let x = 2 + 2;\n        return x;\n    }).not_to_throw();\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does string literals work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet escaped = \"line1\\nline2\\ttabbed\";\nlet quote = \"She said \\\"hello\\\"\";\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does exception assertions work in Hemlock?", "output": "**Note:** The value passed to `expect()` must be a function, not a function call.\n\n```hemlock\n// âœ“ Correct\nexpect(fn() { risky_operation(); }).to_throw();\n\n// âœ— Wrong - calls the function immediately\nexpect(risky_operation()).to_throw();\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does âŒ don't add implicit behavior work in Hemlock?", "output": "```hemlock\n// BAD: Automatic semicolon insertion\nlet x = 5\nlet y = 10\n\n// BAD: Automatic memory management\nlet s = \"hello\"  // String auto-freed at end of scope? NO!\n\n// BAD: Implicit type conversions that lose precision\nlet x: i32 = 3.14  // Should truncate or error?\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does byte access work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// UTF-8 example\nlet emoji = \"ðŸš€\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does implicit return work in Hemlock?", "output": "Functions without return type annotation implicitly return `null`:\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // Implicitly returns null\n}\n\nlet result = print_message(\"hello\");  // result is null\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does capacity management work in Hemlock?", "output": "```hemlock\nlet arr = [];  // Initial capacity: 0\n\narr.push(1);   // Grows to capacity 1\narr.push(2);   // Grows to capacity 2\narr.push(3);   // Grows to capacity 4 (doubles)\narr.push(4);   // Still capacity 4\narr.push(5);   // Grows to capacity 8 (doubles)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does multiple signal handlers work in Hemlock?", "output": "Different handlers for different signals:\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does type annotations (optional) work in Hemlock?", "output": "```hemlock\n// No annotations (types inferred)\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\n// With annotations (checked at runtime)\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does read file in chunks work in Hemlock?", "output": "```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // Read 1KB at a time\n        if (chunk.length == 0) {\n            break;  // EOF\n        }\n\n        // Process chunk\n        print(\"Processing\", chunk.length, \"bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does basic syntax work in Hemlock?", "output": "```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does method chaining work in Hemlock?", "output": "Methods that return arrays or values enable chaining:\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test type mismatch when inserting into typed array\n\nlet arr: array<string> = [\"hello\", \"world\"];\narr.insert(1, 123);  // Should error: type mismatch\n```", "output": "Runtime error: Type mismatch in typed array - expected element of specific type", "category": "tests/typed_arrays", "source": "tests/typed_arrays/type_mismatch_insert_error.hml"}
{"instruction": "Show an example of example: event handler in Hemlock.", "output": "```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "- Throws exception on connection failure\n\n```hemlock\nlet stream = TcpStream(\"example.com\", 80);\nlet stream2 = TcpStream(\"192.168.1.1\", 9000);\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does udp echo server work in Hemlock?", "output": "```hemlock\nimport { UdpSocket } from \"@stdlib/net\";\n\nlet sock = UdpSocket(\"0.0.0.0\", 5000);\ndefer sock.close();\n\nprint(\"UDP echo server listening on port 5000\");\n\nwhile (true) {\n    let packet = sock.recv_from(1024);\n    print(\"Echo from \" + packet.address + \":\" + typeof(packet.port));\n    sock.send_to(packet.address, packet.port, packet.data);\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does method call detection work in Hemlock?", "output": "```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// Called as method - self is bound\nprint(obj.method());  // 10\n\n// Called as function - self is null (error)\nlet f = obj.method;\nprint(f());  // ERROR: self is not defined\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does object type annotations (duck typing) work in Hemlock?", "output": "```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does closing connection work in Hemlock?", "output": "```hemlock\nws.close();\n// Or use defer for automatic cleanup:\ndefer ws.close();\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does 3. no timeout work in Hemlock?", "output": "Commands can run indefinitely:\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// Blocks for 1000 seconds\n// No way to timeout or cancel\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test bitwise operators\n\n// Basic bitwise operations\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\n// AND\nprint(a & b);   // 8  (1000)\n\n// OR\nprint(a | b);   // 14 (1110)\n\n// XOR\nprint(a ^ b);   // 6  (0110)\n\n// Left shift\nprint(a << 2);  // 48 (110000)\n\n// Right shift\nprint(a >> 1);  // 6  (110)\n\n// NOT (bitwise complement) - signed int gives -16 for 15\nlet c = 15;\nprint(~c);        // -16 (for signed i32)\n\n// Combined operations\nprint((5 & 3) | 8);  // 1 | 8 = 9\n\n// Shift with addition\nprint(1 << 3);  // 8\n\nprint(\"done\");\n```", "output": "8\n14\n6\n48\n6\n-16\n9\n8\ndone", "category": "tests/compiler", "source": "tests/compiler/bitwise.hml"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "**1. Long-running services:**\n\n```hemlock\n// Bad\nlet r = exec(\"nginx\");  // Blocks forever\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does 4. platform compatibility work in Hemlock?", "output": "```hemlock\n// Handle platform differences\n// Use appropriate library extensions (.so, .dylib, .dll)\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does async_file_stat work in Hemlock?", "output": "```hemlock\nimport { async_file_stat } from \"@stdlib/async_fs\";\n\nlet future = async_file_stat(\"data.txt\");\nlet stat = future.get();\nprint(\"Size: \" + stat.size);\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does `logger.debug(message, data?)` work in Hemlock?", "output": "```hemlock\nlogger.debug(\"Variable value\", { x: 42, y: 100 });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does exec work in Hemlock?", "output": "```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// Check exit status\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found:\", r.output);\n} else {\n    print(\"Pattern not found\");\n}\n\n// Process multi-line output\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does array basics work in Hemlock?", "output": "```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Modify elements\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does gzip_file(input_path, output_path, level?) -> null work in Hemlock?", "output": "```hemlock\nimport { gzip_file, gunzip_file } from \"@stdlib/compression\";\n\n// Compress file\ngzip_file(\"data.txt\", \"data.txt.gz\");\n\n// Decompress file\ngunzip_file(\"data.txt.gz\", \"data_restored.txt\");\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does âŒ discouraged contributions work in Hemlock?", "output": "**2. RAII/destructors**\n\n```hemlock\n// BAD: This would be rejected\nlet f = open(\"file.txt\");\n// File automatically closed at end of scope\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does safe practices work in Hemlock?", "output": "**4. Avoid exec() for file operations:**\n\n```hemlock\n// Bad - use exec for file operations\nlet r = exec(\"cat file.txt\");\n\n// Good - use Hemlock's file API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test that C keywords can be used as variable names in Hemlock\n// This tests the compiler's identifier sanitization\n\n// Test local variables with C keyword names\nfn test_local_keywords() {\n    let char = \"a\";\n    let float = 3.14;\n    let double = 2.718;\n    let short = 10;\n    let long = 1000000;\n    let signed = -1;\n    let unsigned = 1;\n    let auto = \"automatic\";\n    let register = \"fast\";\n    let volatile = \"changing\";\n    let inline = \"embedded\";\n    let restrict = \"limited\";\n    let sizeof = 8;\n    let typedef = \"alias\";\n    let struct = \"data\";\n    let union = \"combine\";\n    let goto = \"jump\";\n    let static = \"fixed\";\n    let NULL = \"nil\";\n    let main = \"entry\";\n\n    print(char);\n    print(float);\n    print(double);\n    print(short);\n    print(long);\n    print(signed);\n    print(unsigned);\n    print(auto);\n    print(register);\n    print(volatile);\n    print(inline);\n    print(restrict);\n    print(sizeof);\n    print(typedef);\n    print(struct);\n    print(union);\n    print(goto);\n    print(static);\n    print(NULL);\n    print(main);\n}\n\n// Test function parameters with C keyword names\nfn test_param_keywords(char, float, double) {\n    print(char);\n    print(float);\n    print(double);\n}\n\n// Test for-in loop variables with C keyword names\nfn test_for_in_keywords() {\n    let arr = [1, 2, 3];\n    for (let short in arr) {\n        print(short);\n    }\n\n    let obj = { a: 10, b: 20 };\n    for (let char, double in obj) {\n        print(char);\n        print(double);\n    }\n}\n\n// Test catch parameter with C keyword name\nfn test_catch_keyword() {\n    try {\n        throw \"error\";\n    } catch (char) {\n        print(char);\n    }\n}\n\n// Test assignment to keyword-named variables\nfn test_assignment() {\n    let long = 1;\n    long = long + 1;\n    print(long);\n\n    // Test increment\n    let float = 10;\n    float = float + 1;\n    print(float);\n}\n\n// Run all tests\ntest_local_keywords();\ntest_param_keywords(\"x\", 3.5, 2.0);\ntest_for_in_keywords();\ntest_catch_keyword();\ntest_assignment();\n```", "output": "a\n3.14\n2.718\n10\n1000000\n-1\n1\nautomatic\nfast\nchanging\nembedded\nlimited\n8\nalias\ndata\ncombine\njump\nfixed\nnil\nentry\nx\n3.5\n2\n1\n2\n3\na\n10\nb\n20\nerror\n2\n11", "category": "parity/language", "source": "tests/parity/language/c_keyword_names.hml"}
{"instruction": "How do you work with boolean values in Hemlock?", "output": "```hemlock\nlet x = true;\nlet y = false;\n\nprint(x);\nprint(y);\nprint(!x);\nprint(x && y);\nprint(x || y);\n\nlet a = 5;\nlet b = 10;\nprint(a < b && b < 20);\n```", "category": "examples", "source": "examples/bools.hml"}
{"instruction": "How does functions work in Hemlock?", "output": "```hemlock\nimport { matches } from \"@stdlib/regex\";\n\nlet is_valid = matches(\"^[A-Z][a-z]+$\", \"Hello\");\nprint(is_valid);  // true\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does write binary file work in Hemlock?", "output": "```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does reference semantics work in Hemlock?", "output": "```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Shallow copy (same reference)\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (both refer to same object)\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does async_copy_file work in Hemlock?", "output": "```hemlock\nimport { async_copy_file } from \"@stdlib/async_fs\";\n\nlet future = async_copy_file(\"original.txt\", \"backup.txt\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does test organization work in Hemlock?", "output": "5. **Use hooks for setup:**\n\n```hemlock\ndescribe(\"Database\", fn() {\n    let db = null;\n\n    before_each(fn() {\n        db = create_test_db();\n    });\n\n    after_each(fn() {\n        db.destroy();\n    });\n\n    // Tests use db...\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does shared libraries work in Hemlock?", "output": "**Windows:** `.dll` files\n\n```hemlock\nexample.dll\nkernel32.dll\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does extraction operations work in Hemlock?", "output": "**`last()`** - Get last element (without removing):\n\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3 (without removing)\nprint(arr);                  // [1, 2, 3] (unchanged)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does formatting methods work in Hemlock?", "output": "Get the full weekday name.\n\n```hemlock\nlet dt = from_date(2025, 3, 15, 0, 0, 0);  // Saturday\nprint(dt.weekday_name());  // \"Saturday\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does 3. system apis work in Hemlock?", "output": "**Example: POSIX APIs**\n\n```hemlock\n// Call getpid, getuid, etc.\n// Access low-level system functionality\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does 3. unsafe is a feature, not a bug work in Hemlock?", "output": "- Type system prevents accidents but allows footguns when needed\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation - allowed but dangerous\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does pitfall: mutation vs. new array work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\n\n// Mutates original\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// Returns new array\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1] (unchanged)\nprint(sub);  // [3, 2]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does basic pattern work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Show an example of example: sorting with custom comparator in Hemlock.", "output": "```hemlock\nfn sort(arr, compare) {\n    // Bubble sort with custom comparator\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does is_alnum(str) work in Hemlock?", "output": "**Returns:** `bool` - True if all characters are alphanumeric\n\n```hemlock\nimport { is_alnum } from \"@stdlib/strings\";\n\nprint(is_alnum(\"hello123\"));  // true\nprint(is_alnum(\"ABC123\"));    // true\nprint(is_alnum(\"test\"));      // true\nprint(is_alnum(\"123\"));       // true\nprint(is_alnum(\"a1b2c3\"));    // true\n\nprint(is_alnum(\"hello world\"));  // false (space)\nprint(is_alnum(\"test!\"));        // false (punctuation)\nprint(is_alnum(\"a-b\"));          // false (hyphen)\nprint(is_alnum(\"\"));             // false (empty)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does getenv(name) work in Hemlock?", "output": "- Checking feature flags\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\n// Get common environment variables\nlet home = getenv(\"HOME\");\nlet path = getenv(\"PATH\");\nlet user = getenv(\"USER\");\n\nif (home != null) {\n    print(\"Home directory: \" + home);\n} else {\n    print(\"HOME not set\");\n}\n\n// Check if variable exists\nlet debug = getenv(\"DEBUG\");\nif (debug != null) {\n    print(\"Debug mode enabled\");\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does `abort()` work in Hemlock?", "output": "Abort the current process, generating a core dump.\n\n```hemlock\nif (critical_error) {\n    abort();  // Terminates immediately with core dump\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does timeout handling work in Hemlock?", "output": "```hemlock\nimport { TcpStream } from \"@stdlib/net\";\n\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();\n\nstream.set_timeout(5.0);  // 5 second timeout\n\ntry {\n    let data = stream.read(1024);\n    print(\"Received data\");\n} catch (e) {\n    print(\"Timeout or error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Show how to perform file I/O operations in Hemlock.", "output": "```hemlock\n// Hemlock I/O System Demo\n// Demonstrates all I/O features in v0.1\n\nprint(\"=== Hemlock I/O System Demo ===\");\nprint(\"\");\n\n// 1. High-level convenience functions\nprint(\"1. High-level file operations:\");\nwrite_file(\"demo.txt\", \"Hello, Hemlock!\\nThis is a test.\\n\");\nprint(\"  Written to demo.txt\");\n\nlet content = read_file(\"demo.txt\");\nprint(\"  Read from demo.txt:\");\nprint(\"  \" + content);\n\nappend_file(\"demo.txt\", \"Appended line.\\n\");\nprint(\"  Appended to demo.txt\");\n\nif (file_exists(\"demo.txt\")) {\n    print(\"  File exists: true\");\n}\n\nprint(\"\");\n\n// 2. Binary operations\nprint(\"2. Binary file operations:\");\nlet buf = buffer(5);\nbuf[0] = 72;   // 'H'\nbuf[1] = 101;  // 'e'\nbuf[2] = 108;  // 'l'\nbuf[3] = 108;  // 'l'\nbuf[4] = 111;  // 'o'\nwrite_bytes(\"demo.bin\", buf);\nprint(\"  Written binary data\");\n\nlet data = read_bytes(\"demo.bin\");\nprint(\"  Read binary data, length:\");\nprint(data.length);\nfree(buf);\nfree(data);\n\nprint(\"\");\n\n// 3. Low-level file operations\nprint(\"3. Low-level file operations:\");\nlet f = open(\"demo.txt\", \"r\");\nprint(\"  Opened file:\");\nprint(f);\nprint(\"  Mode:\");\nprint(f.mode);\nprint(\"  Closed:\");\nprint(f.closed);\n\nlet pos = f.tell();\nprint(\"  Current position:\");\nprint(pos);\n\nlet chunk = f.read_text(10);\nprint(\"  Read chunk: \" + chunk);\n\nf.seek(0);\nprint(\"  Seeked to beginning\");\n\nlet line = f.read_text(100);\nprint(\"  Read full content: \" + line);\n\nf.close();\nprint(\"  File closed:\");\nprint(f.closed);\n\nprint(\"\");\n\n// 4. Standard streams\nprint(\"4. Standard streams:\");\neprint(\"This message goes to stderr\");\nprint(\"This message goes to stdout\");\n\nprint(\"\");\nprint(\"=== Demo Complete ===\");\nprint(\"(Temporary files: demo.txt, demo.bin)\");\n```", "category": "examples", "source": "examples/io_demo.hml"}
{"instruction": "How does dependencies work in Hemlock?", "output": "```hemlock\n**Install if needed:**\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does 5. prefer hemlock apis over exec() work in Hemlock?", "output": "```hemlock\n// Bad - use exec for file operations\nlet r = exec(\"cat file.txt\");\n\n// Good - use Hemlock's File API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does shutdown_async_fs work in Hemlock?", "output": "```hemlock\nshutdown_async_fs(): null\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does ceil(x) work in Hemlock?", "output": "**Returns:** `f64` - Ceiling of x\n\n```hemlock\nimport { ceil } from \"@stdlib/math\";\n\nlet result = ceil(3.2);   // 4.0\nlet result2 = ceil(-2.7); // -2.0\nlet result3 = ceil(5.0);  // 5.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does boolean literals work in Hemlock?", "output": "```hemlock\nlet t = true;\nlet f = false;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does words(str) work in Hemlock?", "output": "- Returns empty array for empty string or whitespace-only string\n\n```hemlock\nimport { words } from \"@stdlib/strings\";\n\n// Basic word splitting\nlet w1 = words(\"hello world\");\nprint(w1.length);   // 2\nprint(w1[0]);       // \"hello\"\nprint(w1[1]);       // \"world\"\n\n// Multiple words\nlet w2 = words(\"the quick brown fox\");\nprint(w2.length);   // 4\n\n// Extra spaces (filtered out)\nlet w3 = words(\"hello  world\");\nprint(w3.length);   // 2 (not 3)\n\n// Leading/trailing spaces\nlet w4 = words(\"  hello world  \");\nprint(w4.length);   // 2\n\n// Single word\nlet w5 = words(\"hello\");\nprint(w5.length);   // 1\n\n// Empty string\nlet w6 = words(\"\");\nprint(w6.length);   // 0\n\n// Only spaces\nlet w7 = words(\"   \");\nprint(w7.length);   // 0\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does integer â†” rune work in Hemlock?", "output": "Convert between integers and runes to work with codepoint values:\n\n```hemlock\n// Integer to rune (codepoint value)\nlet code: rune = 65;            // 'A' (ASCII 65)\nlet emoji_code: rune = 128640;  // U+1F680 (ðŸš€)\n\n// Rune to integer (get codepoint value)\nlet r = 'Z';\nlet value: i32 = r;             // 90 (ASCII value)\n\nlet rocket = 'ðŸš€';\nlet code: i32 = rocket;         // 128640 (U+1F680)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does comparison methods work in Hemlock?", "output": "Check if this DateTime is before another.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 15, 0, 0, 0);\nlet dt2 = from_date(2025, 1, 20, 0, 0, 0);\n\nif (dt1.is_before(dt2)) {\n    print(\"dt1 is before dt2\");  // This will print\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does operator precedence work in Hemlock?", "output": "```hemlock\nlet x = 2 + 3 * 4;      // 14 (not 20)\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show an example of bitwise examples in Hemlock.", "output": "**With unsigned types:**\n\n```hemlock\nlet c: u8 = 15;   // 00001111 in binary\nlet d: u8 = 7;    // 00000111 in binary\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - in u8\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "**`chars()`** - Convert to array of runes (codepoints):\n\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (array of runes)\n\n// UTF-8 example\nlet text = \"HiðŸš€\";\nlet chars2 = text.chars();      // ['H', 'i', 'ðŸš€']\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does pass-by-value work in Hemlock?", "output": "**Note:** Objects and arrays are passed by reference (the reference is copied), so their contents can be modified:\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // Modifies original array\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99 (modified)\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does comparison operators work in Hemlock?", "output": "```hemlock\nprint(a == b);  // false - Equal\nprint(a != b);  // true  - Not equal\nprint(a > b);   // true  - Greater than\nprint(a < b);   // false - Less than\nprint(a >= b);  // true  - Greater or equal\nprint(a <= b);  // false - Less or equal\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Type conversions test\n// Uses Hemlock's built-in conversion mechanisms\n\n// Implicit numeric conversion\nlet i: i32 = 42;\nlet f: f64 = i;  // i32 to f64\nprint(f);\n\n// String concatenation forces conversion\nlet num = 123;\nlet str = \"\" + num;  // number to string via concat\nprint(str);\nprint(typeof(str));\n\n// Arithmetic promotes types\nlet a: i32 = 5;\nlet b: f64 = 2.5;\nlet c = a + b;  // i32 promoted to f64\nprint(c);\nprint(typeof(c));\n\n// Array length\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);\n\n// String length\nlet text = \"hello\";\nprint(text.length);\n\n// Boolean in string context\nprint(\"value: \" + true);\nprint(\"value: \" + false);\n\n// Division always returns float\nlet x = 7 / 2;     // division always returns float (f64)\nprint(x);\n\nlet y = 7.0 / 2.0; // explicit float division (same result)\nprint(y);\n```", "output": "42\n123\nstring\n7.5\nf64\n5\n5\nvalue: true\nvalue: false\n3.5\n3.5", "category": "parity/language", "source": "tests/parity/language/conversions.hml"}
{"instruction": "How does overview work in Hemlock?", "output": "```hemlock\n// Anonymous object\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// Object with methods\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does type promotion rules work in Hemlock?", "output": "**Promotion Hierarchy:**\n\n```hemlock\nf64 (highest precision)\n â†‘\nf32\n â†‘\nu64\n â†‘\ni64\n â†‘\nu32\n â†‘\ni32\n â†‘\nu16\n â†‘\ni16\n â†‘\nu8\n â†‘\ni8 (lowest)\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does custom headers & authentication work in Hemlock?", "output": "```hemlock\nimport { get } from \"@stdlib/http\";\n\nlet headers = [\n    \"User-Agent: My-App/1.0\",\n    \"Accept: application/json\",\n    \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n];\n\nlet response = get(\"https://api.example.com/protected\", headers);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does runes (unicode codepoints) work in Hemlock?", "output": "```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = 'ðŸš€';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Rune + String concatenation\nlet msg = '>' + \" Important\";\nprint(msg);  // \"> Important\"\n\n// Convert between rune and integer\nlet code: i32 = ch;     // 65 (ASCII code)\nlet r: rune = 128640;   // U+1F680 (ðŸš€)\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does dynamic growth pattern work in Hemlock?", "output": "```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// ... use memory ...\n\n// Need more space - check for failure\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // Original pointer still valid, clean up\n    free(p);\n    panic(\"realloc failed\");\n}\np = new_p;\nsize = 200;\n\n// ... use expanded memory ...\n\nfree(p);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does c-style for work in Hemlock?", "output": "Classic three-part for loop:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does `logger(config?)` work in Hemlock?", "output": "```hemlock\nimport { Logger, DEBUG } from \"@stdlib/logging\";\n\n// Basic logger (stdout, INFO level)\nlet logger1 = Logger();\n\n// Custom configuration\nlet logger2 = Logger({\n    output: \"/var/log/app.log\",\n    level: DEBUG,\n    format: \"[{level}] {message}\",\n    include_timestamp: false\n});\n\n// Don't forget to close file loggers!\ndefer logger2.close();\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does nested objects work in Hemlock?", "output": "```hemlock\nlogger.error(\"API request failed\", {\n    endpoint: \"/api/users\",\n    status: 500,\n    error: {\n        code: \"TIMEOUT\",\n        message: \"Request timed out after 30s\",\n        retry_count: 3\n    }\n});\n\n// Output includes nested JSON\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does color_bg(text, fg, bg) work in Hemlock?", "output": "**Returns:** `string` - Colorized text with reset\n\n```hemlock\nimport { color_bg, WHITE, RED, BG_RED, BG_GREEN } from \"@stdlib/terminal\";\n\nprint(color_bg(\" ERROR \", WHITE, BG_RED));\nprint(color_bg(\" OK \", WHITE, BG_GREEN));\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does overview work in Hemlock?", "output": "```hemlock\n// Array literals\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Mixed types allowed\nlet mixed = [1, \"hello\", true, null];\n\n// Dynamic sizing\narr.push(6);           // Grows automatically\narr.push(7);\nprint(arr.length);     // 7\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does finally block work in Hemlock?", "output": "**Finally with return:**\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // âœ… Returns 1 after finally runs\n    } finally {\n        print(\"cleanup\");  // Runs before returning\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // âš ï¸ Finally return overrides - returns 2\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does functions as variables work in Hemlock?", "output": "```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// Reassign\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does types work in Hemlock?", "output": "Hemlock has a rich type system:\n\n```hemlock\n// Integers\nlet small: i8 = 127;          // 8-bit signed\nlet byte: u8 = 255;           // 8-bit unsigned\nlet num: i32 = 2147483647;    // 32-bit signed (default)\nlet big: i64 = 9223372036854775807;  // 64-bit signed\n\n// Floats\nlet f: f32 = 3.14;            // 32-bit float\nlet d: f64 = 2.71828;         // 64-bit float (default)\n\n// Strings and characters\nlet text: string = \"Hello\";   // UTF-8 string\nlet emoji: rune = 'ðŸš€';       // Unicode codepoint\n\n// Boolean and null\nlet flag: bool = true;\nlet empty = null;\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does path access work in Hemlock?", "output": "Get value by path using dot notation.\n\n```hemlock\nimport { get } from \"@stdlib/json\";\n\nlet doc = {\n    user: {\n        name: \"Alice\",\n        address: { city: \"NYC\", zip: 10001 }\n    },\n    items: [1, 2, 3]\n};\n\n// Nested object access\nlet name = get(doc, \"user.name\");  // \"Alice\"\nlet city = get(doc, \"user.address.city\");  // \"NYC\"\n\n// Array access (numeric indices)\nlet first = get(doc, \"items.0\");  // 1\nlet second = get(doc, \"items.1\");  // 2\n\n// Default value for missing paths\nlet phone = get(doc, \"user.phone\", \"(none)\");  // \"(none)\"\n\n// Empty path returns root\nlet root = get(doc, \"\");  // doc\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does stack operations work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does helper function pattern work in Hemlock?", "output": "```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// Usage:\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does reading elements work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10 (first element)\nprint(arr[4]);  // 50 (last element)\n\n// Out of bounds returns null (no error)\nprint(arr[10]);  // null\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does function parameter annotations work in Hemlock?", "output": "```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hello, \" + name + \"!\");\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does async_read_file work in Hemlock?", "output": "```hemlock\nasync_read_file(path: string): Future<string>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test reduce() - accumulate values into single result\n\n// Basic reduce - sum\nlet nums = [1, 2, 3, 4, 5];\nlet sum = nums.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(sum);  // 15\n\n// Reduce without initial value - uses first element\nlet sum2 = [10, 20, 30].reduce(fn(acc, x) {\n    return acc + x;\n});\nprint(sum2);  // 60\n\n// Reduce - product\nlet product = [1, 2, 3, 4, 5].reduce(fn(acc, x) {\n    return acc * x;\n}, 1);\nprint(product);  // 120\n\n// Reduce - find maximum\nlet max = [3, 7, 2, 9, 5].reduce(fn(acc, x) {\n    if (x > acc) {\n        return x;\n    } else {\n        return acc;\n    }\n}, 0);\nprint(max);  // 9\n\n// Reduce - concatenate strings\nlet words = [\"Hello\", \"world\", \"from\", \"Hemlock\"];\nlet sentence = words.reduce(fn(acc, word) {\n    return acc + \" \" + word;\n}, \"\");\nprint(sentence.trim());  // Hello world from Hemlock\n\n// Reduce with single element array\nlet single = [42].reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(single);  // 42\n\n// Reduce with single element, no initial value\nlet single2 = [42].reduce(fn(acc, x) {\n    return acc + x;\n});\nprint(single2);  // 42 (first element becomes accumulator)\n\n// Reduce - count occurrences\nlet items = [1, 2, 1, 3, 2, 1];\nlet count_ones = items.reduce(fn(count, x) {\n    if (x == 1) {\n        return count + 1;\n    } else {\n        return count;\n    }\n}, 0);\nprint(count_ones);  // 3\n\n// Reduce with closure\nlet multiplier = 2;\nlet result = [1, 2, 3].reduce(fn(acc, x) {\n    return acc + (x * multiplier);\n}, 0);\nprint(result);  // 12 (2+4+6)\n\n// Reduce preserves original array\nlet original = [1, 2, 3];\nlet reduced = original.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(original.length);  // 3 (unchanged)\nprint(reduced);  // 6\n\n// Reduce - build new array (flatten)\nlet nested = [1, 2, 3];\nlet doubled_via_reduce = nested.reduce(fn(acc, x) {\n    acc.push(x * 2);\n    return acc;\n}, []);\nprint(doubled_via_reduce[0]);  // 2\nprint(doubled_via_reduce[1]);  // 4\nprint(doubled_via_reduce[2]);  // 6\n\n// Reduce to accumulate string length\nlet strings = [\"a\", \"bb\", \"ccc\"];\nlet total_len = strings.reduce(fn(acc, s) {\n    return acc + s.length;\n}, 0);\nprint(total_len);  // 6\n```", "output": "15\n60\n120\n9\nHello world from Hemlock\n42\n42\n3\n12\n3\n6\n2\n4\n6\n6", "category": "tests/arrays", "source": "tests/arrays/reduce.hml"}
{"instruction": "How does memory functions work in Hemlock?", "output": "```hemlock\n// Reallocate\nlet p = alloc(64);\np = realloc(p, 128);  // Resize to 128 bytes\nfree(p);\n\n// Typed allocation (future)\n// let arr = talloc(i32, 100);  // Array of 100 i32s\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does memory management work in Hemlock?", "output": "**Memory leak example:**\n\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // New allocation\n    // s2 never freed - memory leak\n}\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\nimport { get, post, fetch } from \"@stdlib/http\";\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does empty objects work in Hemlock?", "output": "```hemlock\nlet obj = {};  // Empty object\n\n// Add fields later\nobj.name = \"Alice\";\nobj.age = 30;\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does async_rename work in Hemlock?", "output": "```hemlock\nimport { async_rename } from \"@stdlib/async_fs\";\n\nlet future = async_rename(\"old_name.txt\", \"new_name.txt\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does `kill(pid: i32, signal: i32)` work in Hemlock?", "output": "Send a signal to a process.\n\n```hemlock\n// Send SIGTERM (15) to process\nkill(target_pid, 15);\n\n// Send signal 0 to check if process exists\ntry {\n    kill(target_pid, 0);\n    print(\"Process exists\");\n} catch (e) {\n    print(\"Process does not exist\");\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does clone & merge work in Hemlock?", "output": "Create deep copy of value (independent copy).\n\n```hemlock\nimport { clone } from \"@stdlib/json\";\n\nlet original = { x: 10, items: [1, 2, 3] };\nlet copy = clone(original);\n\ncopy.x = 20;\ncopy.items.push(4);\n\nprint(original.x);  // 10 (unchanged)\nprint(original.items.length);  // 3 (unchanged)\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does uptime() work in Hemlock?", "output": "- Performance logging\n\n```hemlock\nimport { uptime } from \"@stdlib/os\";\n\nlet up = uptime();\nlet days = up / 86400;\nlet hours = (up % 86400) / 3600;\nlet minutes = (up % 3600) / 60;\n\nprint(\"System uptime: \" + typeof(days) + \" days, \" + typeof(hours) + \" hours, \" + typeof(minutes) + \" minutes\");\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does when you need `free()` vs when it's automatic work in Hemlock?", "output": "**Automatic (no `free()` needed):** Local variables of refcounted types are freed when scope exits:\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... use them ...\n}  // All automatically freed when function returns - no free() needed\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does resource management work in Hemlock?", "output": "Always use `defer` to ensure sockets are closed:\n\n```hemlock\nlet listener = TcpListener(\"0.0.0.0\", 8080);\ndefer listener.close();  // Guaranteed cleanup\n\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();    // Guaranteed cleanup\n\nlet sock = UdpSocket(\"0.0.0.0\", 5000);\ndefer sock.close();      // Guaranteed cleanup\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does `logger.error(message, data?)` work in Hemlock?", "output": "```hemlock\nlogger.error(\"Database error\", { code: 500, message: \"Connection timeout\" });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does `buffer` - safe wrapper (recommended) work in Hemlock?", "output": "```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100 (current size)\nprint(buf.capacity);    // 100 (allocated capacity)\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does memset work in Hemlock?", "output": "```hemlock\nlet p = alloc(100);\n\n// Zero out memory\nmemset(p, 0, 100);\n\n// Fill with specific value\nmemset(p, 0xFF, 100);\n\n// Initialize buffer\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Fill with 'A'\n\nfree(p);\nfree(buf);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does serialize to json work in Hemlock?", "output": "Convert objects to JSON strings:\n\n```hemlock\n// obj.serialize() - Convert object to JSON string\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Nested objects\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does pow(base, exponent) work in Hemlock?", "output": "**Returns:** `f64` - base^exponent\n\n```hemlock\nimport { pow } from \"@stdlib/math\";\n\nlet result = pow(2.0, 3.0);   // 8.0\nlet result2 = pow(10.0, 2.0); // 100.0\nlet result3 = pow(4.0, 0.5);  // 2.0 (square root)\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does async_file_stat work in Hemlock?", "output": "```hemlock\nasync_file_stat(path: string): Future<object>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test unprefixed builtin aliases\n\n// Math functions (using direct function call)\nprint(sin(0.0));\nprint(cos(0.0));\nprint(sqrt(4.0));\nprint(floor(3.7));\nprint(ceil(2.3));\nprint(round(2.5));\n\n// Test pow\nprint(pow(2.0, 3.0));\n\n// Test log functions\nprint(log(1.0));\nprint(log10(100.0));\nprint(log2(8.0));\n\n// Test atan2\nprint(atan2(1.0, 1.0));\n\n// Environment functions\nlet test_var = getenv(\"PATH\");\nif (test_var != null) {\n    print(\"PATH exists\");\n} else {\n    print(\"PATH not found\");\n}\n\n// get_pid should return a positive integer\nlet pid = get_pid();\nif (pid > 0) {\n    print(\"PID is positive\");\n}\n\nprint(\"done\");\n```", "output": "0\n1\n2\n3\n3\n3\n8\n0\n2\n3\n0.785398\nPATH exists\nPID is positive\ndone", "category": "tests/compiler", "source": "tests/compiler/unprefixed_builtins.hml"}
{"instruction": "How does pitfall: direct index out of bounds work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\n\n// No bounds checking!\narr[10] = 99;  // Creates sparse array with nulls\nprint(arr.length);  // 11 (not 3!)\n\n// Better: Use push() or check length\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All fs functions use exception-based error handling:\n\n```hemlock\nimport { read_file, write_file } from \"@stdlib/fs\";\n\ntry {\n    let content = read_file(\"config.json\");\n    // Process content...\n    write_file(\"output.json\", content);\n} catch (e) {\n    print(\"Filesystem error: \" + e);\n    // e contains descriptive error message with filename\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as hash from \"@stdlib/hash\";\nlet checksum = hash.sha256(\"data\");\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does with error handling (recommended) work in Hemlock?", "output": "Use `finally` to ensure files are closed even on errors:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Always close, even on error\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test FFI callbacks in compiled Hemlock\n// This test verifies that callback(), callback_free(), and ptr helpers work\n\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Comparison function for integers (ascending order)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) {\n        return -1;\n    }\n    if (va > vb) {\n        return 1;\n    }\n    return 0;\n}\n\n// Test qsort with callback\nfn test_qsort() {\n    print(\"Testing qsort with FFI callback (compiled)...\");\n\n    // Allocate array of 5 integers (4 bytes each)\n    let arr = alloc(20);  // 5 * 4 bytes\n\n    // Initialize array: [5, 2, 8, 1, 9]\n    ptr_write_i32(arr, 5);\n    ptr_write_i32(ptr_offset(arr, 1, 4), 2);\n    ptr_write_i32(ptr_offset(arr, 2, 4), 8);\n    ptr_write_i32(ptr_offset(arr, 3, 4), 1);\n    ptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n    // Create callback from comparison function\n    let cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\n\n    // Sort the array\n    qsort(arr, 5, 4, cmp);\n\n    // Verify sorted order: [1, 2, 5, 8, 9]\n    let sorted = true;\n    let i = 0;\n    while (i < 4) {\n        let current = ptr_deref_i32(ptr_offset(arr, i, 4));\n        let next = ptr_deref_i32(ptr_offset(arr, i + 1, 4));\n        if (current > next) {\n            sorted = false;\n        }\n        i = i + 1;\n    }\n\n    if (sorted) {\n        print(\"PASS: Array is sorted correctly\");\n    } else {\n        print(\"FAIL: Array is not sorted correctly\");\n        // Print the array for debugging\n        i = 0;\n        while (i < 5) {\n            let val = ptr_deref_i32(ptr_offset(arr, i, 4));\n            print(`  arr[${i}] = ${val}`);\n            i = i + 1;\n        }\n    }\n\n    // Clean up\n    callback_free(cmp);\n    free(arr);\n\n    return sorted;\n}\n\n// Run test\nlet result = test_qsort();\nif (result) {\n    print(\"All FFI callback tests passed!\");\n} else {\n    print(\"FFI callback tests FAILED\");\n}\n```", "output": "Testing qsort with FFI callback (compiled)...\nPASS: Array is sorted correctly\nAll FFI callback tests passed!", "category": "parity/builtins", "source": "tests/parity/builtins/ffi_callback.hml"}
{"instruction": "How does object type work in Hemlock?", "output": "```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Add field dynamically\nperson.email = \"alice@example.com\";\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Show an example of bitwise examples in Hemlock.", "output": "**Type preservation:**\n\n```hemlock\n// Bitwise operations preserve the type of operands\nlet x: u8 = 255;\nlet result = ~x;  // result is u8 with value 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 is i32 with value 400\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does json deserialization work in Hemlock?", "output": "```hemlock\nstring.deserialize(): any\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1 (not found)\nlet pos3 = s.find(\"l\");         // 2 (first 'l')\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does clean build work in Hemlock?", "output": "```hemlock\nRebuild from scratch:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does pitfall: type confusion work in Hemlock?", "output": "```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// ERROR: Missing required field 'y'\nlet p: Point = obj;\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does expect(value) work in Hemlock?", "output": "Create an expectation object for assertions. Returns an object with assertion methods.\n\n```hemlock\ntest(\"expect API\", fn() {\n    expect(42).to_equal(42);\n    expect(\"hello\").to_contain(\"ell\");\n    expect(true).to_be_true();\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How do you print a number in Hemlock?", "output": "```hemlock\nlet message = 42;\nprint(message);\n```", "category": "examples", "source": "examples/42.hml"}
{"instruction": "How does integer literals work in Hemlock?", "output": "```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // Auto i64\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show an example of example 4: dynamic log level in Hemlock.", "output": "```hemlock\nimport { Logger, DEBUG, INFO, getenv } from \"@stdlib/logging\";\nimport { getenv } from \"@stdlib/env\";\n\n// Set log level from environment variable\nlet log_level = INFO;\nlet env_level = getenv(\"LOG_LEVEL\");\n\nif (env_level == \"DEBUG\") {\n    log_level = DEBUG;\n}\n\nlet logger = Logger({ level: log_level });\n\nlogger.debug(\"This shows only if LOG_LEVEL=DEBUG\");\nlogger.info(\"This always shows\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does ecdsa_verify(data: string, signature: buffer, keypair: ecdsakeypair): bool work in Hemlock?", "output": "Verify ECDSA signature with public key using SHA-256 digest.\n\n```hemlock\nimport { ecdsa_verify } from \"@stdlib/crypto\";\n\nlet valid = ecdsa_verify(data, signature, keypair);\n\nif (valid) {\n    print(\"âœ“ Signature is valid\");\n} else {\n    print(\"âœ— Signature is invalid\");\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test: Arguments passed to spawn are deep-copied for thread isolation\n// Modifications in the spawned task should NOT affect the parent's copy\n\nasync fn modify_array(arr: array): array {\n    // Modify the array in the task\n    arr.push(999);\n    arr[0] = -1;\n    return arr;\n}\n\nasync fn modify_object(obj: object): object {\n    // Modify the object in the task\n    obj.modified = true;\n    obj.value = 42;\n    return obj;\n}\n\n// Test 1: Array isolation\nlet original_arr = [1, 2, 3];\nlet t1 = spawn(modify_array, original_arr);\nlet modified_arr = join(t1);\n\n// Original should be unchanged\nprint(original_arr.length);  // Should be 3\nprint(original_arr[0]);      // Should be 1\n\n// Modified should have changes\nprint(modified_arr.length);  // Should be 4\nprint(modified_arr[0]);      // Should be -1\n\n// Test 2: Object isolation\nlet original_obj = { value: 10, name: \"test\" };\nlet t2 = spawn(modify_object, original_obj);\nlet modified_obj = join(t2);\n\n// Original should be unchanged\nprint(original_obj.value);  // Should be 10\n\n// Modified should have changes\nprint(modified_obj.value);  // Should be 42\nprint(modified_obj.modified);  // Should be true\n\n// Test 3: Nested object isolation\nasync fn modify_nested(data: object): object {\n    data.inner.count = 100;\n    return data;\n}\n\nlet nested = { inner: { count: 0 } };\nlet t3 = spawn(modify_nested, nested);\nlet modified_nested = join(t3);\n\n// Original nested data should be unchanged\nprint(nested.inner.count);  // Should be 0\n\n// Modified should have changes\nprint(modified_nested.inner.count);  // Should be 100\n\nprint(\"All isolation tests passed!\");\n```", "output": "3\n1\n4\n-1\n10\n42\ntrue\n0\n100\nAll isolation tests passed!", "category": "tests/async", "source": "tests/async/test_argument_isolation.hml"}
{"instruction": "How does when to use type annotations work in Hemlock?", "output": "- Enforcing constraints (e.g., range checks)\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // Implementation\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does difference methods work in Hemlock?", "output": "Get the difference in minutes.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 1, 12, 0, 0);\nlet dt2 = from_date(2025, 1, 1, 12, 30, 0);\n\nlet diff = dt2.diff_minutes(dt1);\nprint(diff);  // 30\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "```hemlock\nlet func = fn(params) {\n    // body\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does sqrt(x) work in Hemlock?", "output": "**Returns:** `f64` - Square root of x\n\n```hemlock\nimport { sqrt } from \"@stdlib/math\";\n\nlet result = sqrt(16.0);  // 4.0\nlet result2 = sqrt(2.0);  // 1.414213...\nlet result3 = sqrt(0.0);  // 0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does phase 2: syntax analysis (parser) work in Hemlock?", "output": "**Implementation:** `src/parser.c`\n\n```hemlock\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   â†“\nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "How does array type work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Show an example of example: array deduplication in Hemlock.", "output": "```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does generate_aes_key(): buffer work in Hemlock?", "output": "Generate a secure 256-bit (32-byte) AES key.\n\n```hemlock\nimport { generate_aes_key } from \"@stdlib/crypto\";\n\nlet key = generate_aes_key();\nprint(key.length);  // 32 bytes\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does rand() work in Hemlock?", "output": "**Returns:** `f64` - Random value in [0.0, 1.0)\n\n```hemlock\nimport { rand } from \"@stdlib/math\";\n\nlet random = rand();  // e.g., 0.7382491...\nlet random2 = rand(); // e.g., 0.2194837...\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does `getppid(): i32` work in Hemlock?", "output": "Get the parent process ID.\n\n```hemlock\nlet ppid = getppid();\nprint(\"Parent PID: \" + typeof(ppid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test: High concurrency stress test\n// Spawns 100 concurrent tasks to test thread safety\n\nasync fn compute_sum(start: i32, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        sum = sum + (start + i);\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn 100 tasks\nlet num_tasks = 100;\nlet tasks = [];\nlet i = 0;\n\nwhile (i < num_tasks) {\n    let task = spawn(compute_sum, i * 100, 100);\n    tasks.push(task);\n    i = i + 1;\n}\n\n// Join all tasks and compute total\nlet total = 0;\ni = 0;\nwhile (i < tasks.length) {\n    let result = join(tasks[i]);\n    total = total + result;\n    i = i + 1;\n}\n\nprint(\"Completed:\");\nprint(num_tasks);\nprint(\"Total sum:\");\nprint(total);\n```", "output": "Completed:\n100\nTotal sum:\n504950", "category": "tests/async", "source": "tests/async/stress_concurrent_tasks.hml"}
{"instruction": "How does concatenation work in Hemlock?", "output": "Use `+` to concatenate strings:\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// With variables\nlet name = \"Alice\";\nlet msg = \"Hi, \" + name + \"!\";  // \"Hi, Alice!\"\n\n// With runes (see Runes documentation)\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does good use cases work in Hemlock?", "output": "**1. Running system utilities:**\n\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does exists(path) work in Hemlock?", "output": "**Returns:** `bool` - True if path exists, false otherwise\n\n```hemlock\nimport { exists } from \"@stdlib/fs\";\n\nif (exists(\"/etc/passwd\")) {\n    print(\"File exists\");\n}\n\nif (!exists(\"missing.txt\")) {\n    print(\"File does not exist\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test enum with typed variable\n\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet color: Color = Color.RED;\nprint(color);\n\ncolor = Color.BLUE;\nprint(color);\n```", "output": "0\n2", "category": "tests/enums", "source": "tests/enums/typed_variable.hml"}
{"instruction": "How does async_remove_file work in Hemlock?", "output": "```hemlock\nasync_remove_file(path: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does syntax work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error, e contains the thrown value\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All functions that can fail throw exceptions:\n\n```hemlock\ntry {\n    let result = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Execution failed: \" + e);\n}\n\ntry {\n    kill(99999, 15);  // Non-existent PID\n} catch (e) {\n    print(\"Could not signal process: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does safety tools provided work in Hemlock?", "output": "**4. Runtime type checking:**\n\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // Safe to use as integer\n}\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test datetime builtins\n\n// Get current timestamp\nlet ts = now();\nprint(ts > 0);\n\n// localtime - convert timestamp to time object\nlet local = localtime(ts);\nprint(local.year >= 2024);\nprint(local.month >= 1 && local.month <= 12);\nprint(local.day >= 1 && local.day <= 31);\nprint(local.hour >= 0 && local.hour <= 23);\nprint(local.minute >= 0 && local.minute <= 59);\nprint(local.second >= 0 && local.second <= 60);\n\n// gmtime - convert timestamp to UTC time object\nlet utc = gmtime(ts);\nprint(utc.year >= 2024);\nprint(utc.month >= 1 && utc.month <= 12);\n\n// mktime - convert time object back to timestamp\nlet ts2 = mktime(local);\nprint(ts2 > 0);\n\n// strftime - format time\nlet formatted = strftime(\"%Y\", local);\nprint(formatted.length == 4);\n\n// Test with fixed timestamp (2024-01-01 00:00:00 UTC approximately)\nlet fixed_ts = 1704067200;\nlet fixed_local = gmtime(fixed_ts);\nprint(fixed_local.year == 2024);\nprint(fixed_local.month == 1);\nprint(fixed_local.day == 1);\n\nprint(\"done\");\n```", "output": "true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/datetime.hml"}
{"instruction": "How does .length work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"ðŸš€\";\nprint(emoji.length);    // 1 (one codepoint)\n\nlet text = \"Hello ðŸŒ!\";\nprint(text.length);     // 8 (7 ASCII + 1 emoji)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does optional fields work in Hemlock?", "output": "```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // Optional with default\n    timeout?: i32,     // Optional, defaults to null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false (default)\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true (overridden)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does deserialize from json work in Hemlock?", "output": "Parse JSON strings back to objects:\n\n```hemlock\n// json.deserialize() - Parse JSON string to object\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does directory structure work in Hemlock?", "output": "After building, your Hemlock directory will look like this:\n\n```hemlock\nhemlock/\nâ”œâ”€â”€ hemlock           # Compiled interpreter executable\nâ”œâ”€â”€ src/              # Source code\nâ”œâ”€â”€ include/          # Header files\nâ”œâ”€â”€ tests/            # Test suite\nâ”œâ”€â”€ examples/         # Example programs\nâ”œâ”€â”€ docs/             # Documentation\nâ”œâ”€â”€ stdlib/           # Standard library\nâ”œâ”€â”€ Makefile          # Build configuration\nâ””â”€â”€ README.md         # Project README\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does is_secure_url work in Hemlock?", "output": "Check if URL uses secure WebSocket:\n\n```hemlock\nimport { is_secure_url } from \"@stdlib/websocket\";\n\nif (is_secure_url(\"wss://example.com\")) {\n    print(\"Secure connection\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does compiled regex (reusable) work in Hemlock?", "output": "```hemlock\nimport { compile } from \"@stdlib/regex\";\n\n// Compile pattern once\nlet email_pattern = compile(\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\");\n\n// Reuse for multiple tests\nprint(email_pattern.test(\"user@example.com\"));    // true\nprint(email_pattern.test(\"invalid.email\"));       // false\nprint(email_pattern.test(\"another@test.org\"));    // true\n\n// Must manually free when done\nemail_pattern.free();\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How do you read and write files in Hemlock?", "output": "Use the `open()` function with mode strings:\n\n```hemlock\n// Read file\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Write file\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, World!\");\nf.close();\n\n// Append to file\nlet f = open(\"log.txt\", \"a\");\nf.write(\"New entry\\n\");\nf.close();\n\n// Modes: r, w, a, r+, w+, a+\n```\n\nOr use the fs stdlib module:\n\n```hemlock\nimport { read_file, write_file } from \"@stdlib/fs\";\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n```", "category": "concepts/io", "source": "CLAUDE.md"}
{"instruction": "How does object literals work in Hemlock?", "output": "```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does catch block work in Hemlock?", "output": "The catch block receives the thrown value:\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Caught: \" + error);  // error = \"oops\"\n    // error only accessible here\n}\n// error not accessible here\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Hash functions test\nimport { sha256, sha512, md5 } from \"@stdlib/hash\";\n\n// SHA256\nprint(sha256(\"hello\"));\nprint(sha256(\"\"));\nprint(sha256(\"The quick brown fox\"));\n\n// SHA512\nprint(sha512(\"hello\").slice(0, 32));  // First 32 chars to keep output manageable\n\n// MD5\nprint(md5(\"hello\"));\nprint(md5(\"\"));\n```", "output": "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n5cac4f980fedc3d3f1f99b4be3472c9b30d56523e632d151237ec9309048bda9\n9b71d224bd62f3785d96d46ad3ea3d73\n5d41402abc4b2a76b9719d911017c592\nd41d8cd98f00b204e9800998ecf8427e", "category": "parity/modules", "source": "tests/parity/modules/stdlib_hash.hml"}
{"instruction": "How does status code helpers work in Hemlock?", "output": "Check if status code indicates success (200-299).\n\n```hemlock\nimport { get, is_success } from \"@stdlib/http\";\n\nlet response = get(\"https://example.com\", null);\nif (is_success(response.status_code)) {\n    print(\"Success!\");\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does stack operations work in Hemlock?", "output": "```hemlock\narray.push(value: any): null\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test modulo in complex expressions\n\n// Modulo with addition/subtraction\nlet a = 10 % 3 + 5;\nprint(a);  // 6 (1 + 5)\n\nlet b = 20 - 15 % 4;\nprint(b);  // 17 (20 - 3)\n\n// Modulo with multiplication (same precedence, left-to-right)\nlet c = 10 * 3 % 7;\nprint(c);  // 2 (30 % 7)\n\nlet d = 20 % 3 * 4;\nprint(d);  // 8 (2 * 4)\n\n// Modulo with division (same precedence, left-to-right)\nlet e = 20 / 3 % 5;\nprint(e);  // 1 (6 % 5)\n\nlet f = 20 % 7 / 2;\nprint(f);  // 3 (6 / 2)\n\n// Parentheses\nlet g = 20 % (3 + 2);\nprint(g);  // 0 (20 % 5)\n\nlet h = (20 + 5) % 7;\nprint(h);  // 4 (25 % 7)\n```", "output": "6\n17\n2\n8\n1\n3\n0\n4", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_expressions.hml"}
{"instruction": "How does channel work in Hemlock?", "output": "```hemlock\nchannel(capacity: i32): channel\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How do you use defer in Hemlock?", "output": "`defer` schedules code to run when the function returns:\n\n```hemlock\nfn process_file(path: string) {\n    let f = open(path, \"r\");\n    defer f.close();  // runs when function returns\n    \n    // ... work with file ...\n    \n    if (error) {\n        return;  // f.close() still runs\n    }\n    \n    // f.close() runs here too\n}\n```\n\nDeferred statements run in reverse order (LIFO).", "category": "concepts/defer", "source": "CLAUDE.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test: Exception breaks out of loop\nlet i = 0;\ntry {\n    while (i < 10) {\n        print(i);\n        i = i + 1;\n        if (i == 3) {\n            throw \"break at 3\";\n        }\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\nprint(\"Final i: \" + typeof(i));\n```", "output": "0\n1\n2\nCaught: break at 3\nFinal i: i32", "category": "tests/exceptions", "source": "tests/exceptions/exception_in_loop.hml"}
{"instruction": "How does arrays work in Hemlock?", "output": "Dynamic arrays with mixed types:\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Array methods\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// Mixed types allowed\nlet mixed = [1, \"two\", true, null];\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test map, filter, and reduce array methods\n\n// Basic map\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) { return x * 2; });\nprint(doubled[0]);\nprint(doubled[1]);\nprint(doubled[2]);\nprint(doubled[3]);\nprint(doubled[4]);\n\n// Map with multiplication\nlet indexed = nums.map(fn(x) { return x * 10; });\nprint(indexed.join(\",\"));\n\n// Basic filter\nlet filtered = nums.filter(fn(x) { return x > 2; });\nprint(filtered.length);\nprint(filtered[0]);\nprint(filtered[1]);\nprint(filtered[2]);\n\n// Filter even numbers\nlet evens = nums.filter(fn(x) { return x % 2 == 0; });\nprint(evens.join(\",\"));\n\n// Filter odd numbers\nlet odds = nums.filter(fn(x) { return x % 2 != 0; });\nprint(odds.join(\",\"));\n\n// Basic reduce (sum)\nlet sum = nums.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);\n\n// Reduce (product)\nlet product = nums.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);\n\n// Reduce to find max\nlet max = nums.reduce(fn(acc, x) { return acc > x ? acc : x; }, nums[0]);\nprint(max);\n\n// Reduce to find min\nlet min = nums.reduce(fn(acc, x) { return acc < x ? acc : x; }, nums[0]);\nprint(min);\n\n// Chained operations: filter then map\nlet processed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })\n    .map(fn(x) { return x * x; });\nprint(processed.join(\",\"));\n\n// Map then reduce\nlet sumOfSquares = [1, 2, 3, 4]\n    .map(fn(x) { return x * x; })\n    .reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sumOfSquares);\n\n// Filter with objects\nlet people = [\n    { name: \"Alice\", age: 30 },\n    { name: \"Bob\", age: 25 },\n    { name: \"Charlie\", age: 35 }\n];\n\nlet adults = people.filter(fn(p) { return p.age >= 30; });\nprint(adults.length);\nprint(adults[0].name);\nprint(adults[1].name);\n\n// Map to extract property\nlet names = people.map(fn(p) { return p.name; });\nprint(names.join(\", \"));\n\n// Reduce to sum ages\nlet totalAge = people.reduce(fn(acc, p) { return acc + p.age; }, 0);\nprint(totalAge);\n\n// Empty array handling\nlet empty = [];\nlet emptyMapped = empty.map(fn(x) { return x * 2; });\nprint(emptyMapped.length);\n\nlet emptyFiltered = empty.filter(fn(x) { return true; });\nprint(emptyFiltered.length);\n\nlet emptyReduced = empty.reduce(fn(acc, x) { return acc + x; }, 42);\nprint(emptyReduced);\n\nprint(\"done\");\n```", "output": "2\n4\n6\n8\n10\n10,20,30,40,50\n3\n3\n4\n5\n2,4\n1,3,5\n15\n120\n5\n1\n4,16,36,64,100\n30\n2\nAlice\nCharlie\nAlice, Bob, Charlie\n90\n0\n0\n42\ndone", "category": "parity/methods", "source": "tests/parity/methods/map_filter_reduce.hml"}
{"instruction": "How does exception handling patterns work in Hemlock?", "output": "**Pattern 2: Propagate to caller**\n\n```hemlock\nasync fn task_that_throws() {\n    throw \"error\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Caught from task: \" + e);\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test filesystem builtins\n\nlet test_dir = \"/tmp/hemlock_fs_test\";\nlet test_file = \"/tmp/hemlock_fs_test/test.txt\";\n\n// Clean up any previous test artifacts\nif (exists(test_dir)) {\n    if (exists(test_file)) {\n        remove_file(test_file);\n    }\n    remove_dir(test_dir);\n}\n\n// Test cwd() - returns current working directory\nlet current = cwd();\nprint(typeof(current) == \"string\");  // true\nprint(current.length > 0);  // true\n\n// Test exists() - check if path exists\nprint(exists(\"/tmp\"));  // true\nprint(exists(\"/nonexistent_path_12345\"));  // false\n\n// Test is_dir()\nprint(is_dir(\"/tmp\"));  // true\nprint(is_dir(\"/etc/passwd\"));  // false (it's a file)\n\n// Test is_file()\nprint(is_file(\"/etc/passwd\"));  // true\nprint(is_file(\"/tmp\"));  // false (it's a directory)\n\n// Test make_dir()\nmake_dir(test_dir);\nprint(exists(test_dir));  // true\nprint(is_dir(test_dir));  // true\n\n// Test write_file()\nwrite_file(test_file, \"Hello, World!\");\nprint(exists(test_file));  // true\nprint(is_file(test_file));  // true\n\n// Test read_file()\nlet content = read_file(test_file);\nprint(content == \"Hello, World!\");  // true\n\n// Test append_file()\nappend_file(test_file, \"\\nGoodbye!\");\nlet updated = read_file(test_file);\nprint(updated == \"Hello, World!\\nGoodbye!\");  // true\n\n// Test copy_file()\nlet copy_path = \"/tmp/hemlock_fs_test/copy.txt\";\ncopy_file(test_file, copy_path);\nprint(exists(copy_path));  // true\nlet copied = read_file(copy_path);\nprint(copied == updated);  // true\n\n// Test rename()\nlet renamed_path = \"/tmp/hemlock_fs_test/renamed.txt\";\nrename(copy_path, renamed_path);\nprint(exists(renamed_path));  // true\nprint(exists(copy_path));  // false\n\n// Test list_dir()\nlet entries = list_dir(test_dir);\nprint(entries.length == 2);  // true (test.txt and renamed.txt)\n\n// Test file_stat()\nlet stat = file_stat(test_file);\nprint(stat.size > 0);  // true\nprint(stat.is_file == true);  // true\nprint(stat.is_dir == false);  // true\n\n// Test absolute_path()\nlet abs = absolute_path(test_file);\nprint(abs.starts_with(\"/\"));  // true\n\n// Test chdir()\nlet original_dir = cwd();\nchdir(\"/tmp\");\nprint(cwd() == \"/tmp\");  // true\nchdir(original_dir);  // restore\n\n// Clean up\nremove_file(test_file);\nremove_file(renamed_path);\nremove_dir(test_dir);\nprint(exists(test_dir));  // false\n\nprint(\"All filesystem tests passed!\");\n```", "output": "true\ntrue\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nAll filesystem tests passed!", "category": "tests/compiler", "source": "tests/compiler/filesystem.hml"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "**`byte_at(index)`** - Get byte value at index (returns u8):\n\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII value of 'h')\n\n// UTF-8 example\nlet emoji = \"ðŸš€\";\nlet first_byte = emoji.byte_at(0);  // 240 (first UTF-8 byte)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does import immutability work in Hemlock?", "output": "Imported bindings cannot be reassigned:\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // ERROR: cannot reassign imported binding\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does ssl/tls support work in Hemlock?", "output": "Secure WebSocket (wss://) is fully supported:\n\n```hemlock\n// Connects with SSL/TLS\nlet ws = WebSocket(\"wss://secure.example.com/api\");\ndefer ws.close();\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does command injection work in Hemlock?", "output": "The `exec()` function executes commands via the shell, which can be dangerous with untrusted input:\n\n```hemlock\n// âŒ UNSAFE - vulnerable to command injection\nlet user_input = \"file.txt; rm -rf /\";\nlet result = exec(\"cat \" + user_input);\n\n// âœ… SAFE - validate/sanitize input\nfn safe_exec(filename: string) {\n    // Validate filename contains only safe characters\n    let i = 0;\n    while (i < filename.length) {\n        let ch = filename[i];\n        if (!(ch >= 'a' && ch <= 'z') &&\n            !(ch >= 'A' && ch <= 'Z') &&\n            !(ch >= '0' && ch <= '9') &&\n            ch != '.' && ch != '_' && ch != '-') {\n            throw \"Invalid filename\";\n        }\n        i = i + 1;\n    }\n    return exec(\"cat \" + filename);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does pattern: array as stack work in Hemlock?", "output": "```hemlock\nlet stack = [];\n\n// Push onto stack\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop from stack\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test modulo with negative numbers (C-style modulo)\n\n// Negative dividend\nlet a = -10 % 3;\nprint(a);  // -1 (C-style: sign follows dividend)\n\nlet b = -15 % 4;\nprint(b);  // -3\n\n// Negative divisor\nlet c = 10 % -3;\nprint(c);  // 1\n\nlet d = 15 % -4;\nprint(d);  // 3\n\n// Both negative\nlet e = -10 % -3;\nprint(e);  // -1\n\nlet f = -15 % -4;\nprint(f);  // -3\n```", "output": "-1\n-3\n1\n3\n-1\n-3", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_signed.hml"}
{"instruction": "How does throwing error objects work in Hemlock?", "output": "Create structured error information:\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"File does not exist\"\n        };\n    }\n    // ... read file\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"File not found: \" + e.path);\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does words(str) work in Hemlock?", "output": "**Use case - word counting:**\n\n```hemlock\nimport { words } from \"@stdlib/strings\";\n\nfn word_count(text: string): i32 {\n    return words(text).length;\n}\n\nlet text = \"The quick brown fox jumps over the lazy dog\";\nprint(word_count(text));  // 9\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does planned features work in Hemlock?", "output": "**2. Array/Buffer Handling**\n\n```hemlock\n// Future: Better array passing\nlet arr = [1, 2, 3, 4, 5];\nprocess_array(arr);  // Pass to C function\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All networking operations can throw exceptions:\n\n```hemlock\ntry {\n    let listener = TcpListener(\"0.0.0.0\", 8080);\n    defer listener.close();\n    // ... server code\n} catch (e) {\n    print(\"Failed to start server: \" + e);\n}\n\ntry {\n    let stream = TcpStream(\"example.com\", 80);\n    defer stream.close();\n    stream.write(\"data\");\n} catch (e) {\n    print(\"Connection failed: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does fetch and parse json api work in Hemlock?", "output": "```hemlock\nimport { get_json } from \"@stdlib/http\";\n\n// Fetch GitHub user data\nlet user = get_json(\"https://api.github.com/users/octocat\");\nprint(\"Name: \" + user.name);\nprint(\"Bio: \" + user.bio);\nprint(\"Public repos: \" + typeof(user.public_repos));\n\n// Fetch todos\nlet todos = get_json(\"https://jsonplaceholder.typicode.com/todos/1\");\nprint(\"Title: \" + todos.title);\nprint(\"Completed: \" + typeof(todos.completed));\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does pattern: character filter work in Hemlock?", "output": "```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does commands with pipes work in Hemlock?", "output": "```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does 6. legacy code integration work in Hemlock?", "output": "Reuse existing C codebases:\n\n```hemlock\n// Call functions from legacy C applications\n// Gradually migrate to Hemlock\n// Preserve working C code\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does testing edge cases work in Hemlock?", "output": "**Example: tests/arrays/edge_cases.hml**\n\n```hemlock\n// Empty array\nlet empty = [];\nprint(empty.length);  // Expect: 0\n\n// Single element\nlet single = [42];\nprint(single[0]);  // Expect: 42\n\n// Negative index (should error in separate test file)\n// print(single[-1]);  // Error\n\n// Past-end index (should error)\n// print(single[100]);  // Error\n\n// Boundary conditions\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Expect: [] (empty)\nprint(arr.slice(3, 3));  // Expect: [] (empty)\nprint(arr.slice(1, 2));  // Expect: [2]\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does size() work in Hemlock?", "output": "**Returns:** `object` - `{ rows: i32, cols: i32 }`\n\n```hemlock\nimport { size } from \"@stdlib/terminal\";\n\nlet dimensions = size();\nprint(\"Terminal size: \" + typeof(dimensions.rows) + \"x\" + typeof(dimensions.cols));\n\n// Center text\nlet text = \"Hello, World!\";\nlet col = (dimensions.cols - text.length) / 2;\nprint_at(dimensions.rows / 2, col, text);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as math from \"@stdlib/math\";\nlet result = math.sqrt(16);\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does detach work in Hemlock?", "output": "```hemlock\ndetach(task: task): null\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does pitfall: rune vs. byte confusion work in Hemlock?", "output": "```hemlock\n// DON'T: Treat runes as bytes\nlet r: rune = 'ðŸš€';\nlet b: u8 = r;              // ERROR: Rune codepoint 128640 doesn't fit in u8\n\n// DO: Use appropriate conversions\nlet r: rune = 'ðŸš€';\nlet code: i32 = r;          // OK: 128640\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does pattern: resource management with try/finally work in Hemlock?", "output": "Ensure cleanup even on errors:\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... risky operations\n    process(data);\n} finally {\n    free(data);  // Always freed, even on error\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Writes `line` followed by newline (`\\n`). Returns number of bytes written.\n\n```hemlock\nstream.write_line(\"GET / HTTP/1.1\");\nstream.write_line(\"Host: example.com\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does function scope work in Hemlock?", "output": "Functions create their own scope:\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // Can read outer scope\n}\n\nfoo();\n// print(local);  // ERROR: 'local' not defined here\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does overview work in Hemlock?", "output": "```hemlock\n// Basic error handling\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// With cleanup\ntry {\n    process_file();\n} catch (e) {\n    print(\"Failed: \" + e);\n} finally {\n    cleanup();\n}\n\n// Throwing errors\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Show an example of example: text processing in Hemlock.", "output": "```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // Normalize whitespace\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does async_write_file work in Hemlock?", "output": "```hemlock\nasync_write_file(path: string, content: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All functions throw exceptions on errors:\n\n```hemlock\nimport { compress, decompress, gunzip } from \"@stdlib/compression\";\n\n// Invalid compression level\ntry {\n    compress(\"data\", 15);  // Level must be 0-9\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// Corrupted data\ntry {\n    let bad_data = buffer(10);\n    decompress(bad_data);\n} catch (e) {\n    print(\"Decompression error: \" + e);\n}\n\n// Invalid gzip data\ntry {\n    let not_gzip = buffer(10);\n    not_gzip[0] = 0;  // Wrong magic byte\n    gunzip(not_gzip);\n} catch (e) {\n    print(\"Gunzip error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test array methods\n\nlet arr = [1, 2, 3];\n\n// Push/pop\narr.push(4);\nprint(arr.length);\nlet popped = arr.pop();\nprint(popped);\nprint(arr.length);\n\n// Shift/unshift\narr.unshift(0);\nprint(arr[0]);\nlet shifted = arr.shift();\nprint(shifted);\n\n// First/last\nprint(arr.first());\nprint(arr.last());\n\n// Find/contains\nprint(arr.find(2));\nprint(arr.find(99));\nprint(arr.contains(3));\nprint(arr.contains(99));\n\n// Slice\nlet sliced = arr.slice(0, 2);\nprint(sliced.length);\nprint(sliced[0]);\nprint(sliced[1]);\n\n// Join\nlet joined = arr.join(\"-\");\nprint(joined);\n\n// Concat\nlet arr2 = [4, 5];\nlet combined = arr.concat(arr2);\nprint(combined.length);\n\n// Reverse (in-place)\nlet rev = [1, 2, 3];\nrev.reverse();\nprint(rev[0]);\nprint(rev[2]);\n\n// Insert/remove\nlet arr3 = [1, 3];\narr3.insert(1, 2);\nprint(arr3[1]);\nlet removed = arr3.remove(1);\nprint(removed);\n\n// Clear\nlet arr4 = [1, 2, 3];\narr4.clear();\nprint(arr4.length);\n\nprint(\"done\");\n```", "output": "4\n4\n3\n0\n0\n1\n3\n1\n-1\ntrue\nfalse\n2\n1\n2\n1-2-3\n5\n3\n1\n2\n2\n0\ndone", "category": "parity/methods", "source": "tests/parity/methods/array_methods.hml"}
{"instruction": "How does safe buffers (recommended) work in Hemlock?", "output": "```hemlock\n// Allocate buffer\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// Set values (bounds-checked)\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Access values\nprint(buf[0]);  // 65\n\n// Must free when done\nfree(buf);\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does panic vs throw work in Hemlock?", "output": "```hemlock\n// throw - Recoverable error (can be caught)\ntry {\n    throw \"recoverable error\";\n} catch (e) {\n    print(\"Caught: \" + e);  // âœ… Caught successfully\n}\n\n// panic - Unrecoverable error (cannot be caught)\ntry {\n    panic(\"unrecoverable error\");  // âŒ Program exits immediately\n} catch (e) {\n    print(\"This never runs\");       // âŒ Never executes\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does implicit type promotion work in Hemlock?", "output": "**Promotion Hierarchy (lowest to highest):**\n\n```hemlock\ni8 â†’ i16 â†’ i32 â†’ u32 â†’ i64 â†’ u64 â†’ f32 â†’ f64\n      â†‘     â†‘     â†‘\n     u8    u16\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does export statements work in Hemlock?", "output": "```hemlock\n// Re-export from another module\nexport { add, subtract } from \"./math.hml\";\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does testing exceptions work in Hemlock?", "output": "Always wrap risky calls in functions:\n\n```hemlock\n// âœ“ Correct\nexpect(fn() {\n    let result = divide(10, 0);\n}).to_throw();\n\n// âœ— Wrong - throws immediately, test fails\nexpect(divide(10, 0)).to_throw();\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does trunc(x) work in Hemlock?", "output": "**Returns:** `f64` - Truncated value\n\n```hemlock\nimport { trunc } from \"@stdlib/math\";\n\nlet result = trunc(3.7);   // 3.0\nlet result2 = trunc(-2.9); // -2.0\nlet result3 = trunc(5.0);  // 5.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does switch statements work in Hemlock?", "output": "```hemlock\nswitch (expression) {\n    case value1:\n        // body\n        break;\n    case value2:\n        // body\n        break;\n    default:\n        // default body\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does md5(input: string): string work in Hemlock?", "output": "âš ï¸ **WARNING:** MD5 is cryptographically broken. Use only for legacy compatibility, NOT for security.\n\n```hemlock\nlet hash = md5(\"hello\");\nprint(hash);\n// \"5d41402abc4b2a76b9719d911017c592\"\n\nassert(hash.length == 32, \"MD5 produces 32 hex characters\");\n\n// Known MD5 hash\nlet test_hash = md5(\"The quick brown fox jumps over the lazy dog\");\nassert(test_hash == \"9e107d9d372bb6826bd81d3542a419d6\");\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does binary arithmetic work in Hemlock?", "output": "```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Float division\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Mixed types\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promoted)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does 3. handle exceptions appropriately work in Hemlock?", "output": "```hemlock\nasync fn task() {\n    try {\n        // risky operation\n    } catch (e) {\n        // Log error\n        throw e;  // Re-throw if caller should know\n    }\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does functions work in Hemlock?", "output": "```hemlock\n// Named function\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// Anonymous function\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test optional chaining operator (?.)\n\n// Basic property access\nlet obj = { name: \"Alice\", age: 30 };\nprint(obj?.name);\nprint(obj?.age);\n\n// Null/undefined object\nlet empty = null;\nprint(empty?.name);\n\n// Nested optional chaining\nlet nested = { inner: { value: 42 } };\nprint(nested?.inner?.value);\n\n// Optional indexing\nlet arr = [1, 2, 3];\nprint(arr?.[0]);\nprint(arr?.[1]);\n\n// Null array\nlet nullArr = null;\nprint(nullArr?.[0]);\n\n// String indexing with optional\nlet str = \"hello\";\nprint(str?.[0]);\n\n// Object with method-like property (function stored as property)\nlet calculator = {\n    value: 10,\n    double: fn() { return 20; }\n};\nprint(calculator?.value);\n\n// Chained property access\nlet deep = { a: { b: { c: 100 } } };\nprint(deep?.a?.b?.c);\n\n// Mixed null in chain\nlet partial = { a: null };\nprint(partial?.a?.b);\n\nprint(\"done\");\n```", "output": "Alice\n30\nnull\n42\n1\n2\nnull\n'h'\n10\n100\nnull\ndone", "category": "parity/language", "source": "tests/parity/language/optional_chaining.hml"}
{"instruction": "How does raise work in Hemlock?", "output": "```hemlock\nraise(signum: i32): null\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does date arithmetic methods work in Hemlock?", "output": "Add (or subtract) days from the date. Returns a new DateTime object.\n\n```hemlock\nlet dt = from_date(2025, 1, 15, 12, 0, 0);\n\nlet future = dt.add_days(7);\nprint(future.to_string());  // \"2025-01-22 12:00:00\"\n\nlet past = dt.add_days(-3);\nprint(past.to_string());    // \"2025-01-12 12:00:00\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Show an example of example 4: configuration tool in Hemlock.", "output": "```hemlock\n// Usage: ./hemlock config.hml <action> [arguments]\n// Actions:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions:\");\n    print(\"  get <key>         Get configuration value\");\n    print(\"  set <key> <value> Set configuration value\");\n    print(\"  list              List all configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Error: 'get' requires a key\");\n        } else {\n            let key = args[2];\n            print(\"Getting: \" + key);\n            // ... get from config\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Error: 'set' requires key and value\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setting \" + key + \" = \" + value);\n            // ... set in config\n        }\n    } else if (action == \"list\") {\n        print(\"Listing all configuration:\");\n        // ... list config\n    } else {\n        print(\"Error: Unknown action: \" + action);\n        show_usage();\n    }\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does logical or (`||`) work in Hemlock?", "output": "At least one condition must be true:\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"out of range\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { platform, hostname, cpu_count } from \"@stdlib/os\";\n\nprint(\"Platform: \" + platform());\nprint(\"Hostname: \" + hostname());\nprint(\"CPU cores: \" + typeof(cpu_count()));\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does 1. simple argument processing work in Hemlock?", "output": "Check for required argument:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Processing file: \" + filename);\n    // ... process file\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does rune â†’ string work in Hemlock?", "output": "Runes can be explicitly converted to strings:\n\n```hemlock\n// Explicit conversion\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = 'ðŸš€';       // \"ðŸš€\"\n\n// Automatic during concatenation\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does your first program work in Hemlock?", "output": "Create a file called `hello.hml`:\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does 1. always check argument count work in Hemlock?", "output": "```hemlock\n// Good\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// Bad - may crash if no arguments\nprocess_file(args[1]);  // Error if args.length == 1\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does early return work in Hemlock?", "output": "```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Early exit\n        }\n    }\n    return -1;  // Not found\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does recursive directory creation work in Hemlock?", "output": "```hemlock\nimport { exists, make_dir, is_dir } from \"@stdlib/fs\";\n\nfn make_dirs(path: string): bool {\n    if (exists(path)) {\n        return is_dir(path);\n    }\n\n    // Find the last slash\n    let parts = path.split(\"/\");\n    if (parts.length <= 1) {\n        try {\n            make_dir(path);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    // Create parent first\n    let parent_parts = parts.slice(0, parts.length - 1);\n    let parent = parent_parts.join(\"/\");\n\n    if (!make_dirs(parent)) {\n        return false;\n    }\n\n    // Then create this directory\n    try {\n        make_dir(path);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Usage\nif (make_dirs(\"/tmp/app/data/logs\")) {\n    print(\"Directory tree created\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does channel implementation work in Hemlock?", "output": "Channels use a circular buffer with pthread synchronization:\n\n```hemlock\nChannel Structure:\n- buffer[] - Fixed-size array of Values\n- capacity - Maximum number of elements\n- size - Current number of elements\n- head - Read position\n- tail - Write position\n- mutex - pthread_mutex_t for thread-safe access\n- not_empty - pthread_cond_t for blocking recv\n- not_full - pthread_cond_t for blocking send\n- closed - Boolean flag\n- refcount - Reference count for cleanup\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// JSON functions test\nimport { parse, stringify } from \"@stdlib/json\";\n\n// Parse simple object\nlet obj = parse(\"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}\");\nprint(obj.name);\nprint(obj.age);\n\n// Parse array\nlet arr = parse(\"[1, 2, 3]\");\nprint(arr[0]);\nprint(arr[1]);\nprint(arr[2]);\n\n// Stringify object\nlet data = { x: 10, y: 20 };\nprint(stringify(data));\n\n// Nested object\nlet nested = parse(\"{\\\"user\\\": {\\\"name\\\": \\\"Bob\\\"}}\");\nprint(nested.user.name);\n\n// Boolean and null\nlet mixed = parse(\"{\\\"flag\\\": true, \\\"empty\\\": null}\");\nprint(mixed.flag);\nprint(mixed.empty);\n```", "output": "Alice\n30\n1\n2\n3\n{\"x\":10,\"y\":20}\nBob\ntrue\nnull", "category": "parity/modules", "source": "tests/parity/modules/stdlib_json.hml"}
{"instruction": "How does clamp(value, min_val, max_val) work in Hemlock?", "output": "**Returns:** `f64` - Clamped value\n\n```hemlock\nimport { clamp } from \"@stdlib/math\";\n\nlet result = clamp(5.0, 0.0, 10.0);   // 5.0\nlet result2 = clamp(-3.0, 0.0, 10.0); // 0.0 (clamped to min)\nlet result3 = clamp(15.0, 0.0, 10.0); // 10.0 (clamped to max)\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does type safety patterns work in Hemlock?", "output": "**Validate function arguments:**\n\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"arguments must be integers\";\n    }\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does arrays in structured data work in Hemlock?", "output": "```hemlock\nlogger.warn(\"Multiple validation errors\", {\n    field: \"email\",\n    errors: [\"Invalid format\", \"Domain not allowed\", \"Too long\"]\n});\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does permission checks work in Hemlock?", "output": "Always check if operations succeed:\n\n```hemlock\ntry {\n    kill(target_pid, 15);\n    print(\"Signal sent successfully\");\n} catch (e) {\n    print(\"Failed to send signal: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test primitive types and basic operations\n\n// Integers\nlet a = 42;\nprint(a);\n\n// Floats\nlet b = 3.14;\nprint(b);\n\n// Booleans\nprint(true);\nprint(false);\n\n// Null\nprint(null);\n\n// Strings\nlet s = \"hello\";\nprint(s);\n\n// Arithmetic\nprint(10 + 5);\nprint(10 - 5);\nprint(10 * 5);\nprint(10 / 5);\nprint(10 % 3);\n\n// Comparisons\nprint(5 == 5);\nprint(5 != 3);\nprint(5 < 10);\nprint(5 > 3);\nprint(5 <= 5);\nprint(5 >= 5);\n\nprint(\"done\");\n```", "output": "42\n3.14\ntrue\nfalse\nnull\nhello\n15\n5\n50\n2\n1\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ndone", "category": "parity/language", "source": "tests/parity/language/primitives.hml"}
{"instruction": "How does tcp client work in Hemlock?", "output": "```hemlock\nimport { TcpStream } from \"@stdlib/net\";\n\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();\n\nstream.write(\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\");\nlet response = stream.read(4096);\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does permission considerations work in Hemlock?", "output": "Commands run with the same permissions as the Hemlock process:\n\n```hemlock\n// If Hemlock runs as root, exec() commands also run as root!\nlet r = exec(\"rm -rf /important\");  // DANGEROUS if running as root\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\n// Import specific functions\nimport { compress, decompress, gzip, gunzip } from \"@stdlib/compression\";\nimport { TarWriter, TarReader } from \"@stdlib/compression\";\n\n// Import all\nimport * as compression from \"@stdlib/compression\";\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does pattern: callback functions work in Hemlock?", "output": "```hemlock\nfn process_async(data, callback) {\n    // ... do processing\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does reading work in Hemlock?", "output": "```hemlock\nfile.read(size?: i32): string\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does .capacity work in Hemlock?", "output": "```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Show an example of example: menu system in Hemlock.", "output": "```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Start\");\n        print(\"2. Settings\");\n        print(\"3. Exit\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Goodbye!\");\n                return;\n            default:\n                print(\"Invalid choice\");\n                break;\n        }\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does export statements work in Hemlock?", "output": "```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test UTF-8 string iteration in for-in loops\n// Should iterate over Unicode codepoints (runes), not bytes\n\n// ASCII string\nlet ascii = \"Hello\";\nlet count = 0;\nfor (let ch in ascii) {\n    print(ch);\n    count = count + 1;\n}\nprint(\"ASCII count: \" + count);\n\n// UTF-8 with emojis (rocket is 4 bytes)\nlet emoji = \"Hi!\";\ncount = 0;\nfor (let ch in emoji) {\n    print(ch);\n    count = count + 1;\n}\nprint(\"Emoji count: \" + count);\n\n// Mixed UTF-8\nlet mixed = \"cafe\";\ncount = 0;\nfor (let ch in mixed) {\n    print(ch);\n    count = count + 1;\n}\nprint(\"Mixed count: \" + count);\n\n// Chinese characters (3 bytes each)\nlet chinese = \"abc\";\ncount = 0;\nfor (let ch in chinese) {\n    print(ch);\n    count = count + 1;\n}\nprint(\"CJK count: \" + count);\n```", "output": "'H'\n'e'\n'l'\n'l'\n'o'\nASCII count: 5\n'H'\n'i'\n'!'\nEmoji count: 3\n'c'\n'a'\n'f'\n'e'\nMixed count: 4\n'a'\n'b'\n'c'\nCJK count: 3", "category": "parity/language", "source": "tests/parity/language/string_utf8_iteration.hml"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test: Exception handling with many concurrent tasks\n// Some tasks throw exceptions, verify they're properly caught\n\nasync fn maybe_fail(id: i32): i32 {\n    // Tasks with even IDs throw exceptions\n    if (id == 2 || id == 4 || id == 6 || id == 8) {\n        throw \"Task failed\";\n    }\n    return id * 10;\n}\n\n// Spawn 10 tasks (half will fail)\nlet tasks = [];\nlet i = 0;\nwhile (i < 10) {\n    tasks.push(spawn(maybe_fail, i));\n    i = i + 1;\n}\n\n// Join tasks and handle exceptions\nlet successful = 0;\nlet failed = 0;\nlet sum = 0;\n\ni = 0;\nwhile (i < tasks.length) {\n    try {\n        let result = join(tasks[i]);\n        sum = sum + result;\n        successful = successful + 1;\n    } catch (e) {\n        failed = failed + 1;\n    }\n    i = i + 1;\n}\n\nprint(\"Successful:\");\nprint(successful);\nprint(\"Failed:\");\nprint(failed);\nprint(\"Sum:\");\nprint(sum);\n```", "output": "Successful:\n6\nFailed:\n4\nSum:\n250", "category": "tests/async", "source": "tests/async/stress_exception_handling.hml"}
{"instruction": "How does safety tools provided work in Hemlock?", "output": "**2. Unsafe raw pointers:**\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // You must remember to free\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does break and continue work in Hemlock?", "output": "```hemlock\n// Break: exit loop\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue: skip to next iteration\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does pointer types work in Hemlock?", "output": "```hemlock\nlet buf: buffer = buffer(64);\n// Bounds-checked, tracks length and capacity\nfree(buf);\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does tarreader(data) -> object work in Hemlock?", "output": "```hemlock\n{\n    name: string,      // File/directory name\n    content: string,   // File content (empty for directories)\n    size: i64,         // Content size in bytes\n    mode: i32,         // File permissions\n    mtime: i64,        // Modification time\n    type: rune,        // Entry type ('0'=file, '5'=dir, etc.)\n}\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does pattern: object builder work in Hemlock?", "output": "```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // Enable chaining\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does exit(code?) work in Hemlock?", "output": "- Early exit on fatal errors\n\n```hemlock\nimport { exit } from \"@stdlib/env\";\n\n// Exit with success\nexit(0);\n\n// Exit with error\nexit(1);\n\n// Exit with default (0)\nexit();\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does convenience functions work in Hemlock?", "output": "GET a URL and automatically parse the response as JSON.\n\n```hemlock\nimport { get_json } from \"@stdlib/http\";\n\nlet user = get_json(\"https://jsonplaceholder.typicode.com/users/1\");\nprint(user.name);  // \"Leanne Graham\"\nprint(user.email); // \"Sincere@april.biz\"\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "Show an example of example: character classification in Hemlock.", "output": "```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "What string methods are available in Hemlock?", "output": "Hemlock strings have 19 methods:\n\n**Slicing:** `substr(start, len)`, `slice(start, end)`\n**Search:** `find(needle)`, `contains(str)`\n**Transform:** `split(delim)`, `trim()`, `to_upper()`, `to_lower()`\n**Check:** `starts_with(prefix)`, `ends_with(suffix)`\n**Replace:** `replace(old, new)`, `replace_all(old, new)`\n**Other:** `repeat(n)`, `char_at(i)`, `byte_at(i)`, `chars()`, `bytes()`, `to_bytes()`, `deserialize()`\n\n```hemlock\nlet s = \"hello world\";\nprint(s.length);           // 11\nprint(s.substr(0, 5));     // \"hello\"\nprint(s.split(\" \")[0]);   // \"hello\"\nprint(s.to_upper());       // \"HELLO WORLD\"\n```", "category": "concepts/strings", "source": "CLAUDE.md"}
{"instruction": "How does success! work in Hemlock?", "output": "```hemlock\n**5. Check for memory leaks:**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does hex_to_buffer(hex: string): buffer work in Hemlock?", "output": "Convert hexadecimal string to buffer.\n\n```hemlock\nimport { hex_to_buffer } from \"@stdlib/crypto\";\n\nlet hex = \"48656c6c6f\";  // \"Hello\" in hex\nlet buf = hex_to_buffer(hex);\nprint(buf.length);  // 5\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does 3. no timeout work in Hemlock?", "output": "**Workaround - use timeout command:**\n\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// Will timeout after 5 seconds\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does 1. always close file loggers work in Hemlock?", "output": "Use `defer` to ensure cleanup:\n\n```hemlock\nlet logger = Logger({ output: \"app.log\" });\ndefer logger.close();\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does http client (simple get) work in Hemlock?", "output": "```hemlock\nimport { TcpStream } from \"@stdlib/net\";\n\nfn http_get(host: string, path: string) {\n    let stream = TcpStream(host, 80);\n    defer stream.close();\n\n    stream.set_timeout(10.0);  // 10 second timeout\n\n    let request = \"GET \" + path + \" HTTP/1.1\\r\\n\";\n    request = request + \"Host: \" + host + \"\\r\\n\";\n    request = request + \"Connection: close\\r\\n\\r\\n\";\n\n    stream.write(request);\n\n    let response = stream.read_all();\n    return response;\n}\n\nlet html = http_get(\"example.com\", \"/\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does task type work in Hemlock?", "output": "```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does linux: libffi not found work in Hemlock?", "output": "pkg-config --cflags --libs libffi\n\n```hemlock\n3. If not found, you may need to set `PKG_CONFIG_PATH`:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does command chaining work in Hemlock?", "output": "```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test string utility builtins\n\n// Test to_string\nprint(to_string(42) == \"42\");\nprint(to_string(3.14) == \"3.14\");\nprint(to_string(true) == \"true\");\nprint(to_string(false) == \"false\");\nprint(to_string(null) == \"null\");\nprint(to_string(\"hello\") == \"hello\");\n\n// Test string_byte_length\nprint(string_byte_length(\"hello\") == 5);\nprint(string_byte_length(\"\") == 0);\n\n// strerror() returns the last errno message\n// Just test it returns a string\nlet err = strerror();\nprint(typeof(err) == \"string\");\n\n// Test string_to_cstr and cstr_to_string roundtrip\nlet original = \"Hello, World!\";\nlet cstr = string_to_cstr(original);\nprint(cstr != null);\nlet restored = cstr_to_string(cstr);\nprint(restored == original);\n\nprint(\"done\");\n```", "output": "true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/string_utils.hml"}
{"instruction": "How does functions work in Hemlock?", "output": "```hemlock\nimport { test } from \"@stdlib/regex\";\n\nif (test(\"^[0-9]+$\", \"12345\")) {\n    print(\"String contains only digits\");\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does byte access work in Hemlock?", "output": "```hemlock\nstring.bytes(): array\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Comprehensive comparison operations test\n// Tests: ==, !=, <, >, <=, >=\n\n// Numeric equality\nprint(5 == 5);   // true\nprint(5 == 6);   // false\nprint(5 != 6);   // true\nprint(5 != 5);   // false\n\n// Numeric relational\nprint(3 < 5);    // true\nprint(5 < 3);    // false\nprint(5 > 3);    // true\nprint(3 > 5);    // false\n\nprint(5 <= 5);   // true\nprint(5 <= 6);   // true\nprint(6 <= 5);   // false\nprint(5 >= 5);   // true\nprint(6 >= 5);   // true\nprint(5 >= 6);   // false\n\n// Float comparisons\nprint(3.14 < 3.15);  // true\nprint(3.14 > 3.13);  // true\nprint(3.14 == 3.14); // true\n\n// String equality\nprint(\"abc\" == \"abc\");   // true\nprint(\"abc\" == \"def\");   // false\nprint(\"abc\" != \"def\");   // true\n\n// String ordering\nprint(\"abc\" < \"def\");    // true\nprint(\"def\" > \"abc\");    // true\nprint(\"abc\" <= \"abc\");   // true\nprint(\"abc\" >= \"abc\");   // true\nprint(\"xyz\" > \"abc\");    // true\n\n// Boolean comparisons\nprint(true == true);     // true\nprint(true == false);    // false\nprint(true != false);    // true\n\n// Null comparisons\nprint(null == null);     // true\nlet x = null;\nprint(x == null);        // true\n```", "output": "true\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\ntrue\nfalse\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue", "category": "parity/language", "source": "tests/parity/language/comparisons.hml"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Boolean logic test\n// Tests: &&, ||, !, truthiness\n\n// Basic logic\nprint(true && true);    // true\nprint(true && false);   // false\nprint(false && true);   // false\nprint(false && false);  // false\n\nprint(true || true);    // true\nprint(true || false);   // true\nprint(false || true);   // true\nprint(false || false);  // false\n\nprint(!true);           // false\nprint(!false);          // true\nprint(!!true);          // true\n\n// Compound expressions\nprint((true && false) || true);   // true\nprint(true && (false || true));   // true\nprint(!(true && false));          // true\n\n// Short-circuit evaluation\nfn side_effect() {\n    print(\"called\");\n    return true;\n}\n\n// Should not call side_effect\nlet a = false && side_effect();\nprint(a);  // false\n\n// Should call side_effect\nlet b = true && side_effect();\nprint(b);  // true (after \"called\")\n```", "output": "true\nfalse\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ncalled\ntrue", "category": "parity/language", "source": "tests/parity/language/booleans.hml"}
{"instruction": "How does supports_color() work in Hemlock?", "output": "**Returns:** `bool` - True if colors are supported\n\n```hemlock\nimport { supports_color, RED, RESET } from \"@stdlib/terminal\";\n\nif (supports_color()) {\n    print(RED + \"Colored output!\" + RESET);\n} else {\n    print(\"No color support\");\n}\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does expected output methods work in Hemlock?", "output": "**test_name.hml.out:**\n\n```hemlock\nline 1\nline 2\nline 3\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does async_remove_dir work in Hemlock?", "output": "```hemlock\nimport { async_remove_dir } from \"@stdlib/async_fs\";\n\nlet future = async_remove_dir(\"./temp\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does parsing functions work in Hemlock?", "output": "- `YYYY-MM-DDTHH:MM:SSZ` - Date and time (UTC)\n\n```hemlock\nimport { parse_iso } from \"@stdlib/datetime\";\n\n// Date only\nlet dt1 = parse_iso(\"2025-01-15\");\nprint(dt1.to_string());  // \"2025-01-15 00:00:00\"\n\n// Date and time\nlet dt2 = parse_iso(\"2025-03-20T14:30:45\");\nprint(dt2.to_string());  // \"2025-03-20 14:30:45\"\n\n// UTC format\nlet dt3 = parse_iso(\"2025-12-31T23:59:59Z\");\nprint(dt3.to_string());\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test type definitions with duck typing\n\n// Define a simple type\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// Create an object that matches the type\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(p.name);\nprint(p.age);\n\n// Define a type with optional field\ndefine Config {\n    host: string,\n    port?: 8080,\n}\n\n// Create config with optional field defaulted\nlet c1: Config = { host: \"localhost\" };\nprint(c1.host);\nprint(c1.port);\n\n// Create config with optional field specified\nlet c2: Config = { host: \"example.com\", port: 3000 };\nprint(c2.host);\nprint(c2.port);\n\nprint(\"done\");\n```", "output": "Alice\n30\nlocalhost\n8080\nexample.com\n3000\ndone", "category": "tests/compiler", "source": "tests/compiler/type_definitions.hml"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as collections from \"@stdlib/collections\";\nlet map = collections.HashMap();\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does floor(x) work in Hemlock?", "output": "**Returns:** `f64` - Floor of x\n\n```hemlock\nimport { floor } from \"@stdlib/math\";\n\nlet result = floor(3.7);   // 3.0\nlet result2 = floor(-2.3); // -3.0\nlet result3 = floor(5.0);  // 5.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does mutual recursion work in Hemlock?", "output": "Functions can call each other:\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test chained imports (module imports from another module)\nimport { square, sum_of_squares } from \"./math_utils.hml\";\n\nprint(square(5));\nprint(sum_of_squares(3, 4));\n```", "output": "25\n25", "category": "parity/modules", "source": "tests/parity/modules/chained_import.hml"}
{"instruction": "How does spawn/join work in Hemlock?", "output": "```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does execution order work in Hemlock?", "output": "Understanding the execution order:\n\n```hemlock\ntry {\n    print(\"1: try block start\");\n    throw \"error\";\n    print(\"2: never reached\");\n} catch (e) {\n    print(\"3: catch block\");\n} finally {\n    print(\"4: finally block\");\n}\nprint(\"5: after try/catch/finally\");\n\n// Output:\n// 1: try block start\n// 3: catch block\n// 4: finally block\n// 5: after try/catch/finally\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "**6. Unchecked Allocation Failure**\n\n```hemlock\n// BAD: Not checking for null\nlet p = alloc(1000000000);  // May fail on low memory\nmemset(p, 0, 1000000000);   // CRASH: p is null\n\n// GOOD: Always check allocation result\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"out of memory\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does throwing errors work in Hemlock?", "output": "```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"Age cannot be negative\";\n    }\n    if (age > 150) {\n        throw \"Age is unrealistic\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Validation error: \" + e);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does when to use panic work in Hemlock?", "output": "```hemlock\n// Unreachable code\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"invalid state: \" + typeof(state));  // Should never happen\n    }\n}\n\n// Critical resource check\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json not found - cannot start\");\n    }\n    // ...\n}\n\n// Data structure invariant\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() called on empty stack\");\n    }\n    return stack.pop();\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does open work in Hemlock?", "output": "```hemlock\n// Read mode (default)\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// Write mode (truncate)\nlet f_write = open(\"output.txt\", \"w\");\n\n// Append mode\nlet f_append = open(\"log.txt\", \"a\");\n\n// Read/write mode\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// Read/write (truncate)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Read/append\nlet f_ra = open(\"log.txt\", \"a+\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { read_file, write_file, exists } from \"@stdlib/fs\";\n\nif (exists(\"config.json\")) {\n    let content = read_file(\"config.json\");\n    print(content);\n} else {\n    write_file(\"config.json\", \"{}\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does pitfall: mutation surprises work in Hemlock?", "output": "```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // Shallow copy\ns1[0] = 'H';       // Mutates s1\nprint(s2);         // Still \"hello\" (strings are value types)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How do you define an enum in Hemlock?", "output": "Enums define named constants:\n\n```hemlock\n// Auto-numbered (0, 1, 2...)\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\n// Custom values\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 100\n}\n\n// Usage\nlet c = Color.RED;    // 0\nlet s = Status.ERROR; // 1\nprint(c);  // 0\n```", "category": "concepts/enums", "source": "CLAUDE.md"}
{"instruction": "How does functions work in Hemlock?", "output": "```hemlock\nimport { compile, REG_EXTENDED, REG_ICASE } from \"@stdlib/regex\";\n\n// Basic pattern\nlet pattern = compile(\"^hello\");\n\n// Case-insensitive pattern\nlet pattern2 = compile(\"WORLD\", REG_EXTENDED | REG_ICASE);\n\n// Don't forget to free!\npattern.free();\npattern2.free();\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test optional parameters with default values\n\nfn greet(name, greeting?: \"Hello\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));\nprint(greet(\"Bob\", \"Hi\"));\n\n// Multiple optional parameters\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));\nprint(add(1, 2));\nprint(add(1, 2, 3));\n\n// All optional\nfn test(x?: 1, y?: 2) {\n    return x + y;\n}\n\nprint(test());\nprint(test(10));\nprint(test(10, 20));\n\nprint(\"done\");\n```", "output": "Hello Alice\nHi Bob\n111\n103\n6\n3\n12\n30\ndone", "category": "parity/language", "source": "tests/parity/language/optional_params.hml"}
{"instruction": "How does object type work in Hemlock?", "output": "**Type Definitions:**\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Optional field\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does style constants work in Hemlock?", "output": "```hemlock\nimport { BOLD, ITALIC, UNDERLINE, DIM } from \"@stdlib/terminal\";\n\nprint(BOLD + \"Bold text\" + RESET);\nprint(ITALIC + \"Italic text\" + RESET);\nprint(UNDERLINE + \"Underlined text\" + RESET);\nprint(DIM + \"Dim text\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does reading work in Hemlock?", "output": "**Without size (read all):**\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // Read from current position to EOF\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does return inside try/catch/finally work in Hemlock?", "output": "```hemlock\nfn example() {\n    try {\n        return 1;  // âœ… Returns 1 after finally runs\n    } finally {\n        print(\"cleanup\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // âš ï¸ Finally return overrides try return - returns 2\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test modulo with different integer types\n\n// i8\nlet a: i8 = 10;\nlet b: i8 = 3;\nprint(a % b);  // 1\n\n// i16\nlet c: i16 = 100;\nlet d: i16 = 7;\nprint(c % d);  // 2\n\n// i32\nlet e: i32 = 1000;\nlet f: i32 = 13;\nprint(e % f);  // 12\n\n// i64\nlet g: i64 = 100000;\nlet h: i64 = 7;\nprint(g % h);  // 5\n\n// u8\nlet i: u8 = 255;\nlet j: u8 = 10;\nprint(i % j);  // 5\n\n// u16\nlet k: u16 = 1000;\nlet l: u16 = 17;\nprint(k % l);  // 13\n\n// u32\nlet m: u32 = 50000;\nlet n: u32 = 19;\nprint(m % n);  // 10\n\n// u64\nlet o: u64 = 100000;\nlet p: u64 = 11;\nprint(o % p);  // 10\n```", "output": "1\n2\n12\n5\n5\n14\n11\n10", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_types.hml"}
{"instruction": "How does the `self` keyword work in Hemlock?", "output": "When a function is called as a method, `self` is automatically bound to the object:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self refers to counter\n    }\n};\n\ncounter.increment();  // self is bound to counter\nprint(counter.count);  // 1\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does when you need `free()` vs when it's automatic work in Hemlock?", "output": "2. **Early cleanup** - free before scope ends to release memory sooner:\n\n```hemlock\nfn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... done with big ...\n       free(big);  // Free now, don't wait for function to return\n       // ... more work that doesn't need big ...\n   }\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does reserved keywords work in Hemlock?", "output": "The following keywords are reserved in Hemlock:\n\n```hemlock\nlet, const, fn, if, else, while, for, in, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does floor division (div / divi) work in Hemlock?", "output": "For other rounding operations that return integers:\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// These can be used directly as array indices\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20 (index 1)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does seed(value) work in Hemlock?", "output": "```hemlock\nimport { seed, rand } from \"@stdlib/math\";\n\nseed(42);\nlet r1 = rand();  // Same sequence every time with seed 42\nlet r2 = rand();\n\nseed(42);         // Reset to same seed\nlet r3 = rand();  // r3 == r1\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does type checking work in Hemlock?", "output": "```hemlock\n// Check types with typeof()\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does panic work in Hemlock?", "output": "```hemlock\npanic(message?: any): never\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does file i/o work in Hemlock?", "output": "```hemlock\n// Write to file\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// Read from file\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test defer statement - LIFO order execution\n\nfn test_single_defer() {\n    defer print(\"cleanup\");\n    print(\"work\");\n    return null;\n}\n\nfn test_multiple_defers() {\n    defer print(\"first\");\n    defer print(\"second\");\n    defer print(\"third\");\n    print(\"start\");\n    return null;\n}\n\nfn test_early_return() {\n    defer print(\"always runs\");\n    print(\"before return\");\n    return 42;\n    print(\"never prints\");\n}\n\n// Run tests\ntest_single_defer();\nprint(\"---\");\ntest_multiple_defers();\nprint(\"---\");\nlet result = test_early_return();\nprint(result);\n```", "output": "work\ncleanup\n---\nstart\nthird\nsecond\nfirst\n---\nbefore return\nalways runs\n42", "category": "tests/compiler", "source": "tests/compiler/defer.hml"}
{"instruction": "How does planned features work in Hemlock?", "output": "**5. Error Handling**\n\n```hemlock\n// Future: Better error reporting\ntry {\n    let result = risky_c_function();\n} catch (e) {\n    print(\"FFI error: \" + e);\n}\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does type definitions (duck typing) work in Hemlock?", "output": "```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // Optional with default\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // Duck typing validates structure\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true (default applied)\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How do you import modules in Hemlock?", "output": "Use `import` with the `@stdlib/` prefix for standard library:\n\n```hemlock\n// Import specific items\nimport { sin, cos, PI } from \"@stdlib/math\";\n\n// Import all as namespace\nimport * as math from \"@stdlib/math\";\nlet result = math.sqrt(16);\n\n// Import from local files\nimport { helper } from \"./utils.hml\";\n```\n\nStandard library modules: math, collections, fs, net, json, http, crypto, regex, time, datetime, encoding, hash, logging, terminal, testing, and more.", "category": "concepts/modules", "source": "CLAUDE.md"}
{"instruction": "How does basic timing work in Hemlock?", "output": "```hemlock\nimport { time_ms } from \"@stdlib/time\";\n\nfn measure(task_name: string, fn: function): null {\n    let start = time_ms();\n    fn();\n    let elapsed = time_ms() - start;\n    print(task_name + \" took \" + typeof(elapsed) + \"ms\");\n    return null;\n}\n\nmeasure(\"Heavy computation\", fn() {\n    let sum = 0;\n    let i = 0;\n    while (i < 1000000) {\n        sum = sum + i;\n        i = i + 1;\n    }\n});\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does pretty printing work in Hemlock?", "output": "Pretty-print value to file.\n\n```hemlock\nimport { pretty_file } from \"@stdlib/json\";\n\nlet config = { server: { port: 8080, host: \"localhost\" } };\npretty_file(\"config.json\", config, 2);\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does substring & slicing work in Hemlock?", "output": "```hemlock\nstring.slice(start: i32, end: i32): string\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test compound assignment operators\n\n// Basic compound assignment\nlet a = 10;\na = a + 5;\nprint(a);\n\na = a - 3;\nprint(a);\n\na = a * 2;\nprint(a);\n\na = divi(a, 4);  // Use integer division to keep a as integer\nprint(a);\n\na = a % 5;\nprint(a);\n\n// With different types\nlet b = 3.14;\nb = b + 1.0;\nprint(b);\n\n// String concatenation\nlet s = \"Hello\";\ns = s + \" World\";\nprint(s);\n\n// Array modification through index\nlet arr = [1, 2, 3];\narr[0] = arr[0] + 10;\nprint(arr[0]);\n\narr[1] = arr[1] * 5;\nprint(arr[1]);\n\n// Object property modification\nlet obj = { x: 100, y: 200 };\nobj.x = obj.x + 50;\nprint(obj.x);\n\nobj.y = divi(obj.y, 2);  // Use integer division for integer result\nprint(obj.y);\n\n// Bitwise compound\nlet c = 0b1010;\nc = c | 0b0101;\nprint(c);\n\nc = c & 0b1100;\nprint(c);\n\nc = c ^ 0b1111;\nprint(c);\n\n// Shift compound\nlet d = 1;\nd = d << 4;\nprint(d);\n\nd = d >> 2;\nprint(d);\n\n// Nested object modification\nlet nested = { inner: { value: 10 } };\nnested.inner.value = nested.inner.value * 3;\nprint(nested.inner.value);\n\nprint(\"done\");\n```", "output": "15\n12\n24\n6\n1\n4.14\nHello World\n11\n10\n150\n100\n15\n12\n3\n16\n4\n30\ndone", "category": "parity/language", "source": "tests/parity/language/compound_assignment.hml"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test functions\n\nfn add(a, b) {\n    return a + b;\n}\n\nprint(add(2, 3));\n\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\nprint(greet(\"World\"));\n\n// Recursion\nfn factorial(n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));\n\n// Higher-order function\nfn apply(f, x) {\n    return f(x);\n}\n\nfn twice(n) {\n    return n * 2;\n}\n\nprint(apply(twice, 5));\n\nprint(\"done\");\n```", "output": "5\nHello, World\n120\n10\ndone", "category": "parity/language", "source": "tests/parity/language/functions.hml"}
{"instruction": "How does os_version() work in Hemlock?", "output": "**Returns:** `string` - Version string (e.g., `\"5.15.0-generic\"`, `\"22.1.0\"`)\n\n```hemlock\nimport { os_version } from \"@stdlib/os\";\n\nlet version = os_version();\nprint(\"Kernel version: \" + version);  // e.g., \"5.15.0-generic\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does `exit(code?: i32)` work in Hemlock?", "output": "Terminate the current process with an optional exit code (default: 0).\n\n```hemlock\n// Exit with success\nexit();\n\n// Exit with error code\nif (error_occurred) {\n    exit(1);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Explain what this Hemlock code does:\n\n```hemlock\n// WebSocket Client Example (libwebsockets version)\n// Demonstrates @stdlib/websocket (production FFI implementation)\n// Requires: libwebsockets-dev and compiled lws_wrapper.so (make stdlib)\n\nimport { WebSocket } from \"@stdlib/websocket\";\n\nprint(\"=== Hemlock WebSocket Client (libwebsockets) ===\");\nprint(\"\");\nprint(\"Requirements:\");\nprint(\"  1. Install: sudo apt-get install libwebsockets-dev\");\nprint(\"  2. Compile: make stdlib\");\nprint(\"\");\n\ntry {\n    print(\"Connecting to ws://echo.websocket.org...\");\n\n    let ws = WebSocket(\"ws://echo.websocket.org\");\n    defer ws.close();\n\n    print(\"âœ“ Connected!\");\n    print(\"\");\n\n    // Send test message\n    print(\"Sending: 'Hello from Hemlock!'\");\n    let sent = ws.send_text(\"Hello from Hemlock!\");\n\n    if (sent) {\n        print(\"âœ“ Message sent\");\n    } else {\n        print(\"âœ— Failed to send\");\n    }\n\n    // Wait for echo (5 second timeout)\n    print(\"Waiting for echo (5s timeout)...\");\n    let msg = ws.recv(5000);\n\n    if (msg != null) {\n        print(\"âœ“ Received message!\");\n        print(\"  Type: \" + msg.type);\n        if (msg.type == \"text\") {\n            print(\"  Data: \" + msg.data);\n        }\n    } else {\n        print(\"âœ— No response (timeout or connection closed)\");\n    }\n\n    print(\"\");\n    print(\"Sending another message...\");\n    ws.send_text(\"Second message from Hemlock\");\n\n    let msg2 = ws.recv(5000);\n    if (msg2 != null && msg2.type == \"text\") {\n        print(\"âœ“ Received: \" + msg2.data);\n    }\n\n    print(\"\");\n    print(\"Closing connection...\");\n\n} catch (e) {\n    print(\"\");\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"  - lws_wrapper.so not found: Run 'make stdlib'\");\n    print(\"  - libwebsockets not installed: Run 'sudo apt-get install libwebsockets-dev'\");\n    print(\"  - Network connectivity issues\");\n    print(\"  - echo.websocket.org is down\");\n}\n\nprint(\"\");\nprint(\"Done!\");\nprint(\"\");\nprint(\"Features of libwebsockets version:\");\nprint(\"  âœ“ SSL/TLS support (wss://\");\nprint(\"  âœ“ Production-ready performance\");\nprint(\"  âœ“ Proper protocol compliance\");\nprint(\"  âœ“ Large message support\");\nprint(\"  âœ“ Automatic ping/pong handling\");\n```", "output": "This program create a WebSocket client. WebSocket Client Example (libwebsockets version) Demonstrates @stdlib/websocket (production FFI implementation) Requires: libwebsockets-dev and compiled lws_wrapper.so (make stdlib)", "category": "examples/explanation", "source": "examples/websocket_client_lws.hml"}
{"instruction": "How does logical and (`&&`) work in Hemlock?", "output": "Both conditions must be true:\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"single digit positive\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does built-in functions work in Hemlock?", "output": "```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... processing logic\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does common errors work in Hemlock?", "output": "```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test @stdlib/math imports\nimport { PI, sqrt, abs, sin, cos, floor, ceil, min, max } from \"@stdlib/math\";\n\n// Test constants\nprint(PI);\n\n// Test single-arg functions\nprint(sqrt(16.0));\nprint(abs(-42));\nprint(floor(3.7));\nprint(ceil(3.2));\n\n// Test two-arg functions\nprint(min(10, 5));\nprint(max(10, 5));\n\n// Test trig\nlet angle = PI / 2.0;\nprint(floor(sin(angle) * 100.0));\nprint(floor(cos(0.0) * 100.0));\n```", "output": "3.14159\n4\n42\n3\n4\n5\n10\n100\n100", "category": "parity/modules", "source": "tests/parity/modules/stdlib_math.hml"}
{"instruction": "How does throwing objects work in Hemlock?", "output": "```hemlock\ntry {\n    throw { code: 404, message: \"Not found\" };\n} catch (e) {\n    print(\"Error \" + typeof(e.code) + \": \" + e.message);\n}\n// Output: Error 404: Not found\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does common leak sources work in Hemlock?", "output": "```hemlock\n**2. Lost pointers:**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "**`contains(needle)`** - Check if string contains substring:\n\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All crypto functions validate inputs and throw exceptions on errors:\n\n```hemlock\nimport { aes_encrypt, generate_aes_key, generate_iv } from \"@stdlib/crypto\";\n\n// Wrong key size\ntry {\n    let bad_key = random_bytes(16);  // Too small\n    aes_encrypt(\"data\", bad_key, generate_iv());\n} catch (e) {\n    print(\"Error: \" + e);  // \"aes_encrypt() requires 32-byte (256-bit) key\"\n}\n\n// Wrong IV size\ntry {\n    aes_encrypt(\"data\", generate_aes_key(), random_bytes(8));  // Too small\n} catch (e) {\n    print(\"Error: \" + e);  // \"aes_encrypt() requires 16-byte (128-bit) iv\"\n}\n\n// Decryption failure (wrong key or corrupted data)\ntry {\n    let ciphertext = aes_encrypt(\"data\", key1, iv);\n    aes_decrypt(ciphertext, key2, iv);  // Different key\n} catch (e) {\n    print(\"Error: \" + e);  // \"EVP_DecryptFinal_ex() failed...\"\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does multiple commands work in Hemlock?", "output": "```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does pattern: map (transform) work in Hemlock?", "output": "```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does macos: library not found errors work in Hemlock?", "output": "brew --prefix openssl\n\n```hemlock\n3. The Makefile should auto-detect these paths. If it doesn't, check that `brew` is in your PATH:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does multi-producer, multi-consumer work in Hemlock?", "output": "Channels can be safely shared between multiple producers and consumers:\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// Multiple producers\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// Multiple consumers\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// Wait for all\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does `getgid(): i32` work in Hemlock?", "output": "Get the real group ID of the current process.\n\n```hemlock\nlet gid = getgid();\nprint(\"Group ID: \" + typeof(gid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How do you handle errors in Hemlock?", "output": "Hemlock uses try/catch/finally for error handling:\n\n```hemlock\ntry {\n    throw \"something went wrong\";\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    cleanup();\n}\n\n// Unrecoverable errors\npanic(\"fatal error\");  // exits immediately, not catchable\n```\n\nUse `throw` for recoverable errors, `panic` for unrecoverable ones.", "category": "concepts/errors", "source": "CLAUDE.md"}
{"instruction": "How does type checking work in Hemlock?", "output": "```hemlock\nimport { is_string, is_number, is_bool, is_null } from \"@stdlib/json\";\n\nprint(is_string(\"hello\"));  // true\nprint(is_number(42));  // true\nprint(is_number(3.14));  // true\nprint(is_bool(true));  // true\nprint(is_null(null));  // true\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does read_file(path) work in Hemlock?", "output": "**Throws:** Exception if file doesn't exist or cannot be read\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\n\ntry {\n    let content = read_file(\"data.txt\");\n    print(\"File contents: \" + content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does async_rename work in Hemlock?", "output": "```hemlock\nasync_rename(old_path: string, new_path: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does higher-order functions work in Hemlock?", "output": "```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does regex object work in Hemlock?", "output": "```hemlock\nlet pattern = compile(\"test\");\npattern.test(\"testing\");\npattern.free();  // Required!\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does async_exists work in Hemlock?", "output": "```hemlock\nasync_exists(path: string): Future<bool>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does type checking work in Hemlock?", "output": "```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // Promotes to f64, returns f64\nadd(\"a\", \"b\");     // Runtime error: type mismatch\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test enums\n\n// Simple enum (auto values: 0, 1, 2)\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nprint(Color.RED);    // 0\nprint(Color.GREEN);  // 1\nprint(Color.BLUE);   // 2\n\n// Enum with explicit values\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 100\n}\n\nprint(Status.OK);       // 0\nprint(Status.ERROR);    // 1\nprint(Status.PENDING);  // 100\n\n// Using enum in switch\nlet color = Color.GREEN;\nswitch (color) {\n    case Color.RED:\n        print(\"red\");\n        break;\n    case Color.GREEN:\n        print(\"green\");\n        break;\n    case Color.BLUE:\n        print(\"blue\");\n        break;\n}\n\n// Comparison\nif (color == Color.GREEN) {\n    print(\"is green\");\n}\n\nprint(\"done\");\n```", "output": "0\n1\n2\n0\n1\n100\ngreen\nis green\ndone", "category": "tests/compiler", "source": "tests/compiler/enums.hml"}
{"instruction": "How does min(a, b) work in Hemlock?", "output": "**Returns:** `f64` - Minimum of a and b\n\n```hemlock\nimport { min } from \"@stdlib/math\";\n\nlet result = min(5.0, 10.0);  // 5.0\nlet result2 = min(-3.0, 2.0); // -3.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does read file line by line work in Hemlock?", "output": "```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does empty arrays work in Hemlock?", "output": "```hemlock\nlet arr = [];  // Empty array\n\n// Add elements later\narr.push(1);\narr.push(2);\narr.push(3);\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does string conversion work in Hemlock?", "output": "```hemlock\narray.join(delimiter: string): string\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does pointer arithmetic work in Hemlock?", "output": "**Allowed but dangerous:**\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation boundary\n*q = 42;          // UNDEFINED: Out of bounds write\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does quick start work in Hemlock?", "output": "```hemlock\nimport { now, from_date, parse_iso } from \"@stdlib/datetime\";\n\n// Get current date/time\nlet current = now();\nprint(current.to_string());  // \"2025-01-16 12:30:45\"\n\n// Create from specific date\nlet birthday = from_date(1990, 5, 15, 14, 30, 0);\nprint(birthday.format(\"%B %d, %Y\"));  // \"May 15, 1990\"\n\n// Parse ISO date\nlet meeting = parse_iso(\"2025-03-20T14:30:00\");\nprint(meeting.to_string());  // \"2025-03-20 14:30:00\"\n\n// Date arithmetic\nlet next_week = current.add_days(7);\nprint(\"Next week: \" + next_week.to_date_string());\n\n// Comparison\nif (meeting.is_after(current)) {\n    print(\"Meeting is in the future\");\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does difference methods work in Hemlock?", "output": "Get the difference in seconds.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 1, 12, 0, 0);\nlet dt2 = from_date(2025, 1, 1, 12, 0, 45);\n\nlet diff = dt2.diff_seconds(dt1);\nprint(diff);  // 45\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does system monitoring work in Hemlock?", "output": "```hemlock\nimport * as os from \"@stdlib/os\";\nimport { sleep } from \"@stdlib/time\";\n\nfn monitor_system(interval_seconds: i32, iterations: i32): null {\n    print(\"=== System Monitor ===\");\n    print(\"Host: \" + os.hostname());\n    print(\"Platform: \" + os.platform() + \" \" + os.arch());\n    print(\"CPUs: \" + typeof(os.cpu_count()));\n    print(\"\");\n\n    let i = 0;\n    while (i < iterations) {\n        let mem = os.memory_info();\n        let usage_percent = (mem.used * 100) / mem.total;\n\n        print(\"[\" + typeof(i + 1) + \"] Memory: \" +\n              os.format_bytes(mem.used) + \" / \" +\n              os.format_bytes(mem.total) +\n              \" (\" + typeof(usage_percent) + \"%)\");\n\n        sleep(interval_seconds);\n        i = i + 1;\n    }\n\n    return null;\n}\n\n// Monitor every 5 seconds, 10 times\nmonitor_system(5, 10);\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does string basics work in Hemlock?", "output": "Strings are **mutable** and **UTF-8**:\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5 (character count)\nprint(s.byte_length); // 5 (byte count)\n\n// Mutation\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does handler limitations work in Hemlock?", "output": "```hemlock\nfn complex_handler(sig) {\n    // Avoid these in signal handlers:\n\n    // âŒ Long-running operations\n    // process_large_file();\n\n    // âŒ Blocking I/O\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal received\\n\");\n\n    // âŒ Complex state changes\n    // rebuild_entire_data_structure();\n\n    // âœ… Simple flag setting is safe\n    let should_stop = true;\n\n    // âœ… Simple counter updates are usually safe\n    let signal_count = signal_count + 1;\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does do's work in Hemlock?", "output": "Bad:  tests/test1.hml\n\n```hemlock\nâœ… **Keep tests focused**\n- One feature area per file\n- Clear setup and assertions\n- Minimal code\n\nâœ… **Add comments explaining tricky tests**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test for-in loop - array iteration\n\n// Test 1: Simple value iteration\nlet arr = [10, 20, 30];\nfor (let val in arr) {\n    print(val);\n}\n\n// Test 2: Index and value iteration\nprint(\"---\");\nlet names = [\"Alice\", \"Bob\", \"Charlie\"];\nfor (let i, name in names) {\n    print(i);\n    print(name);\n}\n\n// Test 3: Empty array\nprint(\"---\");\nlet empty = [];\nfor (let x in empty) {\n    print(\"should not print\");\n}\nprint(\"done\");\n\n// Test 4: Nested loops\nprint(\"---\");\nlet matrix = [[1, 2], [3, 4]];\nfor (let row in matrix) {\n    for (let val in row) {\n        print(val);\n    }\n}\n```", "output": "10\n20\n30\n---\n0\nAlice\n1\nBob\n2\nCharlie\n---\ndone\n---\n1\n2\n3\n4", "category": "tests/compiler", "source": "tests/compiler/for_in.hml"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test: Exception in for loop initializer should be caught\nprint(\"Test 1: Exception in for initializer\");\ntry {\n    fn bad_init() {\n        throw \"error in init\";\n    }\n    for (let i = bad_init(); i < 10; i = i + 1) {\n        print(\"Should not reach here\");\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for loop condition should be caught\nprint(\"\\nTest 2: Exception in for condition\");\ntry {\n    fn bad_condition() {\n        throw \"error in condition\";\n    }\n    for (let i = 0; bad_condition(); i = i + 1) {\n        print(\"Should not reach here\");\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for loop body should be caught\nprint(\"\\nTest 3: Exception in for body\");\ntry {\n    for (let i = 0; i < 5; i = i + 1) {\n        if (i == 2) {\n            throw \"error at i=2\";\n        }\n        print(\"i = \" + typeof(i));\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for loop increment should be caught\nprint(\"\\nTest 4: Exception in for increment\");\ntry {\n    fn bad_increment(x) {\n        if (x == 2) {\n            throw \"error in increment at i=2\";\n        }\n        return x + 1;\n    }\n    for (let i = 0; i < 5; i = bad_increment(i)) {\n        print(\"i = \" + typeof(i));\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for-in iterable evaluation\nprint(\"\\nTest 5: Exception in for-in iterable\");\ntry {\n    fn bad_iterable() {\n        throw \"error evaluating iterable\";\n    }\n    for (let val in bad_iterable()) {\n        print(\"Should not reach here\");\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for-in body\nprint(\"\\nTest 6: Exception in for-in body\");\ntry {\n    let arr = [1, 2, 3, 4, 5];\n    for (let val in arr) {\n        if (val == 3) {\n            throw \"error at val=3\";\n        }\n        print(\"val = \" + typeof(val));\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\nprint(\"\\nAll tests completed\");\n```", "output": "Test 1: Exception in for initializer\nCaught: error in init\n\\nTest 2: Exception in for condition\nCaught: error in condition\n\\nTest 3: Exception in for body\ni = i32\ni = i32\nCaught: error at i=2\n\\nTest 4: Exception in for increment\ni = i32\ni = i32\ni = i32\nCaught: error in increment at i=2\n\\nTest 5: Exception in for-in iterable\nCaught: error evaluating iterable\n\\nTest 6: Exception in for-in body\nval = i32\nval = i32\nCaught: error at val=3\n\\nAll tests completed", "category": "tests/exceptions", "source": "tests/exceptions/loop_exception_leak.hml"}
{"instruction": "How does channel methods work in Hemlock?", "output": "Send value to channel (blocks if full).\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\n// Import specific functions\nimport { get_pid, getppid, exec, kill } from \"@stdlib/process\";\n\n// Import all as namespace\nimport * as process from \"@stdlib/process\";\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does explicit type conversion work in Hemlock?", "output": "```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32 â†’ rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune â†’ i32 (90)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "What integer types are available in Hemlock?", "output": "Hemlock provides signed and unsigned integers:\n\n**Signed:** `i8`, `i16`, `i32`, `i64`\n**Unsigned:** `u8`, `u16`, `u32`, `u64`\n\nType aliases: `integer` (i32), `byte` (u8)\n\nLiterals auto-detect size: `42` â†’ i32, `5000000000` â†’ i64 (exceeds i32 max)", "category": "concepts/types", "source": "CLAUDE.md"}
{"instruction": "How does blocking i/o safe work in Hemlock?", "output": "Blocking operations in one task don't block others:\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // Blocks this thread only\n    let content = f.read();       // Blocks this thread only\n    f.close();\n    return content;\n}\n\n// Both read concurrently (on different threads)\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does with error handling work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Always close, even on error\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does basic types work in Hemlock?", "output": "```hemlock\nlet x: i32 = 42;           // 32-bit signed integer\nlet y: u8 = 255;           // 8-bit unsigned integer\nlet pi: f64 = 3.14159;     // 64-bit float\nlet name: string = \"Alice\"; // UTF-8 string\nlet flag: bool = true;     // Boolean\nlet ch: rune = 'ðŸš€';       // Unicode codepoint\n```", "category": "docs", "source": "docs/README.md"}
{"instruction": "How does type checking work in Hemlock?", "output": "Check if value is an object.\n\n```hemlock\nimport { is_object } from \"@stdlib/json\";\n\nprint(is_object({}));  // true\nprint(is_object({ x: 10 }));  // true\nprint(is_object([]));  // false\nprint(is_object(\"text\"));  // false\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does checking argument count work in Hemlock?", "output": "```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <argument>\");\n    // exit or return\n} else {\n    let arg = args[1];\n    // process arg\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does replacement work in Hemlock?", "output": "**`replace_all(old, new)`** - Replace all occurrences:\n\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "**4. Buffer Overflow (ptr)**\n\n```hemlock\n// BAD: Buffer overflow with ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // CRASH: writing past allocation\n\n// GOOD: Use buffer for bounds checking\nlet buf = buffer(10);\n// buf[100] = 65;  // ERROR: bounds check fails\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does creating callbacks work in Hemlock?", "output": "Use `callback()` to create a C-callable function pointer from a Hemlock function:\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test optional parameters\n\n// Function with one optional parameter\nfn greet(name, greeting?: \"Hello\") {\n    print(greeting + \" \" + name);\n}\n\ngreet(\"Alice\");              // Hello Alice\ngreet(\"Bob\", \"Hi\");          // Hi Bob\n\n// Function with multiple optional parameters\nfn format(value, prefix?: \"[\", suffix?: \"]\") {\n    print(prefix + value + suffix);\n}\n\nformat(\"test\");              // [test]\nformat(\"test\", \"(\");         // (test]\nformat(\"test\", \"<\", \">\");    // <test>\n\n// Optional parameter with numeric default\nfn multiply(x, factor?: 2) {\n    return x * factor;\n}\n\nprint(multiply(5));      // 10\nprint(multiply(5, 3));   // 15\n\nprint(\"done\");\n```", "output": "Hello Alice\nHi Bob\n[test]\n(test]\n<test>\n10\n15\ndone", "category": "tests/compiler", "source": "tests/compiler/optional_params.hml"}
{"instruction": "How does forgetting semicolons work in Hemlock?", "output": "```hemlock\n// âŒ ERROR: Missing semicolon\nlet x = 42\nlet y = 10\n\n// âœ… CORRECT\nlet x = 42;\nlet y = 10;\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does split & trim work in Hemlock?", "output": "**`trim()`** - Remove leading/trailing whitespace:\n\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Show an example of example: vector math in Hemlock.", "output": "```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does repetition work in Hemlock?", "output": "```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does panic work in Hemlock?", "output": "```hemlock\npanic(\"unrecoverable error\");\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does rune type work in Hemlock?", "output": "```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = 'ðŸš€';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "What is the difference between `ptr` and `buffer` in Hemlock?", "output": "`ptr` is a raw pointer with no safety checks - you're responsible for bounds.\n\n`buffer` is a safe wrapper that provides bounds checking:\n\n```hemlock\n// Raw pointer - no bounds checking\nlet p = alloc(10);\np[100] = 1;  // undefined behavior, no error\n\n// Buffer - bounds checked\nlet b = buffer(10);\nb[100] = 1;  // runtime error: index out of bounds\n```\n\nUse `ptr` for performance-critical code, `buffer` for safety.", "category": "concepts/memory", "source": "CLAUDE.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "```hemlock\n// BAD: Double free\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: double free\n\n// GOOD: Free once\nlet p2 = alloc(100);\nfree(p2);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Show how to websocket echo client in Hemlock.", "output": "```hemlock\n// WebSocket Echo Client Example\n// Demonstrates @stdlib/websocket_pure (pure Hemlock implementation)\n\nimport { WebSocket } from \"@stdlib/websocket_pure\";\n\nprint(\"=== Hemlock WebSocket Echo Client ===\");\nprint(\"\");\n\n// Note: This uses the pure Hemlock implementation\n// For production with SSL, use @stdlib/websocket (requires libwebsockets)\n\nprint(\"Connecting to ws://echo.websocket.org...\");\n\ntry {\n    let ws = WebSocket(\"ws://echo.websocket.org\");\n    defer ws.close();\n\n    print(\"âœ“ Connected!\");\n    print(\"\");\n\n    // Send a few test messages\n    print(\"Sending: 'Hello WebSocket!'\");\n    ws.send_text(\"Hello WebSocket!\");\n\n    print(\"Waiting for echo...\");\n    let msg1 = ws.recv();\n\n    if (msg1 != null && msg1.type == \"text\") {\n        print(\"âœ“ Received: \" + msg1.data);\n    } else {\n        print(\"âœ— No response or wrong type\");\n    }\n\n    print(\"\");\n\n    // Send another message\n    print(\"Sending: 'Hemlock WebSocket Test'\");\n    ws.send_text(\"Hemlock WebSocket Test\");\n\n    print(\"Waiting for echo...\");\n    let msg2 = ws.recv();\n\n    if (msg2 != null && msg2.type == \"text\") {\n        print(\"âœ“ Received: \" + msg2.data);\n    } else {\n        print(\"âœ— No response or wrong type\");\n    }\n\n    print(\"\");\n    print(\"Closing connection...\");\n\n} catch (e) {\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"- Message >125 bytes (not yet supported in pure implementation)\");\n    print(\"- Network connectivity\");\n    print(\"- echo.websocket.org is down\");\n    print(\"\");\n    print(\"Limitations of pure Hemlock implementation:\");\n    print(\"- No wss:// (SSL) support\");\n    print(\"- Messages limited to <126 bytes\");\n    print(\"- Simplified masking and validation\");\n    print(\"\");\n    print(\"For production use, install libwebsockets and use @stdlib/websocket\");\n}\n\nprint(\"Done!\");\n```", "category": "examples", "source": "examples/websocket_echo_client.hml"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test scientific notation support\n\n// Basic scientific notation\nprint(1e0);\nprint(1e1);\nprint(1e2);\n\n// Negative exponents\nprint(1e-1);\nprint(1e-2);\n\n// With decimal point\nprint(3.14e2);\nprint(2.5e-3);\n\n// Case insensitive\nprint(1E10 == 1e10);\n\n// Explicit positive exponent\nprint(1e+5);\n\n// Type inference (always f64)\nprint(typeof(1e5));\nprint(typeof(1e-12));\n\n// Arithmetic with scientific notation\nprint(1e3 + 1e2);\nprint(1e6 / 1e3);\n\nprint(\"done\");\n```", "output": "1\n10\n100\n0.1\n0.01\n314\n0.0025\ntrue\n100000\nf64\nf64\n1100\n1000\ndone", "category": "parity/language", "source": "tests/parity/language/scientific_notation.hml"}
{"instruction": "How does cursor save/restore work in Hemlock?", "output": "```hemlock\nimport { SAVE_CURSOR, RESTORE_CURSOR } from \"@stdlib/terminal\";\n\n// Save current position\nexec(\"printf '\" + SAVE_CURSOR + \"'\");\n\n// ... print something elsewhere ...\n\n// Restore saved position\nexec(\"printf '\" + RESTORE_CURSOR + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does configuration file manager work in Hemlock?", "output": "```hemlock\nimport { exists, read_file, write_file } from \"@stdlib/fs\";\n\nfn load_config(path: string, defaults: object): object {\n    if (!exists(path)) {\n        print(\"Config not found, creating default\");\n        let json = defaults.serialize();\n        write_file(path, json);\n        return defaults;\n    }\n\n    try {\n        let json = read_file(path);\n        let config = json.deserialize();\n        return config;\n    } catch (e) {\n        print(\"Error loading config: \" + e);\n        return defaults;\n    }\n}\n\nfn save_config(path: string, config: object): bool {\n    try {\n        let json = config.serialize();\n        write_file(path, json);\n        return true;\n    } catch (e) {\n        print(\"Error saving config: \" + e);\n        return false;\n    }\n}\n\n// Usage\nlet defaults = { port: 8080, debug: false };\nlet config = load_config(\"config.json\", defaults);\nconfig.debug = true;\nsave_config(\"config.json\", config);\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does print_at(row, col, text) work in Hemlock?", "output": "```hemlock\nimport { print_at } from \"@stdlib/terminal\";\n\nprint_at(10, 20, \"Hello at position (10, 20)\");\nprint_at(15, 30, \"Another line here\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does appending to file work in Hemlock?", "output": "```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Event occurred\\n\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as os from \"@stdlib/os\";\n\nif (os.is_linux()) {\n    print(\"Running on Linux\");\n}\n\nlet info = os.info();\nprint(\"Memory: \" + os.format_bytes(info.total_memory));\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test modulo by zero (should error)\n\nlet a = 10 % 0;\nprint(a);\n```", "output": "Runtime error: Division by zero", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_zero_error.hml"}
{"instruction": "How does url protocol extraction work in Hemlock?", "output": "```hemlock\nimport { test, REG_ICASE } from \"@stdlib/regex\";\n\nfn has_https(url: string): bool {\n    return test(\"^https://\", url, REG_ICASE);\n}\n\nprint(has_https(\"https://example.com\"));  // true\nprint(has_https(\"http://example.com\"));   // false\nprint(has_https(\"HTTPS://Example.com\"));  // true (case-insensitive)\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport { pad_left, pad_right, center } from \"@stdlib/strings\";\nimport { is_alpha, is_digit, is_alnum } from \"@stdlib/strings\";\nimport { reverse, lines, words } from \"@stdlib/strings\";\n\n// Create formatted table\nfn format_table(data: array): null {\n    let header = center(\"USER DATA\", 40, \"=\");\n    print(header);\n\n    let i = 0;\n    while (i < data.length) {\n        let item = data[i];\n        let id_str = pad_left(typeof(item.id), 5);\n        let name_str = pad_right(item.name, 20);\n        print(id_str + \" | \" + name_str);\n        i = i + 1;\n    }\n\n    return null;\n}\n\n// Validate user input\nfn validate_username(name: string): bool {\n    // Must be 3-20 characters, alphanumeric only\n    if (name.length < 3 || name.length > 20) {\n        return false;\n    }\n    return is_alnum(name);\n}\n\n// Parse multi-line config\nfn parse_config(text: string): array {\n    let config_lines = lines(text);\n    let result: array = [];\n\n    let i = 0;\n    while (i < config_lines.length) {\n        let line = config_lines[i].trim();\n        if (line.length > 0) {\n            let parts = words(line);\n            if (parts.length == 2) {\n                result.push({ key: parts[0], value: parts[1] });\n            }\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\n// Example usage\nlet users = [\n    { id: 1, name: \"Alice\" },\n    { id: 42, name: \"Bob\" },\n    { id: 999, name: \"Carol\" }\n];\n\nformat_table(users);\n\nprint(validate_username(\"alice123\"));  // true\nprint(validate_username(\"ab\"));        // false (too short)\nprint(validate_username(\"alice!\"));    // false (not alnum)\n\nlet config_text = \"host localhost\\nport 8080\\nssl true\";\nlet config = parse_config(config_text);\nprint(config.length);  // 3\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does clear screen work in Hemlock?", "output": "```hemlock\nimport { CLEAR_SCREEN, CLEAR_TO_END, CLEAR_TO_START } from \"@stdlib/terminal\";\n\n// Clear entire screen\nexec(\"printf '\" + CLEAR_SCREEN + \"'\");\n\n// Clear from cursor to end of screen\nexec(\"printf '\" + CLEAR_TO_END + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does escape sequences work in Hemlock?", "output": "Common escape sequences for special characters:\n\n```hemlock\nlet newline = '\\n';     // Newline (U+000A)\nlet tab = '\\t';         // Tab (U+0009)\nlet backslash = '\\\\';   // Backslash (U+005C)\nlet quote = '\\'';       // Single quote (U+0027)\nlet dquote = '\"';       // Double quote (U+0022)\nlet null_char = '\\0';   // Null character (U+0000)\nlet cr = '\\r';          // Carriage return (U+000D)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Provide a Hemlock example that demonstrates range error3.", "output": "```hemlock\nlet x: i8 = 128;\n```", "category": "examples", "source": "examples/range_error3.hml"}
{"instruction": "How does null type work in Hemlock?", "output": "```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does udpsocket work in Hemlock?", "output": "Sends datagram to `dest_addr:dest_port`. Returns number of bytes sent.\n\n```hemlock\nlet sent = sock.send_to(\"192.168.1.100\", 9000, \"Hello UDP!\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does type checking strategy work in Hemlock?", "output": "Hemlock uses **runtime type checking** with **optional type annotations**:\n\n```hemlock\nlet x = 42;           // No type check, infers i32\nlet y: u8 = 255;      // Runtime check: value must fit in u8\nlet z: i32 = x + y;   // Runtime check + type promotion\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "How does common errors work in Hemlock?", "output": "**Reading from closed file:**\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How do you use using valgrind in Hemlock?", "output": "valgrind --leak-check=full ./hemlock test.hml\n\n```hemlock\n**Example output (no leaks):**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "- No exceptions are thrown for domain errors\n\n```hemlock\nimport { sqrt, log, NAN, INF } from \"@stdlib/math\";\n\nlet result1 = sqrt(-1.0);  // NAN\nlet result2 = log(0.0);    // -INF\nlet result3 = log(-1.0);   // NAN\n\n// Check for invalid results\nif (result1 != result1) {  // NAN != NAN is true\n    print(\"Result is NaN\");\n}\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Show an example of example 1: system information gatherer in Hemlock.", "output": "```hemlock\nfn get_system_info() {\n    print(\"=== System Information ===\");\n\n    // Hostname\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // Uptime\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // Disk usage\n    let r3 = exec(\"df -h /\");\n    print(\"\\nDisk Usage:\");\n    print(r3.output);\n\n    // Memory usage\n    let r4 = exec(\"free -h\");\n    print(\"Memory Usage:\");\n    print(r4.output);\n}\n\nget_system_info();\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does insertion and removal work in Hemlock?", "output": "**`remove(index)`** - Remove and return element at index:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // Returns 3, arr is now [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does range checking work in Hemlock?", "output": "**Invalid Assignments (Runtime Error):**\n\n```hemlock\nlet x: u8 = 256;             // ERROR: out of range\nlet y: i8 = 128;             // ERROR: max is 127\nlet z: u64 = -1;             // ERROR: u64 cannot be negative\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does printing work in Hemlock?", "output": "How runes are displayed depends on the codepoint:\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (quoted, printable ASCII)\n\nlet emoji = 'ðŸš€';\nprint(emoji);                   // U+1F680 (Unicode notation for non-ASCII)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (non-printable as hex)\n\nlet space = ' ';\nprint(space);                   // ' ' (printable)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does 7. use shell features wisely work in Hemlock?", "output": "```hemlock\n// Use pipes for efficiency\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// Use command substitution\nlet r = exec(\"echo Current user: $(whoami)\");\n\n// Use conditional execution\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does `logger.close()` work in Hemlock?", "output": "```hemlock\nlet logger = Logger({ output: \"app.log\" });\n\n// ... use logger ...\n\nlogger.close();  // Close file when done\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does basic structured logging work in Hemlock?", "output": "```hemlock\nimport { Logger, INFO } from \"@stdlib/logging\";\n\nlet logger = Logger();\n\n// Log with structured data\nlogger.info(\"User login\", {\n    user_id: 12345,\n    username: \"alice\",\n    ip_address: \"192.168.1.100\",\n    timestamp: 1638360000\n});\n\n// Output: 1638360123 [INFO] User login {\"user_id\":12345,\"username\":\"alice\",\"ip_address\":\"192.168.1.100\",\"timestamp\":1638360000}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does hex_encode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { hex_encode } from \"@stdlib/encoding\";\n\n// Basic encoding\nlet hex1 = hex_encode(\"Hello\");\nprint(hex1);  // \"48656c6c6f\"\n\n// Binary data\nlet data = \"\";\nlet b1: rune = 0;\nlet b2: rune = 255;\ndata = data + b1 + b2;\nlet hex2 = hex_encode(data);\nprint(hex2);  // \"00ff\"\n\n// Unicode (UTF-8 bytes are hex-encoded)\nlet hex3 = hex_encode(\"ðŸš€\");\nprint(hex3);  // UTF-8 encoding of rocket emoji\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test async operations\n\n// Simple async function\nasync fn compute(n) {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn and join\nlet task1 = spawn(compute, 5);\nlet task2 = spawn(compute, 10);\n\nlet result1 = join(task1);\nlet result2 = join(task2);\n\nprint(result1);  // 0+1+2+3+4 = 10\nprint(result2);  // 0+1+...+9 = 45\n\n// Await syntax\nlet task3 = spawn(compute, 3);\nlet result3 = await task3;\nprint(result3);  // 0+1+2 = 3\n\nprint(\"done\");\n```", "output": "10\n45\n3\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/async.hml"}
{"instruction": "How does string type work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate (now \"Hello\")\nprint(s.length);        // 5 (codepoint count)\nprint(s.byte_length);   // 5 (UTF-8 bytes)\n\nlet emoji = \"ðŸš€\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport {\n    sin, cos, tan, sqrt, pow,\n    PI, abs, min, max,\n    rand_range, seed\n} from \"@stdlib/math\";\n\n// Trigonometry: Calculate point on unit circle\nfn point_on_circle(angle: f64): object {\n    return {\n        x: cos(angle),\n        y: sin(angle)\n    };\n}\n\nlet p = point_on_circle(PI / 4.0);\nprint(\"Point at 45Â°: (\" + typeof(p.x) + \", \" + typeof(p.y) + \")\");\n\n// Distance formula\nfn distance(x1: f64, y1: f64, x2: f64, y2: f64): f64 {\n    let dx = x2 - x1;\n    let dy = y2 - y1;\n    return sqrt(dx * dx + dy * dy);\n}\n\nlet dist = distance(0.0, 0.0, 3.0, 4.0);\nprint(\"Distance: \" + typeof(dist));  // 5.0\n\n// Random dice roller\nfn roll_dice(sides: i32): i32 {\n    let result: i32 = rand_range(1.0, sides + 1.0);\n    return result;\n}\n\nseed(42);  // Reproducible results\nlet roll = roll_dice(6);\nprint(\"Dice roll: \" + typeof(roll));\n\n// Find max of three values\nfn max3(a: f64, b: f64, c: f64): f64 {\n    return max(max(a, b), c);\n}\n\nprint(\"Max: \" + typeof(max3(5.0, 12.0, 8.0)));  // 12.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does 6. avoid reading large files entirely work in Hemlock?", "output": "```hemlock\n// Bad for large files\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // Loads entire file into memory\nf.close();\n\n// Good - process in chunks\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Comprehensive arithmetic operations test\n// Tests: +, -, *, /, %, negation, precedence\n\n// Basic operations\nprint(5 + 3);    // 8\nprint(10 - 4);   // 6\nprint(3 * 4);    // 12\nprint(20 / 4);   // 5\nprint(17 % 5);   // 2\n\n// Negation\nprint(-5);       // -5\nprint(-(-3));    // 3\n\n// Precedence\nprint(2 + 3 * 4);      // 14\nprint((2 + 3) * 4);    // 20\nprint(10 - 4 / 2);     // 8\nprint(10 / 2 + 3);     // 8\n\n// Mixed types (type promotion)\nlet i: i32 = 10;\nlet f: f64 = 3.5;\nprint(i + f);    // 13.5\n\n// Large numbers\nlet big: i64 = 5000000000;\nprint(big + 1);  // 5000000001\n\n// Float operations\nprint(3.14 + 2.86);   // 6\nprint(10.5 - 3.5);    // 7\nprint(2.5 * 4.0);     // 10\nprint(15.0 / 3.0);    // 5\n\n// Compound expressions\nlet x = 10;\nlet y = 3;\nprint((x + y) * (x - y));  // 91\n```", "output": "8\n6\n12\n5\n2\n-5\n3\n14\n20\n8\n8\n13.5\n5000000001\n6\n7\n10\n5\n91", "category": "parity/language", "source": "tests/parity/language/arithmetic.hml"}
{"instruction": "How does import statements work in Hemlock?", "output": "```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All hash functions validate input types and throw exceptions on errors:\n\n```hemlock\nimport { sha256, file_sha256 } from \"@stdlib/hash\";\n\n// Type validation\ntry {\n    sha256(123);  // Error: requires string\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// File not found\ntry {\n    file_sha256(\"/nonexistent/file.txt\");\n} catch (e) {\n    print(\"File error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nlet future = pool.submit1(compute, data);\nlet result = future.get();  // Blocks until done\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does when exec() does not throw work in Hemlock?", "output": "```hemlock\n// Command runs but returns non-zero exit code\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1 (not an exception)\n\n// Command produces no output\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\" (not an exception)\n\n// Command not found by shell\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127 (not an exception)\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does try/catch work in Hemlock?", "output": "```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n// Output: Error: division by zero\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does sleep(seconds) work in Hemlock?", "output": "```hemlock\nimport { sleep } from \"@stdlib/time\";\n\n// Sleep for 1 second\nsleep(1.0);\n\n// Sleep for half a second (500ms)\nsleep(0.5);\n\n// Sleep for 100 milliseconds\nsleep(0.1);\n\n// Sleep for 10 milliseconds\nsleep(0.01);\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does async_make_dir work in Hemlock?", "output": "```hemlock\nimport { async_make_dir } from \"@stdlib/async_fs\";\n\nlet future = async_make_dir(\"./output\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does rsa_verify(data: string, signature: buffer, keypair: rsakeypair): bool work in Hemlock?", "output": "Verify RSA signature with public key using SHA-256 digest.\n\n```hemlock\nimport { rsa_verify } from \"@stdlib/crypto\";\n\nlet valid = rsa_verify(data, signature, keypair);\n\nif (valid) {\n    print(\"âœ“ Signature is valid\");\n} else {\n    print(\"âœ— Signature is invalid\");\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does working with string indexing work in Hemlock?", "output": "**Important:** String indexing uses codepoint positions, not byte offsets:\n\n```hemlock\nlet text = \"HiðŸš€!\";\n// Codepoint positions: 0='H', 1='i', 2='ðŸš€', 3='!'\n// Byte positions:      0='H', 1='i', 2-5='ðŸš€', 6='!'\n\nlet r = text[2];                // 'ðŸš€' (codepoint 2)\nprint(typeof(r));               // \"rune\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { compile, test, matches, REG_EXTENDED, REG_ICASE } from \"@stdlib/regex\";\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "```hemlock\narray.contains(value: any): bool\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does random_bytes(size: i32): buffer work in Hemlock?", "output": "Generate cryptographically secure random bytes using OpenSSL's RAND_bytes.\n\n```hemlock\nimport { random_bytes } from \"@stdlib/crypto\";\n\n// Generate random bytes\nlet random = random_bytes(32);\nprint(random.length);  // 32\n\n// Generate secret token\nlet token = random_bytes(16);\nprint(buffer_to_hex(token));  // \"3a7f2c9e...\" (32 hex chars)\n\n// Generate nonce\nlet nonce = random_bytes(12);\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does substring & slicing work in Hemlock?", "output": "```hemlock\nstring.substr(start: i32, length: i32): string\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does scrolling work in Hemlock?", "output": "```hemlock\nimport { scroll_up, scroll_down } from \"@stdlib/terminal\";\n\n// Scroll entire display up 3 lines\nexec(\"printf '\" + scroll_up(3) + \"'\");\n\n// Scroll entire display down 2 lines\nexec(\"printf '\" + scroll_down(2) + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does .mode work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Show an example of example 4: timeout pattern in Hemlock.", "output": "```hemlock\nlet operation_complete = false;\nlet timed_out = false;\n\nfn timeout_handler(sig) {\n    timed_out = true;\n}\n\nsignal(SIGALRM, timeout_handler);\n\n// Start long operation\nasync fn long_operation() {\n    // ... work\n    operation_complete = true;\n}\n\nlet task = spawn(long_operation);\n\n// Wait with timeout (manual check)\nlet elapsed = 0;\nwhile (!operation_complete && elapsed < 1000) {\n    // Sleep or check\n    elapsed = elapsed + 1;\n}\n\nif (!operation_complete) {\n    print(\"Operation timed out\");\n    detach(task);  // Give up waiting\n} else {\n    join(task);\n    print(\"Operation completed\");\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does async_remove_file work in Hemlock?", "output": "```hemlock\nimport { async_remove_file } from \"@stdlib/async_fs\";\n\nlet future = async_remove_file(\"temp.txt\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does configuration from environment work in Hemlock?", "output": "```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nfn get_config(): object {\n    return {\n        host: getenv(\"SERVER_HOST\"),\n        port: getenv(\"SERVER_PORT\"),\n        debug: getenv(\"DEBUG\") != null,\n        log_level: getenv(\"LOG_LEVEL\")\n    };\n}\n\nlet config = get_config();\n\nif (config.host == null) {\n    config.host = \"localhost\";  // Default\n}\n\nif (config.port == null) {\n    config.port = \"8080\";  // Default\n}\n\nprint(\"Server: \" + config.host + \":\" + config.port);\nprint(\"Debug: \" + typeof(config.debug));\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does null checks work in Hemlock?", "output": "Check if value is null.\n\n```hemlock\ntest(\"null checks\", fn() {\n    let x = null;\n    expect(x).to_be_null();\n\n    let y = 42;\n    expect(y).not_to_be_null();\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Show an example of example: prime checker in Hemlock.", "output": "```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does nested arrays work in Hemlock?", "output": "```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does pass-by-value work in Hemlock?", "output": "All arguments are **copied** (pass-by-value):\n\n```hemlock\nfn modify(x) {\n    x = 100;  // Only modifies local copy\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // Still 10 (unchanged)\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test chaining map, filter, and reduce\n\n// Example 1: Double numbers, filter evens, sum them\nlet result1 = [1, 2, 3, 4, 5]\n    .map(fn(x) { return x * 2; })\n    .filter(fn(x) { return x % 4 == 0; })\n    .reduce(fn(acc, x) { return acc + x; }, 0);\nprint(result1);  // 12 (4 + 8)\n\n// Example 2: Filter > 2, square them, find product\nlet result2 = [1, 2, 3, 4, 5]\n    .filter(fn(x) { return x > 2; })\n    .map(fn(x) { return x * x; })\n    .reduce(fn(acc, x) { return acc * x; }, 1);\nprint(result2);  // 3600 (9 * 16 * 25)\n\n// Example 3: String processing pipeline\nlet words = [\"hello\", \"world\", \"test\", \"code\"];\nlet result3 = words\n    .filter(fn(w) { return w.length > 4; })\n    .map(fn(w) { return w.to_upper(); })\n    .reduce(fn(acc, w) { return acc + \" \" + w; }, \"\");\nprint(result3.trim());  // HELLO WORLD\n\n// Example 4: Count even numbers after doubling\nlet count = [1, 2, 3, 4, 5, 6]\n    .map(fn(x) { return x * 2; })\n    .filter(fn(x) { return x % 4 == 0; })\n    .reduce(fn(acc, x) { return acc + 1; }, 0);\nprint(count);  // 3 (4, 8, 12)\n\n// Example 5: Complex pipeline\nlet nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet result5 = nums\n    .filter(fn(x) { return x % 2 == 1; })  // Odds: 1,3,5,7,9\n    .map(fn(x) { return x + 1; })          // Add 1: 2,4,6,8,10\n    .filter(fn(x) { return x > 5; })       // Keep > 5: 6,8,10\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // Sum: 24\nprint(result5);  // 24\n\n// Example 6: Array building with reduce\nlet doubled_evens = [1, 2, 3, 4, 5, 6]\n    .filter(fn(x) { return x % 2 == 0; })\n    .map(fn(x) { return x * 2; })\n    .reduce(fn(acc, x) {\n        acc.push(x);\n        return acc;\n    }, []);\nprint(doubled_evens[0]);  // 4\nprint(doubled_evens[1]);  // 8\nprint(doubled_evens[2]);  // 12\nprint(doubled_evens.length);  // 3\n\nprint(\"All chaining tests passed\");\n```", "output": "12\n3600\nHELLO WORLD\n3\n24\n4\n8\n12\n3\nAll chaining tests passed", "category": "tests/arrays", "source": "tests/arrays/map_filter_reduce_chaining.hml"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test comparison operations\nlet a = 10;\nlet b = 5;\nlet c = 10;\n\nprint(a > b);\nprint(a < b);\nprint(a >= c);\nprint(a <= c);\nprint(a == c);\nprint(a != b);\n\n// Boolean comparisons\nprint(true == true);\nprint(true != false);\nprint(false == false);\n```", "output": "true\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue", "category": "tests/compiler", "source": "tests/compiler/comparisons.hml"}
{"instruction": "How does 3. error checking work in Hemlock?", "output": "```hemlock\n// Check return values\nlet result = c_function();\nif (result == null) {\n    print(\"C function failed\");\n}\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does race conditions work in Hemlock?", "output": "Handlers can be called at any time, interrupting normal execution:\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // Race condition if called during counter update\n}\n\nsignal(SIGUSR1, increment);\n\n// Main code also modifies counter\ncounter = counter + 1;  // Could be interrupted by signal handler\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does object type work in Hemlock?", "output": "```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does built-in functions work in Hemlock?", "output": "```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // Blocks until compute() finishes\nprint(result);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test memory builtins\n\n// alloc and free\nlet p = alloc(64);\nprint(p != null);\nfree(p);\n\n// buffer\nlet buf = buffer(32);\nprint(buf.length);\n\nbuf[0] = 65;\nbuf[1] = 66;\nprint(buf[0]);\nprint(buf[1]);\n\nfree(buf);\n\n// memset\nlet p2 = alloc(16);\nmemset(p2, 0, 16);\nprint(\"memset ok\");\nfree(p2);\n\nprint(\"done\");\n```", "output": "true\n32\n65\n66\nmemset ok\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/memory.hml"}
{"instruction": "How does basic throw work in Hemlock?", "output": "Throw any value as an exception:\n\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\nthrow [\"error\", \"details\"];\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does background colors work in Hemlock?", "output": "```hemlock\nimport { BG_RED, BG_GREEN, BG_BLUE, WHITE } from \"@stdlib/terminal\";\n\nprint(WHITE + BG_RED + \" Error \" + RESET);\nprint(WHITE + BG_GREEN + \" Success \" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does raise work in Hemlock?", "output": "```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does total_memory() work in Hemlock?", "output": "- Resource monitoring\n\n```hemlock\nimport { total_memory, format_bytes } from \"@stdlib/os\";\n\nlet total = total_memory();\nprint(\"Total memory: \" + format_bytes(total));  // e.g., \"16 GB\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does common errors work in Hemlock?", "output": "**Reading from write-only file:**\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// Error: Cannot read from file 'output.txt' opened in write-only mode\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does log10(x) work in Hemlock?", "output": "**Returns:** `f64` - logâ‚â‚€(x)\n\n```hemlock\nimport { log10 } from \"@stdlib/math\";\n\nlet result = log10(1.0);    // 0.0\nlet result2 = log10(10.0);  // 1.0\nlet result3 = log10(100.0); // 2.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does error: method 'first' not found on array work in Hemlock?", "output": "// ... add to array method registration\n\n```hemlock\n**4. Run the test (should pass):**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does stack operations work in Hemlock?", "output": "**`push(value)`** - Add element to end:\n\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does 1. no stderr capture work in Hemlock?", "output": "**Workaround - redirect stderr to stdout:**\n\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// Now error messages are in r.output\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Provide a Hemlock example that demonstrates work with strings.", "output": "```hemlock\nlet name = \"Alice\";\nlet greeting = \"Hello, \";\nlet message = greeting + name;\n\nprint(name);\nprint(greeting);\nprint(message);\n```", "category": "examples", "source": "examples/strings.hml"}
{"instruction": "How does reading work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// Read 256 bytes\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// Process binary data\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does 2. configuration reload (without restart) work in Hemlock?", "output": "```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Reloading configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // Use config...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does reading work in Hemlock?", "output": "**Returns:** Buffer containing the read bytes\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // Read 256 bytes\nprint(binary.length);  // 256 (or less if EOF)\n\n// Access individual bytes\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\n\nlet angle = PI / 4;\nlet x = cos(angle);\nlet y = sin(angle);\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Show an example of example 4: backup script in Hemlock.", "output": "```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Backing up \" + source + \" to \" + dest);\n\n    // Create backup directory\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Error creating backup directory\");\n        return false;\n    }\n\n    // Create tarball with timestamp\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creating archive: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Error creating backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completed successfully\");\n\n    // Show backup size\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup size: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test: Try/catch/finally all together\ntry {\n    print(\"try\");\n    throw \"error\";\n} catch (e) {\n    print(\"catch: \" + e);\n} finally {\n    print(\"finally\");\n}\nprint(\"after\");\n```", "output": "try\ncatch: error\nfinally\nafter", "category": "tests/exceptions", "source": "tests/exceptions/try_catch_finally.hml"}
{"instruction": "How does safety tools provided work in Hemlock?", "output": "**3. Type annotations:**\n\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // ERROR: out of range\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does bright colors (foreground) work in Hemlock?", "output": "```hemlock\nimport { BRIGHT_RED, BRIGHT_GREEN, BRIGHT_BLUE, GRAY } from \"@stdlib/terminal\";\n\nprint(BRIGHT_RED + \"Bright red\" + RESET);\nprint(GRAY + \"Gray text\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does maybe add (under discussion) work in Hemlock?", "output": "**2. Pattern matching**\n\n```hemlock\nmatch (value) {\n    case i32: print(\"integer\");\n    case string: print(\"text\");\n    case _: print(\"other\");\n}\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does benchmarking cpu vs wall time work in Hemlock?", "output": "```hemlock\nimport { clock, time_ms, sleep } from \"@stdlib/time\";\n\nfn benchmark(): null {\n    let wall_start = time_ms();\n    let cpu_start = clock();\n\n    // CPU-intensive work\n    let sum = 0;\n    let i = 0;\n    while (i < 10000000) {\n        sum = sum + i;\n        i = i + 1;\n    }\n\n    // I/O wait (doesn't use CPU)\n    sleep(1.0);\n\n    let wall_elapsed = time_ms() - wall_start;\n    let cpu_elapsed = clock() - cpu_start;\n\n    print(\"Wall time: \" + typeof(wall_elapsed) + \"ms\");\n    print(\"CPU time: \" + typeof(cpu_elapsed * 1000.0) + \"ms\");\n    print(\"Efficiency: \" + typeof(cpu_elapsed * 1000.0 / wall_elapsed * 100.0) + \"%\");\n\n    return null;\n}\n\nbenchmark();\n// Output might be:\n// Wall time: 1245ms\n// CPU time: 234ms\n// Efficiency: 18.8%\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does transformation operations work in Hemlock?", "output": "**`join(delimiter)`** - Join elements into string:\n\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Works with mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does try block work in Hemlock?", "output": "The try block executes statements sequentially:\n\n```hemlock\ntry {\n    print(\"Starting...\");\n    risky_operation();\n    print(\"Success!\");  // Only if no exception\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does formatting methods work in Hemlock?", "output": "Format the date/time using strftime-style format string.\n\n```hemlock\nlet dt = from_date(2025, 3, 15, 14, 30, 45);\n\nprint(dt.format(\"%Y-%m-%d\"));           // \"2025-03-15\"\nprint(dt.format(\"%B %d, %Y\"));          // \"March 15, 2025\"\nprint(dt.format(\"%Y-%m-%d %H:%M:%S\"));  // \"2025-03-15 14:30:45\"\nprint(dt.format(\"%I:%M %p\"));           // \"02:30 PM\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does writing work in Hemlock?", "output": "```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Create buffer\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Write buffer\nlet written = f.write_bytes(buf);\nprint(\"Wrote\", written, \"bytes\");\n\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does tcplistener work in Hemlock?", "output": "- Throws exception on bind failure\n\n```hemlock\nlet listener = TcpListener(\"127.0.0.1\", 8080);\nlet listener2 = TcpListener(\"0.0.0.0\", 9000);  // Listen on all interfaces\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does detach work in Hemlock?", "output": "```hemlock\nasync fn background_work() {\n    print(\"Working in background...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // Task continues running independently\n\n// Cannot join detached task\n// join(t);  // ERROR\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does stack operations work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does test organization work in Hemlock?", "output": "1. **One file per module:**\n\n```hemlock\ntests/\n  my_module/\n    test_basic.hml\n    test_advanced.hml\n    test_edge_cases.hml\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test switch statements\n\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n    default:\n        print(\"other\");\n        break;\n}\n\n// String switch\nlet color = \"green\";\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown\");\n        break;\n}\n\n// Default case\nlet y = 100;\nswitch (y) {\n    case 1:\n        print(\"one\");\n        break;\n    default:\n        print(\"default\");\n        break;\n}\n\nprint(\"done\");\n```", "output": "two\ngo\ndefault\ndone", "category": "parity/language", "source": "tests/parity/language/switch.hml"}
{"instruction": "How does file backup system work in Hemlock?", "output": "```hemlock\nimport { exists, copy_file } from \"@stdlib/fs\";\nimport { now } from \"@stdlib/time\";\n\nfn backup_file(filepath: string): bool {\n    if (!exists(filepath)) {\n        print(\"File not found: \" + filepath);\n        return false;\n    }\n\n    let timestamp = now();\n    let backup_path = filepath + \".backup.\" + typeof(timestamp);\n\n    try {\n        copy_file(filepath, backup_path);\n        print(\"Backup created: \" + backup_path);\n        return true;\n    } catch (e) {\n        print(\"Backup failed: \" + e);\n        return false;\n    }\n}\n\nbackup_file(\"important.txt\");\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test higher-order functions: map, filter, reduce\n\n// map - transform elements\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) {\n    return x * 2;\n});\nfor (let x in doubled) {\n    print(x);\n}\n\n// filter - select elements\nlet evens = nums.filter(fn(x) {\n    return x % 2 == 0;\n});\nfor (let x in evens) {\n    print(x);\n}\n\n// reduce - accumulate\nlet sum = nums.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(sum);\n\nprint(\"done\");\n```", "output": "2\n4\n6\n8\n10\n2\n4\n15\ndone", "category": "parity/language", "source": "tests/parity/language/higher_order.hml"}
{"instruction": "How does dangling pointers work in Hemlock?", "output": "**Allowed but undefined behavior:**\n\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // UNDEFINED: Reading freed memory\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does concatenation work in Hemlock?", "output": "**Multiple Concatenations:**\n\n```hemlock\nlet msg = \"Hi \" + 'ðŸ‘‹' + \" World \" + 'ðŸŒ';  // \"Hi ðŸ‘‹ World ðŸŒ\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does syntax work in Hemlock?", "output": "**Try/catch/finally:**\n\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n} finally {\n    // cleanup code\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does async/concurrency work in Hemlock?", "output": "```hemlock\nasync fn compute(n: i32): i32 {\n    return n * n;\n}\n\nlet task = spawn(compute, 42);\nlet result = join(task);  // 1764\n```", "category": "docs", "source": "docs/README.md"}
{"instruction": "How does handling multiple tasks work in Hemlock?", "output": "```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task \" + typeof(id) + \" failed\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // Will fail\nlet t3 = spawn(work, 3, 0);\n\n// Join with error handling\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Task 1:\", r1);\n\n    let r2 = join(t2);  // Throws\n    print(\"Task 2:\", r2);  // Never reached\n} catch (e) {\n    print(\"Error:\", e);  // \"Error: Task 2 failed\"\n}\n\n// Can still join remaining task\nlet r3 = join(t3);\nprint(\"Task 3:\", r3);\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does rate limiting work in Hemlock?", "output": "```hemlock\nimport { sleep } from \"@stdlib/time\";\n\nfn rate_limited_task(): null {\n    let i = 0;\n    while (i < 10) {\n        print(\"Processing item \" + typeof(i));\n        // Process item...\n\n        // Wait 100ms between items (max 10 items/second)\n        sleep(0.1);\n        i = i + 1;\n    }\n    return null;\n}\n\nrate_limited_task();\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does recursion work in Hemlock?", "output": "```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does closed: bool work in Hemlock?", "output": "Whether the file is closed.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does type annotations work in Hemlock?", "output": "Optional type annotations on parameters:\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // Runtime type check promotes to f64\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test basic modulo operator with i32\nlet a = 10 % 3;\nprint(a);  // 1\n\nlet b = 15 % 4;\nprint(b);  // 3\n\nlet c = 20 % 5;\nprint(c);  // 0\n\nlet d = 7 % 2;\nprint(d);  // 1\n\nlet e = 100 % 7;\nprint(e);  // 2\n```", "output": "1\n3\n0\n1\n2", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_basic.hml"}
{"instruction": "How does channel methods work in Hemlock?", "output": "```hemlock\nchannel.send(value: any): null\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test type mismatch when pushing to typed array\n\nlet arr: array<u8> = [1, 2, 3];\narr.push(\"string\");  // Should error: type mismatch\n```", "output": "Runtime error: Type mismatch in typed array - expected element of specific type", "category": "tests/typed_arrays", "source": "tests/typed_arrays/type_mismatch_push_error.hml"}
{"instruction": "How does cycle detection work in Hemlock?", "output": "Circular references are detected and cause errors:\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Create circular reference\n\nobj.serialize();  // ERROR: serialize() detected circular reference\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does don'ts work in Hemlock?", "output": "âŒ **Don't write tests that depend on each other**\n\n```hemlock\n// BAD: test2.hml depends on test1.hml output\n// Tests should be independent\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Show an example of example: safe array operations in Hemlock.", "output": "```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // Fill array\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // Process\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // Always cleanup\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does 3. log rotation work in Hemlock?", "output": "```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // Rename old log, open new one\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // Normal logging...\n    log_file.write(\"Log entry\\n\");\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does bitwise operations work in Hemlock?", "output": "```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24 (left shift)\nprint(a >> 1);  // 6  (right shift)\nprint(~a);      // -13 (NOT)\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does open work in Hemlock?", "output": "```hemlock\nopen(path: string, mode?: string): file\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test edge cases for map, filter, reduce\n\n// Test 1: map with non-function argument\ntry {\n    let arr = [1, 2, 3];\n    arr.map(42);  // Not a function\n} catch (e) {\n    print(\"Caught: map() argument must be a function\");\n}\n\n// Test 2: filter with non-function argument\ntry {\n    let arr = [1, 2, 3];\n    arr.filter(\"not a function\");\n} catch (e) {\n    print(\"Caught: filter() argument must be a function\");\n}\n\n// Test 3: reduce with non-function argument\ntry {\n    let arr = [1, 2, 3];\n    arr.reduce(null, 0);\n} catch (e) {\n    print(\"Caught: reduce() first argument must be a function\");\n}\n\n// Test 4: reduce on empty array without initial value\ntry {\n    let empty = [];\n    empty.reduce(fn(acc, x) { return acc + x; });\n} catch (e) {\n    print(\"Caught: reduce() on empty array with no initial value\");\n}\n\n// Test 5: map with wrong number of arguments\ntry {\n    let arr = [1, 2, 3];\n    arr.map(fn(x) { return x; }, 42);  // Too many args\n} catch (e) {\n    print(\"Caught: map() expects 1 argument\");\n}\n\n// Test 6: filter with no arguments\ntry {\n    let arr = [1, 2, 3];\n    arr.filter();\n} catch (e) {\n    print(\"Caught: filter() expects 1 argument\");\n}\n\n// Test 7: reduce with too many arguments\ntry {\n    let arr = [1, 2, 3];\n    arr.reduce(fn(acc, x) { return acc; }, 0, 100);\n} catch (e) {\n    print(\"Caught: reduce() expects 1 or 2 arguments\");\n}\n\n// Test 8: callback with wrong arity in map\ntry {\n    let arr = [1, 2, 3];\n    arr.map(fn(x, y, z) { return x; });  // Expects 3 args, gets 1\n} catch (e) {\n    print(\"Caught: Callback expects 3 arguments, got 1\");\n}\n\n// Test 9: callback with wrong arity in filter\ntry {\n    let arr = [1, 2, 3];\n    arr.filter(fn() { return true; });  // Expects 0 args, gets 1\n} catch (e) {\n    print(\"Caught: Callback expects 0 arguments, got 1\");\n}\n\n// Test 10: callback with wrong arity in reduce\ntry {\n    let arr = [1, 2, 3];\n    arr.reduce(fn(x) { return x; }, 0);  // Expects 1 arg, gets 2\n} catch (e) {\n    print(\"Caught: Callback expects 1 arguments, got 2\");\n}\n\n// Test 11: Exception in map callback\ntry {\n    let arr = [1, 2, 3];\n    arr.map(fn(x) {\n        if (x == 2) {\n            throw \"error in map\";\n        }\n        return x;\n    });\n} catch (e) {\n    print(\"Caught: error in map\");\n}\n\n// Test 12: Exception in filter callback\ntry {\n    let arr = [1, 2, 3];\n    arr.filter(fn(x) {\n        if (x == 2) {\n            throw \"error in filter\";\n        }\n        return true;\n    });\n} catch (e) {\n    print(\"Caught: error in filter\");\n}\n\n// Test 13: Exception in reduce callback\ntry {\n    let arr = [1, 2, 3];\n    arr.reduce(fn(acc, x) {\n        if (x == 2) {\n            throw \"error in reduce\";\n        }\n        return acc + x;\n    }, 0);\n} catch (e) {\n    print(\"Caught: error in reduce\");\n}\n\nprint(\"All edge cases passed\");\n```", "output": "Caught: map() argument must be a function\nCaught: filter() argument must be a function\nCaught: reduce() first argument must be a function\nCaught: reduce() on empty array with no initial value\nCaught: map() expects 1 argument\nCaught: filter() expects 1 argument\nCaught: reduce() expects 1 or 2 arguments\nCaught: Callback expects 3 arguments, got 1\nCaught: Callback expects 0 arguments, got 1\nCaught: Callback expects 1 arguments, got 2\nCaught: error in map\nCaught: error in filter\nCaught: error in reduce\nAll edge cases passed", "category": "tests/arrays", "source": "tests/arrays/edge_map_filter_reduce.hml"}
{"instruction": "How does reading work in Hemlock?", "output": "**Example - Reading entire file:**\n\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test type coercion and promotion rules\n\n// Integer promotion\nlet i8val: i8 = 10;\nlet i16val: i16 = 1000;\nlet i32val: i32 = 100000;\nlet i64val: i64 = 10000000000;\n\n// i8 + i16 -> i16\nprint(typeof(i8val + i16val));\n\n// i16 + i32 -> i32\nprint(typeof(i16val + i32val));\n\n// i32 + i64 -> i64\nprint(typeof(i32val + i64val));\n\n// Integer + float -> float\nlet f32val: f32 = 3.14;\nlet f64val: f64 = 2.71828;\n\n// i32 + f32 -> f32\nprint(typeof(i32val + f32val));\n\n// i32 + f64 -> f64\nprint(typeof(i32val + f64val));\n\n// f32 + f64 -> f64\nprint(typeof(f32val + f64val));\n\n// Explicit conversions\nlet big: i64 = 9999999999;\nprint(big);\n\n// String concatenation with number\nlet num = 42;\nlet str = \"The answer is: \";\nprint(str + num);\n\n// Comparison type handling\nprint(10 == 10.0);\nprint(10 < 10.5);\n\n// Unsigned types\nlet u8val: u8 = 255;\nlet u16val: u16 = 65535;\nlet u32val: u32 = 4294967295;\n\nprint(u8val);\nprint(u16val);\nprint(u32val);\n\n// Mixed signed/unsigned\nprint(typeof(i32val + u32val));\n\nprint(\"done\");\n```", "output": "i16\ni32\ni64\nf32\nf64\nf64\n9999999999\nThe answer is: 42\ntrue\ntrue\n255\n65535\n4294967295\nu32\ndone", "category": "parity/language", "source": "tests/parity/language/type_coercion.hml"}
{"instruction": "How does named functions work in Hemlock?", "output": "```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Hello, Alice!\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does log2(x) work in Hemlock?", "output": "**Returns:** `f64` - logâ‚‚(x)\n\n```hemlock\nimport { log2 } from \"@stdlib/math\";\n\nlet result = log2(1.0);  // 0.0\nlet result2 = log2(2.0); // 1.0\nlet result3 = log2(8.0); // 3.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does path types work in Hemlock?", "output": "```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does seeking work in Hemlock?", "output": "**Returns:** New position (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Move to byte 100\nf.seek(100);\n\n// Read from position 100\nlet data = f.read(50);\n\n// Reset to beginning\nf.seek(0);\n\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does case conversion work in Hemlock?", "output": "```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does info() work in Hemlock?", "output": "**Object structure:**\n\n```hemlock\n{\n    platform: string,      // \"linux\", \"macos\", \"windows\"\n    arch: string,          // \"x86_64\", \"aarch64\", etc.\n    os_name: string,       // \"Linux\", \"Darwin\", etc.\n    os_version: string,    // Kernel version\n    hostname: string,      // System hostname\n    username: string,      // Current username\n    homedir: string,       // Home directory path\n    tmpdir: string,        // Temp directory path\n    cpu_count: i32,        // Number of CPUs\n    total_memory: i64,     // Total RAM in bytes\n    free_memory: i64,      // Free RAM in bytes\n    uptime: i64            // Uptime in seconds\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does rename(old_path, new_path) work in Hemlock?", "output": "**Throws:** Exception if operation fails\n\n```hemlock\nimport { rename } from \"@stdlib/fs\";\n\ntry {\n    rename(\"old_name.txt\", \"new_name.txt\");\n    print(\"File renamed\");\n\n    // Can also move files\n    rename(\"file.txt\", \"/tmp/file.txt\");\n    print(\"File moved\");\n} catch (e) {\n    print(\"Error renaming file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How do you use timeout using sigalrm in Hemlock?", "output": "```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// Set alarm (not yet implemented in Hemlock, example only)\n// alarm(5);  // 5 second timeout\n\nwhile (!timed_out) {\n    // Do work with timeout\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does character access work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// UTF-8 example\nlet emoji = \"ðŸš€\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (rocket)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does pattern: resource cleanup work in Hemlock?", "output": "Always use `finally` for cleanup:\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Error processing file: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // Always closes, even on error\n        }\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "Using a freed regex throws an exception:\n\n```hemlock\nlet pattern = compile(\"test\");\npattern.free();\n\ntry {\n    pattern.test(\"testing\");  // Error!\n} catch (e) {\n    print(e);  // \"Regex has been freed\"\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Sets read/write timeout in seconds. Supports fractional seconds.\n\n```hemlock\nstream.set_timeout(5.0);   // 5 second timeout\nstream.set_timeout(0.5);   // 500ms timeout\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does test with raise() work in Hemlock?", "output": "```hemlock\nfn test_handler(sig) {\n    print(\"Test signal received: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// Test by manually raising\nraise(SIGUSR1);\nprint(\"Handler should have been called\");\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does ecdsa_free_keys(keypair: ecdsakeypair): null work in Hemlock?", "output": "Free ECDSA key pair memory. Always call when done with keys.\n\n```hemlock\necdsa_free_keys(keypair);\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does json deserialization work in Hemlock?", "output": "```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does murmur3(input: string, seed?: 0): i32 work in Hemlock?", "output": "MurmurHash3 (32-bit) - excellent distribution, widely used in production systems.\n\n```hemlock\nlet h = murmur3(\"hello world\");\nprint(h);  // -862545276\n\n// With custom seed\nlet h2 = murmur3(\"hello world\", 42);\nprint(h2);  // Different hash due to different seed\n\n// Seed changes output\nassert(murmur3(\"test\", 0) != murmur3(\"test\", 1));\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does replacement work in Hemlock?", "output": "**`replace(old, new)`** - Replace first occurrence:\n\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\" (first only)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does process identification work in Hemlock?", "output": "```hemlock\nimport { get_pid } from \"@stdlib/env\";\nimport { write_file } from \"@stdlib/fs\";\n\nfn create_pid_file(app_name: string): null {\n    let pid = get_pid();\n    let pid_file = \"/var/run/\" + app_name + \".pid\";\n\n    write_file(pid_file, typeof(pid));\n    print(\"PID file created: \" + pid_file);\n\n    return null;\n}\n\nfn remove_pid_file(app_name: string): null {\n    let pid_file = \"/var/run/\" + app_name + \".pid\";\n    // Remove file (using fs module)\n    return null;\n}\n\n// Usage in daemon/service\ncreate_pid_file(\"myapp\");\n// ... run application ...\n// remove_pid_file(\"myapp\");  // On shutdown\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test: Basic assert with truthy values\nassert(true);\nprint(\"assert(true) passed\");\n\nassert(1);\nprint(\"assert(1) passed\");\n\nassert(42);\nprint(\"assert(42) passed\");\n\nassert(\"non-empty\");\nprint(\"assert with non-empty string passed\");\n\n// Test: Assert with falsy values (should throw)\ntry {\n    assert(false);\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\ntry {\n    assert(0);\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\ntry {\n    assert(null);\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\ntry {\n    assert(\"\");\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Assert with custom message\ntry {\n    assert(false, \"custom error message\");\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\ntry {\n    assert(0, \"number was zero\");\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n```", "output": "assert(true) passed\nassert(1) passed\nassert(42) passed\nassert with non-empty string passed\nCaught: assertion failed\nCaught: assertion failed\nCaught: assertion failed\nCaught: assertion failed\nCaught: custom error message\nCaught: number was zero", "category": "tests/exceptions", "source": "tests/exceptions/assert_basic.hml"}
{"instruction": "How does graceful shutdown handler work in Hemlock?", "output": "```hemlock\nimport { exit } from \"@stdlib/env\";\nimport { signal, SIGINT, SIGTERM } from \"builtin\";  // Signal handling\n\nlet should_exit = false;\n\nfn handle_shutdown(sig: i32): null {\n    print(\"Received signal \" + typeof(sig) + \", shutting down...\");\n    should_exit = true;\n    return null;\n}\n\n// Register signal handlers\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Main loop\nwhile (!should_exit) {\n    // ... do work ...\n\n    if (should_exit) {\n        print(\"Performing cleanup...\");\n        // ... cleanup code ...\n        exit(0);\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does parse_ws_url work in Hemlock?", "output": "Parse WebSocket URL into components:\n\n```hemlock\nimport { parse_ws_url } from \"@stdlib/websocket\";\n\nlet parts = parse_ws_url(\"wss://example.com:8080/socket\");\n// {\n//     secure: true,\n//     host: \"example.com\",\n//     port: 8080,\n//     path: \"/socket\"\n// }\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does basic assignment work in Hemlock?", "output": "```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test process management builtins\n\n// Test process ID functions\nlet pid = get_pid();\nprint(pid > 0);\n\nlet ppid = getppid();\nprint(ppid > 0);\n\nlet uid = getuid();\nprint(uid >= 0);\n\nlet euid = geteuid();\nprint(euid >= 0);\n\nlet gid = getgid();\nprint(gid >= 0);\n\nlet egid = getegid();\nprint(egid >= 0);\n\n// Test that IDs are consistent\nprint(uid == getuid());\nprint(gid == getgid());\nprint(pid == get_pid());\n\n// Test exec\nlet result = exec(\"echo hello\");\nprint(result.exit_code == 0);\nprint(result.output == \"hello\\n\");\n\n// Note: fork/wait/waitpid/kill not tested here as they're\n// complex to test reliably in a test harness\n\nprint(\"done\");\n```", "output": "true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/process.hml"}
{"instruction": "How does memory management work in Hemlock?", "output": "Hemlock uses **manual memory management**:\n\n```hemlock\n// Safe buffer (recommended)\nlet buf = buffer(64);   // Allocate 64 bytes\nbuf[0] = 65;            // Set first byte to 'A'\nprint(buf[0]);          // 65\nfree(buf);              // Free memory\n\n// Raw pointer (advanced)\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // Fill with zeros\nfree(ptr);\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test channel timeout methods\nprint(\"=== Channel Timeout Tests ===\");\n\n// Test recv_timeout - should return null on timeout\nlet ch = channel(1);\n\n// Channel is empty, recv_timeout should return null after 100ms\nlet result = ch.recv_timeout(100);\nprint(\"recv_timeout on empty channel:\");\nprint(result == null);\n\n// Now send a value and receive it with timeout\nch.send(42);\nlet val = ch.recv_timeout(100);\nprint(\"recv with value:\");\nprint(val);\n\nch.close();\n\n// Test send_timeout - should return false on timeout when channel is full\nlet ch2 = channel(1);\n\n// Fill the channel\nch2.send(\"first\");\n\n// Channel is full, send_timeout should return false after 100ms\nlet success = ch2.send_timeout(\"second\", 100);\nprint(\"send_timeout on full channel:\");\nprint(success);\n\n// Drain the channel and try again\nlet first = ch2.recv();\nprint(\"drained:\");\nprint(first);\n\nlet success2 = ch2.send_timeout(\"second\", 100);\nprint(\"send after drain:\");\nprint(success2);\n\nlet second = ch2.recv();\nprint(\"received:\");\nprint(second);\n\nch2.close();\nprint(\"=== Done ===\");\n```", "output": "=== Channel Timeout Tests ===\nrecv_timeout on empty channel:\ntrue\nrecv with value:\n42\nsend_timeout on full channel:\nfalse\ndrained:\nfirst\nsend after drain:\ntrue\nreceived:\nsecond\n=== Done ===", "category": "parity/builtins", "source": "tests/parity/builtins/channel_timeout.hml"}
{"instruction": "How does pattern: configuration object work in Hemlock?", "output": "```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does 1. system libraries work in Hemlock?", "output": "```hemlock\n// Call sqrt from libm\nlet result = sqrt(16.0);  // 4.0\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does if without else work in Hemlock?", "output": "```hemlock\nif (x > 0) {\n    print(\"positive\");\n}\n// No else branch needed\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Show an example of multiple tasks example in Hemlock.", "output": "```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Spawn multiple tasks (run in parallel!)\nlet t1 = spawn(factorial, 5);   // Thread 1\nlet t2 = spawn(factorial, 6);   // Thread 2\nlet t3 = spawn(factorial, 7);   // Thread 3\nlet t4 = spawn(factorial, 8);   // Thread 4\n\n// All four are computing simultaneously!\n\n// Wait for results\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does tcp echo server work in Hemlock?", "output": "```hemlock\nimport { TcpListener } from \"@stdlib/net\";\n\nasync fn handle_client(stream) {\n    defer stream.close();\n\n    let data = stream.read(1024);\n    stream.write(data);  // Echo back\n}\n\nlet listener = TcpListener(\"0.0.0.0\", 8080);\ndefer listener.close();\n\nwhile (true) {\n    let stream = listener.accept();\n    spawn(handle_client, stream);  // Handle concurrently\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does negative indices work in Hemlock?", "output": "**Not supported** - Use positive indices only:\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // ERROR or undefined behavior\n\n// Use length for last element\nprint(arr[arr.length - 1]);  // 3\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does good use cases work in Hemlock?", "output": "**2. Quick data processing with Unix tools:**\n\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Unique lines: \" + r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does switch statements work in Hemlock?", "output": "```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other day\");\n        break;\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test typeof builtin\nprint(typeof(42));\nprint(typeof(\"hello\"));\nprint(typeof(true));\nprint(typeof(false));\nprint(typeof(null));\nprint(typeof(3.14));\n```", "output": "i32\nstring\nbool\nbool\nnull\nf64", "category": "tests/compiler", "source": "tests/compiler/typeof.hml"}
{"instruction": "How does scope rules work in Hemlock?", "output": "```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // Can access: inner_var, outer_var, global\n    }\n\n    // Can access: outer_var, global\n    // Cannot access: inner_var\n}\n\n// Can access: global\n// Cannot access: outer_var, inner_var\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does syntax work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} finally {\n    // always executes, even if exception thrown\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does pad_left(str, width, fill?) work in Hemlock?", "output": "- Padding length is calculated in codepoints (emoji = 1 character)\n\n```hemlock\nimport { pad_left } from \"@stdlib/strings\";\n\nlet s1 = pad_left(\"42\", 5);\nprint(s1);  // \"   42\"\n\nlet s2 = pad_left(\"42\", 5, \"0\");\nprint(s2);  // \"00042\"\n\nlet s3 = pad_left(\"test\", 10, \"*\");\nprint(s3);  // \"******test\"\n\n// Unicode fill character\nlet s4 = pad_left(\"Hi\", 5, \"ðŸš€\");\nprint(s4);  // \"ðŸš€ðŸš€ðŸš€Hi\"\nprint(s4.length);  // 5 (codepoints)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does file size work in Hemlock?", "output": "```hemlock\nfn file_size(path: string): i32 {\n    let f = open(path, \"r\");\n    try {\n        // Seek to end\n        let end = f.seek(999999999);  // Large number\n        f.seek(0);  // Reset\n        return end;\n    } finally {\n        f.close();\n    }\n}\n\nlet size = file_size(\"data.txt\");\nprint(\"File size: \" + typeof(size) + \" bytes\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does mixed value types work in Hemlock?", "output": "```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Show an example of example: word counter in Hemlock.", "output": "```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"The quick brown fox\";\nlet count = count_words(sentence);  // 4\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does user-defined signals work in Hemlock?", "output": "```hemlock\n// Use for custom communication\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does comparison methods work in Hemlock?", "output": "Check if two DateTime objects represent the same moment in time.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 15, 12, 0, 0);\nlet dt2 = from_date(2025, 1, 15, 12, 0, 0);\n\nif (dt1.is_equal(dt2)) {\n    print(\"Same time\");  // This will print\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does insertion & removal work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does channel type work in Hemlock?", "output": "```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does base64_encode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { base64_encode } from \"@stdlib/encoding\";\n\n// Basic encoding\nlet encoded1 = base64_encode(\"Hello, World!\");\nprint(encoded1);  // \"SGVsbG8sIFdvcmxkIQ==\"\n\n// Empty string\nlet encoded2 = base64_encode(\"\");\nprint(encoded2);  // \"\"\n\n// Binary data (all bytes 0-255)\nlet binary = \"\";\nlet i = 0;\nwhile (i < 256) {\n    let b: rune = i;\n    binary = binary + b;\n    i = i + 1;\n}\nlet encoded3 = base64_encode(binary);\n\n// Unicode/UTF-8\nlet encoded4 = base64_encode(\"Hello ä¸–ç•Œ ðŸš€\");\nprint(encoded4);  // UTF-8 bytes encoded to Base64\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does directory tree listing work in Hemlock?", "output": "```hemlock\nimport { list_dir, is_dir } from \"@stdlib/fs\";\n\nfn list_recursive(path: string, indent: string): null {\n    try {\n        let entries = list_dir(path);\n\n        let i = 0;\n        while (i < entries.length) {\n            let name = entries[i];\n            let full_path = path + \"/\" + name;\n\n            print(indent + name);\n\n            if (is_dir(full_path)) {\n                list_recursive(full_path, indent + \"  \");\n            }\n\n            i = i + 1;\n        }\n    } catch (e) {\n        print(indent + \"Error: \" + e);\n    }\n\n    return null;\n}\n\nprint(\"Directory tree:\");\nlist_recursive(\".\", \"\");\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does rune literals work in Hemlock?", "output": "```hemlock\nlet ch = 'A';\nlet emoji = 'ðŸš€';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does test-driven development (tdd) work in Hemlock?", "output": "1. Write the test first:\n\n```hemlock\ntest(\"parses JSON string\", fn() {\n    let obj = parse_json('{\"x\": 10}');\n    expect(obj.x).to_equal(10);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Variable declarations and assignments test\n\n// Basic declaration\nlet x = 10;\nprint(x);\n\n// Multiple declarations\nlet a = 1;\nlet b = 2;\nlet c = 3;\nprint(a + b + c);\n\n// Typed declarations\nlet i: i32 = 42;\nlet f: f64 = 3.14;\nlet s: string = \"hello\";\nlet flag: bool = true;\n\nprint(i);\nprint(f);\nprint(s);\nprint(flag);\n\n// Reassignment\nlet y = 5;\ny = 10;\nprint(y);\n\n// Block scoping\nlet z = 1;\n{\n    let inner = 2;\n    print(inner);\n    print(z);  // can access outer z\n}\nprint(z);\n\n// Compound assignment simulation\nlet counter = 0;\ncounter = counter + 1;\ncounter = counter + 1;\ncounter = counter + 1;\nprint(counter);\n```", "output": "10\n6\n42\n3.14\nhello\ntrue\n10\n2\n1\n1\n3", "category": "parity/language", "source": "tests/parity/language/variables.hml"}
{"instruction": "How does dot operator work in Hemlock?", "output": "```hemlock\n// Object field access\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Array property\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// String property\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Method call\nlet result = s.to_upper(); // \"HELLO\"\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does split & trim work in Hemlock?", "output": "**`split(delimiter)`** - Split into array of strings:\n\n```hemlock\nlet csv = \"apple,banana,cherry\";\nlet parts = csv.split(\",\");     // [\"apple\", \"banana\", \"cherry\"]\n\nlet words = \"one two three\".split(\" \");  // [\"one\", \"two\", \"three\"]\n\n// Empty delimiter splits by character\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does switch value types work in Hemlock?", "output": "Switch works with any value type:\n\n```hemlock\n// Integers\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"one\"); break;\n}\n\n// Strings\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// Booleans\nswitch (flag) {\n    case true: print(\"on\"); break;\n    case false: print(\"off\"); break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does all heap blocks were freed -- no leaks are possible work in Hemlock?", "output": "```hemlock\n**6. Run full test suite:**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does udp socket work in Hemlock?", "output": "```hemlock\nimport { UdpSocket } from \"@stdlib/net\";\n\nlet sock = UdpSocket(\"0.0.0.0\", 5000);\ndefer sock.close();\n\n// Receive datagram\nlet packet = sock.recv_from(1024);\nprint(\"Received from \" + packet.address + \":\" + typeof(packet.port));\n\n// Send reply\nsock.send_to(packet.address, packet.port, \"Reply\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does low-level builtins work in Hemlock?", "output": "Convert Unix timestamp to local time components.\n\n```hemlock\nimport { localtime } from \"@stdlib/datetime\";\n\nlet components = localtime(1737037845);\nprint(\"Year: \" + typeof(components.year));\nprint(\"Month: \" + typeof(components.month));\nprint(\"Day: \" + typeof(components.day));\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does type promotion work in Hemlock?", "output": "When mixing types, Hemlock promotes to the larger/more precise type:\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result is f64 (10.0 + 3.5 = 13.5)\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does fnv1a(input: string): i32 work in Hemlock?", "output": "FNV-1a hash algorithm - better avalanche properties than djb2 for certain data patterns.\n\n```hemlock\nlet h = fnv1a(\"hello world\");\nprint(h);  // -1382160680\n\n// FNV-1a is deterministic\nlet h2 = fnv1a(\"hello world\");\nassert(h == h2, \"Same input = same hash\");\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How do you define objects in Hemlock?", "output": "Hemlock supports object literals and defined types:\n\n```hemlock\n// Anonymous object\nlet point = { x: 10, y: 20 };\nprint(point.x);  // 10\n\n// Defined type with defaults\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true  // optional with default\n}\n\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(p.active);  // true (default)\n\n// Serialization\nlet json = p.serialize();\nlet restored = json.deserialize();\n```", "category": "concepts/objects", "source": "CLAUDE.md"}
{"instruction": "How does bg_rgb(r, g, b) work in Hemlock?", "output": "**Returns:** `string` - RGB background color code\n\n```hemlock\nimport { bg_rgb, rgb, RESET } from \"@stdlib/terminal\";\n\nprint(rgb(255, 255, 255) + bg_rgb(255, 0, 0) + \" White on red \" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does replacement work in Hemlock?", "output": "```hemlock\nstring.replace(old: string, new: string): string\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does low-level builtins work in Hemlock?", "output": "Format time components using strftime format string.\n\n```hemlock\nimport { strftime } from \"@stdlib/datetime\";\n\nlet components = {\n    year: 2025,\n    month: 12,\n    day: 25,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    weekday: 0,\n    yearday: 1\n};\n\nlet formatted = strftime(\"%B %d, %Y\", components);\nprint(formatted);  // \"December 25, 2025\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does queue operations work in Hemlock?", "output": "```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does resource management work in Hemlock?", "output": "Exception handling with cleanup:\n\n```hemlock\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();  // Runs even if exception is thrown\n\ntry {\n    stream.write(\"data\");\n    let response = stream.read(1024);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n// stream.close() called automatically here\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "Example module structure:\n\n```hemlock\nproject/\nâ”œâ”€â”€ main.hml\nâ”œâ”€â”€ lib/\nâ”‚   â”œâ”€â”€ math.hml\nâ”‚   â”œâ”€â”€ string.hml\nâ”‚   â””â”€â”€ index.hml (barrel module)\nâ””â”€â”€ utils/\n    â””â”€â”€ helpers.hml\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does memory operations work in Hemlock?", "output": "**`memset(ptr, byte, size)` - Fill memory**\n\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // Zero out 100 bytes\nmemset(p, 65, 10);     // Fill first 10 bytes with 'A'\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Provide a Hemlock example that demonstrates manage memory with alloc and free.", "output": "```hemlock\n// Memory Management Demo\n\n// 1. sizeof() - Query type sizes\nprint(sizeof(u8));     // 1\nprint(sizeof(i32));    // 4\nprint(sizeof(f64));    // 8\nprint(sizeof(ptr));    // 8 (on 64-bit systems)\n\n// 2. talloc() - Typed allocation\nlet numbers = talloc(i32, 10);  // allocate 10 i32s (40 bytes)\nprint(numbers);\n\n// Initialize the array using memset\nlet elem_size = sizeof(i32);\nlet total_bytes = elem_size * 10;\nmemset(numbers, 0, total_bytes);\n\n// 3. buffer() - Safe wrapper with bounds checking\nlet buf = buffer(256);\nbuf[0] = 72;   // 'H'\nbuf[1] = 101;  // 'e'\nbuf[2] = 108;  // 'l'\nbuf[3] = 108;  // 'l'\nbuf[4] = 111;  // 'o'\nprint(buf[0]);\nprint(buf.length);\n\n// 4. realloc() - Resize allocations\nlet p = alloc(64);\nprint(p);\np = realloc(p, 128);\nprint(p);\np = realloc(p, 256);\nprint(p);\n\n// Clean up\nfree(numbers);\nfree(buf);\nfree(p);\n```", "category": "examples", "source": "examples/memory_demo.hml"}
{"instruction": "How does buffer work in Hemlock?", "output": "```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Access with bounds checking\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // ERROR: out of bounds\n\nfree(buf);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does why message-passing? work in Hemlock?", "output": "This follows Hemlock's \"explicit over implicit\" philosophy:\n\n```hemlock\n// BAD: Shared mutable state (would cause data races)\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // Race!\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // Race!\n\n// GOOD: Message-passing via channels\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - no race condition\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does debugging failed tests work in Hemlock?", "output": "Use verbose mode to see errors inline:\n\n```hemlock\nrun({ verbose: true });\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does print work in Hemlock?", "output": "```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// Multiple values\nprint(\"x =\", 10, \"y =\", 20);\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test user-defined functions\nfn add(a, b) {\n    return a + b;\n}\n\nfn multiply(x, y) {\n    return x * y;\n}\n\nfn greet(name) {\n    print(\"Hello, \" + name + \"!\");\n    return null;\n}\n\n// Test function calls\nprint(add(10, 20));\nprint(multiply(6, 7));\ngreet(\"World\");\n\n// Test function with local variables\nfn compute(x) {\n    let doubled = x * 2;\n    let tripled = x * 3;\n    return doubled + tripled;\n}\n\nprint(compute(5));\n```", "output": "30\n42\nHello, World!\n25", "category": "tests/compiler", "source": "tests/compiler/functions.hml"}
{"instruction": "How does relational work in Hemlock?", "output": "```hemlock\nif (x < 10) { }     // Less than\nif (x > 10) { }     // Greater than\nif (x <= 10) { }    // Less than or equal\nif (x >= 10) { }    // Greater than or equal\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "- May return less than `size` bytes\n\n```hemlock\nlet data = stream.read(1024);\nprint(\"Received \" + typeof(data.length) + \" bytes\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does signal(signum, handler_fn) work in Hemlock?", "output": "```hemlock\nfn my_handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does safe practices work in Hemlock?", "output": "**3. Escape special characters:**\n\n```hemlock\nfn shell_escape(s: string): string {\n    // Simple escape - wrap in single quotes and escape single quotes\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does 4. no signal handling work in Hemlock?", "output": "Cannot send signals to running commands:\n\n```hemlock\nlet r = exec(\"long_command\");\n// Cannot send SIGINT, SIGTERM, etc. to the command\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does when to use type annotations work in Hemlock?", "output": "- Unnecessary ceremony\n\n```hemlock\n// Unnecessary\nlet x: i32 = 42;\n\n// Better\nlet x = 42;\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does tmpdir() work in Hemlock?", "output": "- Intermediate processing files\n\n```hemlock\nimport { tmpdir, get_pid } from \"@stdlib/os\";\nimport { get_pid } from \"@stdlib/env\";\n\nlet tmp = tmpdir();\nprint(\"Temp directory: \" + tmp);  // e.g., \"/tmp\"\n\n// Create unique temp file path\nlet temp_file = tmp + \"/myapp.\" + typeof(get_pid()) + \".tmp\";\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does array literals work in Hemlock?", "output": "```hemlock\nlet arr = [element1, element2, element3];\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does function type work in Hemlock?", "output": "```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test type checking builtins\n\n// Basic types\nprint(typeof(42));\nprint(typeof(3.14));\nprint(typeof(\"hello\"));\nprint(typeof(true));\nprint(typeof(false));\nprint(typeof(null));\n\n// Complex types\nprint(typeof([1, 2, 3]));\nprint(typeof({ x: 1 }));\n\n// Function type\nlet f = fn(x) { return x; };\nprint(typeof(f));\n\n// Specific numeric types\nlet i8v: i8 = 1;\nlet i16v: i16 = 1;\nlet i32v: i32 = 1;\nlet i64v: i64 = 1;\nlet u8v: u8 = 1;\nlet u16v: u16 = 1;\nlet u32v: u32 = 1;\nlet u64v: u64 = 1;\nlet f32v: f32 = 1.0;\nlet f64v: f64 = 1.0;\n\nprint(typeof(i8v));\nprint(typeof(i16v));\nprint(typeof(i32v));\nprint(typeof(i64v));\nprint(typeof(u8v));\nprint(typeof(u16v));\nprint(typeof(u32v));\nprint(typeof(u64v));\nprint(typeof(f32v));\nprint(typeof(f64v));\n\n// Rune type\nlet ch = 'A';\nprint(typeof(ch));\n\n// After operations\nlet sum = i32v + i64v;\nprint(typeof(sum));\n\n// Typed array\nlet arr: array<i32> = [1, 2, 3];\nprint(typeof(arr));\n\n// Buffer type\nlet buf = buffer(10);\nprint(typeof(buf));\nfree(buf);\n\n// Pointer type\nlet p = alloc(10);\nprint(typeof(p));\nfree(p);\n\nprint(\"done\");\n```", "output": "i32\nf64\nstring\nbool\nbool\nnull\narray\nobject\nfunction\ni8\ni16\ni32\ni64\nu8\nu16\nu32\nu64\nf32\nf64\nrune\ni64\narray\nbuffer\nptr\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/type_checking.hml"}
{"instruction": "How does runtime type checking work in Hemlock?", "output": "Type annotations are checked at **runtime**, not compile-time:\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // Runtime error: type mismatch\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hello\");     // Runtime error: type mismatch\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does pattern: character counting work in Hemlock?", "output": "```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does 5. argument validation work in Hemlock?", "output": "```hemlock\nfn validate_file(filename: string): bool {\n    // Check if file exists (example)\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Error: No filename provided\");\n} else if (!validate_file(args[1])) {\n    print(\"Error: Invalid file: \" + args[1]);\n} else {\n    print(\"Processing: \" + args[1]);\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does `logger.set_level(level)` work in Hemlock?", "output": "```hemlock\nimport { Logger, DEBUG, INFO, ERROR } from \"@stdlib/logging\";\n\nlet logger = Logger({ level: INFO });\n\nlogger.debug(\"Not shown\");   // Filtered\nlogger.info(\"Shown\");        // âœ“\n\n// Change to DEBUG level\nlogger.set_level(DEBUG);\n\nlogger.debug(\"Now shown\");   // âœ“\nlogger.info(\"Still shown\");  // âœ“\n\n// Change to ERROR only\nlogger.set_level(ERROR);\n\nlogger.info(\"Not shown\");    // Filtered\nlogger.warn(\"Not shown\");    // Filtered\nlogger.error(\"Shown\");       // âœ“\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does ptr (raw pointer) work in Hemlock?", "output": "```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Show an example of example 2: bitwise operators in Hemlock.", "output": "```hemlock\nlet result1 = 12 | 10 & 8;\n// Evaluated as: 12 | (10 & 8) = 12 | 8 = 12\n// & has higher precedence than |\n\nlet result2 = 8 | 1 << 2;\n// Evaluated as: 8 | (1 << 2) = 8 | 4 = 12\n// Shift has higher precedence than bitwise OR\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);\n// Evaluated as: 1 | 4 = 5\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does fall-through behavior work in Hemlock?", "output": "Cases without `break` fall through to the next case (C-style):\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C or below\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does method chaining work in Hemlock?", "output": "All string methods return new strings, enabling chaining:\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does reduce pattern work in Hemlock?", "output": "```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does string type work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\ns[0] = 'H';             // Set with rune\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test array find() and contains() with i64/u64 values\n// This tests the fix for Issue #4\n\n// Test with i64 values\nlet arr = [1, 2, 5000000000, 4, 5];\n\n// find() should locate i64 values\nlet idx = arr.find(5000000000);\nprint(idx);  // Expected: 2\n\n// find() should return -1 for non-existent i64\nlet idx2 = arr.find(9000000000);\nprint(idx2);  // Expected: -1\n\n// contains() should find i64 values\nlet has = arr.contains(5000000000);\nprint(has);  // Expected: true\n\n// contains() should return false for non-existent i64\nlet has2 = arr.contains(9000000000);\nprint(has2);  // Expected: false\n\n// Test with u64 values\nlet val1: u64 = 100;\nlet val2: u64 = 200;\nlet val3: u64 = 5000000000;\nlet val4: u64 = 400;\nlet arr2 = [val1, val2, val3, val4];\n\n// find() should locate u64 values\nprint(arr2.find(val3));  // Expected: 2\n\n// contains() should find u64 values\nprint(arr2.contains(val3));  // Expected: true\n```", "output": "2\n-1\ntrue\nfalse\n2\ntrue", "category": "tests/arrays", "source": "tests/arrays/test_i64_u64_find.hml"}
{"instruction": "How do you use pitfall: using panic for expected errors in Hemlock?", "output": "```hemlock\n// BAD: Panic for expected error\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Config file not found\");  // âŒ Too harsh\n    }\n    return read_file(path);\n}\n\n// GOOD: Throw for expected error\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Config file not found: \" + path;  // âœ… Recoverable\n    }\n    return read_file(path);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does validation work in Hemlock?", "output": "Validate JSON and return detailed result object.\n\n```hemlock\nimport { validate } from \"@stdlib/json\";\n\nlet result = validate('{\"x\":10}');\nprint(result.valid);  // true\n\nlet result2 = validate('{\"unclosed\"');\nprint(result2.valid);  // false\nprint(result2.message);  // Error message\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does environment variable validator work in Hemlock?", "output": "```hemlock\nimport { getenv, exit } from \"@stdlib/env\";\n\ndefine EnvVar {\n    name: string,\n    required: bool,\n    default_value?: string,\n}\n\nfn validate_environment(vars: array): object {\n    let config = {};\n    let errors = [];\n\n    let i = 0;\n    while (i < vars.length) {\n        let var_def = vars[i];\n        let value = getenv(var_def.name);\n\n        if (value == null) {\n            if (var_def.required) {\n                errors.push(\"Required variable \" + var_def.name + \" not set\");\n            } else if (var_def.default_value != null) {\n                value = var_def.default_value;\n            }\n        }\n\n        // Store in config object (simplified)\n        print(var_def.name + \" = \" + (value == null ? \"(not set)\" : value));\n\n        i = i + 1;\n    }\n\n    if (errors.length > 0) {\n        let j = 0;\n        while (j < errors.length) {\n            print(\"Error: \" + errors[j]);\n            j = j + 1;\n        }\n        exit(1);\n    }\n\n    return config;\n}\n\n// Usage\nlet env_vars = [\n    { name: \"API_KEY\", required: true },\n    { name: \"PORT\", required: false, default_value: \"8080\" },\n    { name: \"DEBUG\", required: false }\n];\n\nlet config = validate_environment(env_vars);\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does block scope work in Hemlock?", "output": "Variables are scoped to the nearest enclosing block:\n\n```hemlock\nlet x = 1;  // Outer scope\n\nif (true) {\n    let x = 2;  // Inner scope (shadows outer)\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does named arguments (flags) work in Hemlock?", "output": "Simple pattern for named arguments:\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Verbose mode enabled\");\n}\nprint(\"Input: \" + input_file);\nprint(\"Output: \" + output_file);\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does 4. configure from environment work in Hemlock?", "output": "```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet log_level = INFO;\nlet env_level = getenv(\"LOG_LEVEL\");\nif (env_level == \"DEBUG\") {\n    log_level = DEBUG;\n}\n\nlet logger = Logger({ level: log_level });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does allocation strategy work in Hemlock?", "output": "```hemlock\n- Direct malloc/free\n- No tracking\n- User responsibility to free\n\n**2. Buffers (`buffer`):**\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "How does temporary file creation work in Hemlock?", "output": "```hemlock\nimport { write_file, remove_file, exists } from \"@stdlib/fs\";\nimport { get_pid } from \"@stdlib/env\";\nimport { now } from \"@stdlib/time\";\n\nfn create_temp_file(prefix: string): string {\n    let pid = get_pid();\n    let timestamp = now();\n    let temp_path = \"/tmp/\" + prefix + \".\" + typeof(pid) + \".\" + typeof(timestamp);\n\n    let counter = 0;\n    let final_path = temp_path;\n\n    while (exists(final_path)) {\n        counter = counter + 1;\n        final_path = temp_path + \".\" + typeof(counter);\n    }\n\n    try {\n        write_file(final_path, \"\");\n        return final_path;\n    } catch (e) {\n        print(\"Error creating temp file: \" + e);\n        return \"\";\n    }\n}\n\nfn cleanup_temp_file(path: string): null {\n    if (exists(path)) {\n        try {\n            remove_file(path);\n        } catch (e) {\n            print(\"Error removing temp file: \" + e);\n        }\n    }\n    return null;\n}\n\n// Usage\nlet temp = create_temp_file(\"myapp\");\nprint(\"Temp file: \" + temp);\n// ... use temp file ...\ncleanup_temp_file(temp);\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does one-shot pattern matching work in Hemlock?", "output": "```hemlock\nimport { test } from \"@stdlib/regex\";\n\n// Test if string matches pattern\nif (test(\"^hello\", \"hello world\")) {\n    print(\"Match found!\");\n}\n\n// Case-insensitive matching\nimport { REG_ICASE } from \"@stdlib/regex\";\nif (test(\"HELLO\", \"hello world\", REG_ICASE)) {\n    print(\"Case-insensitive match!\");\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does memory operations work in Hemlock?", "output": "**`realloc(ptr, size)` - Resize allocation**\n\n```hemlock\nlet p = alloc(100);\n// ... use 100 bytes\np = realloc(p, 200);   // Resize to 200 bytes\n// ... use 200 bytes\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does signal work in Hemlock?", "output": "```hemlock\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Reset to default\nsignal(SIGINT, null);\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does writing work in Hemlock?", "output": "```hemlock\nfile.write_bytes(data: buffer): i32\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does exception propagation work in Hemlock?", "output": "Exceptions thrown in spawned tasks are propagated when joined:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught: \" + e);  // \"Caught: Task failed!\"\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does file properties work in Hemlock?", "output": "```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does duck typing (objects) work in Hemlock?", "output": "Objects use **structural typing** (duck typing):\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Has all required fields\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Extra fields allowed\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// ERROR: Missing 'age' field\nlet p3: Person = { name: \"Carol\" };\n\n// ERROR: Wrong type for 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show an example of example: array chunking in Hemlock.", "output": "```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does character types work in Hemlock?", "output": "```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// Multi-byte UTF-8\nlet rocket = 'ðŸš€';      // U+1F680\nlet heart = 'â¤';        // U+2764\nlet chinese = 'ä¸­';     // U+4E2D\n\n// Escape sequences\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// Unicode escapes\nlet emoji = '\\u{1F680}';   // Up to 6 hex digits\nlet max = '\\u{10FFFF}';    // Maximum codepoint\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does if statements work in Hemlock?", "output": "```hemlock\nif (condition) {\n    // body\n}\n\nif (condition) {\n    // then branch\n} else {\n    // else branch\n}\n\nif (condition1) {\n    // branch 1\n} else if (condition2) {\n    // branch 2\n} else {\n    // default branch\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does info() work in Hemlock?", "output": "**Returns:** `object` - Object containing all system information\n\n```hemlock\nimport { info } from \"@stdlib/os\";\n\nlet sys = info();\n\nprint(\"Platform: \" + sys.platform);\nprint(\"Architecture: \" + sys.arch);\nprint(\"OS Name: \" + sys.os_name);\nprint(\"OS Version: \" + sys.os_version);\nprint(\"Hostname: \" + sys.hostname);\nprint(\"Username: \" + sys.username);\nprint(\"Home Dir: \" + sys.homedir);\nprint(\"Temp Dir: \" + sys.tmpdir);\nprint(\"CPU Cores: \" + typeof(sys.cpu_count));\nprint(\"Total Memory: \" + typeof(sys.total_memory));\nprint(\"Free Memory: \" + typeof(sys.free_memory));\nprint(\"Uptime: \" + typeof(sys.uptime) + \" seconds\");\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does type aliases work in Hemlock?", "output": "```hemlock\nlet count: integer = 100;       // Same as i32\nlet price: number = 19.99;      // Same as f64\nlet b: byte = 255;              // Same as u8\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does named functions work in Hemlock?", "output": "```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does return statement work in Hemlock?", "output": "```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test typed arrays\n\n// Typed array of i32\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nprint(nums[0]);\nprint(nums.length);\n\n// Typed array of string\nlet names: array<string> = [\"Alice\", \"Bob\", \"Charlie\"];\nprint(names[0]);\nprint(names.length);\n\n// Untyped array (explicit)\nlet mixed: array = [1, \"hello\", true];\nprint(mixed[0]);\nprint(mixed[1]);\nprint(mixed[2]);\nprint(mixed.length);\n\nprint(\"done\");\n```", "output": "1\n5\nAlice\n3\n1\nhello\ntrue\n3\ndone", "category": "tests/compiler", "source": "tests/compiler/typed_arrays.hml"}
{"instruction": "How does file_checksum(path: string, hash_fn): string work in Hemlock?", "output": "Generic file checksum using any hash function.\n\n```hemlock\nimport { sha256, djb2, file_checksum } from \"@stdlib/hash\";\n\n// SHA-256 checksum of a file\nlet checksum = file_checksum(\"data.txt\", sha256);\nprint(checksum);  // Hex string (64 chars for SHA-256)\n\n// Fast non-crypto checksum\nlet fast_checksum = file_checksum(\"data.txt\", djb2);\nprint(fast_checksum);  // String representation of i32\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does processing large files in chunks work in Hemlock?", "output": "```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // 4KB chunks\n            if (chunk == \"\") { break; }\n\n            // Process chunk\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport {\n    base64_encode, base64_decode,\n    hex_encode, hex_decode,\n    url_encode, url_decode\n} from \"@stdlib/encoding\";\n\n// Base64 example\nlet data = \"Hello, World!\";\nlet b64 = base64_encode(data);\nprint(\"Base64: \" + b64);\nprint(\"Decoded: \" + base64_decode(b64));\n\n// Hex example\nlet hex = hex_encode(data);\nprint(\"\\nHex: \" + hex);\nprint(\"Decoded: \" + hex_decode(hex));\n\n// URL example\nlet url_data = \"hello@example.com?query=value\";\nlet url_enc = url_encode(url_data);\nprint(\"\\nURL Encoded: \" + url_enc);\nprint(\"Decoded: \" + url_decode(url_enc));\n\n// Working with binary data\nlet binary = \"\";\nlet i = 0;\nwhile (i < 10) {\n    let b: rune = i * 25;\n    binary = binary + b;\n    i = i + 1;\n}\n\nprint(\"\\nBinary data (10 bytes):\");\nprint(\"  Base64: \" + base64_encode(binary));\nprint(\"  Hex: \" + hex_encode(binary));\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "Show an example of complete example: hash table with murmurhash3 in Hemlock.", "output": "```hemlock\nimport { murmur3 } from \"@stdlib/hash\";\n\n// Simple hash table implementation\nfn create_hash_table(size: i32) {\n    let buckets = [];\n    let i = 0;\n    while (i < size) {\n        buckets.push([]);\n        i = i + 1;\n    }\n    return buckets;\n}\n\nfn hash_insert(table, key: string, value) {\n    let hash = murmur3(key);\n    let bucket_index = (hash % table.length);\n    if (bucket_index < 0) {\n        bucket_index = bucket_index + table.length;\n    }\n    table[bucket_index].push({key: key, value: value});\n    return null;\n}\n\n// Usage\nlet table = create_hash_table(16);\nhash_insert(table, \"name\", \"Alice\");\nhash_insert(table, \"age\", 30);\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does clone & merge work in Hemlock?", "output": "**Status:** Not yet implemented (requires object iteration builtin)\n\n```hemlock\n// Planned API:\nlet base = { x: 10, nested: { a: 1 } };\nlet update = { y: 20, nested: { b: 2 } };\nlet result = merge(base, update);\n// { x: 10, y: 20, nested: { a: 1, b: 2 } }\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does async/await work in Hemlock?", "output": "Hemlock has built-in structured concurrency with pthread-based parallelism:\n\n```hemlock\n// Define async function\nasync fn compute(n: i32): i32 {\n    return n * n;\n}\n\n// Spawn a task\nlet task = spawn(compute, 42);\n\n// Wait for result\nlet result = await task;  // or join(task)\nprint(result);  // 1764\n\n// Fire and forget\ndetach(spawn(background_work));\n\n// Channels for communication\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```", "category": "concepts/async", "source": "CLAUDE.md"}
{"instruction": "How does run(options?) work in Hemlock?", "output": "**Returns:** Object with test statistics:\n\n```hemlock\n{\n    total: i32,      // Total tests run\n    passed: i32,     // Tests that passed\n    failed: i32,     // Tests that failed\n    success: bool    // true if all tests passed\n}\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does do's work in Hemlock?", "output": "do_invalid_thing();  // Should error\n\n```hemlock\nâœ… **Use descriptive test names**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test: Basic reference counting - expressions are released\n// This test ensures that expression results are properly released\n\n// Standalone expression statements should not leak\n\"hello\";\n[1, 2, 3];\n({ x: 10, y: 20 });  // Parentheses force object literal interpretation\n42 + 58;\n\n// Variable assignments should have correct ref_count\nlet s = \"world\";\nlet arr = [4, 5, 6];\nlet obj = { a: 1, b: 2 };\n\n// Reassignment should release old values\ns = \"new string\";\narr = [7, 8, 9];\nobj = { c: 3, d: 4 };\n\n// Nested expressions\nlet combined = \"prefix_\" + \"suffix\";\nlet computed = [1, 2].concat([3, 4]);\n\n// Print to verify execution completed\nprint(\"refcount_basic test passed\");\n```", "output": "refcount_basic test passed", "category": "tests/memory", "source": "tests/memory/refcount_basic.hml"}
{"instruction": "How does unary bitwise work in Hemlock?", "output": "```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (two's complement)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does boolean assertions work in Hemlock?", "output": "Check boolean values.\n\n```hemlock\ntest(\"boolean checks\", fn() {\n    expect(true).to_be_true();\n    expect(false).to_be_false();\n    expect(5 > 3).to_be_true();\n    expect(10 < 5).to_be_false();\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test sizeof builtin\n\nprint(sizeof(\"i8\"));\nprint(sizeof(\"i16\"));\nprint(sizeof(\"i32\"));\nprint(sizeof(\"u8\"));\nprint(sizeof(\"u16\"));\nprint(sizeof(\"u32\"));\nprint(sizeof(\"f32\"));\nprint(sizeof(\"f64\"));\nprint(sizeof(\"ptr\"));\n\nprint(\"done\");\n```", "output": "1\n2\n4\n1\n2\n4\n4\n8\n8\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/sizeof.hml"}
{"instruction": "How does package format work in Hemlock?", "output": "Packaged executables use the HMLP format:\n\n```hemlock\n[hemlock binary][HMLB/HMLC payload][payload_size:u64][HMLP magic:u32]\n```", "category": "docs", "source": "docs/advanced/bundling-packaging.md"}
{"instruction": "Show an example of example 1: basic console logging in Hemlock.", "output": "```hemlock\n1638360123 [INFO] Application starting...\n1638360124 [INFO] Loading configuration\n1638360125 [INFO] Server ready on port 8080\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test HTTP/WebSocket builtins codegen\n// Without libwebsockets installed, actual calls exit with error.\n// This test verifies function-as-value (EXPR_IDENT) codegen works.\n\n// Test that HTTP functions are recognized as function values\nlet get_fn = __lws_http_get;\nprint(typeof(get_fn) == \"function\");\n\nlet post_fn = __lws_http_post;\nprint(typeof(post_fn) == \"function\");\n\nlet status_fn = __lws_response_status;\nprint(typeof(status_fn) == \"function\");\n\nlet body_fn = __lws_response_body;\nprint(typeof(body_fn) == \"function\");\n\nlet headers_fn = __lws_response_headers;\nprint(typeof(headers_fn) == \"function\");\n\nlet free_fn = __lws_response_free;\nprint(typeof(free_fn) == \"function\");\n\n// Test that functions can be stored in arrays\nlet funcs = [get_fn, post_fn, status_fn, body_fn, headers_fn, free_fn];\nprint(funcs.length == 6);\n\n// Verify functions stored in array are still functions\nprint(typeof(funcs[0]) == \"function\");\nprint(typeof(funcs[5]) == \"function\");\n\nprint(\"done\");\n```", "output": "true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/http_websocket.hml"}
{"instruction": "How does cos(x) work in Hemlock?", "output": "**Returns:** `f64` - Cosine of x in range [-1, 1]\n\n```hemlock\nimport { cos, PI } from \"@stdlib/math\";\n\nlet result = cos(0.0);        // 1.0\nlet result2 = cos(PI / 2.0);  // ~0.0\nlet result3 = cos(PI);        // -1.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does path access work in Hemlock?", "output": "Set value by path. Modifies object in-place.\n\n```hemlock\nimport { set } from \"@stdlib/json\";\n\nlet doc = { user: { name: \"Alice\" }, items: [1, 2, 3] };\n\n// Update nested property\nset(doc, \"user.name\", \"Bob\");\nprint(doc.user.name);  // \"Bob\"\n\n// Update array element\nset(doc, \"items.1\", 99);\nprint(doc.items[1]);  // 99\n\n// Add new property\nset(doc, \"user.email\", \"bob@example.com\");\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nlet future = pool.submit1(slow_compute, data);\n\n// Try to get result with 100ms timeout\nlet result = future.get_timeout(100);\nif (result == null) {\n    print(\"Still computing...\");\n    result = future.get();  // Wait for completion\n}\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "Show an example of example 3: git helper in Hemlock.", "output": "```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Error: Not a git repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Working directory clean\");\n    } else {\n        print(\"Changes:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Adding all changes...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Error adding files\");\n        return;\n    }\n\n    print(\"Committing...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Error committing\");\n        return;\n    }\n\n    print(\"Committed successfully\");\n    print(r2.output);\n}\n\n// Usage\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does closing work in Hemlock?", "output": "Close file (idempotent, can call multiple times).\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ... use file\nf.close();\nf.close();  // Safe - no error on second close\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test null coalescing operator (??)\n\n// Basic null coalescing\nlet a = null;\nprint(a ?? \"default\");\n\n// Non-null value\nlet b = \"hello\";\nprint(b ?? \"default\");\n\n// With numbers\nlet c = null;\nprint(c ?? 42);\n\nlet d = 100;\nprint(d ?? 42);\n\n// Chained null coalescing\nlet e = null;\nlet f = null;\nlet g = \"found\";\nprint(e ?? f ?? g);\n\n// All null\nlet h = null;\nlet i = null;\nprint(h ?? i ?? \"fallback\");\n\n// With zero (should NOT coalesce - zero is not null)\nlet zero = 0;\nprint(zero ?? 100);\n\n// With false (should NOT coalesce - false is not null)\nlet falsy = false;\nprint(falsy ?? true);\n\n// With empty string (should NOT coalesce)\nlet empty = \"\";\nprint(empty ?? \"default\");\nprint(empty == \"\" ?? \"was null\");\n\n// In function return\nfn maybeNull(flag) {\n    if (flag) {\n        return \"value\";\n    }\n    return null;\n}\n\nprint(maybeNull(true) ?? \"was null\");\nprint(maybeNull(false) ?? \"was null\");\n\n// Combined with optional chaining\nlet obj = { name: \"Alice\" };\nlet nullObj = null;\nprint(obj?.name ?? \"unknown\");\nprint(nullObj?.name ?? \"unknown\");\n\nprint(\"done\");\n```", "output": "default\nhello\n42\n100\nfound\nfallback\n0\nfalse\n\ntrue\nvalue\nwas null\nAlice\nunknown\ndone", "category": "parity/language", "source": "tests/parity/language/null_coalesce.hml"}
{"instruction": "How does `getuid(): i32` work in Hemlock?", "output": "Get the real user ID of the current process.\n\n```hemlock\nlet uid = getuid();\nprint(\"User ID: \" + typeof(uid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does closure environment access work in Hemlock?", "output": "However, **modifying variables from the parent scope is undefined behavior**:\n\n```hemlock\nlet x = 10;\n\nasync fn read_only(): i32 {\n    return x;  // OK: reading closure variable\n}\n\nasync fn modify_closure() {\n    x = 20;  // UNDEFINED BEHAVIOR: don't do this!\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does type annotations (optional) work in Hemlock?", "output": "```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hello\";\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does pattern: state machine work in Hemlock?", "output": "```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Starting...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Stopped\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does assert_throws(fn, expected_msg?) work in Hemlock?", "output": "Assert function throws exception.\n\n```hemlock\ntest(\"throw assertion\", fn() {\n    assert_throws(fn() {\n        throw \"error!\";\n    });\n\n    assert_throws(fn() {\n        throw \"specific error\";\n    }, \"specific error\");\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does typeof(value) work in Hemlock?", "output": "```hemlock\ntypeof(value: any): string\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does when you need `free()` vs when it's automatic work in Hemlock?", "output": "3. **Long-lived data** - globals or data stored in persistent structures:\n\n```hemlock\nlet cache = {};  // Module-level, lives until program exit unless freed\n\n   fn cleanup() {\n       free(cache);  // Manual cleanup for long-lived data\n   }\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test math builtins\n\n// sqrt\nlet x = sqrt(16.0);\nprint(x);\n\nlet y = sqrt(25.0);\nprint(y);\n\n// floor, ceil, round\nprint(floor(3.7));\nprint(ceil(3.2));\nprint(round(3.5));\nprint(round(3.4));\n\n// abs\nprint(abs(-5));\nprint(abs(5));\nprint(abs(-3.14));\n\n// min, max\nprint(min(10, 5));\nprint(max(10, 5));\nprint(min(3.14, 2.71));\nprint(max(3.14, 2.71));\n\n// pow, exp, log\nprint(pow(2, 3));\nprint(pow(2.0, 0.5));\n\n// trunc\nprint(trunc(3.9));\nprint(trunc(-3.9));\n\n// Trig functions (just test they work, not exact values)\nlet pi = 3.14159265359;\nlet sinval = sin(0.0);\nprint(sinval);\n\nlet cosval = cos(0.0);\nprint(cosval);\n\n// clamp\nprint(clamp(5, 0, 10));   // 5 (in range)\nprint(clamp(-5, 0, 10));  // 0 (below min)\nprint(clamp(15, 0, 10));  // 10 (above max)\n\n// rand_range - just test it runs (seeded for reproducibility)\nseed(42);\nlet r = rand_range(0.0, 10.0);\nprint(r >= 0.0 && r <= 10.0);  // true\n\n// log10, log2\nprint(log10(100.0));  // 2\nprint(log2(8.0));     // 3\n\n// atan2\nprint(atan2(1.0, 1.0) > 0.0);  // true (pi/4 radians)\n\nprint(\"done\");\n```", "output": "4\n5\n3\n4\n4\n3\n5\n5\n3.14\n5\n10\n2.71\n3.14\n8\n1.41421\n3\n-3\n0\n1\n5\n0\n10\ntrue\n2\n3\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/math_builtins.hml"}
{"instruction": "How does sensitive data work in Hemlock?", "output": "```hemlock\nimport { getenv, unsetenv } from \"@stdlib/env\";\n\n// Get sensitive value\nlet api_key = getenv(\"API_KEY\");\n\n// Use it...\nauthenticate(api_key);\n\n// Clear it from environment\nunsetenv(\"API_KEY\");\n\n// api_key variable still in memory, but not in environment\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does current implementation: exec() wrapper work in Hemlock?", "output": "This module wraps the curl CLI tool via Hemlock's `exec()` builtin:\n\n```hemlock\n// Simplified internal implementation\nlet cmd = \"curl -s -w '\\\\n%{http_code}' -L -X POST\";\ncmd = cmd + \" -H 'Content-Type: application/json'\";\ncmd = cmd + \" -d '\" + body + \"'\";\ncmd = cmd + \" '\" + url + \"'\";\n\nlet result = exec(cmd);\n// Parse result.output to extract body and status code\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does rsa_generate_key(): rsakeypair work in Hemlock?", "output": "Generate a 2048-bit RSA key pair for signing and verification.\n\n```hemlock\nimport { rsa_generate_key, rsa_free_keys } from \"@stdlib/crypto\";\n\nlet keypair = rsa_generate_key();\ndefer rsa_free_keys(keypair);  // Always free keys when done\n\nprint(typeof(keypair));  // \"RSAKeyPair\"\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does pitfall: swallowing errors work in Hemlock?", "output": "```hemlock\n// BAD: Silent failure\ntry {\n    risky_operation();\n} catch (e) {\n    // Error ignored - silent failure\n}\n\n// GOOD: Log or handle\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation failed: \" + e);\n    // Handle appropriately\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Show an example of example: custom error types in Hemlock.", "output": "```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a must be a number\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b must be a number\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Cannot divide by zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does detached lifecycle work in Hemlock?", "output": "```hemlock\nasync fn background() {\n    print(\"Background task running\");\n    return null;\n}\n\n// 1. Create task\nlet t = spawn(background);  // State: Running\n\n// 2. Detach task\ndetach(t);                  // State: Detached\n\n// Task continues running independently\n// Resources cleaned up by OS when done\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does writing work in Hemlock?", "output": "**Example - Copying binary file:**\n\n```hemlock\nlet src = open(\"input.bin\", \"r\");\nlet dst = open(\"output.bin\", \"w\");\n\nlet data = src.read_bytes(1024);\nwhile (data.length > 0) {\n    dst.write_bytes(data);\n    data = src.read_bytes(1024);\n}\n\nsrc.close();\ndst.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { ThreadPool, parallel_map } from \"@stdlib/async\";\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does import statements work in Hemlock?", "output": "**Namespace Import:**\n\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "Show an example of complete example: secure file storage in Hemlock.", "output": "Encrypt a file with AES and sign it with ECDSA to ensure authenticity and integrity.\n\n```hemlock\nimport { generate_aes_key, generate_iv, aes_encrypt, aes_decrypt } from \"@stdlib/crypto\";\nimport { ecdsa_generate_key, ecdsa_sign, ecdsa_verify, ecdsa_free_keys } from \"@stdlib/crypto\";\nimport { buffer_to_hex, hex_to_buffer } from \"@stdlib/crypto\";\nimport { write_file, read_file } from \"@stdlib/fs\";\n\n// Step 1: Generate keys\nlet aes_key = generate_aes_key();\nlet aes_iv = generate_iv();\nlet signing_key = ecdsa_generate_key();\ndefer ecdsa_free_keys(signing_key);\n\nprint(\"Keys generated\");\n\n// Step 2: Encrypt data\nlet plaintext = \"Sensitive financial data: $1,000,000 transaction\";\nlet ciphertext = aes_encrypt(plaintext, aes_key, aes_iv);\n\nprint(\"Data encrypted (\" + typeof(ciphertext.length) + \" bytes)\");\n\n// Step 3: Sign ciphertext\nlet ciphertext_hex = buffer_to_hex(ciphertext);\nlet signature = ecdsa_sign(ciphertext_hex, signing_key);\n\nprint(\"Data signed (\" + typeof(signature.length) + \" bytes)\");\n\n// Step 4: Save to file (in real app, you'd save key/IV securely)\nwrite_file(\"encrypted.bin\", ciphertext_hex);\nwrite_file(\"signature.bin\", buffer_to_hex(signature));\n\nprint(\"Files saved\");\n\n// Step 5: Load and verify\nlet loaded_ciphertext_hex = read_file(\"encrypted.bin\");\nlet loaded_signature_hex = read_file(\"signature.bin\");\n\nlet loaded_ciphertext = hex_to_buffer(loaded_ciphertext_hex);\nlet loaded_signature = hex_to_buffer(loaded_signature_hex);\n\n// Step 6: Verify signature\nlet valid = ecdsa_verify(loaded_ciphertext_hex, loaded_signature, signing_key);\n\nif (!valid) {\n    panic(\"Signature verification failed! File may be tampered.\");\n}\n\nprint(\"âœ“ Signature verified\");\n\n// Step 7: Decrypt\nlet decrypted = aes_decrypt(loaded_ciphertext, aes_key, aes_iv);\n\nprint(\"Decrypted: \" + decrypted);\n\nif (decrypted == plaintext) {\n    print(\"âœ“ File integrity verified!\");\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does memory copy pattern work in Hemlock?", "output": "```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// Create copy\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does http methods work in Hemlock?", "output": "Perform an HTTP DELETE request.\n\n```hemlock\nlet response = delete(\"https://api.example.com/users/1\", null);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "Show an example of memory layout examples in Hemlock.", "output": "```hemlock\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // Pointer to heap\n}\n\nHeap: Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "Show an example of example in Hemlock.", "output": "```hemlock\nimport { Stack } from \"@stdlib/collections\";\n\nlet s = Stack();\n\n// Push items\ns.push(10);\ns.push(20);\ns.push(30);\n\n// Peek at top\nprint(s.peek());  // 30\n\n// Pop items (LIFO order)\nprint(s.pop());  // 30\nprint(s.pop());  // 20\nprint(s.pop());  // 10\n\n// Check if empty\nif (s.is_empty()) {\n    print(\"Stack is empty\");\n}\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does download progress work in Hemlock?", "output": "```hemlock\nimport { ProgressBar } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nfn download(url: string, size: i32): null {\n    print(\"Downloading: \" + url);\n\n    let bar = ProgressBar(size, 50);\n    let downloaded = 0;\n\n    while (downloaded < size) {\n        // Simulate download chunk\n        let chunk_size = 1024;\n        if (downloaded + chunk_size > size) {\n            chunk_size = size - downloaded;\n        }\n\n        downloaded = downloaded + chunk_size;\n        bar.update(downloaded);\n        sleep(0.01);\n    }\n\n    bar.finish();\n    print(\"Download complete!\");\n    return null;\n}\n\ndownload(\"http://example.com/file.zip\", 102400);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does setenv(name, value) work in Hemlock?", "output": "- Setting feature flags\n\n```hemlock\nimport { setenv, getenv } from \"@stdlib/env\";\n\n// Set a new environment variable\nsetenv(\"MY_APP_CONFIG\", \"/etc/myapp/config.json\");\n\n// Update existing variable\nlet path = getenv(\"PATH\");\nsetenv(\"PATH\", path + \":/usr/local/myapp/bin\");\n\n// Set debugging flag\nsetenv(\"DEBUG\", \"1\");\n\n// Verify\nprint(\"Config: \" + getenv(\"MY_APP_CONFIG\"));\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does closures in callbacks work in Hemlock?", "output": "Callbacks capture their closure environment, so they can access outer scope variables:\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // Can access 'multiplier' from outer scope\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "**Bitwise XOR (`^`)**\n\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does 5. close files in reverse order of opening work in Hemlock?", "output": "```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... use files\n} finally {\n    // Close in reverse order\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test string builtin functions\n\n// Length - basic ASCII (emoji length differs between interpreter and compiler)\nprint(\"hello\".length);\nprint(\"\".length);\n\n// Character access\nprint(\"hello\".char_at(0));\nprint(\"hello\".char_at(4));\n\n// Byte access\nprint(\"hello\".byte_at(0));\nprint(\"hello\".byte_at(4));\n\n// Chars iteration\nlet chars = \"abc\".chars();\nprint(chars[0]);\nprint(chars[1]);\nprint(chars[2]);\nprint(chars.length);\n\n// Bytes\nlet bytes = \"Hi\".bytes();\nprint(bytes[0]);\nprint(bytes[1]);\nprint(bytes.length);\n\n// to_bytes\nlet b = \"AB\".to_bytes();\nprint(b[0]);\nprint(b[1]);\n\n// String concatenation\nlet a = \"Hello\";\nlet b2 = \" World\";\nprint(a + b2);\n\n// String with numbers\nlet num = 42;\nprint(\"Value: \" + num);\n\n// Template string\nlet name = \"Alice\";\nprint(`Hello ${name}!`);\n\n// Nested template\nlet x = 5;\nlet y = 3;\nprint(`${x} + ${y} = ${x + y}`);\n\nprint(\"done\");\n```", "output": "5\n0\n'h'\n'o'\n104\n111\n'a'\n'b'\n'c'\n3\n72\n105\n2\n65\n66\nHello World\nValue: 42\nHello Alice!\n5 + 3 = 8\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/string_builtins.hml"}
{"instruction": "How does chdir(path) work in Hemlock?", "output": "**Throws:** Exception if directory doesn't exist or cannot be accessed\n\n```hemlock\nimport { chdir, cwd } from \"@stdlib/fs\";\n\ntry {\n    print(\"Before: \" + cwd());\n\n    chdir(\"/tmp\");\n    print(\"After: \" + cwd());\n\n    // Change back\n    chdir(\"..\");\n} catch (e) {\n    print(\"Error changing directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How do you use 2. provide usage information in Hemlock?", "output": "```hemlock\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show help\");\n    print(\"  -v, --verbose  Verbose output\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does equality work in Hemlock?", "output": "Works with all types:\n\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does comparison operators work in Hemlock?", "output": "```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// String comparison\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexicographic)\n\n// Mixed types\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (promoted to i32)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does substring & slicing work in Hemlock?", "output": "**`slice(start, end)`** - Extract substring by range (end exclusive):\n\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\" (index 0 to 4)\nlet slice2 = s.slice(6, 11);    // \"world\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does closure with parameters work in Hemlock?", "output": "```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test try/catch/finally\n\n// Basic try/catch\ntry {\n    print(\"try block\");\n    throw \"error!\";\n    print(\"never reached\");\n} catch (e) {\n    print(\"caught\");\n    print(e);\n}\n\nprint(\"---\");\n\n// Try/finally without throw\ntry {\n    print(\"try 2\");\n} finally {\n    print(\"finally 2\");\n}\n\nprint(\"---\");\n\n// Try/catch/finally with throw\ntry {\n    print(\"try 3\");\n    throw \"boom\";\n} catch (e) {\n    print(\"caught 3\");\n} finally {\n    print(\"finally 3\");\n}\n\nprint(\"done\");\n```", "output": "try block\ncaught\nerror!\n---\ntry 2\nfinally 2\n---\ntry 3\ncaught 3\nfinally 3\ndone", "category": "tests/compiler", "source": "tests/compiler/exceptions.hml"}
{"instruction": "How does replacement work in Hemlock?", "output": "```hemlock\nstring.replace_all(old: string, new: string): string\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does compilation errors work in Hemlock?", "output": "```hemlock\n4. Check that all dependencies are installed\n5. Try rebuilding from scratch:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does comparison work in Hemlock?", "output": "Deep equality check for values.\n\n```hemlock\nimport { equals } from \"@stdlib/json\";\n\nlet obj1 = { x: 10, items: [1, 2, 3] };\nlet obj2 = { x: 10, items: [1, 2, 3] };\n\nprint(equals(obj1, obj2));  // true\n\nobj2.x = 20;\nprint(equals(obj1, obj2));  // false\n\n// Array comparison\nprint(equals([1, 2, 3], [1, 2, 3]));  // true\nprint(equals([1, 2, 3], [1, 2]));  // false\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does free_memory() work in Hemlock?", "output": "**Note:** On Linux, this includes buffers/cache as \"available\" memory.\n\n```hemlock\nimport { free_memory, format_bytes } from \"@stdlib/os\";\n\nlet free = free_memory();\nprint(\"Available memory: \" + format_bytes(free));  // e.g., \"8 GB\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "Exceptions thrown in tasks are captured and re-thrown when `get()` or `get_timeout()` is called:\n\n```hemlock\nfn failing_task() {\n    throw \"Something went wrong\";\n}\n\nlet pool = ThreadPool(2);\nlet future = pool.submit(failing_task);\n\ntry {\n    let result = future.get();\n} catch (e) {\n    print(\"Task failed: \" + e);  // \"Task failed: Something went wrong\"\n}\n\npool.shutdown();\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test defer statement - LIFO order execution\n\nfn test_single_defer() {\n    defer print(\"cleanup\");\n    print(\"work\");\n    return null;\n}\n\nfn test_multiple_defers() {\n    defer print(\"first\");\n    defer print(\"second\");\n    defer print(\"third\");\n    print(\"start\");\n    return null;\n}\n\nfn test_early_return() {\n    defer print(\"always runs\");\n    print(\"before return\");\n    return 42;\n}\n\n// Run tests\ntest_single_defer();\nprint(\"---\");\ntest_multiple_defers();\nprint(\"---\");\nlet result = test_early_return();\nprint(result);\nprint(\"done\");\n```", "output": "work\ncleanup\n---\nstart\nthird\nsecond\nfirst\n---\nbefore return\nalways runs\n42\ndone", "category": "parity/language", "source": "tests/parity/language/defer.hml"}
{"instruction": "How does stdlib imports work in Hemlock?", "output": "The bundler automatically resolves `@stdlib/` imports:\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```", "category": "docs", "source": "docs/advanced/bundling-packaging.md"}
{"instruction": "How does circular dependency detection work in Hemlock?", "output": "The module system detects circular dependencies and reports an error:\n\n```hemlock\nError: Circular dependency detected when loading '/path/to/a.hml'\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does float literal inference work in Hemlock?", "output": "```hemlock\nlet x = 3.14;        // f64 (default)\nlet y: f32 = 3.14;   // f32 (explicit)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does building arrays work in Hemlock?", "output": "```hemlock\nlet arr = [];\n\n// Build array with loop\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does double-free work in Hemlock?", "output": "```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // Set to null after freeing\n\nif (p != null) {\n    free(p);  // Won't execute\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does formatting methods work in Hemlock?", "output": "Get the full month name.\n\n```hemlock\nlet dt = from_date(2025, 3, 15, 0, 0, 0);\nprint(dt.month_name());  // \"March\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does typeof(value) work in Hemlock?", "output": "```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does type: array of strings work in Hemlock?", "output": "All arguments are stored as strings:\n\n```hemlock\n// Arguments: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\" (string, not number)\nprint(args[2]);  // \"3.14\" (string, not number)\nprint(args[3]);  // \"true\" (string, not boolean)\n\n// Convert as needed:\nlet num = 42;  // Parse manually if needed\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does semicolons are mandatory work in Hemlock?", "output": "Unlike JavaScript or Python, semicolons are **always required** at the end of statements:\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does index operator work in Hemlock?", "output": "```hemlock\n// Array indexing\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// String indexing (returns rune)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Buffer indexing\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does url_decode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { url_decode } from \"@stdlib/encoding\";\n\n// Basic decoding\nlet decoded1 = url_decode(\"Hello+World\");\nprint(decoded1);  // \"Hello World\"\n\n// %20 also decodes to space\nlet decoded2 = url_decode(\"Hello%20World\");\nprint(decoded2);  // \"Hello World\"\n\n// Percent-encoded characters\nlet decoded3 = url_decode(\"hello%40example.com\");\nprint(decoded3);  // \"hello@example.com\"\n\n// Complex URL\nlet decoded4 = url_decode(\"key%3Dvalue%26foo%3Dbar\");\nprint(decoded4);  // \"key=value&foo=bar\"\n\n// Unicode\nlet decoded5 = url_decode(\"Hello+%E4%B8%96%E7%95%8C\");\nprint(decoded5);  // \"Hello ä¸–ç•Œ\"\n\n// Round-trip\nlet original = \"Hello, World! 100% sure?\";\nlet encoded = url_encode(original);\nlet decoded6 = url_decode(encoded);\nprint(decoded6 == original);  // true\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does cross-platform configuration paths work in Hemlock?", "output": "```hemlock\nimport { platform, homedir } from \"@stdlib/os\";\n\nfn get_config_dir(app_name: string): string {\n    let p = platform();\n    let home = homedir();\n\n    if (p == \"linux\") {\n        // Follow XDG Base Directory spec\n        return home + \"/.config/\" + app_name;\n    } else if (p == \"macos\") {\n        return home + \"/Library/Application Support/\" + app_name;\n    } else if (p == \"windows\") {\n        // On Windows, use APPDATA\n        return home + \"/AppData/Roaming/\" + app_name;\n    }\n\n    // Fallback\n    return home + \"/.\" + app_name;\n}\n\nfn get_data_dir(app_name: string): string {\n    let p = platform();\n    let home = homedir();\n\n    if (p == \"linux\") {\n        return home + \"/.local/share/\" + app_name;\n    } else if (p == \"macos\") {\n        return home + \"/Library/\" + app_name;\n    } else if (p == \"windows\") {\n        return home + \"/AppData/Local/\" + app_name;\n    }\n\n    return home + \"/.\" + app_name + \"/data\";\n}\n\nprint(\"Config: \" + get_config_dir(\"myapp\"));\nprint(\"Data: \" + get_data_dir(\"myapp\"));\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does basic syntax work in Hemlock?", "output": "Single quotes denote rune literals:\n\n```hemlock\nlet a = 'A';            // ASCII character\nlet b = '0';            // Digit character\nlet c = '!';            // Punctuation\nlet d = ' ';            // Space\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does test file format work in Hemlock?", "output": "**Example: tests/primitives/integers.hml**\n\n```hemlock\n// Test basic integer literals\nlet x = 42;\nprint(x);  // Expect: 42\n\nlet y: i32 = 100;\nprint(y);  // Expect: 100\n\n// Test arithmetic\nlet sum = x + y;\nprint(sum);  // Expect: 142\n\n// Test type inference\nlet small = 10;\nprint(typeof(small));  // Expect: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Expect: i64\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does multiple files work in Hemlock?", "output": "```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does catching ctrl+c work in Hemlock?", "output": "```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Program continues running...\n// User presses Ctrl+C -> handle_interrupt() is called\n\nwhile (!interrupted) {\n    // Do work...\n}\n\nprint(\"Exiting due to interrupt\");\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does pattern: filter work in Hemlock?", "output": "```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does braces are always required work in Hemlock?", "output": "All control flow blocks must use braces, even for single statements:\n\n```hemlock\n// âœ… CORRECT\nif (x > 0) {\n    print(\"positive\");\n}\n\n// âŒ ERROR: Missing braces\nif (x > 0)\n    print(\"positive\");\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does value comparison work in Hemlock?", "output": "`find()` and `contains()` use value equality:\n\n```hemlock\n// Primitives: compare by value\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// Strings: compare by value\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// Objects: compare by reference\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true (same reference)\narr2.contains(obj2);  // false (different reference)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does project structure work in Hemlock?", "output": "```hemlock\nhemlock/\nâ”œâ”€â”€ include/              # Public headers\nâ”‚   â”œâ”€â”€ ast.h            # AST node definitions\nâ”‚   â”œâ”€â”€ lexer.h          # Tokenization API\nâ”‚   â”œâ”€â”€ parser.h         # Parsing API\nâ”‚   â””â”€â”€ interpreter.h    # Interpreter public API\nâ”œâ”€â”€ src/                  # Implementation\nâ”‚   â”œâ”€â”€ ast.c             # AST node constructors and cleanup\nâ”‚   â”œâ”€â”€ lexer.c           # Tokenization implementation\nâ”‚   â”œâ”€â”€ parser.c          # Parsing (tokens â†’ AST)\nâ”‚   â”œâ”€â”€ main.c            # CLI entry point, REPL\nâ”‚   â””â”€â”€ interpreter/      # Interpreter subsystem (modular)\nâ”‚       â”œâ”€â”€ internal.h        # Internal API shared between modules\nâ”‚       â”œâ”€â”€ environment.c     # Variable scoping (121 lines)\nâ”‚       â”œâ”€â”€ values.c          # Value constructors, data structures (394 lines)\nâ”‚       â”œâ”€â”€ types.c           # Type system, conversions, duck typing (440 lines)\nâ”‚       â”œâ”€â”€ builtins.c        # Builtin functions, registration (955 lines)\nâ”‚       â”œâ”€â”€ io.c              # File I/O, serialization (449 lines)\nâ”‚       â”œâ”€â”€ ffi.c             # Foreign function interface (libffi)\nâ”‚       â””â”€â”€ runtime.c         # eval_expr, eval_stmt, control flow (865 lines)\nâ”œâ”€â”€ tests/                # Test suite\nâ”‚   â”œâ”€â”€ primitives/       # Type system tests\nâ”‚   â”œâ”€â”€ conversions/      # Type conversion tests\nâ”‚   â”œâ”€â”€ memory/           # Pointer/buffer tests\nâ”‚   â”œâ”€â”€ strings/          # String operation tests\nâ”‚   â”œâ”€â”€ control/          # Control flow tests\nâ”‚   â”œâ”€â”€ functions/        # Function and closure tests\nâ”‚   â”œâ”€â”€ objects/          # Object, method, serialization tests\nâ”‚   â”œâ”€â”€ arrays/           # Array operations tests\nâ”‚   â”œâ”€â”€ loops/            # For, while, break, continue tests\nâ”‚   â”œâ”€â”€ exceptions/       # Try/catch/finally/throw tests\nâ”‚   â”œâ”€â”€ io/               # File I/O tests\nâ”‚   â”œâ”€â”€ async/            # Async/concurrency tests\nâ”‚   â”œâ”€â”€ ffi/              # FFI tests\nâ”‚   â”œâ”€â”€ args/             # Command-line argument tests\nâ”‚   â””â”€â”€ run_tests.sh      # Test runner\nâ”œâ”€â”€ examples/             # Example programs\nâ””â”€â”€ docs/                 # Documentation\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "How does `geteuid(): i32` work in Hemlock?", "output": "Get the effective user ID of the current process.\n\n```hemlock\nlet euid = geteuid();\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does max(a, b) work in Hemlock?", "output": "**Returns:** `f64` - Maximum of a and b\n\n```hemlock\nimport { max } from \"@stdlib/math\";\n\nlet result = max(5.0, 10.0);  // 10.0\nlet result2 = max(-3.0, 2.0); // 2.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "```hemlock\n// BAD: Memory leak\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // Memory leaked!\n}\n\n// GOOD: Proper cleanup\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... use memory ...\n    free(p);\n    return null;\n}\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does accepting connections work in Hemlock?", "output": "```hemlock\nwhile (true) {\n    let conn = server.accept(-1);  // Block forever\n    if (conn != null) {\n        spawn(handle_client, conn);\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does test(name, fn) work in Hemlock?", "output": "Define a test case within a suite.\n\n```hemlock\ndescribe(\"Calculator\", fn() {\n    test(\"adds positive numbers\", fn() {\n        expect(add(2, 3)).to_equal(5);\n    });\n\n    test(\"handles negative numbers\", fn() {\n        expect(add(-5, 3)).to_equal(-2);\n    });\n\n    test(\"handles zero\", fn() {\n        expect(add(0, 0)).to_equal(0);\n    });\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does platform() work in Hemlock?", "output": "- Feature availability checks\n\n```hemlock\nimport { platform } from \"@stdlib/os\";\n\nlet p = platform();\nprint(\"Running on: \" + p);  // e.g., \"linux\"\n\nif (p == \"linux\") {\n    print(\"Using Linux-specific features\");\n} else if (p == \"macos\") {\n    print(\"Using macOS-specific features\");\n} else if (p == \"windows\") {\n    print(\"Using Windows-specific features\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does memset work in Hemlock?", "output": "```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does unicode support work in Hemlock?", "output": "All functions are **Unicode-aware** and work with UTF-8 encoded strings:\n\n```hemlock\nimport { reverse, pad_left, pad_right, center } from \"@stdlib/strings\";\n\n// Reverse with emojis\nprint(reverse(\"Hello ðŸŒ\"));      // \"ðŸŒ olleH\"\nprint(reverse(\"ðŸš€ðŸŒŸðŸ’«\"));        // \"ðŸ’«ðŸŒŸðŸš€\"\n\n// Reverse with CJK characters\nprint(reverse(\"ä½ å¥½\"));          // \"å¥½ä½ \"\nprint(reverse(\"ã“ã‚“ã«ã¡ã¯\"));    // \"ã¯ã¡ã«ã‚“ã“\"\n\n// Padding with Unicode\nlet s1 = pad_left(\"test\", 10, \"â–ˆ\");\nprint(s1);  // \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆtest\"\n\nlet s2 = pad_right(\"test\", 10, \"â–‘\");\nprint(s2);  // \"testâ–‘â–‘â–‘â–‘â–‘â–‘\"\n\n// Centering with Unicode\nlet s3 = center(\"ä¸­\", 5, \"â”€\");\nprint(s3);  // \"â”€â”€ä¸­â”€â”€\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does planned features work in Hemlock?", "output": "```hemlock\n// Future: Type annotations for FFI\n@ffi(\"libm.so\")\nfn sqrt(x: f64): f64;\n\nlet result = sqrt(16.0);  // Type-checked\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test closures - capturing variables from enclosing scope\n\n// Closure factory (makeAdder pattern)\nfn makeAdder(n) {\n    return fn(x) {\n        return n + x;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\nprint(add5(3));\nprint(add10(3));\n\n// Multiple captures from function parameter\nfn makeMultiplier(a, b) {\n    return fn(x) {\n        return a * x + b;\n    };\n}\n\nlet mult = makeMultiplier(2, 3);\nprint(mult(5));\n\nprint(\"done\");\n```", "output": "8\n13\n13\ndone", "category": "parity/language", "source": "tests/parity/language/closures.hml"}
{"instruction": "How does signal work in Hemlock?", "output": "**Handler Signature:**\n\n```hemlock\nfn handler(signum: i32) {\n    // signum contains the signal number\n}\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does phase 1: lexical analysis (lexer) work in Hemlock?", "output": "**Implementation:** `src/lexer.c`\n\n```hemlock\nSource: \"let x = 42;\"\n   â†“\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "Show an example of complete ecdsa example in Hemlock.", "output": "```hemlock\nimport {\n    ecdsa_generate_key,\n    ecdsa_sign,\n    ecdsa_verify,\n    ecdsa_free_keys,\n    buffer_to_hex\n} from \"@stdlib/crypto\";\n\n// Generate key pair (fast operation)\nprint(\"Generating ECDSA P-256 key pair...\");\nlet keypair = ecdsa_generate_key();\ndefer ecdsa_free_keys(keypair);\n\n// Sign a message\nlet message = \"Authenticate this message\";\nlet signature = ecdsa_sign(message, keypair);\n\nprint(\"Message: \" + message);\nprint(\"Signature (\" + typeof(signature.length) + \" bytes): \" + buffer_to_hex(signature));\n\n// Verify signature\nlet valid = ecdsa_verify(message, signature, keypair);\nprint(\"Signature valid: \" + typeof(valid));  // true\n\n// Tamper with message\nlet tampered = \"Authenticate this messag3\";\nlet still_valid = ecdsa_verify(tampered, signature, keypair);\nprint(\"Tampered message valid: \" + typeof(still_valid));  // false\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does for-in iteration (including script name) work in Hemlock?", "output": "```hemlock\nscript.hml\nfoo\nbar\nbaz\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does abs(x) work in Hemlock?", "output": "**Returns:** `f64` - |x|\n\n```hemlock\nimport { abs } from \"@stdlib/math\";\n\nlet result = abs(-5.0);  // 5.0\nlet result2 = abs(3.2);  // 3.2\nlet result3 = abs(0.0);  // 0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does equality work in Hemlock?", "output": "```hemlock\nif (x == 10) { }    // Equal\nif (x != 10) { }    // Not equal\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does async_read_file work in Hemlock?", "output": "```hemlock\nimport { async_read_file } from \"@stdlib/async_fs\";\n\nlet future = async_read_file(\"data.txt\");\n// Do other work...\nlet content = future.get();\nprint(content);\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does type checking work in Hemlock?", "output": "Get JSON type as string.\n\n```hemlock\nimport { type_of } from \"@stdlib/json\";\n\nprint(type_of({}));  // \"object\"\nprint(type_of([]));  // \"array\"\nprint(type_of(\"text\"));  // \"string\"\nprint(type_of(42));  // \"number\"\nprint(type_of(true));  // \"bool\"\nprint(type_of(null));  // \"null\"\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "Show an example of bitwise examples in Hemlock.", "output": "```hemlock\n// Check if bit is set\nif (flags & 0x04) {\n    print(\"bit 2 is set\");\n}\n\n// Set a bit\nflags = flags | 0x08;\n\n// Clear a bit\nflags = flags & ~0x02;\n\n// Toggle a bit\nflags = flags ^ 0x01;\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does pitfall: modifying captured variables work in Hemlock?", "output": "```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Can read and modify captured variables\n        return count;\n    };\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does finally block work in Hemlock?", "output": "**Finally with control flow:**\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // âœ… Breaks after finally runs\n        }\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Show an example of example 1: basic console logging in Hemlock.", "output": "```hemlock\nimport { Logger, INFO } from \"@stdlib/logging\";\n\nlet logger = Logger();\n\nlogger.info(\"Application starting...\");\nlogger.info(\"Loading configuration\");\nlogger.info(\"Server ready on port 8080\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does test organization work in Hemlock?", "output": "4. **Group related tests:**\n\n```hemlock\ndescribe(\"String methods\", fn() {\n    describe(\"substr()\", fn() {\n        test(\"extracts substring\", fn() { ... });\n        test(\"handles out of bounds\", fn() { ... });\n    });\n\n    describe(\"split()\", fn() {\n        test(\"splits on delimiter\", fn() { ... });\n        test(\"returns single element for no matches\", fn() { ... });\n    });\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does comparison work in Hemlock?", "output": "Runes can be compared for equality:\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Case sensitive\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Runes can be compared with integers (codepoint values)\nprint(a == 65);                 // true (implicit conversion)\nprint('ðŸš€' == 128640);          // true\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does memory operations work in Hemlock?", "output": "**`memcpy(dest, src, size)` - Copy memory**\n\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // Copy 50 bytes from src to dst\nfree(src);\nfree(dst);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does closing work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Safe to call multiple times\nf.close();  // No error\nf.close();  // No error\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does pattern: input validation work in Hemlock?", "output": "```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does safe practices work in Hemlock?", "output": "**1. Never use unsanitized user input:**\n\n```hemlock\n// Bad\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // DANGEROUS\n\n// Good - validate first\nfn is_safe_filename(name: string): bool {\n    // Only allow alphanumeric, dash, underscore, dot\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Invalid filename\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "**Read and write mode:**\n\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // Existing file, can read/write\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does byte access work in Hemlock?", "output": "```hemlock\nstring.byte_at(index: i32): u8\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test buffer operations\n\n// Create buffer\nlet buf = buffer(10);\nprint(\"Created buffer\");\n\n// Check length\nprint(buf.length);\n\n// Set and get values\nbuf[0] = 65;\nbuf[1] = 66;\nbuf[2] = 67;\nprint(buf[0]);\nprint(buf[1]);\nprint(buf[2]);\n\n// Set values again\nbuf[3] = 72;  // 'H'\nbuf[4] = 105; // 'i'\nprint(buf[3]);\nprint(buf[4]);\n\n// Test alloc and free\nlet p = alloc(32);\nprint(\"Allocated p\");\nfree(p);\nprint(\"Freed p\");\n\n// Test realloc\nlet p2 = alloc(16);\nprint(\"Allocated 16 bytes\");\np2 = realloc(p2, 64);\nprint(\"Reallocated to 64 bytes\");\nfree(p2);\nprint(\"Freed reallocated p\");\n\n// Free buffer at the end\nfree(buf);\nprint(\"done\");\n```", "output": "Created buffer\n10\n65\n66\n67\n72\n105\nAllocated p\nFreed p\nAllocated 16 bytes\nReallocated to 64 bytes\nFreed reallocated p\ndone", "category": "tests/compiler", "source": "tests/compiler/buffers.hml"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test closures - capturing variables from enclosing scope\n\n// Test 1: Closure factory (makeAdder pattern)\nfn makeAdder(n) {\n    return fn(x) {\n        return n + x;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\nprint(add5(3));\nprint(add10(3));\n\n// Test 2: Multiple captures from function parameter\nfn makeMultiplier(a, b) {\n    return fn(x) {\n        return a * x + b;\n    };\n}\n\nlet mult = makeMultiplier(2, 3);\nprint(mult(5));\n```", "output": "8\n13\n13", "category": "tests/compiler", "source": "tests/compiler/closures.hml"}
{"instruction": "How does type promotion rules work in Hemlock?", "output": "```hemlock\n// Size promotion\nu8 + i32    â†’ i32    // Larger size wins\ni32 + i64   â†’ i64    // Larger size wins\nu32 + u64   â†’ u64    // Larger size wins\n\n// Float promotion\ni32 + f32   â†’ f32    // Float always wins\ni64 + f64   â†’ f64    // Float always wins\ni8 + f64    â†’ f64    // Float + largest wins\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does 5. hardware access work in Hemlock?", "output": "Interface with hardware libraries:\n\n```hemlock\n// GPIO control on embedded systems\n// USB device communication\n// Serial port access\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does performance tips work in Hemlock?", "output": "1. **Reuse compiled patterns:** If testing the same pattern multiple times, compile once and reuse:\n\n```hemlock\n// Good: Compile once\n   let pattern = compile(\"test\");\n   pattern.test(text1);\n   pattern.test(text2);\n   pattern.free();\n\n   // Bad: Compile every time\n   test(\"test\", text1);\n   test(\"test\", text2);\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does udpsocket work in Hemlock?", "output": "- Bind to port `0` to let OS assign a random port\n\n```hemlock\nlet sock = UdpSocket(\"0.0.0.0\", 5000);  // Server\nlet sock2 = UdpSocket(\"0.0.0.0\", 0);    // Client (any port)\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does create test file work in Hemlock?", "output": "```hemlock\n**2. Run the test (should fail):**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\npool.submit2(task_fn: fn, arg1, arg2): Future\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does string conversion work in Hemlock?", "output": "```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Works with mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// Empty delimiter\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Show an example of example: array statistics in Hemlock.", "output": "```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does creating channels work in Hemlock?", "output": "```hemlock\nlet ch = channel(10);  // Create channel with buffer size of 10\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test recursive functions\nfn factorial(n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nfn fibonacci(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nfn sum_to(n) {\n    if (n <= 0) {\n        return 0;\n    }\n    return n + sum_to(n - 1);\n}\n\nprint(factorial(5));\nprint(factorial(6));\nprint(fibonacci(10));\nprint(sum_to(10));\n```", "output": "120\n720\n55\n55", "category": "tests/compiler", "source": "tests/compiler/recursion.hml"}
{"instruction": "How does error handling work in Hemlock?", "output": "Pattern compilation errors throw exceptions:\n\n```hemlock\nimport { compile } from \"@stdlib/regex\";\n\ntry {\n    let pattern = compile(\"[invalid\");  // Unbalanced bracket\n} catch (e) {\n    print(\"Regex error: \" + e);\n    // \"Regex compilation failed: error code 7\" (REG_EBRACK)\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does validation work in Hemlock?", "output": "Check if string is valid JSON (lightweight check).\n\n```hemlock\nimport { is_valid } from \"@stdlib/json\";\n\nprint(is_valid('{\"x\":10}'));  // true\nprint(is_valid('{\"invalid}'));  // false\nprint(is_valid('[1,2,3]'));  // true\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does shell injection risk work in Hemlock?", "output": "```hemlock\n// DANGEROUS - DO NOT DO THIS\nlet filename = args[1];  // User input\nlet r = exec(\"cat \" + filename);  // Shell injection!\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does task spawning work in Hemlock?", "output": "Use `spawn()` to run async functions **in parallel on separate OS threads**:\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Spawn multiple tasks - these run in PARALLEL on different CPU cores!\nlet t1 = spawn(factorial, 5);  // Thread 1\nlet t2 = spawn(factorial, 6);  // Thread 2\nlet t3 = spawn(factorial, 7);  // Thread 3\n\n// All three are computing simultaneously right now!\n\n// Wait for results\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test string to_bytes() method\n// Converts string to a raw buffer\n\nlet s = \"Hi\";\nlet b = s.to_bytes();\n\nprint(typeof(b));\nprint(b.length);\nprint(b[0]);  // 'H' = 72\nprint(b[1]);  // 'i' = 105\n\n// Test with emoji (UTF-8 multibyte)\nlet emoji = \"A\";\nlet eb = emoji.to_bytes();\nprint(eb.length);\nprint(eb[0]);  // 'A' = 65\n\nprint(\"done\");\n```", "output": "buffer\n2\n72\n105\n1\n65\ndone", "category": "parity/methods", "source": "tests/parity/methods/string_to_bytes.hml"}
{"instruction": "How does 1. no stderr capture work in Hemlock?", "output": "Only stdout is captured, stderr goes to terminal:\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output is empty\n// Error message appears on terminal, not captured\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does typed allocation work in Hemlock?", "output": "**`talloc(type, count)`** allocates `count` elements of `type`:\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 bytes for 10 i32 values\nlet floats = talloc(f64, 5);  // 40 bytes for 5 f64 values\nfree(ints);\nfree(floats);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does async_make_dir work in Hemlock?", "output": "```hemlock\nasync_make_dir(path: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does comparison with shell-based tests work in Hemlock?", "output": "```hemlock\n**New style (@stdlib/testing):**\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test print and typeof builtins\n\nprint(typeof(42));\nprint(typeof(3.14));\nprint(typeof(\"hello\"));\nprint(typeof(true));\nprint(typeof(null));\nprint(typeof([1, 2, 3]));\nprint(typeof({ x: 1 }));\n\nfn test() {\n    return 1;\n}\nprint(typeof(test));\n\nprint(\"done\");\n```", "output": "i32\nf64\nstring\nbool\nnull\narray\nobject\nfunction\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/print_typeof.hml"}
{"instruction": "How does split & join work in Hemlock?", "output": "```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test higher-order array functions\n\n// Map - double each number\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) {\n    return x * 2;\n});\nprint(doubled[0]);\nprint(doubled[2]);\nprint(doubled[4]);\n\nprint(\"---\");\n\n// Filter - keep even numbers\nlet evens = nums.filter(fn(x) {\n    return x % 2 == 0;\n});\nprint(evens.length);\nprint(evens[0]);\nprint(evens[1]);\n\nprint(\"---\");\n\n// Reduce - sum\nlet sum = nums.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(sum);\n\n// Reduce - without initial value\nlet product = [1, 2, 3, 4].reduce(fn(acc, x) {\n    return acc * x;\n});\nprint(product);\n\nprint(\"done\");\n```", "output": "2\n6\n10\n---\n2\n2\n4\n---\n15\n24\ndone", "category": "tests/compiler", "source": "tests/compiler/higher_order.hml"}
{"instruction": "How does free work in Hemlock?", "output": "```hemlock\n// Free raw pointer\nlet p = alloc(1024);\nfree(p);\n\n// Free buffer\nlet buf = buffer(256);\nfree(buf);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does 4. use appropriate channel capacity work in Hemlock?", "output": "- **Large capacity (100+):** For high-throughput scenarios\n\n```hemlock\nlet signal_ch = channel(1);      // Coordination\nlet work_ch = channel(50);       // Work queue\nlet buffer_ch = channel(1000);   // High throughput\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does case conversion work in Hemlock?", "output": "```hemlock\nstring.to_upper(): string\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test switch statements\n\n// Test 1: Basic switch with integers\nlet x = 2;\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n    default:\n        print(\"other\");\n        break;\n}\n\n// Test 2: Switch with strings\nlet color = \"green\";\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown\");\n        break;\n}\n\n// Test 3: Switch with default only\nlet y = 100;\nswitch (y) {\n    case 1:\n        print(\"one\");\n        break;\n    default:\n        print(\"default\");\n        break;\n}\n\n// Test 4: No matching case, no default\nlet z = 99;\nswitch (z) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n}\n\n// Test 5: Switch with expressions\nlet a = 5;\nlet b = 3;\nswitch (a + b) {\n    case 7:\n        print(\"seven\");\n        break;\n    case 8:\n        print(\"eight\");\n        break;\n    case 9:\n        print(\"nine\");\n        break;\n}\n\nprint(\"done\");\n```", "output": "two\ngo\ndefault\neight\ndone", "category": "tests/compiler", "source": "tests/compiler/switch.hml"}
{"instruction": "Show an example of example 6: multiple loggers in Hemlock.", "output": "```hemlock\nimport { Logger, DEBUG, ERROR } from \"@stdlib/logging\";\n\n// Application logger (stdout, all levels)\nlet app_logger = Logger({ level: DEBUG });\n\n// Error logger (file, errors only)\nlet error_logger = Logger({\n    output: \"errors.log\",\n    level: ERROR\n});\ndefer error_logger.close();\n\nfn process() {\n    app_logger.debug(\"Starting process\");\n\n    try {\n        // ... work ...\n        app_logger.info(\"Process completed\");\n    } catch (e) {\n        app_logger.error(\"Process failed\");\n        error_logger.error(\"Critical error\", {\n            error: e,\n            timestamp: __now()\n        });\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does type errors work in Hemlock?", "output": "Some operations are not allowed between incompatible types:\n\n```hemlock\n// ERROR: Cannot use bitwise operators on floats\nlet x = 3.14 & 2.71;\n\n// ERROR: Cannot use bitwise operators on strings\nlet y = \"hello\" & \"world\";\n\n// OK: Type promotion for arithmetic\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promoted)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Show an example of example 3: logical operators in Hemlock.", "output": "```hemlock\nlet result = true || false && false;\n// Evaluated as: true || (false && false) = true\n// && has higher precedence than ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// Evaluated as: (5 < 10) && (10 < 20) = true\n// Comparison has higher precedence than &&\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does âŒ discouraged contributions work in Hemlock?", "output": "**3. Implicit type coercion that loses data**\n\n```hemlock\n// BAD: This would be rejected\nlet x: i32 = 3.14;  // Silently truncates to 3\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test command-line arguments array exists and is accessible\n\n// Test args is an array with length property\nprint(typeof(args));\n\n// Test we can access args.length (will be 0 if no args passed)\nprint(args.length >= 0);\n\n// Test args array methods work\nlet pushed = args.length;\nprint(pushed >= 0);\n\nprint(\"done\");\n```", "output": "array\ntrue\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/args.hml"}
{"instruction": "How does read_files_parallel work in Hemlock?", "output": "```hemlock\nimport { read_files_parallel } from \"@stdlib/async_fs\";\n\nlet paths = [\"file1.txt\", \"file2.txt\", \"file3.txt\"];\nlet contents = read_files_parallel(paths);\n\nlet i = 0;\nwhile (i < contents.length) {\n    print(\"File \" + i + \": \" + contents[i].length + \" bytes\");\n    i = i + 1;\n}\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does continue work in Hemlock?", "output": "Skip to next iteration of loop:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // Skip iteration when i is 5\n    }\n    print(i);  // Prints 0,1,2,3,4,6,7,8,9\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does good use cases work in Hemlock?", "output": "**6. Automation scripts:**\n\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push failed\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does remove_dir(path) work in Hemlock?", "output": "**Throws:** Exception if directory doesn't exist, is not empty, or cannot be deleted\n\n```hemlock\nimport { remove_dir } from \"@stdlib/fs\";\n\ntry {\n    remove_dir(\"empty_directory\");\n    print(\"Directory removed\");\n} catch (e) {\n    print(\"Error removing directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does basic type definition work in Hemlock?", "output": "Define object shapes with `define`:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Create object and assign to typed variable\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Duck typing validates structure\n\nprint(typeof(typed_p));  // \"Person\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does predefined spinner styles work in Hemlock?", "output": "```hemlock\nimport { SPINNER_DOTS, SPINNER_LINE, SPINNER_ARROW } from \"@stdlib/terminal\";\n\n// Dots spinner (Unicode braille)\nlet s1 = Spinner(SPINNER_DOTS());\n\n// Classic line spinner\nlet s2 = Spinner(SPINNER_LINE());\n\n// Arrow spinner\nlet s3 = Spinner(SPINNER_ARROW());\n\n// Clock emoji spinner\nlet s4 = Spinner(SPINNER_CLOCK());\n\n// Bounce spinner\nlet s5 = Spinner(SPINNER_BOUNCE());\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does pattern: one-shot functions (no free needed) work in Hemlock?", "output": "```hemlock\n// One-shot functions handle memory automatically\nif (test(\"pattern\", \"text\")) {\n    // No need to free - handled internally\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does exec work in Hemlock?", "output": "```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Failed to execute:\", e);\n}\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does integer + float work in Hemlock?", "output": "```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does open work in Hemlock?", "output": "```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"Failed to open:\", e);\n    // Error: Failed to open 'missing.txt': No such file or directory\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does copy_file(src, dest) work in Hemlock?", "output": "**Throws:** Exception if source doesn't exist or copy fails\n\n```hemlock\nimport { copy_file } from \"@stdlib/fs\";\n\ntry {\n    copy_file(\"original.txt\", \"backup.txt\");\n    print(\"File copied\");\n} catch (e) {\n    print(\"Error copying file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does 1. explicit over implicit work in Hemlock?", "output": "```hemlock\nlet x = 5;\nfree(ptr);  // You allocated it, you free it\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does type checks work in Hemlock?", "output": "Check value type using `typeof()`.\n\n```hemlock\ntest(\"type checks\", fn() {\n    expect(42).to_be_type(\"i32\");\n    expect(\"hello\").to_be_type(\"string\");\n    expect([1, 2, 3]).to_be_type(\"array\");\n    expect(true).to_be_type(\"bool\");\n    expect(null).to_be_type(\"null\");\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does async_exists work in Hemlock?", "output": "```hemlock\nimport { async_exists } from \"@stdlib/async_fs\";\n\nlet future = async_exists(\"config.json\");\nif (future.get()) {\n    print(\"Config file exists\");\n}\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does substring & slicing work in Hemlock?", "output": "```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 example\nlet text = \"HiðŸš€!\";\nlet emoji = text.substr(2, 1);  // \"ðŸš€\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test enum with switch statement\n\nenum Color {\n    RED = 1,\n    GREEN = 2,\n    BLUE = 3\n}\n\nlet color = Color.GREEN;\n\nswitch (color) {\n    case Color.RED:\n        print(\"Red\");\n        break;\n    case Color.GREEN:\n        print(\"Green\");\n        break;\n    case Color.BLUE:\n        print(\"Blue\");\n        break;\n    default:\n        print(\"Unknown\");\n        break;\n}\n```", "output": "Green", "category": "tests/enums", "source": "tests/enums/switch_statement.hml"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test signal handling\n\n// Test signal constants exist\nprint(\"Testing signal constants:\");\nprint(SIGINT);\nprint(SIGTERM);\nprint(SIGUSR1);\nprint(SIGUSR2);\n\n// Test registering a signal handler (no closures - signal handlers are C callbacks)\nfn my_handler(signum) {\n    print(\"Handler called with signal:\");\n    print(signum);\n}\n\n// Register handler for SIGUSR1\nsignal(SIGUSR1, my_handler);\n\n// Raise SIGUSR1 multiple times\nprint(\"Raising SIGUSR1:\");\nraise(SIGUSR1);\nraise(SIGUSR1);\n\n// Test resetting handler to default\nsignal(SIGUSR1, null);\n\nprint(\"done\");\n```", "output": "Testing signal constants:\n2\n15\n10\n12\nRaising SIGUSR1:\nHandler called with signal:\n10\nHandler called with signal:\n10\ndone", "category": "tests/compiler", "source": "tests/compiler/signals.hml"}
{"instruction": "How does return type requirements work in Hemlock?", "output": "Functions with return type annotation **must** return a value:\n\n```hemlock\nfn get_value(): i32 {\n    // ERROR: Missing return statement\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does boolean type work in Hemlock?", "output": "```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test string and array methods\n\n// String methods\nlet s = \"hello world\";\nprint(s.length);\n\nlet sub = s.substr(0, 5);\nprint(sub);\n\nlet upper = s.to_upper();\nprint(upper);\n\nlet idx = s.find(\"world\");\nprint(idx);\n\nlet has = s.contains(\"ell\");\nprint(has);\n\nlet trimmed = \"  hi  \".trim();\nprint(trimmed);\n\n// Array methods\nlet arr = [1, 2, 3];\nprint(arr.length);\n\narr.push(4);\nprint(arr.length);\n\nlet first = arr.first();\nprint(first);\n\nlet last = arr.last();\nprint(last);\n\nlet found = arr.find(3);\nprint(found);\n\nlet has_two = arr.contains(2);\nprint(has_two);\n\n// Slice\nlet slice = arr.slice(1, 3);\nprint(slice.length);\n\n// Join\nlet words = [\"a\", \"b\", \"c\"];\nlet joined = words.join(\"-\");\nprint(joined);\n```", "output": "11\nhello\nHELLO WORLD\n6\ntrue\nhi\n3\n4\n1\n4\n2\ntrue\n2\na-b-c", "category": "tests/compiler", "source": "tests/compiler/methods.hml"}
{"instruction": "How does don'ts work in Hemlock?", "output": "âŒ **Don't use random values in tests**\n\n```hemlock\n// BAD: Non-deterministic\nlet x = random();\nprint(x);  // Can't predict output\n\n// GOOD: Deterministic\nlet x = 42;\nprint(x);  // Expect: 42\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "Functions without names, assigned to variables:\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does 3. variable number of arguments work in Hemlock?", "output": "Process all provided arguments:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test enum with explicit values\n\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);\nprint(Status.ERROR);\nprint(Status.PENDING);\n```", "output": "0\n1\n2", "category": "tests/enums", "source": "tests/enums/explicit_values.hml"}
{"instruction": "How does array type work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// Empty array\nlet empty = [];\nprint(empty.length);   // 0\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does graceful process termination work in Hemlock?", "output": "```hemlock\nfn terminate_gracefully(pid: i32) {\n    // Try SIGTERM first\n    try {\n        kill(pid, 15);  // SIGTERM\n        let i = 0;\n        while (i < 10) {\n            if (!process_exists(pid)) {\n                return true;\n            }\n            import { sleep } from \"@stdlib/time\";\n            sleep(0.1);\n            i = i + 1;\n        }\n        // Force kill if still running\n        kill(pid, 9);  // SIGKILL\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does pattern: iteration with filtering work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Print only even numbers\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // Skip odd numbers\n    }\n    print(arr[i]);\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does basic parameters work in Hemlock?", "output": "```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does typed allocation work in Hemlock?", "output": "Hemlock provides typed allocation helpers for convenience:\n\n```hemlock\nlet arr = talloc(i32, 100);  // Allocate 100 i32 values (400 bytes)\nlet size = sizeof(i32);      // Returns 4 (bytes)\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How do you use using pipes in Hemlock?", "output": "**Complex pipelines:**\n\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does polling with timeout work in Hemlock?", "output": "```hemlock\nimport { now, sleep } from \"@stdlib/time\";\n\nfn wait_for_condition(check: function, timeout_seconds: i32): bool {\n    let start = now();\n\n    while (true) {\n        if (check()) {\n            return true;  // Condition met\n        }\n\n        let elapsed = now() - start;\n        if (elapsed >= timeout_seconds) {\n            return false;  // Timeout\n        }\n\n        sleep(0.1);  // Poll every 100ms\n    }\n}\n\n// Usage\nlet result = wait_for_condition(fn() {\n    // Check some condition\n    return false;  // Example: not ready yet\n}, 30);\n\nif (result) {\n    print(\"Condition met!\");\n} else {\n    print(\"Timeout!\");\n}\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does path traversal work in Hemlock?", "output": "**âš ï¸ WARNING:** Validate user-provided paths to prevent directory traversal attacks:\n\n```hemlock\nimport { absolute_path } from \"@stdlib/fs\";\n\nfn is_safe_path(user_path: string, base_dir: string): bool {\n    try {\n        let abs_base = absolute_path(base_dir);\n        let abs_user = absolute_path(base_dir + \"/\" + user_path);\n\n        // Check if user path is within base directory\n        return abs_user.starts_with(abs_base);\n    } catch (e) {\n        return false;\n    }\n}\n\n// Validate before using\nlet user_input = \"../../etc/passwd\";  // Malicious\nif (is_safe_path(user_input, \"/var/www/uploads\")) {\n    // Safe to use\n} else {\n    print(\"Invalid path detected\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does finally block work in Hemlock?", "output": "```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    // Always runs\n    if (file != null) {\n        file.close();\n    }\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does reverse(str) work in Hemlock?", "output": "**Use case - palindrome checking:**\n\n```hemlock\nimport { reverse } from \"@stdlib/strings\";\n\nfn is_palindrome(s: string): bool {\n    let normalized = s.to_lower();\n    return normalized == reverse(normalized);\n}\n\nprint(is_palindrome(\"racecar\"));  // true\nprint(is_palindrome(\"Racecar\"));  // true\nprint(is_palindrome(\"hello\"));    // false\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does 2. no streaming work in Hemlock?", "output": "Must wait for command completion:\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// Blocks until command finishes\n// Cannot process output incrementally\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test enum with mixed auto and explicit values\n\nenum Code {\n    A,\n    B = 10,\n    C,\n    D = 20,\n    E\n}\n\nprint(Code.A);\nprint(Code.B);\nprint(Code.C);\nprint(Code.D);\nprint(Code.E);\n```", "output": "0\n10\n11\n20\n21", "category": "tests/enums", "source": "tests/enums/mixed_values.hml"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test basic typed array functionality with i32\n\n// Test 1: Create a typed array and assign it\nlet arr: array<i32> = [1, 2, 3];\nprint(arr[0]);  // 1\nprint(arr[1]);  // 2\nprint(arr[2]);  // 3\nprint(arr.length);  // 3\n\n// Test 2: Push to typed array\narr.push(4);\nprint(arr[3]);  // 4\nprint(arr.length);  // 4\n\n// Test 3: Array methods with typed arrays\narr.unshift(0);\nprint(arr[0]);  // 0\nprint(arr.length);  // 5\n\narr.insert(2, 10);\nprint(arr[2]);  // 10\nprint(arr.length);  // 6\n\n// Test 4: Index assignment\narr[0] = 99;\nprint(arr[0]);  // 99\n```", "output": "1\n2\n3\n3\n4\n4\n0\n5\n10\n6\n99", "category": "tests/typed_arrays", "source": "tests/typed_arrays/basic.hml"}
{"instruction": "Show an example of example: multi-module project in Hemlock.", "output": "```hemlock\nmyapp/\nâ”œâ”€â”€ main.hml\nâ”œâ”€â”€ lib/\nâ”‚   â”œâ”€â”€ math.hml\nâ”‚   â””â”€â”€ utils.hml\nâ””â”€â”€ config.hml\n```", "category": "docs", "source": "docs/advanced/bundling-packaging.md"}
{"instruction": "How does reading from closed file work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does basic colors (foreground) work in Hemlock?", "output": "```hemlock\nimport { BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE } from \"@stdlib/terminal\";\n\nprint(RED + \"Red text\" + RESET);\nprint(GREEN + \"Green text\" + RESET);\nprint(BLUE + \"Blue text\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test bitwise operators\n\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\n// Bitwise AND\nprint(a & b);  // 8 (1000)\n\n// Bitwise OR\nprint(a | b);  // 14 (1110)\n\n// Bitwise XOR\nprint(a ^ b);  // 6 (0110)\n\n// Left shift\nprint(a << 2);  // 48 (110000)\n\n// Right shift\nprint(a >> 1);  // 6 (110)\n\n// Bitwise NOT\nprint(~0);  // -1\n\n// Compound expressions\nprint((5 & 3) | (2 << 1));  // 5\n\nprint(\"done\");\n```", "output": "8\n14\n6\n48\n6\n-1\n5\ndone", "category": "parity/language", "source": "tests/parity/language/bitwise.hml"}
{"instruction": "How does crc32(data) -> u32 work in Hemlock?", "output": "```hemlock\nimport { crc32 } from \"@stdlib/compression\";\n\nlet data = buffer(5);\ndata[0] = 72; data[1] = 101; data[2] = 108; data[3] = 108; data[4] = 111;  // \"Hello\"\nlet checksum = crc32(data);\nprint(checksum);\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does file_stat(path) work in Hemlock?", "output": "- `is_dir: bool` - True if directory\n\n```hemlock\nimport { file_stat } from \"@stdlib/fs\";\n\ntry {\n    let info = file_stat(\"data.txt\");\n\n    print(\"Size: \" + typeof(info.size) + \" bytes\");\n    print(\"Modified: \" + typeof(info.mtime));\n    print(\"Is file: \" + typeof(info.is_file));\n    print(\"Is directory: \" + typeof(info.is_dir));\n} catch (e) {\n    print(\"Error getting file info: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does panic work in Hemlock?", "output": "```hemlock\npanic();                          // Default: \"panic!\"\npanic(\"unreachable code reached\");\npanic(42);\n\n// Common use case\nfn process_state(state: i32): string {\n    if (state == 1) { return \"ready\"; }\n    if (state == 2) { return \"running\"; }\n    panic(\"invalid state: \" + typeof(state));\n}\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does good use cases work in Hemlock?", "output": "**4. File existence checks:**\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does slicing & extraction work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3] (unchanged)\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Show an example of example: adding a new operator in Hemlock.", "output": "return create_token(TOKEN_PERCENT, \"%\", line);\n\n```hemlock\n**2. Lexer header (lexer.h):**\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does command chaining work in Hemlock?", "output": "```hemlock\nlet r = exec(\"command1 || command2\");\n// Runs command2 only if command1 fails\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does transformation operations work in Hemlock?", "output": "**`concat(other)`** - Concatenate with another array:\n\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (new array)\n\n// Originals unchanged\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does overview work in Hemlock?", "output": "- **Timestamps** (Unix epoch format)\n\n```hemlock\nimport { Logger, DEBUG, INFO, WARN, ERROR } from \"@stdlib/logging\";\n\nlet logger = Logger({ level: INFO, output: \"app.log\" });\nlogger.info(\"Application started\");\nlogger.warn(\"Low memory warning\");\nlogger.error(\"Database connection failed\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does functions as return values work in Hemlock?", "output": "```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does channel work in Hemlock?", "output": "```hemlock\nlet ch = channel(10);  // Buffered channel with capacity 10\nlet ch2 = channel(1);  // Minimal buffer (synchronous)\nlet ch3 = channel(100); // Large buffer\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does run(options?) work in Hemlock?", "output": "```hemlock\nRunning tests...\n\nSuite Name\n  âœ“ passing test\n  âœ— failing test\n\nTest Summary:\n  Total:  2\n  Passed: 1\n  Failed: 1\n\nFailures:\n\nSuite Name > failing test\nExpected 5 to equal 10\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does unicode escapes work in Hemlock?", "output": "Use `\\u{XXXXXX}` syntax for Unicode codepoints (up to 6 hex digits):\n\n```hemlock\nlet rocket = '\\u{1F680}';   // ðŸš€ Emoji via Unicode escape\nlet heart = '\\u{2764}';     // â¤ Heart\nlet ascii = '\\u{41}';       // 'A' via escape\nlet max = '\\u{10FFFF}';     // Maximum Unicode codepoint\n\n// Leading zeros optional\nlet a = '\\u{41}';           // Same as '\\u{0041}'\nlet b = '\\u{0041}';\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does reading work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Read entire file\nlet all = f.read();\nprint(all);\n\n// Read specific number of bytes\nlet chunk = f.read(1024);\n\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does path: string work in Hemlock?", "output": "The file path used to open the file.\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// Works with strings\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does aes_decrypt(ciphertext: buffer, key: buffer, iv: buffer): string work in Hemlock?", "output": "Decrypt ciphertext using AES-256-CBC, removing PKCS#7 padding.\n\n```hemlock\nimport { aes_decrypt } from \"@stdlib/crypto\";\n\n// Decrypt using same key and IV as encryption\nlet decrypted = aes_decrypt(ciphertext, key, iv);\nprint(decrypted);  // \"Secret message!\"\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does async functions work in Hemlock?", "output": "Functions can be declared as `async` to indicate they're designed for concurrent execution:\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does `logger.info(message, data?)` work in Hemlock?", "output": "```hemlock\nlogger.info(\"Server started\", { port: 8080, pid: 12345 });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does log(x) work in Hemlock?", "output": "**Returns:** `f64` - ln(x)\n\n```hemlock\nimport { log, E } from \"@stdlib/math\";\n\nlet result = log(1.0);  // 0.0\nlet result2 = log(E);   // 1.0\nlet result3 = log(10.0); // 2.302585...\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does freeing callbacks work in Hemlock?", "output": "**Important:** Always free callbacks when done to prevent memory leaks:\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ... use callback ...\ncallback_free(cb);  // Free when done\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does `typeof(value)` work in Hemlock?", "output": "Returns the type name as a string:\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does functions work in Hemlock?", "output": "```hemlock\nimport { find } from \"@stdlib/regex\";\n\nif (find(\"error\", \"This is an error message\")) {\n    print(\"Found error in message\");\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Describe the behavior of this Hemlock program:\n\n```hemlock\n// Hemlock I/O System Demo\n// Demonstrates all I/O features in v0.1\n\nprint(\"=== Hemlock I/O System Demo ===\");\nprint(\"\");\n\n// 1. High-level convenience functions\nprint(\"1. High-level file operations:\");\nwrite_file(\"demo.txt\", \"Hello, Hemlock!\\nThis is a test.\\n\");\nprint(\"  Written to demo.txt\");\n\nlet content = read_file(\"demo.txt\");\nprint(\"  Read from demo.txt:\");\nprint(\"  \" + content);\n\nappend_file(\"demo.txt\", \"Appended line.\\n\");\nprint(\"  Appended to demo.txt\");\n\nif (file_exists(\"demo.txt\")) {\n    print(\"  File exists: true\");\n}\n\nprint(\"\");\n\n// 2. Binary operations\nprint(\"2. Binary file operations:\");\nlet buf = buffer(5);\nbuf[0] = 72;   // 'H'\nbuf[1] = 101;  // 'e'\nbuf[2] = 108;  // 'l'\nbuf[3] = 108;  // 'l'\nbuf[4] = 111;  // 'o'\nwrite_bytes(\"demo.bin\", buf);\nprint(\"  Written binary data\");\n\nlet data = read_bytes(\"demo.bin\");\nprint(\"  Read binary data, length:\");\nprint(data.length);\nfree(buf);\nfree(data);\n\nprint(\"\");\n\n// 3. Low-level file operations\nprint(\"3. Low-level file operations:\");\nlet f = open(\"demo.txt\", \"r\");\nprint(\"  Opened file:\");\nprint(f);\nprint(\"  Mode:\");\nprint(f.mode);\nprint(\"  Closed:\");\nprint(f.closed);\n\nlet pos = f.tell();\nprint(\"  Current position:\");\nprint(pos);\n\nlet chunk = f.read_text(10);\nprint(\"  Read chunk: \" + chunk);\n\nf.seek(0);\nprint(\"  Seeked to beginning\");\n\nlet line = f.read_text(100);\nprint(\"  Read full content: \" + line);\n\nf.close();\nprint(\"  File closed:\");\nprint(f.closed);\n\nprint(\"\");\n\n// 4. Standard streams\nprint(\"4. Standard streams:\");\neprint(\"This message goes to stderr\");\nprint(\"This message goes to stdout\");\n\nprint(\"\");\nprint(\"=== Demo Complete ===\");\nprint(\"(Temporary files: demo.txt, demo.bin)\");\n```", "output": "This program perform file I/O operations. Hemlock I/O System Demo Demonstrates all I/O features in v0.1", "category": "examples/explanation", "source": "examples/io_demo.hml"}
{"instruction": "Provide a Hemlock example that demonstrates create a WebSocket client.", "output": "```hemlock\n// WebSocket Client Example (libwebsockets version)\n// Demonstrates @stdlib/websocket (production FFI implementation)\n// Requires: libwebsockets-dev and compiled lws_wrapper.so (make stdlib)\n\nimport { WebSocket } from \"@stdlib/websocket\";\n\nprint(\"=== Hemlock WebSocket Client (libwebsockets) ===\");\nprint(\"\");\nprint(\"Requirements:\");\nprint(\"  1. Install: sudo apt-get install libwebsockets-dev\");\nprint(\"  2. Compile: make stdlib\");\nprint(\"\");\n\ntry {\n    print(\"Connecting to ws://echo.websocket.org...\");\n\n    let ws = WebSocket(\"ws://echo.websocket.org\");\n    defer ws.close();\n\n    print(\"âœ“ Connected!\");\n    print(\"\");\n\n    // Send test message\n    print(\"Sending: 'Hello from Hemlock!'\");\n    let sent = ws.send_text(\"Hello from Hemlock!\");\n\n    if (sent) {\n        print(\"âœ“ Message sent\");\n    } else {\n        print(\"âœ— Failed to send\");\n    }\n\n    // Wait for echo (5 second timeout)\n    print(\"Waiting for echo (5s timeout)...\");\n    let msg = ws.recv(5000);\n\n    if (msg != null) {\n        print(\"âœ“ Received message!\");\n        print(\"  Type: \" + msg.type);\n        if (msg.type == \"text\") {\n            print(\"  Data: \" + msg.data);\n        }\n    } else {\n        print(\"âœ— No response (timeout or connection closed)\");\n    }\n\n    print(\"\");\n    print(\"Sending another message...\");\n    ws.send_text(\"Second message from Hemlock\");\n\n    let msg2 = ws.recv(5000);\n    if (msg2 != null && msg2.type == \"text\") {\n        print(\"âœ“ Received: \" + msg2.data);\n    }\n\n    print(\"\");\n    print(\"Closing connection...\");\n\n} catch (e) {\n    print(\"\");\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"  - lws_wrapper.so not found: Run 'make stdlib'\");\n    print(\"  - libwebsockets not installed: Run 'sudo apt-get install libwebsockets-dev'\");\n    print(\"  - Network connectivity issues\");\n    print(\"  - echo.websocket.org is down\");\n}\n\nprint(\"\");\nprint(\"Done!\");\nprint(\"\");\nprint(\"Features of libwebsockets version:\");\nprint(\"  âœ“ SSL/TLS support (wss://\");\nprint(\"  âœ“ Production-ready performance\");\nprint(\"  âœ“ Proper protocol compliance\");\nprint(\"  âœ“ Large message support\");\nprint(\"  âœ“ Automatic ping/pong handling\");\n```", "category": "examples", "source": "examples/websocket_client_lws.hml"}
{"instruction": "How does for-in loops work in Hemlock?", "output": "**With index and value:**\n\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(\"Index: \" + typeof(i) + \", Value: \" + arr[i]);\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Show an example of example 2: multi-signal state machine in Hemlock.", "output": "```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"State: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"State: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"State: \" + state);\n    print(\"Requests: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // Do work\n        request_count = request_count + 1;\n    }\n\n    // Check every iteration...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does regex object work in Hemlock?", "output": "```hemlock\nlet pattern = compile(\"^[a-z]+$\");\nprint(pattern.test(\"hello\"));   // true\nprint(pattern.test(\"Hello\"));   // false (capital H)\nprint(pattern.test(\"hello123\")); // false (has digits)\npattern.free();\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does get all process info work in Hemlock?", "output": "```hemlock\nfn get_process_info() {\n    let info = {};\n    info.pid = get_pid();\n    info.ppid = getppid();\n    info.uid = getuid();\n    info.euid = geteuid();\n    info.gid = getgid();\n    info.egid = getegid();\n    return info;\n}\n\nlet info = get_process_info();\nprint(\"PID: \" + typeof(info.pid));\nprint(\"UID: \" + typeof(info.uid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does reverse(str) work in Hemlock?", "output": "- O(n) time complexity where n = string length\n\n```hemlock\nimport { reverse } from \"@stdlib/strings\";\n\nprint(reverse(\"hello\"));       // \"olleh\"\nprint(reverse(\"abc\"));         // \"cba\"\nprint(reverse(\"12345\"));       // \"54321\"\n\n// Single character\nprint(reverse(\"a\"));           // \"a\"\n\n// Empty string\nprint(reverse(\"\"));            // \"\"\n\n// Palindrome\nprint(reverse(\"racecar\"));     // \"racecar\"\n\n// With spaces\nprint(reverse(\"hello world\")); // \"dlrow olleh\"\n\n// Unicode / emojis\nprint(reverse(\"ðŸš€ðŸŒ\"));        // \"ðŸŒðŸš€\"\nprint(reverse(\"HiðŸš€\"));        // \"ðŸš€iH\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does center(str, width, fill?) work in Hemlock?", "output": "- Useful for creating headers, banners, and aligned text\n\n```hemlock\nimport { center } from \"@stdlib/strings\";\n\nlet s1 = center(\"Title\", 10);\nprint(s1);  // \"  Title   \" (2 left, 3 right)\n\nlet s2 = center(\"X\", 5, \"*\");\nprint(s2);  // \"**X**\"\n\n// Create banner\nlet banner = center(\"IMPORTANT\", 40, \"=\");\nprint(banner);  // \"===============IMPORTANT================\"\n\n// Unicode fill\nlet s3 = center(\"test\", 10, \"â”€\");\nprint(s3);  // \"â”€â”€â”€testâ”€â”€â”€\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "**Creating a new file for writing:**\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // Creates or truncates\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does 1. no select() for multiplexing work in Hemlock?", "output": "**Workaround:** Use separate tasks per channel:\n\n```hemlock\nasync fn monitor_ch1(ch1, result_ch) {\n    let val = ch1.recv();\n    result_ch.send({ channel: 1, value: val });\n}\n\n// Similar for ch2, ch3...\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does os_name() work in Hemlock?", "output": "**Returns:** `string` - Kernel name (e.g., `\"Linux\"`, `\"Darwin\"`, `\"Windows_NT\"`)\n\n```hemlock\nimport { os_name } from \"@stdlib/os\";\n\nlet name = os_name();\nprint(\"OS kernel: \" + name);  // e.g., \"Linux\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does exception propagation work in Hemlock?", "output": "Exceptions thrown in tasks are propagated when joined:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\n// Task that succeeds\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// Task that fails\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does 5. no process control work in Hemlock?", "output": "Cannot interact with command after starting:\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// Cannot send input to the program\n// Cannot control execution\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show an example of memory layout examples in Hemlock.", "output": "```hemlock\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Constants test\n// Tests: const declarations, immutability\n\nconst PI = 3.14159;\nconst NAME = \"Hemlock\";\nconst MAX_SIZE = 100;\nconst IS_DEBUG = false;\n\nprint(PI);\nprint(NAME);\nprint(MAX_SIZE);\nprint(IS_DEBUG);\n\n// Constants in expressions\nlet area = PI * 5 * 5;\nprint(area);\n\n// Const arrays and objects\nconst COLORS = [\"red\", \"green\", \"blue\"];\nprint(COLORS[0]);\nprint(COLORS[1]);\nprint(COLORS[2]);\n\nconst CONFIG = { version: 1, name: \"test\" };\nprint(CONFIG.version);\nprint(CONFIG.name);\n```", "output": "3.14159\nHemlock\n100\nfalse\n78.5397\nred\ngreen\nblue\n1\ntest", "category": "parity/language", "source": "tests/parity/language/constants.hml"}
{"instruction": "How does field deletion work in Hemlock?", "output": "**Note:** Field deletion is not currently supported. Set to `null` instead:\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// Cannot delete fields (not supported)\n// obj.x = undefined;  // No 'undefined' in Hemlock\n\n// Workaround: Set to null\nobj.x = null;\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does pattern: partial application work in Hemlock?", "output": "```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show an example of example: memory pool pattern in Hemlock.", "output": "```hemlock\n// Simple memory pool (simplified)\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool exhausted\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// Use pool\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// Free entire pool at once\nfree(pool);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does 5. detach only when necessary work in Hemlock?", "output": "Prefer `join()` over `detach()` for better resource management:\n\n```hemlock\n// Good: Join and get result\nlet task = spawn(work);\nlet result = join(task);\n\n// Use detach only for true fire-and-forget\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // Will run independently\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    print(\"Done\");\n}\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does `logger.warn(message, data?)` work in Hemlock?", "output": "```hemlock\nlogger.warn(\"High CPU usage\", { cpu: 95.5, threshold: 80.0 });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does file search work in Hemlock?", "output": "```hemlock\nimport { list_dir, is_dir, is_file } from \"@stdlib/fs\";\n\nfn find_files(dir: string, pattern: string): array {\n    let results = [];\n\n    try {\n        let entries = list_dir(dir);\n\n        let i = 0;\n        while (i < entries.length) {\n            let name = entries[i];\n            let full_path = dir + \"/\" + name;\n\n            if (is_file(full_path) && name.contains(pattern)) {\n                results.push(full_path);\n            }\n\n            if (is_dir(full_path)) {\n                let sub_results = find_files(full_path, pattern);\n                let j = 0;\n                while (j < sub_results.length) {\n                    results.push(sub_results[j]);\n                    j = j + 1;\n                }\n            }\n\n            i = i + 1;\n        }\n    } catch (e) {\n        print(\"Error searching directory: \" + e);\n    }\n\n    return results;\n}\n\n// Find all .txt files\nlet txt_files = find_files(\".\", \".txt\");\nprint(\"Found \" + typeof(txt_files.length) + \" text files\");\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does argument isolation work in Hemlock?", "output": "When you spawn a task, **arguments are deep-copied** to prevent data races:\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // Modifies the COPY, not original\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - unchanged!\nprint(modified.length);  // 4 - has new element\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does 2. dynamic by default, typed by choice work in Hemlock?", "output": "**Explicit typing when needed:**\n\n```hemlock\nlet x = 42;              // i32 inferred (small value)\nlet y: u8 = 255;         // explicit u8\nlet z = x + y;           // promotes to i32\nlet big = 5000000000;    // i64 inferred (> i32 max)\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "```hemlock\narray.find(value: any): i32\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does writing elements work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // Modify existing\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// Can assign beyond current length (grows array)\narr[5] = 60;    // Creates [10, 20, 3, null, null, 60]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test exception handling\n\n// Basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(e);\n}\n\n// Try without throw\ntry {\n    print(\"no error\");\n} catch (e) {\n    print(\"should not reach\");\n}\n\n// Finally always runs\ntry {\n    print(\"try block\");\n} finally {\n    print(\"finally block\");\n}\n\n// Catch and finally\ntry {\n    throw \"oops\";\n} catch (e) {\n    print(\"caught\");\n} finally {\n    print(\"cleanup\");\n}\n\nprint(\"done\");\n```", "output": "error message\nno error\ntry block\nfinally block\ncaught\ncleanup\ndone", "category": "parity/language", "source": "tests/parity/language/exceptions.hml"}
{"instruction": "How does execute and check success work in Hemlock?", "output": "```hemlock\nfn exec_success(command: string) {\n    let result = exec(command);\n    return result.exit_code == 0;\n}\n\nif (exec_success(\"test -f myfile.txt\")) {\n    print(\"File exists\");\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does circular dependencies work in Hemlock?", "output": "```hemlock\nError: Circular dependency detected when loading 'path/to/module.hml'\n```", "category": "docs", "source": "docs/advanced/bundling-packaging.md"}
{"instruction": "How does checking exit status work in Hemlock?", "output": "```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found: \" + r.output);\n} else {\n    print(\"Pattern not found\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does best practices for safe signal handling work in Hemlock?", "output": "**4. Avoid Re-entrancy Issues**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // Don't modify data while main code is using it\n        return;\n    }\n    // Safe to proceed\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does 6. create argument objects work in Hemlock?", "output": "```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Input: \" + arguments.input);\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does async function declaration work in Hemlock?", "output": "```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Processing:\", data);\n    return null;\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does recursive data processing work in Hemlock?", "output": "```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { HashMap, Queue, Stack, Set, LinkedList } from \"@stdlib/collections\";\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does file truncation work in Hemlock?", "output": "```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // \"w\" mode truncates\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does parallel_map work in Hemlock?", "output": "```hemlock\nparallel_map(arr: array, map_fn: fn, num_workers?: i32): array\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test switch fall-through behavior\n// Cases should fall through to subsequent cases unless break is used\n\nfn test_fallthrough(x) {\n    let result = \"\";\n    switch (x) {\n        case 1:\n            result = result + \"one\";\n            // No break - should fall through\n        case 2:\n            result = result + \"two\";\n            // No break - should fall through\n        case 3:\n            result = result + \"three\";\n            break;\n        case 4:\n            result = result + \"four\";\n            break;\n        default:\n            result = result + \"default\";\n            break;\n    }\n    return result;\n}\n\n// Test case 1: Should fall through 1 -> 2 -> 3 then break\nprint(test_fallthrough(1));  // Should print: onetwothree\n\n// Test case 2: Should fall through 2 -> 3 then break\nprint(test_fallthrough(2));  // Should print: twothree\n\n// Test case 3: Should just print three then break\nprint(test_fallthrough(3));  // Should print: three\n\n// Test case 4: Should just print four then break\nprint(test_fallthrough(4));  // Should print: four\n\n// Test case 5 (no match): Should print default\nprint(test_fallthrough(5));  // Should print: default\n\n// Test default fallthrough\nfn test_default_fallthrough(x) {\n    let result = \"\";\n    switch (x) {\n        case 1:\n            result = result + \"A\";\n            break;\n        default:\n            result = result + \"D\";\n            // No break - should fall through to case 2\n        case 2:\n            result = result + \"B\";\n            break;\n    }\n    return result;\n}\n\n// Default with fall-through to case 2\nprint(test_default_fallthrough(99));  // Should print: DB\n\n// Case 2 directly\nprint(test_default_fallthrough(2));   // Should print: B\n\n// Case 1 with break\nprint(test_default_fallthrough(1));   // Should print: A\n```", "output": "onetwothree\ntwothree\nthree\nfour\ndefault\nDB\nB\nA", "category": "parity/language", "source": "tests/parity/language/switch_fallthrough.hml"}
{"instruction": "How does color(text, code) work in Hemlock?", "output": "**Returns:** `string` - Colorized text with reset\n\n```hemlock\nimport { color, RED, GREEN, BLUE } from \"@stdlib/terminal\";\n\nprint(color(\"Error\", RED));\nprint(color(\"Success\", GREEN));\nprint(color(\"Info\", BLUE));\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does accepting connections work in Hemlock?", "output": "**Accept with timeout:**\n\n```hemlock\nlet conn = server.accept(10000);  // 10 second timeout\nif (conn == null) {\n    print(\"No client connected\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does object literals work in Hemlock?", "output": "```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// Add/modify fields\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does udpsocket work in Hemlock?", "output": "- `port: i32` - Source port\n\n```hemlock\nlet packet = sock.recv_from(1024);\nprint(\"From \" + packet.address + \":\" + typeof(packet.port));\nprint(\"Data: \" + typeof(packet.data.length) + \" bytes\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nfuture.get_timeout(timeout_ms: i32): any | null\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does duck typing work in Hemlock?", "output": "Objects are validated against `define` using **structural compatibility**:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// âœ… OK: Has all required fields\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// âœ… OK: Extra fields are allowed\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// âŒ ERROR: Missing required field 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// âŒ ERROR: Wrong type for 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does is_dir(path) work in Hemlock?", "output": "**Returns:** `bool` - True if path is a directory, false otherwise\n\n```hemlock\nimport { is_dir } from \"@stdlib/fs\";\n\nif (is_dir(\".\")) {\n    print(\"Current directory exists\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does safety tools provided work in Hemlock?", "output": "**1. Safe buffer type:**\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bounds checked\nprint(b.length);        // 64\nfree(b);                // still manual\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does pipeline architecture work in Hemlock?", "output": "```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// Create pipeline\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// Feed input\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// Collect output\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does writing entire file work in Hemlock?", "output": "```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does planned features work in Hemlock?", "output": "**4. String Marshaling**\n\n```hemlock\n// Future: Automatic string conversion\nlet s = \"hello\";\nc_string_function(s);  // Auto-convert to C string\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does color_256(n) work in Hemlock?", "output": "**Returns:** `string` - 256-color code\n\n```hemlock\nimport { color_256, RESET } from \"@stdlib/terminal\";\n\n// 0-15: Standard colors\n// 16-231: 6x6x6 color cube\n// 232-255: Grayscale\n\nprint(color_256(196) + \"Bright red\" + RESET);\nprint(color_256(21) + \"Deep blue\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does is_digit(str) work in Hemlock?", "output": "**Returns:** `bool` - True if all characters are digits\n\n```hemlock\nimport { is_digit } from \"@stdlib/strings\";\n\nprint(is_digit(\"123\"));      // true\nprint(is_digit(\"0\"));        // true\nprint(is_digit(\"999\"));      // true\n\nprint(is_digit(\"123a\"));     // false\nprint(is_digit(\"12.3\"));     // false (decimal point)\nprint(is_digit(\"1 2 3\"));    // false (spaces)\nprint(is_digit(\"\"));         // false (empty)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does functions as arguments work in Hemlock?", "output": "```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does clear line work in Hemlock?", "output": "```hemlock\nimport { CLEAR_LINE, CLEAR_LINE_TO_END } from \"@stdlib/terminal\";\n\n// Clear entire line\nexec(\"printf '\\r\" + CLEAR_LINE + \"'\");\n\n// Clear from cursor to end of line\nexec(\"printf '\" + CLEAR_LINE_TO_END + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Show an example of example: qsort in Hemlock.", "output": "```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Comparison function for integers (ascending order)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// Allocate array of 5 integers\nlet arr = alloc(20);  // 5 * 4 bytes\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// Create callback and sort\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// Array is now sorted: [1, 2, 5, 8, 9]\n\n// Clean up\ncallback_free(cmp);\nfree(arr);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does search operations work in Hemlock?", "output": "**`contains(value)`** - Check if array contains value:\n\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\npool.submit1(task_fn: fn, arg1): Future\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "**Left Shift (`<<`)**\n\n```hemlock\nprint(a << 2);  // 48 (110000) - shift left by 2\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "```hemlock\nstring.find(needle: string): i32\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Show an example of example: simple database in Hemlock.", "output": "```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does type definitions work in Hemlock?", "output": "```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does relational work in Hemlock?", "output": "**Type promotion applies:**\n\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true (i32 promoted to i64)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does expected output methods work in Hemlock?", "output": "```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does pattern: factory functions work in Hemlock?", "output": "```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does colored logger work in Hemlock?", "output": "```hemlock\nimport { RED, YELLOW, GREEN, BLUE, BOLD, RESET } from \"@stdlib/terminal\";\n\nfn log_error(msg: string): null {\n    print(RED + BOLD + \"[ERROR]\" + RESET + \" \" + msg);\n    return null;\n}\n\nfn log_warning(msg: string): null {\n    print(YELLOW + BOLD + \"[WARN]\" + RESET + \" \" + msg);\n    return null;\n}\n\nfn log_info(msg: string): null {\n    print(BLUE + BOLD + \"[INFO]\" + RESET + \" \" + msg);\n    return null;\n}\n\nfn log_success(msg: string): null {\n    print(GREEN + BOLD + \"[OK]\" + RESET + \" \" + msg);\n    return null;\n}\n\n// Usage\nlog_error(\"Connection failed\");\nlog_warning(\"Low disk space\");\nlog_info(\"Starting service...\");\nlog_success(\"Operation complete\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test enum declarations and usage\n\n// Simple enum with auto values\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nprint(Color.RED);\nprint(Color.GREEN);\nprint(Color.BLUE);\n\n// Enum with explicit values\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 100\n}\n\nprint(Status.OK);\nprint(Status.ERROR);\nprint(Status.PENDING);\n\n// Enum comparison\nlet color = Color.GREEN;\nif (color == Color.GREEN) {\n    print(\"is green\");\n}\n\nprint(\"done\");\n```", "output": "0\n1\n2\n0\n1\n100\nis green\ndone", "category": "parity/language", "source": "tests/parity/language/enums.hml"}
{"instruction": "How does 1. graceful server shutdown work in Hemlock?", "output": "```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown signal received\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Server main loop\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server stopped\");\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does sha512(input: string): string work in Hemlock?", "output": "SHA-512 hash (512-bit / 64-byte output). More secure variant of SHA-2 family.\n\n```hemlock\nlet hash = sha512(\"hello\");\nprint(hash);\n// Returns 128-character hex string\n\nassert(hash.length == 128, \"SHA-512 produces 128 hex characters\");\n\n// Empty string\nlet empty_hash = sha512(\"\");\nprint(empty_hash);\n// \"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\n//  47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test environment builtins\n\n// Test get_pid returns positive number\nlet pid = get_pid();\nprint(pid > 0);\n\n// Test getenv returns null for non-existent variable\nlet missing = getenv(\"__TEST_NONEXISTENT_VAR__\");\nprint(missing == null);\n\n// Test setenv and getenv work together\nsetenv(\"__TEST_VAR__\", \"hello\");\nlet val = getenv(\"__TEST_VAR__\");\nprint(val);\n\n// PATH should exist\nlet path = getenv(\"PATH\");\nprint(path != null);\n\nprint(\"done\");\n```", "output": "true\ntrue\nhello\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/env_builtins.hml"}
{"instruction": "How does declare external function work in Hemlock?", "output": "```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show an example of example in Hemlock.", "output": "```hemlock\nimport { HashMap } from \"@stdlib/collections\";\n\nlet map = HashMap();\n\n// Set values\nmap.set(\"name\", \"Alice\");\nmap.set(\"age\", 30);\nmap.set(\"active\", true);\n\n// Get values\nprint(map.get(\"name\"));  // \"Alice\"\nprint(map.get(\"age\"));   // 30\n\n// Check existence\nif (map.has(\"active\")) {\n    print(\"User is active\");\n}\n\n// Delete\nmap.delete(\"age\");\n\n// Get all keys/values\nlet keys = map.keys();\nlet values = map.values();\n\nprint(\"Size: \" + typeof(map.size));  // 2\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "Show an example of example: array flattening in Hemlock.", "output": "```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // Nested array - flatten it\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does semicolons are mandatory work in Hemlock?", "output": "**This will cause an error:**\n\n```hemlock\nlet x = 42  // ERROR: Missing semicolon\nlet y = 10  // ERROR: Missing semicolon\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test: Catch parameter is scoped to catch block\nlet e = \"outer\";\ntry {\n    throw \"inner\";\n} catch (e) {\n    print(\"In catch: \" + e);\n}\nprint(\"After catch: \" + e);\n```", "output": "In catch: inner\nAfter catch: outer", "category": "tests/exceptions", "source": "tests/exceptions/catch_scope.hml"}
{"instruction": "How does closures work in Hemlock?", "output": "Functions capture their environment:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does writing work in Hemlock?", "output": "```hemlock\nfile.write(data: string): i32\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\n// Import specific functions\nimport { random_bytes, aes_encrypt, aes_decrypt } from \"@stdlib/crypto\";\nimport { rsa_generate_key, rsa_sign, rsa_verify } from \"@stdlib/crypto\";\nimport { ecdsa_generate_key, ecdsa_sign, ecdsa_verify } from \"@stdlib/crypto\";\n\n// Or import all as namespace\nimport * as crypto from \"@stdlib/crypto\";\nlet key = crypto.generate_aes_key();\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does 4. use try/catch for critical operations work in Hemlock?", "output": "```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Command failed\";\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    // Cleanup or recovery\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show an example of example: adding a new operator in Hemlock.", "output": "```hemlock\n**6. Tests (tests/operators/modulo.hml):**\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does 1. no select() for multiplexing work in Hemlock?", "output": "Cannot wait on multiple channels simultaneously (planned):\n\n```hemlock\n// NOT YET SUPPORTED:\n// let (value, ch_id) = select(ch1, ch2, ch3);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does api work in Hemlock?", "output": "```hemlock\nlet list = LinkedList();\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test file I/O operations\n\n// Write a test file\nlet f = open(\"/tmp/hemlock_test.txt\", \"w\");\nf.write(\"Hello, World!\\n\");\nf.write(\"Line 2\\n\");\nf.close();\n\n// Read the file back\nlet f2 = open(\"/tmp/hemlock_test.txt\", \"r\");\nlet content = f2.read();\nprint(content);\nf2.close();\n\n// Test seek and tell\nlet f3 = open(\"/tmp/hemlock_test.txt\", \"r\");\nlet pos1 = f3.tell();\nprint(pos1);\nf3.seek(7);\nlet pos2 = f3.tell();\nprint(pos2);\nlet rest = f3.read();\nprint(rest);\nf3.close();\n\nprint(\"done\");\n```", "output": "Hello, World!\nLine 2\n\n0\n7\nWorld!\nLine 2\n\ndone", "category": "tests/compiler", "source": "tests/compiler/file_io.hml"}
{"instruction": "How does method chaining work in Hemlock?", "output": "```hemlock\n// Chain slice and join\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// Chain concat and slice\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Complex chaining\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Show an example of example: string validation in Hemlock.", "output": "```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does line breaks work in Hemlock?", "output": "Statements can span multiple lines:\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does clear() work in Hemlock?", "output": "```hemlock\nimport { clear } from \"@stdlib/terminal\";\n\nclear();  // Fresh screen\nprint(\"Starting new output...\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does writing work in Hemlock?", "output": "**Example - Appending to log file:**\n\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Application started\\n\");\nf.write(\"[INFO] User logged in\\n\");\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test while and for loops\n\n// While loop\nlet i = 0;\nwhile (i < 3) {\n    print(i);\n    i = i + 1;\n}\n\n// For loop\nfor (let j = 0; j < 3; j = j + 1) {\n    print(j);\n}\n\n// Break\nlet k = 0;\nwhile (true) {\n    if (k >= 2) {\n        break;\n    }\n    print(k);\n    k = k + 1;\n}\n\nprint(\"done\");\n```", "output": "0\n1\n2\n0\n1\n2\n0\n1\ndone", "category": "parity/language", "source": "tests/parity/language/loops.hml"}
{"instruction": "How does pretty printing work in Hemlock?", "output": "Format value as pretty-printed JSON with indentation.\n\n```hemlock\nimport { pretty } from \"@stdlib/json\";\n\nlet data = { name: \"Alice\", items: [1, 2, 3] };\n\n// Default 2-space indentation\nlet formatted = pretty(data);\nprint(formatted);\n/*\n{\n  \"name\": \"Alice\",\n  \"items\": [\n    1,\n    2,\n    3\n  ]\n}\n*/\n\n// Custom 4-space indentation\nlet formatted4 = pretty(data, 4);\n\n// Tab indentation\nlet tabbed = pretty(data, \"\\t\");\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does write_file(path, content) work in Hemlock?", "output": "**Throws:** Exception if file cannot be written\n\n```hemlock\nimport { write_file } from \"@stdlib/fs\";\n\ntry {\n    write_file(\"output.txt\", \"Hello, World!\");\n    print(\"File written successfully\");\n} catch (e) {\n    print(\"Error writing file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does writing work in Hemlock?", "output": "**Example - Writing multiple lines:**\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does character access work in Hemlock?", "output": "```hemlock\nstring.char_at(index: i32): rune\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does assert_ne(actual, expected) work in Hemlock?", "output": "```hemlock\ntest(\"simple inequality\", fn() {\n    assert_ne(5, 10);\n    assert_ne(\"foo\", \"bar\");\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does ecdsa_sign(data: string, keypair: ecdsakeypair): buffer work in Hemlock?", "output": "Sign data with ECDSA private key using SHA-256 digest.\n\n```hemlock\nimport { ecdsa_sign } from \"@stdlib/crypto\";\n\nlet data = \"Important message\";\nlet signature = ecdsa_sign(data, keypair);\n\nprint(\"Signature length: \" + typeof(signature.length));  // ~70-72 bytes (DER-encoded)\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does rsa_free_keys(keypair: rsakeypair): null work in Hemlock?", "output": "Free RSA key pair memory. Always call when done with keys.\n\n```hemlock\nrsa_free_keys(keypair);\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does byte access work in Hemlock?", "output": "```hemlock\nstring.to_bytes(): buffer\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does channels work in Hemlock?", "output": "```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does argument parser helper function work in Hemlock?", "output": "```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // Positional argument\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Output: \" + opts.output);\nprint(\"Files: \" + typeof(opts.files.length));\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does equality assertions work in Hemlock?", "output": "Deep equality check (compares values, not references).\n\n```hemlock\ntest(\"to_equal\", fn() {\n    expect(42).to_equal(42);\n    expect(\"hello\").to_equal(\"hello\");\n    expect([1, 2, 3]).to_equal([1, 2, 3]);  // Deep comparison\n    expect(true).to_equal(true);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does channel methods work in Hemlock?", "output": "```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does async echo server work in Hemlock?", "output": "```hemlock\nimport { TcpListener } from \"@stdlib/net\";\n\nasync fn handle_client(stream) {\n    defer stream.close();\n\n    while (true) {\n        let data = stream.read(1024);\n        if (data.length == 0) {\n            break;  // Client disconnected\n        }\n        stream.write(data);\n    }\n}\n\nlet listener = TcpListener(\"0.0.0.0\", 8080);\ndefer listener.close();\n\nprint(\"Echo server listening on port 8080\");\n\nwhile (true) {\n    let stream = listener.accept();\n    spawn(handle_client, stream);\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does don'ts work in Hemlock?", "output": "âŒ **Don't test implementation details**\n\n```hemlock\n// BAD: Testing internal structure\nlet obj = { x: 10 };\n// Don't check internal field order, capacity, etc.\n\n// GOOD: Testing behavior\nprint(obj.x);  // Expect: 10\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\nimport {\n    describe, test, expect,\n    assert_eq, assert_ne, assert_true, assert_false, assert_throws,\n    before_each, after_each, run\n} from \"@stdlib/testing\";\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does file not found work in Hemlock?", "output": "```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does email validation work in Hemlock?", "output": "```hemlock\nimport { compile, REG_EXTENDED } from \"@stdlib/regex\";\n\nfn is_valid_email(email: string): bool {\n    // Simplified email regex\n    let pattern = compile(\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\");\n    let valid = pattern.test(email);\n    pattern.free();\n    return valid;\n}\n\nprint(is_valid_email(\"user@example.com\"));     // true\nprint(is_valid_email(\"invalid.email\"));        // false\nprint(is_valid_email(\"test@domain.co.uk\"));    // true\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does equality assertions work in Hemlock?", "output": "Inverse equality checks.\n\n```hemlock\ntest(\"inequality\", fn() {\n    expect(5).not_to_equal(10);\n    expect([1, 2]).not_to_equal([3, 4]);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test recursive functions\n\n// Factorial\nfn factorial(n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));\nprint(factorial(6));\n\n// Fibonacci\nfn fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\nprint(fib(10));\n\n// Sum of array (recursive)\nfn sum_arr(arr, i) {\n    if (i >= arr.length) {\n        return 0;\n    }\n    return arr[i] + sum_arr(arr, i + 1);\n}\n\nprint(sum_arr([1, 2, 3, 4, 5], 0));\n\nprint(\"done\");\n```", "output": "120\n720\n55\n15\ndone", "category": "parity/language", "source": "tests/parity/language/recursion.hml"}
{"instruction": "How does date range iteration work in Hemlock?", "output": "```hemlock\nimport { from_date } from \"@stdlib/datetime\";\n\nlet start = from_date(2025, 1, 1, 0, 0, 0);\nlet end = from_date(2025, 1, 7, 0, 0, 0);\n\nlet current = start;\nwhile (current.is_before(end) || current.is_equal(end)) {\n    print(current.format(\"%A, %B %d, %Y\"));\n    current = current.add_days(1);\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does run(options?) work in Hemlock?", "output": "Execute all registered tests and print results.\n\n```hemlock\n// Basic usage\nlet results = run();\n\n// With options\nlet results = run({\n    verbose: true,    // Print errors inline\n    no_color: false   // Disable colored output\n});\n\n// Check if all tests passed\nif (!results.success) {\n    import { exit } from \"@stdlib/env\";\n    exit(1);\n}\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Collections test\nimport { HashMap, Set, Stack, Queue } from \"@stdlib/collections\";\n\n// HashMap\nlet map = HashMap();\nmap.set(\"a\", 1);\nmap.set(\"b\", 2);\nmap.set(\"c\", 3);\nprint(map.get(\"a\"));\nprint(map.get(\"b\"));\nprint(map.has(\"c\"));\nprint(map.has(\"d\"));\nprint(map.size);\n\n// Set\nlet s = Set();\ns.add(1);\ns.add(2);\ns.add(3);\ns.add(2);  // duplicate\nprint(s.has(1));\nprint(s.has(4));\nprint(s.size);\n\n// Stack\nlet stack = Stack();\nstack.push(10);\nstack.push(20);\nstack.push(30);\nprint(stack.pop());\nprint(stack.pop());\nprint(stack.size);\n\n// Queue\nlet q = Queue();\nq.enqueue(100);\nq.enqueue(200);\nq.enqueue(300);\nprint(q.dequeue());\nprint(q.dequeue());\nprint(q.size);\n```", "output": "1\n2\ntrue\nfalse\n3\ntrue\nfalse\n3\n30\n20\n1\n100\n200\n1", "category": "parity/modules", "source": "tests/parity/modules/stdlib_collections.hml"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test: Try with finally (no catch)\ntry {\n    print(\"try\");\n} finally {\n    print(\"finally\");\n}\nprint(\"after\");\n```", "output": "try\nfinally\nafter", "category": "tests/exceptions", "source": "tests/exceptions/try_finally.hml"}
{"instruction": "How does djb2(input: string): i32 work in Hemlock?", "output": "DJB2 hash algorithm - fast, simple, with good distribution. Commonly used in hash tables.\n\n```hemlock\nlet h = djb2(\"hello world\");\nprint(h);  // -862545276 (i32 hash value)\n\n// Empty string\nlet h2 = djb2(\"\");\nprint(h2);  // 5381 (djb2 initial value)\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does typeof work in Hemlock?", "output": "```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// Typed objects\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// Other types\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does event countdown work in Hemlock?", "output": "```hemlock\nimport { from_date, now } from \"@stdlib/datetime\";\n\nlet event = from_date(2025, 12, 25, 0, 0, 0);\nlet current = now();\n\nif (event.is_after(current)) {\n    let days_until = event.diff_days(current);\n    print(\"Days until event: \" + typeof(days_until));\n} else {\n    print(\"Event has already occurred\");\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test enum as function parameters\n\nenum Status {\n    OK,\n    ERROR,\n    PENDING\n}\n\nfn process(s: Status): string {\n    if (s == Status.OK) {\n        return \"Success\";\n    }\n    if (s == Status.ERROR) {\n        return \"Failed\";\n    }\n    return \"Waiting\";\n}\n\nprint(process(Status.OK));\nprint(process(Status.ERROR));\nprint(process(Status.PENDING));\n```", "output": "Success\nFailed\nWaiting", "category": "tests/enums", "source": "tests/enums/function_params.hml"}
{"instruction": "How does type checking work in Hemlock?", "output": "Use `typeof()` to check if a value is a rune:\n\n```hemlock\nlet r = 'ðŸš€';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (indexing returns runes)\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test that variables starting with runtime prefixes don't conflict\n// This tests the compiler's identifier sanitization for runtime prefixes\n\n// Test local variables with names that start with runtime prefixes\nfn test_runtime_prefixes() {\n    // Variables starting with hml_ prefix (Hemlock runtime functions)\n    let hml_test = 42;\n    let hml_print = \"not the builtin\";\n    let hml_val_i32 = 100;\n\n    // Variables starting with Hml prefix (Hemlock types)\n    let HmlValue = \"type name\";\n\n    // Variables starting with codegen internal prefixes\n    let _tmp = \"temp var\";\n    let _tmp0 = \"temp var 0\";\n    let _main_var = \"main var\";\n    let _mod0_test = \"module test\";\n    let _env_0 = \"env var\";\n    let _v_test = \"sanitized var\";\n    let _ex_ctx = \"exception context\";\n\n    print(hml_test);\n    print(hml_print);\n    print(hml_val_i32);\n    print(HmlValue);\n    print(_tmp);\n    print(_tmp0);\n    print(_main_var);\n    print(_mod0_test);\n    print(_env_0);\n    print(_v_test);\n    print(_ex_ctx);\n}\n\n// Test function parameters with runtime prefix names\nfn test_param_prefixes(hml_x, _tmp1, _main_y) {\n    print(hml_x);\n    print(_tmp1);\n    print(_main_y);\n}\n\n// Run all tests\ntest_runtime_prefixes();\ntest_param_prefixes(\"param1\", \"param2\", \"param3\");\n\n// Verify that actual print builtin still works\nprint(\"done\");\n```", "output": "42\nnot the builtin\n100\ntype name\ntemp var\ntemp var 0\nmain var\nmodule test\nenv var\nsanitized var\nexception context\nparam1\nparam2\nparam3\ndone", "category": "parity/language", "source": "tests/parity/language/runtime_prefix_names.hml"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as fs from \"@stdlib/fs\";\nlet files = fs.list_dir(\".\");\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does core functions work in Hemlock?", "output": "Parse JSON string to value. Wrapper around built-in `.deserialize()` with enhanced error messages.\n\n```hemlock\nimport { parse } from \"@stdlib/json\";\n\nlet obj = parse('{\"x\":10,\"y\":20}');\nprint(obj.x);  // 10\n\nlet arr = parse('[1,2,3]');\nprint(arr.length);  // 3\n\n// Error handling\ntry {\n    let invalid = parse('{\"unclosed\"');\n} catch (e) {\n    print(\"Parse error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does 2. multiple arguments work in Hemlock?", "output": "```hemlock\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Input: \" + input_file);\n    print(\"Output: \" + output_file);\n\n    // Process files...\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does else-if chains work in Hemlock?", "output": "```hemlock\nif (x > 100) {\n    print(\"very large\");\n} else if (x > 50) {\n    print(\"large\");\n} else if (x > 10) {\n    print(\"medium\");\n} else {\n    print(\"small\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does output field work in Hemlock?", "output": "```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // Directory listing with newlines\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\" (empty string)\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All WebSocket operations can throw exceptions:\n\n```hemlock\ntry {\n    let ws = WebSocket(\"ws://invalid-host:9999\");\n    ws.send_text(\"test\");\n} catch (e) {\n    print(\"Connection failed: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does signal-based state machine work in Hemlock?", "output": "```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // Advance state\nsignal(SIGUSR2, prev_state);  // Go back\n\n// Control state machine:\n// kill -USR1 <pid>  # Next state\n// kill -USR2 <pid>  # Previous state\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does 1. always use try/finally work in Hemlock?", "output": "```hemlock\n// Good\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// Bad - file might not close on error\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // If this throws, file leaks\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport { get_pid, getppid, exec, kill } from \"@stdlib/process\";\nimport { sleep } from \"@stdlib/time\";\n\n// Display process info\nprint(\"=== Process Info ===\");\nprint(\"PID: \" + typeof(get_pid()));\nprint(\"PPID: \" + typeof(getppid()));\n\n// Execute commands\nprint(\"\\n=== Command Execution ===\");\nlet result = exec(\"uname -s\");\nprint(\"OS: \" + result.output.trim());\n\nlet files = exec(\"ls -1 | wc -l\");\nprint(\"Files in directory: \" + files.output.trim());\n\n// Check process status\nprint(\"\\n=== Process Management ===\");\nfn check_process(name: string) {\n    let result = exec(\"pgrep \" + name);\n    if (result.exit_code == 0) {\n        print(name + \" is running (PID: \" + result.output.trim() + \")\");\n        return true;\n    } else {\n        print(name + \" is not running\");\n        return false;\n    }\n}\n\ncheck_process(\"ssh\");\ncheck_process(\"httpd\");\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does async function declaration work in Hemlock?", "output": "```hemlock\nasync fn function_name(params): return_type {\n    // function body\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does 2. check file state before operations work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... use content\n}\n\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does before_each(fn) work in Hemlock?", "output": "Run setup code before each test in the suite.\n\n```hemlock\ndescribe(\"Database tests\", fn() {\n    let db = null;\n\n    before_each(fn() {\n        db = create_db();\n        db.connect();\n    });\n\n    after_each(fn() {\n        db.close();\n    });\n\n    test(\"can insert record\", fn() {\n        db.insert(\"users\", { name: \"Alice\" });\n        expect(db.count(\"users\")).to_equal(1);\n    });\n\n    test(\"can query records\", fn() {\n        db.insert(\"users\", { name: \"Bob\" });\n        let users = db.query(\"users\");\n        expect(users.length).to_equal(1);\n    });\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Show an example of example 3: advanced argument parser in Hemlock.", "output": "```hemlock\n// Usage: ./hemlock app.hml [OPTIONS] <files...>\n// Options:\n//   --verbose, -v     Enable verbose output\n//   --output, -o FILE Set output file\n//   --help, -h        Show help\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Error: --output requires a value\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Error: Unknown option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options:\");\n    print(\"  --verbose, -v     Enable verbose output\");\n    print(\"  --output, -o FILE Set output file\");\n    print(\"  --help, -h        Show this help\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Error: No input files specified\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Verbose mode enabled\");\n        print(\"Output file: \" + config.output);\n        print(\"Input files: \" + typeof(config.files.length));\n    }\n\n    // Process files\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Processing: \" + file);\n        }\n        // ... process file\n    }\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does test organization work in Hemlock?", "output": "3. **Clear test names:**\n\n```hemlock\ntest(\"returns null when key not found\", fn() { ... });\ntest(\"throws error on invalid input\", fn() { ... });\ntest(\"handles empty array correctly\", fn() { ... });\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "**2. Use After Free**\n\n```hemlock\n// BAD: Use after free\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // CRASH: using freed memory\n\n// GOOD: Don't use after free\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// Don't touch p2 after this\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does what reference counting handles work in Hemlock?", "output": "3. **Containers are freed** - elements are released:\n\n```hemlock\nlet arr = [obj1, obj2];\n   free(arr);  // obj1 and obj2 get their ref_counts decremented\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does integer literal inference work in Hemlock?", "output": "```hemlock\nlet small = 42;                    // i32 (fits in i32)\nlet large = 5000000000;            // i64 (> i32 max)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (type annotation overrides)\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does break work in Hemlock?", "output": "Exit the innermost loop or switch:\n\n```hemlock\n// In loops\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // Exit loop\n    }\n    print(i);\n    i = i + 1;\n}\n\n// In switch\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // Exit switch\n    case 2:\n        print(\"two\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does standard library versioning work in Hemlock?", "output": "The standard library (`@stdlib/*`) is versioned **with the main release**:\n\n```hemlock\n// Always uses the stdlib bundled with your Hemlock installation\nimport { HashMap } from \"@stdlib/collections\";\nimport { sin, cos } from \"@stdlib/math\";\n```", "category": "docs", "source": "docs/versioning.md"}
{"instruction": "How does level hierarchy work in Hemlock?", "output": "```hemlock\nimport { Logger, DEBUG, INFO, WARN, ERROR } from \"@stdlib/logging\";\n\nlet logger = Logger({ level: WARN });  // Only WARN and ERROR\n\nlogger.debug(\"This is filtered\");      // Not shown\nlogger.info(\"This is filtered\");       // Not shown\nlogger.warn(\"This is shown\");          // âœ“ Shown\nlogger.error(\"This is shown\");         // âœ“ Shown\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does break and continue work in Hemlock?", "output": "```hemlock\n// Break: exit loop early\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Prints: 0, 1, 2, 3, 4\n\n// Continue: skip to next iteration\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// Prints: 0, 1, 3, 4\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does rand_range(min_val, max_val) work in Hemlock?", "output": "**Returns:** `f64` - Random value in [min, max)\n\n```hemlock\nimport { rand_range } from \"@stdlib/math\";\n\nlet dice = rand_range(1.0, 7.0);       // Random 1.0 to 6.999...\nlet temperature = rand_range(20.0, 30.0); // Random 20-30Â°C\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "**`bytes()`** - Convert to array of bytes (u8 values):\n\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111] (array of u8)\n\n// UTF-8 example\nlet emoji = \"ðŸš€\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test increment and decrement operators\n\n// Basic prefix increment\nlet a = 5;\nprint(++a);\nprint(a);\n\n// Basic prefix decrement\nlet b = 10;\nprint(--b);\nprint(b);\n\n// Basic postfix increment\nlet c = 5;\nprint(c++);\nprint(c);\n\n// Basic postfix decrement\nlet d = 10;\nprint(d--);\nprint(d);\n\n// Increment in expressions\nlet e = 1;\nlet f = ++e + 10;\nprint(f);\nprint(e);\n\n// Postfix in expressions\nlet g = 1;\nlet h = g++ + 10;\nprint(h);\nprint(g);\n\n// Array index increment\nlet arr = [10, 20, 30];\nprint(++arr[0]);\nprint(arr[0]);\n\n// Array index postfix\nprint(arr[1]++);\nprint(arr[1]);\n\n// Object property increment\nlet obj = { x: 100 };\nprint(++obj.x);\nprint(obj.x);\n\n// Object property postfix\nprint(obj.x--);\nprint(obj.x);\n\n// Multiple increments\nlet i = 0;\ni++;\ni++;\ni++;\nprint(i);\n\n// Decrement in loop\nlet j = 5;\nwhile (j > 0) {\n    print(j);\n    j--;\n}\n\nprint(\"done\");\n```", "output": "6\n6\n9\n9\n5\n6\n10\n9\n12\n2\n11\n2\n11\n11\n20\n21\n101\n101\n101\n100\n3\n5\n4\n3\n2\n1\ndone", "category": "parity/language", "source": "tests/parity/language/increment_decrement.hml"}
{"instruction": "How does overview work in Hemlock?", "output": "```hemlock\nlet ch = 'A';           // Rune literal\nlet emoji = 'ðŸš€';       // Multi-byte character as single rune\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // String + rune concatenation\nlet r = '>' + \" msg\";   // Rune + string concatenation\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does receiving messages work in Hemlock?", "output": "**Blocking receive:**\n\n```hemlock\nlet msg = ws.recv(-1);  // Block forever\nif (msg != null && msg.type == \"text\") {\n    print(\"Received: \" + msg.data);\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does async_append_file work in Hemlock?", "output": "```hemlock\nimport { async_append_file } from \"@stdlib/async_fs\";\n\nlet future = async_append_file(\"log.txt\", \"New log entry\\n\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does core allocation work in Hemlock?", "output": "**`free(ptr)` - Free memory**\n\n```hemlock\nlet p = alloc(100);\nfree(p);  // Must free to avoid memory leak\n\nlet buf = buffer(100);\nfree(buf);  // Works on both ptr and buffer\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does character access work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// UTF-8 example\nlet text = \"HiðŸš€!\";\nlet chars2 = text.chars();      // ['H', 'i', 'ðŸš€', '!']\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does file type work in Hemlock?", "output": "```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does signal counter work in Hemlock?", "output": "Track number of signals received:\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Received \" + typeof(signal_count) + \" signals\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// Later...\nprint(\"Total signals: \" + typeof(signal_count));\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does case conversion work in Hemlock?", "output": "**`to_upper()`** - Convert to uppercase:\n\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// Preserves non-ASCII\nlet s2 = \"cafÃ©\";\nlet upper2 = s2.to_upper();     // \"CAFÃ‰\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test namespace imports\nimport * as math from \"./helper.hml\";\n\n// Use namespace to access exports\nprint(math.add(5, 3));\nprint(math.multiply(6, 7));\nprint(math.PI);\nprint(math.greeting);\n```", "output": "8\n42\n3.14159\nHello", "category": "parity/modules", "source": "tests/parity/modules/namespace_import.hml"}
{"instruction": "Show how to define and use functions in Hemlock.", "output": "```hemlock\n// Hemlock Functions Demo\n// Showcases first-class functions, closures, and recursion\n\nprint(\"=== Hemlock Functions Demo ===\");\nprint(\"\");\n\n// 1. Basic named function\nprint(\"1. Basic function:\");\nfn add(a, b) {\n    return a + b;\n}\nprint(add(5, 3));\nprint(\"\");\n\n// 2. Function with type annotations\nprint(\"2. Typed function:\");\nfn multiply(x: i32, y: i32): i32 {\n    return x * y;\n}\nprint(multiply(7, 6));\nprint(\"\");\n\n// 3. Recursive function - factorial\nprint(\"3. Recursion (factorial):\");\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\nprint(factorial(6));\nprint(\"\");\n\n// 4. Closures - function that returns a function\nprint(\"4. Closures:\");\nfn makeMultiplier(factor) {\n    return fn(x) {\n        return x * factor;\n    };\n}\nlet double = makeMultiplier(2);\nlet triple = makeMultiplier(3);\nprint(double(5));\nprint(triple(5));\nprint(\"\");\n\n// 5. Anonymous functions as first-class values\nprint(\"5. Anonymous functions:\");\nlet square = fn(n) {\n    return n * n;\n};\nprint(square(8));\nprint(\"\");\n\n// 6. Higher-order functions - passing functions as arguments\nprint(\"6. Higher-order functions:\");\nfn apply(func, value) {\n    return func(value);\n}\nprint(apply(square, 9));\nprint(\"\");\n\n// 7. Lexical scoping\nprint(\"7. Lexical scoping:\");\nlet message = 100;\nfn getMessage() {\n    return message + 23;\n}\nprint(getMessage());\nprint(\"\");\n\n// 8. Counter closure (stateful closure)\nprint(\"8. Counter closure:\");\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\nlet counter = makeCounter();\nprint(counter());\nprint(counter());\nprint(counter());\nprint(\"\");\n\n// 9. Fibonacci with recursion\nprint(\"9. Fibonacci sequence:\");\nfn fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\nlet i = 0;\nwhile (i < 10) {\n    print(fib(i));\n    i = i + 1;\n}\n\nprint(\"\");\nprint(\"=== Demo Complete ===\");\n```", "category": "examples", "source": "examples/functions_demo.hml"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "**Right Shift (`>>`)**\n\n```hemlock\nprint(a >> 1);  // 6 (110) - shift right by 1\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does 2. memory management work in Hemlock?", "output": "```hemlock\n// Remember to free allocated memory\nlet ptr = c_malloc(1024);\n// ... use ptr\nc_free(ptr);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does producer-consumer pattern work in Hemlock?", "output": "```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Producing:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consuming:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel\nlet ch = channel(10);\n\n// Spawn producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for completion\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does map pattern work in Hemlock?", "output": "```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show an example of lifecycle example in Hemlock.", "output": "```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. Create task\nlet t = spawn(work, 21);  // State: Running\n\n// Task executes on separate thread...\n\n// 2. Join task\nlet result = join(t);     // State: Completed â†’ Joined\nprint(result);            // 42\n\n// Task resources cleaned up after join\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Show an example of complete aes example in Hemlock.", "output": "```hemlock\nimport {\n    generate_aes_key,\n    generate_iv,\n    aes_encrypt,\n    aes_decrypt,\n    buffer_to_hex\n} from \"@stdlib/crypto\";\n\n// Generate key and IV\nlet key = generate_aes_key();\nlet iv = generate_iv();\n\nprint(\"Key: \" + buffer_to_hex(key));\nprint(\"IV:  \" + buffer_to_hex(iv));\n\n// Encrypt\nlet message = \"This is a secret message!\";\nlet encrypted = aes_encrypt(message, key, iv);\n\nprint(\"Encrypted (\" + typeof(encrypted.length) + \" bytes): \" + buffer_to_hex(encrypted));\n\n// Decrypt\nlet decrypted = aes_decrypt(encrypted, key, iv);\nprint(\"Decrypted: \" + decrypted);\n\n// Verify\nif (decrypted == message) {\n    print(\"âœ“ Encryption/decryption successful!\");\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does interactive repl work in Hemlock?", "output": "```hemlock\nYou'll see a prompt where you can type Hemlock code:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does homedir() work in Hemlock?", "output": "- Application data storage\n\n```hemlock\nimport { homedir } from \"@stdlib/os\";\n\nlet home = homedir();\nprint(\"Home directory: \" + home);  // e.g., \"/home/john\"\n\n// Create user-specific paths\nlet config_file = home + \"/.myapp/config.json\";\nlet data_dir = home + \"/.local/share/myapp\";\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\nimport { parse, stringify, pretty } from \"@stdlib/json\";\nimport * as json from \"@stdlib/json\";\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does prefix/suffix checking work in Hemlock?", "output": "**`starts_with(prefix)`** - Check if starts with prefix:\n\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "**3. Commands producing huge output:**\n\n```hemlock\n// Bad - loads entire output into memory\nlet r = exec(\"cat 10GB_file.log\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does bitwise operators work in Hemlock?", "output": "```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - Bitwise AND\nprint(a | b);   // 14 - Bitwise OR\nprint(a ^ b);   // 6  - Bitwise XOR\nprint(a << 2);  // 48 - Left shift\nprint(a >> 1);  // 6  - Right shift\nprint(~a);      // -13 - Bitwise NOT\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test file I/O operations\n\n// Write to file\nlet f = open(\"/tmp/hemlock_parity_test.txt\", \"w\");\nf.write(\"Hello, World!\\n\");\nf.write(\"Line 2\\n\");\nf.close();\n\n// Read from file\nlet f2 = open(\"/tmp/hemlock_parity_test.txt\", \"r\");\nlet content = f2.read();\nprint(content);\nf2.close();\n\n// Append mode\nlet f3 = open(\"/tmp/hemlock_parity_test.txt\", \"a\");\nf3.write(\"Line 3\\n\");\nf3.close();\n\n// Read appended content\nlet f4 = open(\"/tmp/hemlock_parity_test.txt\", \"r\");\nlet full = f4.read();\nf4.close();\n\n// Check line count\nlet lines = full.split(\"\\n\");\nprint(lines.length);\n\nprint(\"done\");\n```", "output": "Hello, World!\nLine 2\n\n4\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/file_io.hml"}
{"instruction": "How does data transformation work in Hemlock?", "output": "```hemlock\nimport { parse, stringify, clone } from \"@stdlib/json\";\n\nlet input = parse(input_json);\n\n// Clone to avoid mutating original\nlet output = clone(input);\n\n// Transform data\nset(output, \"metadata.processed\", true);\nset(output, \"metadata.timestamp\", time());\n\n// Output as JSON\nlet result_json = stringify(output);\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does module caching work in Hemlock?", "output": "Modules are loaded once and cached. Multiple imports of the same module return the same instance:\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // Same instance!\nprint(count);  // Still 1 (shared state)\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does writing files work in Hemlock?", "output": "```hemlock\n// Write text\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, File!\\n\");\nf.write(\"Second line\\n\");\nf.close();\n\n// Append to file\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"Appended line\\n\");\nf2.close();\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test for-in loops\n\n// Array iteration\nlet arr = [10, 20, 30, 40];\nfor (let x in arr) {\n    print(x);\n}\n\n// Nested for-in\nlet matrix = [[1, 2], [3, 4]];\nfor (let row in matrix) {\n    for (let val in row) {\n        print(val);\n    }\n}\n\nprint(\"done\");\n```", "output": "10\n20\n30\n40\n1\n2\n3\n4\ndone", "category": "parity/language", "source": "tests/parity/language/for_in.hml"}
{"instruction": "How does validation workflow work in Hemlock?", "output": "```hemlock\nimport { is_valid, validate, parse } from \"@stdlib/json\";\n\nfn process_json_input(user_input: string) {\n    // Quick validation\n    if (!is_valid(user_input)) {\n        let result = validate(user_input);\n        print(\"Invalid JSON: \" + result.message);\n        return null;\n    }\n\n    // Parse and process\n    let data = parse(user_input);\n\n    // Validate structure\n    if (!has(data, \"version\")) {\n        print(\"Missing required field: version\");\n        return null;\n    }\n\n    return data;\n}\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does case conversion work in Hemlock?", "output": "**`to_lower()`** - Convert to lowercase:\n\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does type safety patterns work in Hemlock?", "output": "**Use duck typing for flexibility:**\n\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show an example of example 1: arithmetic and comparison in Hemlock.", "output": "```hemlock\nlet result = 5 + 3 * 2;\n// Evaluated as: 5 + (3 * 2) = 11\n// Multiplication has higher precedence than addition\n\nlet cmp = 10 > 5 + 3;\n// Evaluated as: 10 > (5 + 3) = true\n// Addition has higher precedence than comparison\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test object literals and methods\n\n// Basic object\nlet point = { x: 10, y: 20 };\nprint(point.x);\nprint(point.y);\n\n// Object with method using self\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n\ncounter.increment();\ncounter.increment();\nprint(counter.get());\n\n// Nested objects\nlet person = {\n    name: \"Alice\",\n    address: {\n        city: \"NYC\",\n        zip: 10001\n    }\n};\nprint(person.name);\nprint(person.address.city);\n\n// Object field assignment\npoint.z = 30;\nprint(point.z);\n```", "output": "10\n20\n2\nAlice\nNYC\n30", "category": "tests/compiler", "source": "tests/compiler/objects.hml"}
{"instruction": "How does mixed integer types work in Hemlock?", "output": "```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does `buffer` - safe wrapper (recommended) work in Hemlock?", "output": "```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // ERROR: Index out of bounds\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Show an example of example: character iteration in Hemlock.", "output": "```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"HiðŸš€\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does raise(signum) work in Hemlock?", "output": "```hemlock\nraise(SIGUSR1);  // Trigger SIGUSR1 handler\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does scientific notation work in Hemlock?", "output": "Hemlock supports scientific notation for numeric literals:\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // Case insensitive\nlet f = 1e+5;        // Explicit positive exponent\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does explicit type conversion work in Hemlock?", "output": "```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8 â†’ rune ('A')\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test if/else statements\nlet x = 10;\n\nif (x > 5) {\n    print(\"greater\");\n}\n\nif (x < 5) {\n    print(\"less\");\n} else {\n    print(\"not less\");\n}\n\nif (x == 10) {\n    print(\"equal to 10\");\n} else if (x == 5) {\n    print(\"equal to 5\");\n} else {\n    print(\"other\");\n}\n\n// Nested if\nlet y = 20;\nif (x > 0) {\n    if (y > 0) {\n        print(\"both positive\");\n    }\n}\n```", "output": "greater\nnot less\nequal to 10\nboth positive", "category": "tests/compiler", "source": "tests/compiler/if_else.hml"}
{"instruction": "How does join work in Hemlock?", "output": "```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // Blocks until task completes\nprint(result);         // 3628800\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does substring & slicing work in Hemlock?", "output": "```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// UTF-8 example\nlet text = \"HiðŸš€!\";\nlet first_three = text.slice(0, 3);  // \"HiðŸš€\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does utf-8 behavior work in Hemlock?", "output": "All string operations work with **codepoints** (characters), not bytes:\n\n```hemlock\nlet text = \"HelloðŸš€World\";\nprint(text.length);        // 11 (codepoints)\nprint(text.byte_length);   // 15 (bytes, emoji is 4 bytes)\n\n// Indexing uses codepoints\nlet h = text[0];           // 'H' (rune)\nlet rocket = text[5];      // 'ðŸš€' (rune)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Show an example of example: direct call vs spawn in Hemlock.", "output": "```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Direct call - runs synchronously\nlet result1 = factorial(5);  // 120\n\n// Spawned task - runs on separate thread\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does .byte_length work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 byte per ASCII char)\n\nlet emoji = \"ðŸš€\";\nprint(emoji.byte_length); // 4 (emoji is 4 UTF-8 bytes)\n\nlet text = \"Hello ðŸŒ!\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 for emoji)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does null type work in Hemlock?", "output": "```hemlock\nlet x = null;\nlet y: i32 = null;  // ERROR: type mismatch\n\nif (x == null) {\n    print(\"x is null\");\n}\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test primitives: integers, strings, booleans\nlet x = 42;\nprint(x);\n\nlet y = -10;\nprint(y);\n\nlet s = \"Hello, World!\";\nprint(s);\n\nlet b = true;\nprint(b);\n\nlet f = false;\nprint(f);\n\nlet n = null;\nprint(n);\n```", "output": "42\n-10\nHello, World!\ntrue\nfalse\nnull", "category": "tests/compiler", "source": "tests/compiler/primitives.hml"}
{"instruction": "How does comparison work in Hemlock?", "output": "- `<`, `>`, `<=`, `>=` - Codepoint order\n\n```hemlock\nprint('A' < 'B');               // true (65 < 66)\nprint('a' > 'Z');               // true (97 > 90)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How do you use using try/catch in Hemlock?", "output": "```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does graceful shutdown pattern work in Hemlock?", "output": "Common pattern for cleanup on termination:\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Main loop\nwhile (!should_exit) {\n    // Do work...\n    // Check should_exit flag periodically\n}\n\nprint(\"Cleanup complete\");\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does error handling in callbacks work in Hemlock?", "output": "- The exception is logged but not propagated\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Something went wrong\";  // Warning printed, returns 0\n}\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does channel methods work in Hemlock?", "output": "Receive value from channel (blocks if empty).\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does environment variables work in Hemlock?", "output": "```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test string interpolation with template strings\n\n// Basic variable interpolation\nlet name = \"Alice\";\nlet greeting = `Hello, ${name}!`;\nprint(greeting);\n\n// Multiple interpolations\nlet age = 30;\nlet msg = `${name} is ${age} years old.`;\nprint(msg);\n\n// Expression interpolation\nlet x = 10;\nlet y = 20;\nlet result = `Sum: ${x + y}, Product: ${x * y}`;\nprint(result);\n\n// Nested property access\nlet person = { name: \"Bob\", city: \"NYC\" };\nprint(`${person.name} lives in ${person.city}`);\n\n// Empty interpolation (edge case)\nlet empty = `start  end`;\nprint(empty);\n\n// Just a plain template string\nlet plain = `no interpolation here`;\nprint(plain);\n\nprint(\"done\");\n```", "output": "Hello, Alice!\nAlice is 30 years old.\nSum: 30, Product: 200\nBob lives in NYC\nstart  end\nno interpolation here\ndone", "category": "tests/compiler", "source": "tests/compiler/string_interpolation.hml"}
{"instruction": "How does pattern: range checking work in Hemlock?", "output": "```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"valid score\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Show an example of example: multi-module project in Hemlock.", "output": "```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```", "category": "docs", "source": "docs/advanced/bundling-packaging.md"}
{"instruction": "How does 2. use structured concurrency work in Hemlock?", "output": "Spawn tasks and join them in the same scope:\n\n```hemlock\nfn process_data(data) {\n    // Spawn tasks\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // Always join before returning\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Show an example of complete server example in Hemlock.", "output": "```hemlock\nimport { WebSocketServer } from \"@stdlib/websocket\";\n\nasync fn handle_client(conn, client_id) {\n    defer conn.close();\n    print(\"Client \" + typeof(client_id) + \" connected\");\n\n    while (true) {\n        let msg = conn.recv(10000);\n        if (msg == null || msg.type == \"close\") {\n            break;\n        }\n\n        if (msg.type == \"text\") {\n            print(\"Client \" + typeof(client_id) + \": \" + msg.data);\n            conn.send_text(\"Received: \" + msg.data);\n        }\n    }\n\n    print(\"Client \" + typeof(client_id) + \" disconnected\");\n}\n\ntry {\n    let server = WebSocketServer(\"0.0.0.0\", 8080);\n    defer server.close();\n\n    print(\"Server started on :8080\");\n\n    let client_id = 0;\n    while (true) {\n        let conn = server.accept(-1);\n        if (conn != null) {\n            client_id = client_id + 1;\n            spawn(handle_client, conn, client_id);\n        }\n    }\n} catch (e) {\n    print(\"Server error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does basic closures work in Hemlock?", "output": "```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does search operations work in Hemlock?", "output": "**`find(value)`** - Find first occurrence:\n\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (index of first occurrence)\nlet idx2 = arr.find(99);     // -1 (not found)\n\n// Works with any type\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Show an example of basic example in Hemlock.", "output": "```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does combining styles work in Hemlock?", "output": "```hemlock\nimport { RED, BOLD, UNDERLINE, BG_YELLOW, RESET } from \"@stdlib/terminal\";\n\nprint(BOLD + UNDERLINE + RED + \"Bold, underlined, red\" + RESET);\nprint(BOLD + RED + BG_YELLOW + \" Alert \" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does script name included work in Hemlock?", "output": "`args[0]` always contains the script path/name:\n\n```hemlock\nprint(\"Running: \" + args[0]);\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Show an example of example 1: file processor in Hemlock.", "output": "```hemlock\n// Usage: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Processing \" + input + \" -> \" + output);\n\n    // Process files\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // Example processing\n        f_out.write(processed);\n\n        print(\"Done!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does methods with parameters work in Hemlock?", "output": "```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does pointer arithmetic work in Hemlock?", "output": "**Use buffers for bounds checking:**\n\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // ERROR: Bounds check prevents overflow\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does prefix & suffix work in Hemlock?", "output": "```hemlock\nstring.starts_with(prefix: string): bool\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does nested objects work in Hemlock?", "output": "```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does tarwriter() -> object work in Hemlock?", "output": "```hemlock\nimport { TarWriter, TarReader } from \"@stdlib/compression\";\n\n// Create tar archive\nlet writer = TarWriter();\nwriter.add_directory(\"myproject/\");\nwriter.add_file(\"myproject/README.md\", \"# My Project\\n\\nWelcome!\");\nwriter.add_file(\"myproject/main.hml\", \"print(\\\"Hello!\\\");\");\n\nlet tar_data = writer.build();\nprint(\"Archive size: \" + typeof(tar_data.length));\n\n// Save to file\nlet f = open(\"myproject.tar\", \"w\");\nf.write_bytes(tar_data);\nf.close();\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does switch with default work in Hemlock?", "output": "```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown color\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does when not to use panic work in Hemlock?", "output": "- Expected error conditions\n\n```hemlock\n// BAD: Panic for expected errors\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"division by zero\");  // âŒ Too harsh\n    }\n    return a / b;\n}\n\n// GOOD: Throw for expected errors\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";  // âœ… Recoverable\n    }\n    return a / b;\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does pad_right(str, width, fill?) work in Hemlock?", "output": "**Returns:** `string` - Padded string\n\n```hemlock\nimport { pad_right } from \"@stdlib/strings\";\n\nlet s1 = pad_right(\"42\", 5);\nprint(s1);  // \"42   \"\n\nlet s2 = pad_right(\"42\", 5, \"0\");\nprint(s2);  // \"42000\"\n\n// Unicode fill\nlet s3 = pad_right(\"test\", 10, \"â”€\");\nprint(s3);  // \"testâ”€â”€â”€â”€â”€â”€\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does pitfall: loop variable scope work in Hemlock?", "output": "```hemlock\n// i is scoped to the loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // ERROR: i not defined here\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does closed: bool work in Hemlock?", "output": "**Example - Checking if file is open:**\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... process content\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"File is now closed\");\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does time_ms() work in Hemlock?", "output": "- Timestamping with millisecond precision\n\n```hemlock\nimport { time_ms } from \"@stdlib/time\";\n\nlet start = time_ms();\n// ... do work ...\nlet end = time_ms();\nlet ms_elapsed = end - start;\nprint(\"Took \" + typeof(ms_elapsed) + \"ms\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does declaring variables work in Hemlock?", "output": "```hemlock\n// Basic variable declaration\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does configuration management work in Hemlock?", "output": "```hemlock\nimport { parse_file, pretty_file, get, set } from \"@stdlib/json\";\n\n// Load configuration\nlet config = parse_file(\"config.json\");\n\n// Read settings with defaults\nlet port = get(config, \"server.port\", 8080);\nlet host = get(config, \"server.host\", \"localhost\");\nlet db_pool = get(config, \"database.pool_size\", 10);\n\nprint(\"Server: \" + host + \":\" + typeof(port));\n\n// Update settings\nset(config, \"server.port\", 9000);\nset(config, \"database.pool_size\", 20);\n\n// Save with formatting\npretty_file(\"config.json\", config, 2);\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does 6. avoid logging sensitive data work in Hemlock?", "output": "```hemlock\n// Bad: Logs password\nlogger.info(\"User login\", { username: \"alice\", password: \"secret123\" });\n\n// Good: Omit sensitive data\nlogger.info(\"User login\", { username: \"alice\" });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\npool.submit(task_fn: fn): Future\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does migration from old api work in Hemlock?", "output": "**Migration Example:**\n\n```hemlock\n// Old (v0.0)\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// New (v0.1)\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does pattern: state object work in Hemlock?", "output": "```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does writing work in Hemlock?", "output": "```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// Write text\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote\", written, \"bytes\");\n\n// Multiple writes\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\n\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does basic iteration work in Hemlock?", "output": "**Output for: `./hemlock script.hml foo bar baz`**\n\n```hemlock\nArgument 1: foo\nArgument 2: bar\nArgument 3: baz\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does forgetting to free memory work in Hemlock?", "output": "```hemlock\n// âŒ MEMORY LEAK\nlet buf = buffer(100);\n// ... use buf ...\n// Forgot to call free(buf)!\n\n// âœ… CORRECT\nlet buf = buffer(100);\n// ... use buf ...\nfree(buf);\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All JSON operations use Hemlock's exception system:\n\n```hemlock\nimport { parse, stringify, get, set } from \"@stdlib/json\";\n\n// Parse errors\ntry {\n    let obj = parse('{\"malformed}');\n} catch (e) {\n    print(\"Parse error: \" + e);\n}\n\n// Serialization errors (circular references)\ntry {\n    let obj = {};\n    obj.self = obj;\n    stringify(obj);\n} catch (e) {\n    print(\"Stringify error: \" + e);\n}\n\n// Path errors\ntry {\n    let obj = { user: { name: \"Alice\" } };\n    set(obj, \"nonexistent.path\", \"value\");\n} catch (e) {\n    print(\"Path error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does `ptr` - raw pointer (dangerous) work in Hemlock?", "output": "```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation - allowed but dangerous\nfree(p);\nlet x = *p;       // Dangling pointer - undefined behavior\nfree(p);          // Double-free - will crash\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does `.length` property work in Hemlock?", "output": "Returns the number of elements:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// Empty array\nlet empty = [];\nprint(empty.length);  // 0\n\n// After modifications\narr.push(6);\nprint(arr.length);  // 6\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does memcpy work in Hemlock?", "output": "```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does channel methods work in Hemlock?", "output": "```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // Signal no more values\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // Channel closed\n        }\n        print(val);\n    }\n    return null;\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does for-in loops work in Hemlock?", "output": "Iterate over array elements:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // Prints each element\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does testing error cases work in Hemlock?", "output": "**Example: tests/primitives/range_error.hml**\n\n```hemlock\n// This should fail with a type error\nlet x: u8 = 256;  // Out of range for u8\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test signal handling - simplified for parity\n\nfn handle_signal(sig) {\n    print(\"signal received\");\n}\n\n// Register handler\nsignal(SIGUSR1, handle_signal);\n\n// Raise signal\nraise(SIGUSR1);\n\n// Reset to default\nsignal(SIGUSR1, null);\n\nprint(\"done\");\n```", "output": "signal received\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/signals.hml"}
{"instruction": "How does unsetenv(name) work in Hemlock?", "output": "- Resetting configuration\n\n```hemlock\nimport { setenv, unsetenv, getenv } from \"@stdlib/env\";\n\n// Set a temporary variable\nsetenv(\"TEMP_VAR\", \"temporary\");\nprint(\"Before: \" + getenv(\"TEMP_VAR\"));  // \"temporary\"\n\n// Remove it\nunsetenv(\"TEMP_VAR\");\nprint(\"After: \" + getenv(\"TEMP_VAR\"));   // null\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet text = \"HiðŸš€!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // 'ðŸš€' (one codepoint)\nprint(text[3]);         // '!'\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does 3. no async i/o integration work in Hemlock?", "output": "File/network operations still block the thread:\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // Blocks the thread\n    f.close();\n    return content;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does date arithmetic methods work in Hemlock?", "output": "Add (or subtract) hours. Returns a new DateTime object.\n\n```hemlock\nlet dt = from_date(2025, 1, 15, 12, 0, 0);\n\nlet later = dt.add_hours(6);\nprint(later.to_string());  // \"2025-01-15 18:00:00\"\n\nlet earlier = dt.add_hours(-2);\nprint(earlier.to_string());  // \"2025-01-15 10:00:00\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Show an example of example: function pipeline in Hemlock.", "output": "```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    // Note: variadic functions not supported yet\n    // This is conceptual\n    return result;\n}\n\n// Workaround: manual composition\nfn process(value) {\n    return increment(double(trim(value)));\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does string literals work in Hemlock?", "output": "```hemlock\n// Basic strings\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// With escape sequences\nlet s3 = \"Line 1\\nLine 2\\ttabbed\";\nlet s4 = \"Quote: \\\"Hello\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Unicode characters\nlet s6 = \"ðŸš€ Emoji\";\nlet s7 = \"ä¸­æ–‡å­—ç¬¦\";\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does slicing & extraction work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3] (unchanged)\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does reading files work in Hemlock?", "output": "```hemlock\n// Read entire file\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// Read specific number of bytes\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // Read 100 bytes\nf2.close();\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does concurrency work in Hemlock?", "output": "WebSocket integrates with Hemlock's async system:\n\n```hemlock\nasync fn process_messages(ws) {\n    while (true) {\n        let msg = ws.recv(1000);\n        if (msg != null) {\n            // Process message...\n        }\n    }\n}\n\nlet ws = WebSocket(\"ws://example.com\");\ndefer ws.close();\n\nspawn(process_messages, ws);\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does explicit type conversion work in Hemlock?", "output": "```hemlock\nlet ch: rune = 'ðŸš€';\nlet s: string = ch;   // rune â†’ string (\"ðŸš€\")\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does pattern: constructor function work in Hemlock?", "output": "```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test while loops\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// Nested while\nlet j = 0;\nwhile (j < 2) {\n    let k = 0;\n    while (k < 2) {\n        print(j * 10 + k);\n        k = k + 1;\n    }\n    j = j + 1;\n}\n\nprint(\"done\");\n```", "output": "0\n1\n2\n3\n4\n0\n1\n10\n11\ndone", "category": "tests/compiler", "source": "tests/compiler/while_loop.hml"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { pad_left, pad_right, center } from \"@stdlib/strings\";\nimport { is_alpha, is_digit, is_alnum, is_whitespace } from \"@stdlib/strings\";\nimport { reverse, lines, words } from \"@stdlib/strings\";\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Show an example of example: dynamic string builder in Hemlock.", "output": "```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // Caller must free\n}\n\nlet msg = build_message(5);\n// ... use msg\nfree(msg);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does parallel map work in Hemlock?", "output": "```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // Spawn workers\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // Send data\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // Collect results\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // Wait for workers\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test: Environment value cleanup\n// Verifies that values are properly freed when environments go out of scope\n// and when variables are reassigned\n\n// Test 1: Basic scope cleanup\n{\n    let s = \"This string should be freed when scope exits\";\n    let arr = [1, 2, 3, 4, 5];\n    let obj = {name: \"test\", value: 42};\n    print(\"Scope 1: Variables created\");\n}\nprint(\"Scope 1 exited - values should be freed\");\n\n// Test 2: Nested scopes\n{\n    let outer = \"outer scope string\";\n    {\n        let inner = \"inner scope string\";\n        let nested_arr = [10, 20, 30];\n        print(\"Inner scope\");\n    }\n    print(\"Inner scope exited - inner values freed\");\n}\nprint(\"Outer scope exited - outer values freed\");\n\n// Test 3: Variable reassignment should free old values\n{\n    let x = \"original string\";\n    print(x);\n    x = \"reassigned string\";  // Old value should be freed\n    print(x);\n    x = \"third value\";  // Second value should be freed\n    print(x);\n}\nprint(\"Reassignment test completed\");\n\n// Test 4: Array reassignment\n{\n    let arr2 = [1, 2, 3];\n    print(\"Original array created\");\n    arr2 = [4, 5, 6, 7, 8];  // Old array should be freed\n    print(\"Array reassigned\");\n}\nprint(\"Array reassignment test completed\");\n\n// Test 5: Object reassignment\n{\n    let obj2 = {x: 10, y: 20};\n    print(\"Original object created\");\n    obj2 = {a: 100, b: 200, c: 300};  // Old object should be freed\n    print(\"Object reassigned\");\n}\nprint(\"Object reassignment test completed\");\n\n// Test 6: Mixed types with nested data\n{\n    let data = {\n        name: \"Test\",\n        values: [1, 2, 3],\n        nested: {x: 10, y: 20}\n    };\n    print(\"Complex nested structure created\");\n}\nprint(\"Nested structure freed\");\n\n// Test 7: String concatenation creates new strings\n{\n    let str1 = \"Hello\";\n    let str2 = \"World\";\n    let str3 = str1 + \" \" + str2;\n    print(str3);\n}\nprint(\"String concatenation test completed\");\n\n// Test 8: Buffer cleanup\n{\n    let buf = buffer(1024);\n    print(\"Buffer allocated\");\n}\nprint(\"Buffer freed\");\n\n// Test 9: Function with local variables\nfn test_function() {\n    let local1 = \"local string 1\";\n    let local2 = [100, 200, 300];\n    let local3 = {msg: \"local object\"};\n    print(\"Function locals created\");\n    return \"function result\";\n}\n\nlet result = test_function();\nprint(result);\nprint(\"Function exited - local variables freed\");\n\n// Test 10: Loop with reassignment (variables persist across iterations in Hemlock)\nlet loop_counter = 0;\nlet loop_var = \"initial\";\nlet loop_arr = [0];\nwhile (loop_counter < 3) {\n    loop_var = \"iteration\";  // Reassigns, old value freed\n    loop_arr = [loop_counter, loop_counter+1, loop_counter+2];  // Old array freed\n    print(loop_var);\n    loop_counter = loop_counter + 1;\n}\nprint(\"Loop completed - loop variables will be freed when scope exits\");\n\n// Test 11: Parent scope variable reassignment\n{\n    let outer_var = \"outer value\";\n    {\n        // Reassign outer scope variable - old value should be freed\n        outer_var = \"modified from inner scope\";\n        print(outer_var);\n    }\n    print(outer_var);\n}\nprint(\"Parent scope reassignment test completed\");\n\n// Test 12: Closure environment cleanup (closures keep reference)\nfn make_closure() {\n    let captured = \"captured value\";\n    return fn() {\n        return captured;\n    };\n}\n\nlet closure = make_closure();\nprint(closure());  // captured value still accessible\nprint(\"Closure test completed\");\n\nprint(\"All environment cleanup tests passed!\");\n```", "output": "Scope 1: Variables created\nScope 1 exited - values should be freed\nInner scope\nInner scope exited - inner values freed\nOuter scope exited - outer values freed\noriginal string\nreassigned string\nthird value\nReassignment test completed\nOriginal array created\nArray reassigned\nArray reassignment test completed\nOriginal object created\nObject reassigned\nObject reassignment test completed\nComplex nested structure created\nNested structure freed\nHello World\nString concatenation test completed\nBuffer allocated\nBuffer freed\nFunction locals created\nfunction result\nFunction exited - local variables freed\niteration\niteration\niteration\nLoop completed - loop variables will be freed when scope exits\nmodified from inner scope\nmodified from inner scope\nParent scope reassignment test completed\ncaptured value\nClosure test completed\nAll environment cleanup tests passed!", "category": "tests/memory", "source": "tests/memory/test_env_value_cleanup.hml"}
{"instruction": "How does cwd() work in Hemlock?", "output": "**Throws:** Exception if current directory cannot be determined\n\n```hemlock\nimport { cwd } from \"@stdlib/fs\";\n\ntry {\n    let current = cwd();\n    print(\"Current directory: \" + current);\n} catch (e) {\n    print(\"Error getting current directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate with rune (now \"Hello\")\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How do you use stack usage in Hemlock?", "output": "```hemlock\nlet stack = [];\n\n// Push elements\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop elements\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does exec work in Hemlock?", "output": "```hemlock\nexec(command: string): object\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does reading work in Hemlock?", "output": "**Example - Reading entire binary file:**\n\n```hemlock\nlet f = open(\"data.bin\", \"r\");\nlet size = 10240;  // Expected size\nlet data = f.read_bytes(size);\nf.close();\n\n// Process binary data\nlet i = 0;\nwhile (i < data.length) {\n    let byte = data[i];\n    // ... process byte\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does workarounds work in Hemlock?", "output": "**For concurrent requests:**\n\n```hemlock\nimport { get } from \"@stdlib/http\";\n\nasync fn fetch_url(url: string): object {\n    return get(url, null);\n}\n\n// Fetch multiple URLs in parallel\nlet task1 = spawn(fetch_url, \"https://api.example.com/data1\");\nlet task2 = spawn(fetch_url, \"https://api.example.com/data2\");\nlet task3 = spawn(fetch_url, \"https://api.example.com/data3\");\n\nlet result1 = await task1;\nlet result2 = await task2;\nlet result3 = await task3;\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does path access work in Hemlock?", "output": "Delete value by path (sets to null).\n\n```hemlock\nimport { delete } from \"@stdlib/json\";\n\nlet doc = { user: { name: \"Alice\", email: \"alice@example.com\" } };\n\ndelete(doc, \"user.email\");\nprint(doc.user.email);  // null\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "What is the purpose of this Hemlock code?\n\n```hemlock\n// Example: Using @stdlib/http module\n// Demonstrates production-ready HTTP/HTTPS client using curl\n\nimport { get, post_json, fetch, get_json, is_success } from \"@stdlib/http\";\n\nprint(\"=== Hemlock HTTP Client Example ===\\n\");\n\n// Example 1: Simple HTTPS GET request\nprint(\"Example 1: HTTPS GET request\");\nprint(\"-----------------------------\");\ntry {\n    let response = get(\"https://httpbin.org/get\", null);\n\n    if (is_success(response.status_code)) {\n        print(\"Status: \" + typeof(response.status_code));\n        print(\"Body (first 100 chars): \" + response.body.substr(0, 100));\n    } else {\n        print(\"Request failed with status: \" + typeof(response.status_code));\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    print(\"(Requires curl to be installed and network access)\");\n}\n\nprint(\"\\n\");\n\n// Example 2: Fetch JSON API\nprint(\"Example 2: Fetch and Parse JSON\");\nprint(\"--------------------------------\");\ntry {\n    let user = get_json(\"https://jsonplaceholder.typicode.com/users/1\");\n    print(\"Name: \" + user.name);\n    print(\"Email: \" + user.email);\n    print(\"Company: \" + user.company.name);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 3: POST JSON data\nprint(\"Example 3: POST JSON\");\nprint(\"--------------------\");\ntry {\n    let data = {\n        title: \"Buy groceries\",\n        completed: false,\n        userId: 1\n    };\n\n    let response = post_json(\"https://jsonplaceholder.typicode.com/todos\", data);\n    print(\"Response (first 100 chars): \" + response.body.substr(0, 100));\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 4: Custom headers with authentication\nprint(\"Example 4: Custom Headers\");\nprint(\"-------------------------\");\ntry {\n    let headers = [\n        \"User-Agent: Hemlock-HTTP/1.0\",\n        \"Accept: application/json\",\n        \"X-Custom-Header: test-value\"\n    ];\n\n    let response = get(\"https://httpbin.org/headers\", headers);\n    print(\"Response received (check headers were sent)\");\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 5: Error handling\nprint(\"Example 5: Error Handling\");\nprint(\"-------------------------\");\ntry {\n    let response = get(\"https://httpbin.org/status/404\", null);\n    if (is_success(response.status_code)) {\n        print(\"Success!\");\n    } else {\n        print(\"Got error status: \" + typeof(response.status_code));\n    }\n} catch (e) {\n    print(\"Request failed: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 6: Simple fetch\nprint(\"Example 6: Simple Fetch\");\nprint(\"-----------------------\");\ntry {\n    let html = fetch(\"https://example.com\");\n    print(\"Fetched \" + typeof(html.length) + \" bytes from example.com\");\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n=== Examples Complete ===\");\n\nprint(\"\\nNOTE: This module uses curl for HTTP/HTTPS support.\");\nprint(\"Ensure curl is installed: which curl\");\n```", "output": "This program create an HTTP client. Example: Using @stdlib/http module Demonstrates production-ready HTTP/HTTPS client using curl", "category": "examples/explanation", "source": "examples/http_example.hml"}
{"instruction": "How does raising signals manually work in Hemlock?", "output": "Send signals to your own process:\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// Trigger handler manually\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does core functions work in Hemlock?", "output": "Serialize value to compact JSON string. Wrapper around built-in `.serialize()`.\n\n```hemlock\nimport { stringify } from \"@stdlib/json\";\n\nlet json = stringify({ name: \"Alice\", age: 30 });\nprint(json);  // {\"name\":\"Alice\",\"age\":30}\n\nlet arr_json = stringify([1, 2, 3]);\nprint(arr_json);  // [1,2,3]\n\n// Circular reference detection\nlet obj = {};\nobj.self = obj;\ntry {\n    stringify(obj);\n} catch (e) {\n    print(e);  // \"serialize() detected circular reference\"\n}\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "Show an example of example in Hemlock.", "output": "```hemlock\nimport { Set } from \"@stdlib/collections\";\n\nlet s = Set();\n\n// Add values\ns.add(10);\ns.add(20);\ns.add(10);  // Duplicate, ignored\n\nprint(s.size);  // 2\n\n// Check membership\nif (s.has(10)) {\n    print(\"10 is in the set\");\n}\n\n// Set operations\nlet s1 = Set();\ns1.add(1);\ns1.add(2);\ns1.add(3);\n\nlet s2 = Set();\ns2.add(2);\ns2.add(3);\ns2.add(4);\n\nlet union = s1.union(s2);         // {1, 2, 3, 4}\nlet inter = s1.intersection(s2);  // {2, 3}\nlet diff = s1.difference(s2);     // {1}\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does http methods work in Hemlock?", "output": "```hemlock\n{\n    status_code: i32,    // HTTP status code (200, 404, etc.)\n    headers: string,     // Response headers (currently empty)\n    body: string,        // Response body\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does mixed types work in Hemlock?", "output": "Arrays can contain different types:\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3] (nested array)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How do you use using pipes in Hemlock?", "output": "```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does 1. explicit over implicit work in Hemlock?", "output": "```hemlock\nlet x = 5  // Missing semicolon - should error\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How do you use FFI to call C functions in Hemlock?", "output": "Use `ffi_open`, `ffi_bind`, and `ffi_close`:\n\n```hemlock\n// Open shared library\nlet lib = ffi_open(\"libc.so.6\");\n\n// Bind function: name, arg types, return type\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\n\n// Call the function\nputs(\"Hello from C!\");\n\n// Clean up\nffi_close(lib);\n```\n\nFFI types: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.", "category": "concepts/ffi", "source": "CLAUDE.md"}
{"instruction": "How does method chaining work in Hemlock?", "output": "```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does memory leaks work in Hemlock?", "output": "**Easy to create, hard to debug:**\n\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // Forgot to free!\n    return;  // Memory leaked\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Show an example of example: basic error handling in Hemlock.", "output": "```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Error: \" + e);  // Prints: Error: division by zero\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Provide a Hemlock example that demonstrates handle command-line arguments.", "output": "```hemlock\n// Example: Command-line argument handling in Hemlock\n//\n// Usage: ./hemlock examples/cli_args.hml [arguments...]\n//\n// This demonstrates accessing command-line arguments via the 'args' array.\n// args[0] is always the script name, args[1+] are the actual arguments.\n\nprint(\"Hemlock Command-Line Arguments Demo\");\nprint(\"====================================\");\nprint(\"\");\n\n// Convert length to string for concatenation\nlet len_str = \"\";\nif (args.length == 0) { len_str = \"0\"; }\nif (args.length == 1) { len_str = \"1\"; }\nif (args.length == 2) { len_str = \"2\"; }\nif (args.length == 3) { len_str = \"3\"; }\nif (args.length == 4) { len_str = \"4\"; }\nif (args.length == 5) { len_str = \"5\"; }\nif (args.length >= 6) { len_str = \"6+\"; }\nprint(\"Total arguments: \" + len_str);\nprint(\"Script name: \" + args[0]);\nprint(\"\");\n\nif (args.length == 1) {\n    print(\"No command-line arguments provided.\");\n    print(\"Try running: ./hemlock examples/cli_args.hml arg1 arg2 arg3\");\n} else {\n    print(\"Arguments provided:\");\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        i = i + 1;\n    }\n}\n```", "category": "examples", "source": "examples/cli_args.hml"}
{"instruction": "How does creating a thread pool work in Hemlock?", "output": "```hemlock\nimport { ThreadPool } from \"@stdlib/async\";\n\n// Create pool with 4 workers\nlet pool = ThreadPool(4);\n\n// Use the pool...\n\n// Always shutdown when done\npool.shutdown();\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does pitfall: missing break in switch work in Hemlock?", "output": "```hemlock\n// Unintentional fall-through\nswitch (x) {\n    case 1:\n        print(\"one\");\n        // Missing break - falls through!\n    case 2:\n        print(\"two\");  // Executes for both 1 and 2\n        break;\n}\n\n// Fix: Add break\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // Now correct\n    case 2:\n        print(\"two\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does read_files_parallel work in Hemlock?", "output": "```hemlock\nread_files_parallel(paths: array<string>): array<string>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does `buffer` - safe wrapper (recommended) work in Hemlock?", "output": "Buffers provide **bounds-checked access** while still requiring manual deallocation:\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bounds checked\nprint(b.length);        // 64\nfree(b);                // still manual\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does reading entire file work in Hemlock?", "output": "```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as env from \"@stdlib/env\";\nlet home = env.getenv(\"HOME\");\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does ecdsa_generate_key(): ecdsakeypair work in Hemlock?", "output": "Generate a P-256 ECDSA key pair for signing and verification.\n\n```hemlock\nimport { ecdsa_generate_key, ecdsa_free_keys } from \"@stdlib/crypto\";\n\nlet keypair = ecdsa_generate_key();\ndefer ecdsa_free_keys(keypair);\n\nprint(typeof(keypair));  // \"ECDSAKeyPair\"\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does tau work in Hemlock?", "output": "The mathematical constant Ï„ (tau) = 2Ï€ â‰ˆ 6.28318530717958647692\n\n```hemlock\nimport { TAU } from \"@stdlib/math\";\nlet full_circle = TAU;  // One complete rotation in radians\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does async_copy_file work in Hemlock?", "output": "```hemlock\nasync_copy_file(src: string, dst: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { async_read_file, async_write_file, read_files_parallel } from \"@stdlib/async_fs\";\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does when exec() throws exceptions work in Hemlock?", "output": "The `exec()` function throws an exception if the command cannot be executed:\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show an example of example 2: log analyzer in Hemlock.", "output": "```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyzing log: \" + logfile);\n\n    // Count total lines\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Total lines: \" + r1.output.trim());\n\n    // Count errors\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errors: \" + errors);\n    } else {\n        print(\"Errors: 0\");\n    }\n\n    // Count warnings\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnings: \" + warnings);\n    } else {\n        print(\"Warnings: 0\");\n    }\n\n    // Recent errors\n    print(\"\\nRecent errors:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test buffer operations\n\n// Create buffer\nlet buf = buffer(10);\nprint(buf.length);\n\n// Set and get values\nbuf[0] = 65;\nbuf[1] = 66;\nbuf[2] = 67;\nprint(buf[0]);\nprint(buf[1]);\nprint(buf[2]);\n\n// Modify\nbuf[0] = 100;\nprint(buf[0]);\n\n// alloc and free\nlet raw = alloc(10);\nfree(raw);\nfree(buf);\n\nprint(\"done\");\n```", "output": "10\n65\n66\n67\n100\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/buffers.hml"}
{"instruction": "How does macos: library not found errors work in Hemlock?", "output": "brew install libffi openssl@3 libwebsockets\n\n```hemlock\n2. Verify Homebrew paths:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does void type work in Hemlock?", "output": "```hemlock\nextern fn exit(code: i32): void;\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does 3. validate before executing work in Hemlock?", "output": "```hemlock\nfn is_valid_command(cmd: string): bool {\n    // Validate command is safe\n    return true;  // Your validation logic\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does array methods work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30];\n\n// Add/remove at end\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40, arr is now [10, 20, 30]\n\n// Add/remove at beginning\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5, arr is now [10, 20, 30]\n\n// Insert/remove at index\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// Search\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// Slice\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// Join to string\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does is_whitespace(str) work in Hemlock?", "output": "- Carriage return (U+000D)\n\n```hemlock\nimport { is_whitespace } from \"@stdlib/strings\";\n\nprint(is_whitespace(\" \"));       // true\nprint(is_whitespace(\"   \"));     // true\nprint(is_whitespace(\"\\t\"));      // true\nprint(is_whitespace(\"\\n\"));      // true\nprint(is_whitespace(\"\\r\"));      // true\nprint(is_whitespace(\" \\t\\n\"));   // true\n\nprint(is_whitespace(\"hello\"));   // false\nprint(is_whitespace(\" a \"));     // false\nprint(is_whitespace(\"\"));        // false (empty)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does realloc work in Hemlock?", "output": "```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nfn square(n) {\n    return n * n;\n}\n\nlet future = pool.submit1(square, 10);\nlet result = future.get();  // 100\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does url_encode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { url_encode } from \"@stdlib/encoding\";\n\n// Safe characters pass through unchanged\nlet safe = url_encode(\"ABCxyz123-_.~\");\nprint(safe);  // \"ABCxyz123-_.~\"\n\n// Space becomes +\nlet space = url_encode(\"Hello World\");\nprint(space);  // \"Hello+World\"\n\n// Special characters become %XX\nlet special = url_encode(\"hello@example.com\");\nprint(special);  // \"hello%40example.com\"\n\n// Query string encoding\nlet query = url_encode(\"key=value&foo=bar\");\nprint(query);  // \"key%3Dvalue%26foo%3Dbar\"\n\n// Unicode (UTF-8 bytes are percent-encoded)\nlet unicode = url_encode(\"Hello ä¸–ç•Œ\");\nprint(unicode);  // \"Hello+%E4%B8%96%E7%95%8C\"\n\n// Emoji\nlet emoji = url_encode(\"Hello ðŸš€\");\nprint(emoji);  // \"Hello+%F0%9F%9A%80\"\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does http methods work in Hemlock?", "output": "Perform an HTTP PUT request.\n\n```hemlock\nlet body = '{\"name\":\"Bob\"}';\nlet response = put(\"https://api.example.com/users/1\", body, null);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does basic if/else work in Hemlock?", "output": "```hemlock\nif (x > 10) {\n    print(\"large\");\n} else {\n    print(\"small\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "What is the purpose of this Hemlock code?\n\n```hemlock\n// HTTP Client Example\n// Demonstrates @stdlib/http (uses libwebsockets)\n\nimport * as http from \"@stdlib/http\";\n\nprint(\"=== Hemlock HTTP Client Examples ===\");\nprint(\"\");\n\n// Example 1: Simple GET request\nprint(\"1. Simple GET request to example.com\");\nprint(\"----------------------------------------\");\n\ntry {\n    let response = http.get(\"http://example.com\", []);\n\n    print(\"Status: \" + typeof(response.status_code));\n    print(\"Success: \" + typeof(http.is_success(response.status_code)));\n    print(\"Body length: \" + typeof(response.body.length) + \" bytes\");\n    print(\"\");\n\n    if (http.is_success(response.status_code)) {\n        print(\"âœ“ GET request successful!\");\n    } else {\n        print(\"âœ— GET request failed\");\n    }\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\n\n// Example 2: Fetch (simpler API)\nprint(\"2. Fetch URL directly\");\nprint(\"----------------------------------------\");\n\ntry {\n    let html = http.fetch(\"http://example.com\");\n    print(\"Fetched \" + typeof(html.length) + \" bytes\");\n    print(\"First 100 chars:\");\n    print(html.substr(0, 100) + \"...\");\n    print(\"\");\n    print(\"âœ“ Fetch successful!\");\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\n\n// Example 3: JSON API (httpbin.org)\nprint(\"3. POST JSON to API\");\nprint(\"----------------------------------------\");\n\ntry {\n    let user_data = {\n        name: \"Hemlock User\",\n        age: 42,\n        lang: \"hemlock\"\n    };\n\n    print(\"Sending JSON:\");\n    print(user_data.serialize());\n    print(\"\");\n\n    let post_response = http.post_json(\"http://httpbin.org/post\", user_data);\n\n    if (http.is_success(post_response.status_code)) {\n        print(\"âœ“ POST successful!\");\n        print(\"Response body:\");\n        print(post_response.body.substr(0, 200) + \"...\");\n    } else {\n        print(\"âœ— POST failed: \" + typeof(post_response.status_code));\n    }\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\nprint(\"=== All Examples Complete ===\");\n```", "output": "This program make HTTP requests. HTTP Client Example Demonstrates @stdlib/http (uses libwebsockets)", "category": "examples/explanation", "source": "examples/http_client.hml"}
{"instruction": "How does writing to read-only file work in Hemlock?", "output": "```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does 5. separate concerns with multiple loggers work in Hemlock?", "output": "```hemlock\nlet app_logger = Logger({ output: \"app.log\" });\nlet access_logger = Logger({ output: \"access.log\" });\nlet error_logger = Logger({ output: \"error.log\", level: ERROR });\n\ndefer app_logger.close();\ndefer access_logger.close();\ndefer error_logger.close();\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does good use cases work in Hemlock?", "output": "**3. Checking system state:**\n\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Disk usage:\\n\" + r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does describe(name, fn) work in Hemlock?", "output": "Create a test suite (group of related tests).\n\n```hemlock\ndescribe(\"Array methods\", fn() {\n    test(\"push adds element\", fn() {\n        let arr = [1, 2, 3];\n        arr.push(4);\n        expect(arr.length).to_equal(4);\n    });\n\n    test(\"pop removes element\", fn() {\n        let arr = [1, 2, 3];\n        let last = arr.pop();\n        expect(last).to_equal(3);\n        expect(arr.length).to_equal(2);\n    });\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "What floating-point types does Hemlock support?", "output": "Hemlock supports two floating-point types:\n\n- `f32` - 32-bit single precision float\n- `f64` - 64-bit double precision float\n\nType alias: `number` (f64)\n\nLiterals default to f64: `3.14` â†’ f64", "category": "concepts/types", "source": "CLAUDE.md"}
{"instruction": "How does conditional read/write work in Hemlock?", "output": "```hemlock\nfn update_file(path: string, condition, new_content: string) {\n    let f = open(path, \"r+\");\n    try {\n        let content = f.read();\n\n        if (condition(content)) {\n            f.seek(0);  // Reset to beginning\n            f.write(new_content);\n        }\n    } finally {\n        f.close();\n    }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does variable annotations work in Hemlock?", "output": "```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does file permissions work in Hemlock?", "output": "**âš ï¸ WARNING:** Be careful with file permissions:\n\n```hemlock\nimport { make_dir } from \"@stdlib/fs\";\n\n// Create directory with restrictive permissions (owner only)\nlet mode: u32 = 448;  // 0700 in octal\nmake_dir(\"private_data\", mode);\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does reading work in Hemlock?", "output": "**Example - Reading in chunks:**\n\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // 4KB chunks\n    if (chunk == \"\") { break; }  // EOF reached\n    process(chunk);\n}\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does pattern: error wrapping work in Hemlock?", "output": "Wrap lower-level errors with context:\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Failed to load config from \" + path + \": \" + e;\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does 2. trim output when needed work in Hemlock?", "output": "```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // Remove trailing newline\nprint(clean);  // \"test\" (no newline)\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does .path work in Hemlock?", "output": "```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does 3. include context with structured data work in Hemlock?", "output": "```hemlock\n// Good: Provides context\nlogger.error(\"Database query failed\", {\n    query: \"SELECT * FROM users\",\n    duration_ms: 5000,\n    error: \"Timeout\"\n});\n\n// Less useful: No context\nlogger.error(\"Query failed\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does platform-specific commands work in Hemlock?", "output": "```hemlock\nimport { platform } from \"@stdlib/os\";\nimport { exec } from \"@stdlib/process\";\n\nfn open_url(url: string): null {\n    let p = platform();\n    let cmd = \"\";\n\n    if (p == \"linux\") {\n        cmd = \"xdg-open \" + url;\n    } else if (p == \"macos\") {\n        cmd = \"open \" + url;\n    } else if (p == \"windows\") {\n        cmd = \"start \" + url;\n    } else {\n        print(\"Cannot open URL on unknown platform\");\n        return null;\n    }\n\n    let result = exec(cmd);\n    if (result.exit_code != 0) {\n        print(\"Failed to open URL: \" + result.output);\n    }\n\n    return null;\n}\n\nfn get_clipboard(): string {\n    let p = platform();\n\n    if (p == \"linux\") {\n        return exec(\"xclip -selection clipboard -o\").output;\n    } else if (p == \"macos\") {\n        return exec(\"pbpaste\").output;\n    }\n\n    return \"\";\n}\n\nfn set_clipboard(text: string): null {\n    let p = platform();\n\n    if (p == \"linux\") {\n        exec(\"echo -n '\" + text + \"' | xclip -selection clipboard\");\n    } else if (p == \"macos\") {\n        exec(\"echo -n '\" + text + \"' | pbcopy\");\n    }\n\n    return null;\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does message types work in Hemlock?", "output": "Messages have the following structure:\n\n```hemlock\n{\n    type: string,      // \"text\", \"binary\", \"ping\", \"pong\", \"close\"\n    data: string,      // Text content (or null)\n    binary: buffer,    // Binary content (or null)\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does signal(signum, handler_fn) work in Hemlock?", "output": "**Resetting to default:**\n\n```hemlock\nsignal(SIGINT, null);  // Reset SIGINT to default behavior\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does http methods work in Hemlock?", "output": "Perform an HTTP POST request.\n\n```hemlock\nimport { post } from \"@stdlib/http\";\n\nlet body = '{\"name\":\"Alice\",\"age\":30}';\nlet headers = [\"Content-Type: application/json\"];\nlet response = post(\"https://httpbin.org/post\", body, headers);\nprint(response.body);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test random builtins\n\n// Test rand returns value in [0, 1)\nseed(42);\nlet r1 = rand();\nprint(r1 >= 0.0);\nprint(r1 < 1.0);\n\n// Test seeding produces reproducible results\nseed(12345);\nlet r2 = rand();\nseed(12345);\nlet r3 = rand();\nprint(r2 == r3);\n\n// Test multiple calls to rand produce different values\nseed(100);\nlet a = rand();\nlet b = rand();\nprint(a != b);\n\nprint(\"done\");\n```", "output": "true\ntrue\ntrue\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/random_builtins.hml"}
{"instruction": "How does logical not (`!`) work in Hemlock?", "output": "Negates boolean value:\n\n```hemlock\nif (!is_valid) {\n    print(\"invalid\");\n}\n\nif (!(x > 10)) {\n    // Same as: if (x <= 10)\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does array indexing work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // Modify element\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does array combination work in Hemlock?", "output": "```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3] (unchanged)\nprint(b);                    // [4, 5, 6] (unchanged)\n\n// Chain concatenations\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "```hemlock\nimport { get, is_success, is_client_error } from \"@stdlib/http\";\n\ntry {\n    let response = get(\"https://httpbin.org/status/404\", null);\n\n    if (is_success(response.status_code)) {\n        print(\"Success: \" + response.body);\n    } else if (is_client_error(response.status_code)) {\n        print(\"Client error: HTTP \" + typeof(response.status_code));\n    } else {\n        print(\"Error: HTTP \" + typeof(response.status_code));\n    }\n} catch (e) {\n    print(\"Request failed: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does hostname() work in Hemlock?", "output": "- Network configuration\n\n```hemlock\nimport { hostname } from \"@stdlib/os\";\n\nlet host = hostname();\nprint(\"Running on: \" + host);  // e.g., \"myserver.example.com\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "- Useful for reading complete messages\n\n```hemlock\nlet all_data = stream.read_all();\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does chained conversions work in Hemlock?", "output": "Type conversions can be chained:\n\n```hemlock\n// i32 â†’ rune â†’ string\nlet code: i32 = 128512;         // Grinning face codepoint\nlet r: rune = code;             // ðŸ˜€\nlet s: string = r;              // \"ðŸ˜€\"\n\n// All in one expression\nlet emoji: string = 128640;     // Implicit i32 â†’ rune â†’ string (ðŸš€)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does queue operations work in Hemlock?", "output": "**`unshift(value)`** - Add element to beginning:\n\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test socket.set_nonblocking method\nprint(\"=== Socket Non-blocking Test ===\");\n\n// Create a TCP socket\nlet sock = socket_create(2, 1, 0);  // AF_INET, SOCK_STREAM, 0\nprint(\"Socket created\");\nprint(sock.fd >= 0);\n\n// Set to non-blocking mode\nsock.set_nonblocking(true);\nprint(\"Set to non-blocking\");\n\n// Set back to blocking mode\nsock.set_nonblocking(false);\nprint(\"Set to blocking\");\n\n// Close socket\nsock.close();\nprint(\"Socket closed\");\n\nprint(\"=== Done ===\");\n```", "output": "=== Socket Non-blocking Test ===\nSocket created\ntrue\nSet to non-blocking\nSet to blocking\nSocket closed\n=== Done ===", "category": "parity/builtins", "source": "tests/parity/builtins/socket_nonblocking.hml"}
{"instruction": "How does worker pool sizing work in Hemlock?", "output": "```hemlock\nimport { cpu_count, total_memory, format_bytes } from \"@stdlib/os\";\n\nfn calculate_workers(memory_per_worker: i64): i32 {\n    let cores = cpu_count();\n    let total = total_memory();\n\n    // Workers based on CPU (leave 1 core for system)\n    let cpu_workers = cores - 1;\n    if (cpu_workers < 1) {\n        cpu_workers = 1;\n    }\n\n    // Workers based on memory (use 75% of total)\n    let available = (total * 75) / 100;\n    let mem_workers: i32 = available / memory_per_worker;\n    if (mem_workers < 1) {\n        mem_workers = 1;\n    }\n\n    // Use the lower of the two\n    let workers = cpu_workers;\n    if (mem_workers < workers) {\n        workers = mem_workers;\n    }\n\n    print(\"Calculated workers:\");\n    print(\"  CPU-based: \" + typeof(cpu_workers) + \" (from \" + typeof(cores) + \" cores)\");\n    print(\"  Memory-based: \" + typeof(mem_workers) + \" (\" + format_bytes(available) + \" available)\");\n    print(\"  Using: \" + typeof(workers) + \" workers\");\n\n    return workers;\n}\n\n// Assume each worker needs 512 MB\nlet worker_memory: i64 = 536870912;  // 512 MB\nlet num_workers = calculate_workers(worker_memory);\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport {\n    describe, test, expect,\n    before_each, after_each, run\n} from \"@stdlib/testing\";\nimport { exit } from \"@stdlib/env\";\n\n// Helper function to test\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\ndescribe(\"Factorial function\", fn() {\n    test(\"base case n=0\", fn() {\n        expect(factorial(0)).to_equal(1);\n    });\n\n    test(\"base case n=1\", fn() {\n        expect(factorial(1)).to_equal(1);\n    });\n\n    test(\"small values\", fn() {\n        expect(factorial(5)).to_equal(120);\n        expect(factorial(6)).to_equal(720);\n    });\n\n    test(\"returns positive numbers\", fn() {\n        expect(factorial(3)).to_be_greater_than(0);\n    });\n});\n\ndescribe(\"Array operations\", fn() {\n    let arr = null;\n\n    before_each(fn() {\n        arr = [1, 2, 3];\n    });\n\n    test(\"push adds element\", fn() {\n        arr.push(4);\n        expect(arr).to_equal([1, 2, 3, 4]);\n    });\n\n    test(\"pop removes element\", fn() {\n        let last = arr.pop();\n        expect(last).to_equal(3);\n        expect(arr.length).to_equal(2);\n    });\n\n    test(\"contains checks membership\", fn() {\n        expect(arr).to_contain(2);\n        expect(arr).not_to_contain(10);\n    });\n});\n\ndescribe(\"Error handling\", fn() {\n    test(\"division by zero throws\", fn() {\n        fn divide_by_zero() {\n            if (true) {\n                throw \"division by zero\";\n            }\n            return null;\n        }\n\n        expect(divide_by_zero).to_throw(\"division by zero\");\n    });\n\n    test(\"safe operations don't throw\", fn() {\n        expect(fn() {\n            let x = 10 + 5;\n            return x;\n        }).not_to_throw();\n    });\n});\n\n// Run all tests\nlet results = run();\n\n// Exit with appropriate code\nif (!results.success) {\n    exit(1);\n}\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "Errors in async operations are captured and re-thrown when `get()` is called:\n\n```hemlock\nimport { async_read_file } from \"@stdlib/async_fs\";\n\nlet future = async_read_file(\"nonexistent.txt\");\n\ntry {\n    let content = future.get();\n} catch (e) {\n    print(\"Failed to read file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does boolean flags work in Hemlock?", "output": "```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Show how to make HTTP requests in Hemlock.", "output": "```hemlock\n// HTTP Client Example\n// Demonstrates @stdlib/http (uses libwebsockets)\n\nimport * as http from \"@stdlib/http\";\n\nprint(\"=== Hemlock HTTP Client Examples ===\");\nprint(\"\");\n\n// Example 1: Simple GET request\nprint(\"1. Simple GET request to example.com\");\nprint(\"----------------------------------------\");\n\ntry {\n    let response = http.get(\"http://example.com\", []);\n\n    print(\"Status: \" + typeof(response.status_code));\n    print(\"Success: \" + typeof(http.is_success(response.status_code)));\n    print(\"Body length: \" + typeof(response.body.length) + \" bytes\");\n    print(\"\");\n\n    if (http.is_success(response.status_code)) {\n        print(\"âœ“ GET request successful!\");\n    } else {\n        print(\"âœ— GET request failed\");\n    }\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\n\n// Example 2: Fetch (simpler API)\nprint(\"2. Fetch URL directly\");\nprint(\"----------------------------------------\");\n\ntry {\n    let html = http.fetch(\"http://example.com\");\n    print(\"Fetched \" + typeof(html.length) + \" bytes\");\n    print(\"First 100 chars:\");\n    print(html.substr(0, 100) + \"...\");\n    print(\"\");\n    print(\"âœ“ Fetch successful!\");\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\n\n// Example 3: JSON API (httpbin.org)\nprint(\"3. POST JSON to API\");\nprint(\"----------------------------------------\");\n\ntry {\n    let user_data = {\n        name: \"Hemlock User\",\n        age: 42,\n        lang: \"hemlock\"\n    };\n\n    print(\"Sending JSON:\");\n    print(user_data.serialize());\n    print(\"\");\n\n    let post_response = http.post_json(\"http://httpbin.org/post\", user_data);\n\n    if (http.is_success(post_response.status_code)) {\n        print(\"âœ“ POST successful!\");\n        print(\"Response body:\");\n        print(post_response.body.substr(0, 200) + \"...\");\n    } else {\n        print(\"âœ— POST failed: \" + typeof(post_response.status_code));\n    }\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\nprint(\"=== All Examples Complete ===\");\n```", "category": "examples", "source": "examples/http_client.hml"}
{"instruction": "How does binary i/o work in Hemlock?", "output": "```hemlock\n// Write binary data\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// Read binary data\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does writing characters work in Hemlock?", "output": "Strings are mutable - you can modify individual characters:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // Now \"Hello\"\ns[4] = '!';            // Now \"Hell!\"\n\n// With Unicode\nlet msg = \"Go!\";\nmsg[0] = 'ðŸš€';         // Now \"ðŸš€o!\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does formatting methods work in Hemlock?", "output": "Format as ISO 8601 string in UTC: \"YYYY-MM-DDTHH:MM:SSZ\".\n\n```hemlock\nlet dt = from_date(2025, 3, 15, 14, 30, 45);\nprint(dt.to_iso_string());  // \"2025-03-15T14:30:45Z\" (UTC)\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Show an example of example: resource management in Hemlock.", "output": "```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"File copied successfully\");\n    } catch (e) {\n        print(\"Failed to copy file: \" + e);\n        throw e;  // Re-throw\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Show an example of complete rsa example in Hemlock.", "output": "```hemlock\nimport {\n    rsa_generate_key,\n    rsa_sign,\n    rsa_verify,\n    rsa_free_keys,\n    buffer_to_hex\n} from \"@stdlib/crypto\";\n\n// Generate key pair (slow operation)\nprint(\"Generating RSA-2048 key pair...\");\nlet keypair = rsa_generate_key();\ndefer rsa_free_keys(keypair);\n\n// Sign a message\nlet message = \"Authenticate this message\";\nlet signature = rsa_sign(message, keypair);\n\nprint(\"Message: \" + message);\nprint(\"Signature (\" + typeof(signature.length) + \" bytes): \" + buffer_to_hex(signature).substr(0, 64) + \"...\");\n\n// Verify signature\nlet valid = rsa_verify(message, signature, keypair);\nprint(\"Signature valid: \" + typeof(valid));  // true\n\n// Tamper with message\nlet tampered = \"Authenticate this messag3\";  // Changed last character\nlet still_valid = rsa_verify(tampered, signature, keypair);\nprint(\"Tampered message valid: \" + typeof(still_valid));  // false\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does unary bitwise operator work in Hemlock?", "output": "**Bitwise NOT (`~`)**\n\n```hemlock\nlet a = 12;\nprint(~a);      // -13 (two's complement)\n\nlet c: u8 = 15;   // 00001111 in binary\nprint(~c);        // 240 (11110000) in u8\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does `get_pid(): i32` work in Hemlock?", "output": "Get the current process ID.\n\n```hemlock\nlet pid = get_pid();\nprint(\"Current PID: \" + typeof(pid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does add diagnostic prints work in Hemlock?", "output": "```hemlock\nfn debug_handler(sig) {\n    print(\"Handler called for signal: \" + typeof(sig));\n    print(\"Stack: (not yet available)\");\n\n    // Your handler logic...\n}\n\nsignal(SIGINT, debug_handler);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "```hemlock\nprint(a | b);   // 14 (1110)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does clock() work in Hemlock?", "output": "- Distinguishing CPU time from wall-clock time\n\n```hemlock\nimport { clock } from \"@stdlib/time\";\n\nlet cpu_start = clock();\n// ... CPU-intensive work ...\nlet cpu_end = clock();\nlet cpu_time = cpu_end - cpu_start;\nprint(\"CPU time: \" + typeof(cpu_time) + \" seconds\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does testing concurrency work in Hemlock?", "output": "**Example: tests/async/basic.hml**\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn tasks\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Join and print results\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Expect: 45\nprint(r2);  // Expect: 190\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test: Assert with different numeric types\nlet x: i32 = 10;\nassert(x);\nprint(\"i32 assertion passed\");\n\nlet y: u8 = 0;\ntry {\n    assert(y);\n} catch (e) {\n    print(\"u8 zero caught: \" + e);\n}\n\nlet z: f64 = 3.14;\nassert(z);\nprint(\"f64 assertion passed\");\n\nlet w: f32 = 0.0;\ntry {\n    assert(w);\n} catch (e) {\n    print(\"f32 zero caught: \" + e);\n}\n\n// Test: Assert with objects (always truthy)\nlet obj = { x: 10, y: 20 };\nassert(obj);\nprint(\"object assertion passed\");\n\n// Test: Assert with arrays (always truthy)\nlet arr = [1, 2, 3];\nassert(arr);\nprint(\"array assertion passed\");\n\n// Test: Assert with functions (always truthy)\nlet func = fn() { return 42; };\nassert(func);\nprint(\"function assertion passed\");\n\n// Test: Assert in functions\nfn check_positive(n) {\n    assert(n > 0, \"number must be positive\");\n    return n * 2;\n}\n\nprint(check_positive(5));\n\ntry {\n    check_positive(-1);\n} catch (e) {\n    print(\"Caught in function: \" + e);\n}\n\n// Test: Assert with comparison expressions\nlet a = 10;\nlet b = 20;\nassert(b > a);\nprint(\"comparison assertion passed\");\n\ntry {\n    assert(a > b);\n} catch (e) {\n    print(\"comparison failed: \" + e);\n}\n```", "output": "i32 assertion passed\nu8 zero caught: assertion failed\nf64 assertion passed\nf32 zero caught: assertion failed\nobject assertion passed\narray assertion passed\nfunction assertion passed\n10\nCaught in function: number must be positive\ncomparison assertion passed\ncomparison failed: assertion failed", "category": "tests/exceptions", "source": "tests/exceptions/assert_types.hml"}
{"instruction": "How does sha256(input: string): string work in Hemlock?", "output": "SHA-256 hash (256-bit / 32-byte output). Industry-standard secure hash.\n\n```hemlock\nlet hash = sha256(\"hello\");\nprint(hash);\n// \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"\n\nassert(hash.length == 64, \"SHA-256 produces 64 hex characters\");\n\n// Empty string\nlet empty_hash = sha256(\"\");\nprint(empty_hash);\n// \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\n// UTF-8 support\nlet emoji_hash = sha256(\"Hello ðŸŒ\");\nprint(emoji_hash);  // Works with any UTF-8 string\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does nan work in Hemlock?", "output": "Not-a-Number (IEEE 754 floating point NaN)\n\n```hemlock\nimport { NAN } from \"@stdlib/math\";\nlet undefined_result = NAN;\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does .length work in Hemlock?", "output": "```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does pattern: always free work in Hemlock?", "output": "```hemlock\nlet pattern = compile(\"test\");\ndefer pattern.free();  // Guaranteed to free\n\n// Use pattern...\npattern.test(\"testing\");\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\n// Import specific functions\nimport { base64_encode, base64_decode } from \"@stdlib/encoding\";\nimport { hex_encode, hex_decode } from \"@stdlib/encoding\";\nimport { url_encode, url_decode } from \"@stdlib/encoding\";\n\n// Import all functions\nimport * as encoding from \"@stdlib/encoding\";\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test optional chaining with method calls (?.)\n// Note: obj?.method() syntax may not be fully supported\n\n// Object with methods\nlet obj = {\n    getValue: fn() { return 42; },\n    add: fn(a, b) { return a + b; },\n    name: \"test\"\n};\n\n// Regular method call (should work)\nprint(obj.getValue());\nprint(obj.add(1, 2));\n\n// Optional property access (should work)\nprint(obj?.name);\n\n// Test with null object - property access\nlet empty = null;\nlet result1 = empty?.name;\nprint(result1);\n\n// Non-null object with optional property access\nlet result2 = obj?.name;\nprint(result2);\n\n// Nested objects with optional chaining\nlet wrapper = { inner: { value: 100 } };\nprint(wrapper?.inner?.value);\n\n// Null in chain\nlet nullWrapper = { inner: null };\nlet result3 = nullWrapper?.inner?.value;\nprint(result3);\n\n// Optional chaining on array\nlet arr = [1, 2, 3];\nprint(arr?.[0]);\n\nlet nullArr = null;\nprint(nullArr?.[0]);\n\nprint(\"done\");\n```", "output": "42\n3\ntest\nnull\ntest\n100\nnull\n1\nnull\ndone", "category": "parity/language", "source": "tests/parity/language/optional_method_calls.hml"}
{"instruction": "How does interrupt & termination work in Hemlock?", "output": "```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // kill command\nsignal(SIGHUP, handle_hangup);      // Terminal closes\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "What is the Hemlock syntax for create a countdown loop?", "output": "```hemlock\nlet n = 10;\nwhile (n > 0) {\n    print(n);\n    n = n - 1;\n}\nprint(n);\n```", "category": "examples", "source": "examples/countdown.hml"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nlet pool = ThreadPool(4);\n\n// Submit tasks...\n\n// Cleanup when done\npool.shutdown();\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does integer types work in Hemlock?", "output": "```hemlock\nlet i: integer = 42;   // Alias for i32\nlet b: byte = 255;     // Alias for u8\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does pitfall: finally override work in Hemlock?", "output": "```hemlock\n// BAD: Finally overrides return\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // âš ï¸ Returns 0, not 42!\n    }\n}\n\n// GOOD: Don't return in finally\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // Just cleanup, no return\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does move_up(n), move_down(n), move_left(n), move_right(n) work in Hemlock?", "output": "**Returns:** `string` - ANSI escape sequence\n\n```hemlock\nimport { move_up, move_down, move_left, move_right } from \"@stdlib/terminal\";\n\n// Move cursor up 3 lines\nexec(\"printf '\" + move_up(3) + \"'\");\n\n// Move cursor right 5 columns\nexec(\"printf '\" + move_right(5) + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does logical operators work in Hemlock?", "output": "```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - AND\nprint(x || y);  // true  - OR\nprint(!x);      // false - NOT\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does simple command work in Hemlock?", "output": "```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test JSON serialization and deserialization\n\n// Serialize simple object\nlet obj = { name: \"Alice\", age: 30, active: true };\nlet json = obj.serialize();\nprint(json);\n\n// Deserialize JSON back to object\nlet parsed = json.deserialize();\nprint(parsed.name);\nprint(parsed.age);\nprint(parsed.active);\n\n// Nested object with array\nlet nested = { user: { name: \"Bob\" }, items: [10, 20] };\nlet nested_json = nested.serialize();\nprint(nested_json);\n\n// Deserialize nested\nlet parsed_nested = nested_json.deserialize();\nprint(parsed_nested.user.name);\nprint(parsed_nested.items[1]);\n\n// Deserialize JSON array string\nlet arr_json = \"[1, 2, 3]\";\nlet parsed_arr = arr_json.deserialize();\nprint(parsed_arr[0]);\nprint(parsed_arr[2]);\n\nprint(\"done\");\n```", "output": "{\"name\":\"Alice\",\"age\":30,\"active\":true}\nAlice\n30\ntrue\n{\"user\":{\"name\":\"Bob\"},\"items\":[10,20]}\nBob\n20\n1\n3\ndone", "category": "tests/compiler", "source": "tests/compiler/serialization.hml"}
{"instruction": "Show how to calculate Fibonacci numbers in Hemlock.", "output": "```hemlock\nlet a = 0;\nlet b = 1;\nlet i = 0;\n\nwhile (i < 10) {\n    print(a);\n    let temp = a + b;\n    a = b;\n    b = temp;\n    i = i + 1;\n}\n```", "category": "examples", "source": "examples/fibonacci.hml"}
{"instruction": "How does 4. handle errors gracefully work in Hemlock?", "output": "```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warning: Could not read \" + path + \": \" + e);\n        return \"\";\n    }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does integer types work in Hemlock?", "output": "```hemlock\nlet tiny: i8 = 127;              // 8-bit  (-128 to 127)\nlet small: i16 = 32767;          // 16-bit (-32768 to 32767)\nlet normal: i32 = 2147483647;    // 32-bit (default)\nlet large: i64 = 9223372036854775807;  // 64-bit\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does slicing & extraction work in Hemlock?", "output": "```hemlock\narray.slice(start: i32, end: i32): array\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does temporary file naming work in Hemlock?", "output": "```hemlock\nimport { get_pid } from \"@stdlib/env\";\n\nfn create_temp_filename(prefix: string, extension: string): string {\n    let pid = get_pid();\n    let timestamp = now();  // From time module\n    return \"/tmp/\" + prefix + \".\" + typeof(pid) + \".\" + typeof(timestamp) + extension;\n}\n\nlet temp_log = create_temp_filename(\"myapp\", \".log\");\nprint(\"Temporary log: \" + temp_log);\n// e.g., \"/tmp/myapp.12345.1700000000.log\"\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test typed arrays\n\n// Basic typed array\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nprint(nums[0]);\nprint(nums.length);\n\nnums.push(6);\nprint(nums[5]);\n\n// String typed array\nlet names: array<string> = [\"Alice\", \"Bob\"];\nprint(names[0]);\nnames.push(\"Charlie\");\nprint(names[2]);\n\n// Explicit untyped array\nlet mixed: array = [1, \"hello\", true];\nprint(mixed[0]);\nprint(mixed[1]);\nprint(mixed[2]);\n\nprint(\"done\");\n```", "output": "1\n5\n6\nAlice\nCharlie\n1\nhello\ntrue\ndone", "category": "parity/language", "source": "tests/parity/language/typed_arrays.hml"}
{"instruction": "How does print work in Hemlock?", "output": "```hemlock\nprint(...values): null\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does signal work in Hemlock?", "output": "```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does opening files work in Hemlock?", "output": "Use `open(path, mode?)` to open a file:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // Read mode (default)\nlet f2 = open(\"output.txt\", \"w\");  // Write mode (truncate)\nlet f3 = open(\"log.txt\", \"a\");     // Append mode\nlet f4 = open(\"data.bin\", \"r+\");   // Read/write mode\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does constants work in Hemlock?", "output": "Use `const` for immutable values:\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show an example of example: event emitter in Hemlock.", "output": "```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Received: \" + data);\n});\n\nemitter.emit(\"message\", \"Hello!\");\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How do you use queue usage in Hemlock?", "output": "```hemlock\nlet queue = [];\n\n// Enqueue\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dequeue\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does true parallelism work in Hemlock?", "output": "```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Sequential execution\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// Parallel execution\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// parallel_time should be ~50% of sequential_time on multi-core systems\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does pattern: allocate, use, free work in Hemlock?", "output": "The basic pattern for memory management:\n\n```hemlock\n// 1. Allocate\nlet data = alloc(1024);\n\n// 2. Use\nmemset(data, 0, 1024);\n// ... do work\n\n// 3. Free\nfree(data);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test: Throwing different types\ntry {\n    throw 42;\n} catch (e) {\n    print(e);\n}\n\ntry {\n    throw true;\n} catch (e) {\n    print(e);\n}\n\ntry {\n    throw null;\n} catch (e) {\n    print(e);\n}\n```", "output": "42\ntrue\nnull", "category": "tests/exceptions", "source": "tests/exceptions/throw_any_type.hml"}
{"instruction": "How does overview work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // mutate with rune (now \"Hello\")\nprint(s.length);        // 5 (codepoint count)\nlet c = s[0];           // returns rune (Unicode codepoint)\nlet msg = s + \" world\"; // concatenation\nlet emoji = \"ðŸš€\";\nprint(emoji.length);    // 1 (one codepoint)\nprint(emoji.byte_length); // 4 (four UTF-8 bytes)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does testing type system work in Hemlock?", "output": "**Example: tests/conversions/promotion.hml**\n\n```hemlock\n// Test type promotion in binary operations\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Expect: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Expect: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Expect: i32\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does numeric comparisons work in Hemlock?", "output": "Check if actual < value.\n\n```hemlock\ntest(\"less than\", fn() {\n    expect(5).to_be_less_than(10);\n    expect(-5).to_be_less_than(0);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does prefix & suffix work in Hemlock?", "output": "```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does planned features work in Hemlock?", "output": "**1. Struct Support**\n\n```hemlock\n// Future: Pass/return C structs\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nlet p = Point { x: 1.0, y: 2.0 };\nc_function_with_struct(p);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does minimum length work in Hemlock?", "output": "Always at least 1 (the script name):\n\n```hemlock\nprint(args.length);  // Minimum: 1\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does date arithmetic methods work in Hemlock?", "output": "Add (or subtract) minutes. Returns a new DateTime object.\n\n```hemlock\nlet dt = from_date(2025, 1, 15, 12, 0, 0);\n\nlet later = dt.add_minutes(45);\nprint(later.to_string());  // \"2025-01-15 12:45:00\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does log line filtering work in Hemlock?", "output": "```hemlock\nimport { compile, REG_ICASE } from \"@stdlib/regex\";\n\nfn filter_logs(lines: array<string>, pattern: string): array<string> {\n    let regex = compile(pattern, REG_ICASE);\n    let filtered: array<string> = [];\n\n    let i = 0;\n    while (i < lines.length) {\n        if (regex.test(lines[i])) {\n            filtered.push(lines[i]);\n        }\n        i = i + 1;\n    }\n\n    regex.free();\n    return filtered;\n}\n\nlet logs = [\n    \"INFO: Starting application\",\n    \"ERROR: Connection failed\",\n    \"INFO: Processing data\",\n    \"ERROR: Invalid input\",\n];\n\nlet errors = filter_logs(logs, \"error\");\n// Returns: [\"ERROR: Connection failed\", \"ERROR: Invalid input\"]\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does implicit type promotion work in Hemlock?", "output": "**Float always wins:**\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result is f64 (13.5)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does process control work in Hemlock?", "output": "```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does difference methods work in Hemlock?", "output": "Get the difference in hours.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 1, 10, 0, 0);\nlet dt2 = from_date(2025, 1, 1, 16, 0, 0);\n\nlet diff = dt2.diff_hours(dt1);\nprint(diff);  // 6\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does basic allocation pattern work in Hemlock?", "output": "```hemlock\n// Allocate\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// Use\nmemset(p, 0, 1024);\n\n// Free\nfree(p);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test break and continue in loops\n\n// Basic break in while\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\nprint(\"after while break\");\n\n// Basic continue in while\ni = 0;\nwhile (i < 5) {\n    i = i + 1;\n    if (i == 3) {\n        continue;\n    }\n    print(i);\n}\nprint(\"after while continue\");\n\n// Break in for loop\nfor (let j = 0; j < 10; j = j + 1) {\n    if (j == 4) {\n        break;\n    }\n    print(j);\n}\nprint(\"after for break\");\n\n// Continue in for loop\nfor (let k = 0; k < 5; k = k + 1) {\n    if (k == 2) {\n        continue;\n    }\n    print(k);\n}\nprint(\"after for continue\");\n\n// Break in for-in loop\nlet arr = [10, 20, 30, 40, 50];\nfor (let item in arr) {\n    if (item == 30) {\n        break;\n    }\n    print(item);\n}\nprint(\"after for-in break\");\n\n// Continue in for-in loop\nfor (let item in arr) {\n    if (item == 30) {\n        continue;\n    }\n    print(item);\n}\nprint(\"after for-in continue\");\n\n// Nested loop break (breaks inner only)\nfor (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (y == 1) {\n            break;\n        }\n        print(x * 10 + y);\n    }\n}\nprint(\"after nested break\");\n\n// Break in switch (distinct from loop break)\nlet val = 2;\nswitch (val) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\nprint(\"after switch\");\n\n// Break in loop with switch inside\nfor (let m = 0; m < 3; m = m + 1) {\n    switch (m) {\n        case 0:\n            print(\"case 0\");\n            break;\n        case 1:\n            print(\"case 1\");\n            break;\n        default:\n            print(\"default\");\n            break;\n    }\n    print(m);\n}\nprint(\"after loop with switch\");\n\nprint(\"done\");\n```", "output": "0\n1\n2\n3\n4\nafter while break\n1\n2\n4\n5\nafter while continue\n0\n1\n2\n3\nafter for break\n0\n1\n3\n4\nafter for continue\n10\n20\nafter for-in break\n10\n20\n40\n50\nafter for-in continue\n0\n10\n20\nafter nested break\ntwo\nafter switch\ncase 0\n0\ncase 1\n1\ndefault\n2\nafter loop with switch\ndone", "category": "parity/language", "source": "tests/parity/language/break_continue.hml"}
{"instruction": "How does implicit type promotion work in Hemlock?", "output": "**Larger size wins:**\n\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum is i64 (300)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does sizeof work in Hemlock?", "output": "```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// Calculate array allocation size\nlet count = 100;\nlet total = sizeof(i32) * count; // 400 bytes\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does replacement work in Hemlock?", "output": "```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Describe the behavior of this Hemlock program:\n\n```hemlock\n// Memory Management Demo\n\n// 1. sizeof() - Query type sizes\nprint(sizeof(u8));     // 1\nprint(sizeof(i32));    // 4\nprint(sizeof(f64));    // 8\nprint(sizeof(ptr));    // 8 (on 64-bit systems)\n\n// 2. talloc() - Typed allocation\nlet numbers = talloc(i32, 10);  // allocate 10 i32s (40 bytes)\nprint(numbers);\n\n// Initialize the array using memset\nlet elem_size = sizeof(i32);\nlet total_bytes = elem_size * 10;\nmemset(numbers, 0, total_bytes);\n\n// 3. buffer() - Safe wrapper with bounds checking\nlet buf = buffer(256);\nbuf[0] = 72;   // 'H'\nbuf[1] = 101;  // 'e'\nbuf[2] = 108;  // 'l'\nbuf[3] = 108;  // 'l'\nbuf[4] = 111;  // 'o'\nprint(buf[0]);\nprint(buf.length);\n\n// 4. realloc() - Resize allocations\nlet p = alloc(64);\nprint(p);\np = realloc(p, 128);\nprint(p);\np = realloc(p, 256);\nprint(p);\n\n// Clean up\nfree(numbers);\nfree(buf);\nfree(p);\n```", "output": "This program manage memory with alloc and free. Memory Management Demo", "category": "examples/explanation", "source": "examples/memory_demo.hml"}
{"instruction": "How does search & find work in Hemlock?", "output": "```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does is_file(path) work in Hemlock?", "output": "**Returns:** `bool` - True if path is a file, false otherwise\n\n```hemlock\nimport { is_file, is_dir } from \"@stdlib/fs\";\n\nif (is_file(\"data.txt\")) {\n    print(\"Path is a file\");\n}\n\nif (is_dir(\"/tmp\")) {\n    print(\"Path is a directory\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does creating a connection work in Hemlock?", "output": "```hemlock\nimport { WebSocket } from \"@stdlib/websocket\";\n\nlet ws = WebSocket(\"ws://echo.websocket.org\");\ndefer ws.close();\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Explain what this Hemlock code does:\n\n```hemlock\n// Hemlock Functions Demo\n// Showcases first-class functions, closures, and recursion\n\nprint(\"=== Hemlock Functions Demo ===\");\nprint(\"\");\n\n// 1. Basic named function\nprint(\"1. Basic function:\");\nfn add(a, b) {\n    return a + b;\n}\nprint(add(5, 3));\nprint(\"\");\n\n// 2. Function with type annotations\nprint(\"2. Typed function:\");\nfn multiply(x: i32, y: i32): i32 {\n    return x * y;\n}\nprint(multiply(7, 6));\nprint(\"\");\n\n// 3. Recursive function - factorial\nprint(\"3. Recursion (factorial):\");\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\nprint(factorial(6));\nprint(\"\");\n\n// 4. Closures - function that returns a function\nprint(\"4. Closures:\");\nfn makeMultiplier(factor) {\n    return fn(x) {\n        return x * factor;\n    };\n}\nlet double = makeMultiplier(2);\nlet triple = makeMultiplier(3);\nprint(double(5));\nprint(triple(5));\nprint(\"\");\n\n// 5. Anonymous functions as first-class values\nprint(\"5. Anonymous functions:\");\nlet square = fn(n) {\n    return n * n;\n};\nprint(square(8));\nprint(\"\");\n\n// 6. Higher-order functions - passing functions as arguments\nprint(\"6. Higher-order functions:\");\nfn apply(func, value) {\n    return func(value);\n}\nprint(apply(square, 9));\nprint(\"\");\n\n// 7. Lexical scoping\nprint(\"7. Lexical scoping:\");\nlet message = 100;\nfn getMessage() {\n    return message + 23;\n}\nprint(getMessage());\nprint(\"\");\n\n// 8. Counter closure (stateful closure)\nprint(\"8. Counter closure:\");\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\nlet counter = makeCounter();\nprint(counter());\nprint(counter());\nprint(counter());\nprint(\"\");\n\n// 9. Fibonacci with recursion\nprint(\"9. Fibonacci sequence:\");\nfn fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\nlet i = 0;\nwhile (i < 10) {\n    print(fib(i));\n    i = i + 1;\n}\n\nprint(\"\");\nprint(\"=== Demo Complete ===\");\n```", "output": "This program define and use functions. Hemlock Functions Demo Showcases first-class functions, closures, and recursion", "category": "examples/explanation", "source": "examples/functions_demo.hml"}
{"instruction": "How does type inference work in Hemlock?", "output": "Hemlock infers types based on values:\n\n```hemlock\nlet small = 42;              // i32 (fits in 32-bit)\nlet large = 5000000000;      // i64 (too big for i32)\nlet decimal = 3.14;          // f64 (default for floats)\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does while loops work in Hemlock?", "output": "```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does core principles work in Hemlock?", "output": "Write tests **before** implementing features:\n\n```hemlock\n1. Write a failing test\n2. Implement the feature\n3. Run the test (should pass)\n4. Refactor if needed\n5. Repeat\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does convenience functions work in Hemlock?", "output": "POST a Hemlock object as JSON (automatically serializes and sets Content-Type).\n\n```hemlock\nimport { post_json } from \"@stdlib/http\";\n\nlet user = { name: \"Alice\", age: 30, active: true };\nlet response = post_json(\"https://httpbin.org/post\", user);\nprint(response.body);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How do you perform arithmetic operations in Hemlock?", "output": "```hemlock\nlet tiny: u8 = 5;\nlet small: i16 = -10;\nlet big: i32 = 100;\nlet precise: f64 = 3.14;\n\nlet result1 = tiny + small;\nprint(result1);\n\nlet result2 = big + precise;\nprint(result2);\n\nlet result3 = tiny + small + big;\nprint(result3);\n\nlet result4 = tiny + small + big + precise;\nprint(result4);\n```", "category": "examples", "source": "examples/mixed_math.hml"}
{"instruction": "How does parallel_map work in Hemlock?", "output": "```hemlock\nimport { parallel_map } from \"@stdlib/async\";\n\nfn expensive_compute(n) {\n    // Simulate expensive operation\n    let result = 0;\n    let i = 0;\n    while (i < 1000000) {\n        result = result + n;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet data = [1, 2, 3, 4, 5, 6, 7, 8];\nlet results = parallel_map(data, expensive_compute, 4);\nprint(results);  // [1000000, 2000000, 3000000, ...]\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does string comparison work in Hemlock?", "output": "Strings are compared lexicographically:\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does named functions work in Hemlock?", "output": "```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // body\n    return value;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does core functions work in Hemlock?", "output": "Read and parse JSON from file.\n\n```hemlock\nimport { parse_file } from \"@stdlib/json\";\n\nlet config = parse_file(\"config.json\");\nprint(config.database.host);\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does try/catch work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does reading work in Hemlock?", "output": "**With size (read specific bytes):**\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // Read up to 1024 bytes\nlet next = f.read(1024);   // Read next 1024 bytes\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test: Return in try block - finally still executes\nfn test() {\n    try {\n        print(\"try\");\n        return 42;\n    } finally {\n        print(\"finally\");\n    }\n}\n\nlet result = test();\nprint(result);\n```", "output": "try\nfinally\n42", "category": "tests/exceptions", "source": "tests/exceptions/return_in_try.hml"}
{"instruction": "How do you use using try/catch in Hemlock?", "output": "```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"File error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does logical and (`&&`) work in Hemlock?", "output": "**Short-circuit evaluation:**\n\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() never called\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does concatenation work in Hemlock?", "output": "```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does control flow work in Hemlock?", "output": "```hemlock\n// If statements\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n\n// While loops\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// For loops\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does tan(x) work in Hemlock?", "output": "**Returns:** `f64` - Tangent of x\n\n```hemlock\nimport { tan, PI } from \"@stdlib/math\";\n\nlet result = tan(0.0);        // 0.0\nlet result2 = tan(PI / 4.0);  // 1.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { djb2, fnv1a, murmur3, sha256, sha512, md5, file_checksum } from \"@stdlib/hash\";\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test filter() - keep elements that pass predicate\n\n// Basic filter - even numbers\nlet nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet evens = nums.filter(fn(x) {\n    return x % 2 == 0;\n});\nprint(evens[0]);  // 2\nprint(evens[1]);  // 4\nprint(evens[2]);  // 6\nprint(evens[3]);  // 8\nprint(evens[4]);  // 10\nprint(evens.length);  // 5\n\n// Filter - odd numbers\nlet odds = nums.filter(fn(x) {\n    return x % 2 == 1;\n});\nprint(odds[0]);  // 1\nprint(odds[1]);  // 3\nprint(odds[2]);  // 5\nprint(odds[3]);  // 7\nprint(odds.length);  // 5\n\n// Filter with empty array\nlet empty = [];\nlet empty_result = empty.filter(fn(x) {\n    return x > 5;\n});\nprint(empty_result.length);  // 0\n\n// Filter that keeps nothing\nlet none = [1, 2, 3].filter(fn(x) {\n    return x > 10;\n});\nprint(none.length);  // 0\n\n// Filter that keeps everything\nlet all = [1, 2, 3].filter(fn(x) {\n    return x > 0;\n});\nprint(all[0]);  // 1\nprint(all[1]);  // 2\nprint(all[2]);  // 3\nprint(all.length);  // 3\n\n// Filter preserves original array\nlet original = [1, 2, 3, 4, 5];\nlet filtered = original.filter(fn(x) {\n    return x > 3;\n});\nprint(original.length);  // 5 (unchanged)\nprint(filtered.length);  // 2\n\n// Filter with strings\nlet words = [\"apple\", \"banana\", \"cherry\", \"date\"];\nlet long_words = words.filter(fn(w) {\n    return w.length > 5;\n});\nprint(long_words[0]);  // banana\nprint(long_words[1]);  // cherry\nprint(long_words.length);  // 2\n\n// Filter with closure\nlet threshold = 5;\nlet above_threshold = [1, 3, 5, 7, 9].filter(fn(x) {\n    return x > threshold;\n});\nprint(above_threshold[0]);  // 7\nprint(above_threshold[1]);  // 9\nprint(above_threshold.length);  // 2\n\n// Truthy filter (non-bool return values)\nlet mixed = [1, 0, 2, null, 3];\nlet truthy = mixed.filter(fn(x) {\n    return x;  // Returns the value itself (truthy check)\n});\nprint(truthy[0]);  // 1\nprint(truthy[1]);  // 2\nprint(truthy[2]);  // 3\nprint(truthy.length);  // 3\n```", "output": "2\n4\n6\n8\n10\n5\n1\n3\n5\n7\n5\n0\n0\n1\n2\n3\n3\n5\n2\nbanana\ncherry\n2\n7\n9\n2\n1\n2\n3\n3", "category": "tests/arrays", "source": "tests/arrays/filter.hml"}
{"instruction": "How does install dependencies via homebrew work in Hemlock?", "output": "brew install libffi openssl@3 libwebsockets\n\n```hemlock\n**Note for macOS users**: The Makefile automatically detects Homebrew installations and sets the correct include/library paths. Hemlock supports both Intel (x86_64) and Apple Silicon (arm64) architectures.\n\n**Ubuntu/Debian:**\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does concatenation work in Hemlock?", "output": "```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = 'â€¢' + \" Item\";        // \"â€¢ Item\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does is_ipv4 work in Hemlock?", "output": "**Note:** Current implementation is simplified. Returns true for basic validation.\n\n```hemlock\nimport { is_ipv4 } from \"@stdlib/net\";\n\nprint(is_ipv4(\"127.0.0.1\"));     // true\nprint(is_ipv4(\"example.com\"));   // false (simplified check)\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Explain what this Hemlock code does:\n\n```hemlock\n// WebSocket Echo Client Example\n// Demonstrates @stdlib/websocket_pure (pure Hemlock implementation)\n\nimport { WebSocket } from \"@stdlib/websocket_pure\";\n\nprint(\"=== Hemlock WebSocket Echo Client ===\");\nprint(\"\");\n\n// Note: This uses the pure Hemlock implementation\n// For production with SSL, use @stdlib/websocket (requires libwebsockets)\n\nprint(\"Connecting to ws://echo.websocket.org...\");\n\ntry {\n    let ws = WebSocket(\"ws://echo.websocket.org\");\n    defer ws.close();\n\n    print(\"âœ“ Connected!\");\n    print(\"\");\n\n    // Send a few test messages\n    print(\"Sending: 'Hello WebSocket!'\");\n    ws.send_text(\"Hello WebSocket!\");\n\n    print(\"Waiting for echo...\");\n    let msg1 = ws.recv();\n\n    if (msg1 != null && msg1.type == \"text\") {\n        print(\"âœ“ Received: \" + msg1.data);\n    } else {\n        print(\"âœ— No response or wrong type\");\n    }\n\n    print(\"\");\n\n    // Send another message\n    print(\"Sending: 'Hemlock WebSocket Test'\");\n    ws.send_text(\"Hemlock WebSocket Test\");\n\n    print(\"Waiting for echo...\");\n    let msg2 = ws.recv();\n\n    if (msg2 != null && msg2.type == \"text\") {\n        print(\"âœ“ Received: \" + msg2.data);\n    } else {\n        print(\"âœ— No response or wrong type\");\n    }\n\n    print(\"\");\n    print(\"Closing connection...\");\n\n} catch (e) {\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"- Message >125 bytes (not yet supported in pure implementation)\");\n    print(\"- Network connectivity\");\n    print(\"- echo.websocket.org is down\");\n    print(\"\");\n    print(\"Limitations of pure Hemlock implementation:\");\n    print(\"- No wss:// (SSL) support\");\n    print(\"- Messages limited to <126 bytes\");\n    print(\"- Simplified masking and validation\");\n    print(\"\");\n    print(\"For production use, install libwebsockets and use @stdlib/websocket\");\n}\n\nprint(\"Done!\");\n```", "output": "This program websocket echo client. WebSocket Echo Client Example Demonstrates @stdlib/websocket_pure (pure Hemlock implementation)", "category": "examples/explanation", "source": "examples/websocket_echo_client.hml"}
{"instruction": "How does do's work in Hemlock?", "output": "3. Run tests until they pass\n\n```hemlock\nâœ… **Test both success and failure**\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Provide a Hemlock example that demonstrates range error2.", "output": "```hemlock\nlet x: u8 = -1;\n```", "category": "examples", "source": "examples/range_error2.hml"}
{"instruction": "How does basic arithmetic work in Hemlock?", "output": "```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3 (integer division)\nprint(a == b);  // false\nprint(a > b);   // true\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does switch with return work in Hemlock?", "output": "In functions, `return` exits the switch immediately:\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        default:\n            return \"Unknown\";\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does assert_true(value) / assert_false(value) work in Hemlock?", "output": "Assert boolean values.\n\n```hemlock\ntest(\"boolean assertions\", fn() {\n    assert_true(10 > 5);\n    assert_false(10 < 5);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does variables work in Hemlock?", "output": "```hemlock\n// Variables are declared with 'let'\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// Type annotations are optional\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does pitfall: assignment in condition work in Hemlock?", "output": "```hemlock\n// This is NOT allowed (no assignment in conditions)\nif (x = 10) { }  // ERROR: Syntax error\n\n// Use comparison instead\nif (x == 10) { }  // OK\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does birthday calculator work in Hemlock?", "output": "```hemlock\nimport { from_date, now } from \"@stdlib/datetime\";\n\nlet birthday = from_date(1990, 5, 15, 0, 0, 0);\nlet today = now();\n\nlet days_old = today.diff_days(birthday);\nlet years_old = days_old / 365;\n\nprint(\"Born on: \" + birthday.format(\"%B %d, %Y\"));\nprint(\"Age: ~\" + typeof(years_old) + \" years\");\nprint(\"Days old: \" + typeof(days_old));\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does replacement work in Hemlock?", "output": "```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\" (only first)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does shared libraries work in Hemlock?", "output": "**macOS:** `.dylib` files\n\n```hemlock\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does reset styles work in Hemlock?", "output": "```hemlock\nimport { BOLD, RESET_BOLD, UNDERLINE, RESET_UNDERLINE, RESET } from \"@stdlib/terminal\";\n\nprint(BOLD + \"Bold \" + RESET_BOLD + \"not bold anymore\");\nprint(UNDERLINE + \"Underlined \" + RESET_UNDERLINE + \"not underlined\");\nprint(BOLD + UNDERLINE + \"Both \" + RESET + \"neither\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does append to file work in Hemlock?", "output": "```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Log entry 1\");\nappend_file(\"log.txt\", \"Log entry 2\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does copy_files_parallel work in Hemlock?", "output": "```hemlock\ncopy_files_parallel(copies: array<object>): null\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does handler function signature work in Hemlock?", "output": "Signal handlers receive one argument: the signal number (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signum contains the signal number (e.g., 2 for SIGINT)\n\n    if (signum == SIGINT) {\n        print(\"This is SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // Same handler for multiple signals\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test math builtins\n\n// Floor, ceil, round\nprint(floor(3.7));\nprint(ceil(3.2));\nprint(round(3.5));\n\n// Integer-returning versions\nprint(floori(3.7));\nprint(ceili(3.2));\nprint(roundi(3.5));\nprint(trunci(3.9));\nprint(typeof(floori(3.7)));\n\n// Negative numbers\nprint(floori(-3.7));\nprint(ceili(-3.2));\nprint(roundi(-3.5));\n\n// Square root\nprint(sqrt(16.0));\nprint(sqrt(25.0));\n\n// Power\nprint(pow(2.0, 3.0));\nprint(pow(3.0, 2.0));\n\n// Trigonometry\nlet sin_val = sin(0.0);\nlet cos_val = cos(0.0);\nprint(sin_val == 0);\nprint(cos_val == 1);\n\nprint(\"done\");\n```", "output": "3\n4\n4\n3\n4\n4\n3\ni64\n-4\n-3\n-4\n4\n5\n8\n9\ntrue\ntrue\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/math.hml"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test type mismatch when unshifting to typed array\n\nlet arr: array<bool> = [true, false];\narr.unshift(42);  // Should error: type mismatch\n```", "output": "Runtime error: Type mismatch in typed array - expected element of specific type", "category": "tests/typed_arrays", "source": "tests/typed_arrays/type_mismatch_unshift_error.hml"}
{"instruction": "How does signature work in Hemlock?", "output": "```hemlock\nexec(command: string): object\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "What array methods are available in Hemlock?", "output": "Hemlock arrays have 18 methods:\n\n**Mutating:** `push(val)`, `pop()`, `shift()`, `unshift(val)`, `insert(i, val)`, `remove(i)`, `clear()`, `reverse()`\n**Access:** `first()`, `last()`, `slice(start, end)`\n**Search:** `find(val)`, `contains(val)`\n**Transform:** `join(sep)`, `concat(arr)`, `map(fn)`, `filter(fn)`, `reduce(fn, init)`\n\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);              // [1, 2, 3, 4]\nlet doubled = arr.map(fn(x) { return x * 2; });  // [2, 4, 6, 8]\nlet sum = arr.reduce(fn(a, b) { return a + b; }, 0);  // 10\n```", "category": "concepts/arrays", "source": "CLAUDE.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as term from \"@stdlib/terminal\";\nprint(term.color(\"Hello\", term.BLUE));\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does phase 3: interpretation (tree-walking) work in Hemlock?", "output": "**Implementation:** `src/interpreter/runtime.c`\n\n```hemlock\nAST: LetStmt { ... }\n   â†“\nExecution: Evaluates AST nodes recursively\n   â†“\nResult: Variable x created with value 42\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test: Large object/array serialization (buffer overflow regression test)\n// This tests the fix for Issue #15 - buffer overflow in serialize()\n\n// Test 1: Object with a very long string value (exceeds initial 256 byte buffer)\nlet long_string = \"a\".repeat(500);\nlet obj = {\n    field1: long_string,\n    field2: \"short\",\n    field3: long_string\n};\n\nlet json = obj.serialize();\nprint(\"Test 1: Large object serialization\");\nprint(json.contains(\"field1\"));  // Should contain field1\nprint(json.contains(\"field2\"));  // Should contain field2\nprint(json.contains(\"field3\"));  // Should contain field3\n\n// Test 2: Deserialize and verify\nlet restored = json.deserialize();\nprint(restored.field1.length);  // Should be 500\nprint(restored.field2);         // Should be \"short\"\nprint(restored.field3.length);  // Should be 500\n\n// Test 3: Object containing array with large string elements\nlet obj_with_arr = {\n    arr: [long_string, \"middle\", long_string, long_string]\n};\nlet arr_json = obj_with_arr.serialize();\nprint(\"Test 2: Large array serialization\");\n\n// Deserialize and verify\nlet arr_restored = arr_json.deserialize();\nprint(arr_restored.arr.length);     // Should be 4\nprint(arr_restored.arr[0].length);  // Should be 500\nprint(arr_restored.arr[1]);         // Should be \"middle\"\nprint(arr_restored.arr[2].length);  // Should be 500\nprint(arr_restored.arr[3].length);  // Should be 500\n\n// Test 4: Nested structure with large values\nlet nested = {\n    outer: {\n        inner: {\n            deep: long_string\n        }\n    },\n    array: [long_string, long_string]\n};\n\nlet nested_json = nested.serialize();\nprint(\"Test 3: Nested structure with large values\");\nlet nested_restored = nested_json.deserialize();\nprint(nested_restored.outer.inner.deep.length);  // Should be 500\nprint(nested_restored.array[0].length);          // Should be 500\n\n// Test 5: Object with many fields (stress test)\nlet many_fields = {\n    f1: long_string, f2: long_string, f3: long_string,\n    f4: long_string, f5: long_string, f6: long_string,\n    f7: long_string, f8: long_string, f9: long_string,\n    f10: long_string\n};\n\nlet many_json = many_fields.serialize();\nprint(\"Test 4: Object with many large fields\");\nlet many_restored = many_json.deserialize();\nprint(many_restored.f1.length);   // Should be 500\nprint(many_restored.f5.length);   // Should be 500\nprint(many_restored.f10.length);  // Should be 500\n\nprint(\"All tests passed!\");\n```", "output": "Test 1: Large object serialization\ntrue\ntrue\ntrue\n500\nshort\n500\nTest 2: Large array serialization\n4\n500\nmiddle\n500\n500\nTest 3: Nested structure with large values\n500\n500\nTest 4: Object with many large fields\n500\n500\n500\nAll tests passed!", "category": "tests/objects", "source": "tests/objects/serialize_large.hml"}
{"instruction": "How does processing all arguments except script name work in Hemlock?", "output": "```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Processing: \" + arg);\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does filter pattern work in Hemlock?", "output": "```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does break/continue inside try/catch/finally work in Hemlock?", "output": "```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // âœ… Breaks after finally runs\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does 2. third-party libraries work in Hemlock?", "output": "**Example: Image processing**\n\n```hemlock\n// Load libpng or libjpeg\n// Process images using C library functions\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { RED, GREEN, BOLD, clear, color } from \"@stdlib/terminal\";\n\n// Colored text\nprint(RED + \"Error: Something went wrong\" + RESET);\nprint(color(\"Success!\", GREEN));\n\n// Styled text\nprint(BOLD + \"Important message\" + RESET);\n\n// Clear screen\nclear();\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Writes `data` to the stream. Returns number of bytes written.\n\n```hemlock\nlet sent = stream.write(\"Hello, server!\");\nlet buf = buffer(10);\nlet sent2 = stream.write(buf);\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does binary bitwise work in Hemlock?", "output": "**Unsigned Example:**\n\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does 5. debug mode toggle work in Hemlock?", "output": "```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug mode: ON\");\n    } else {\n        print(\"Debug mode: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// From shell: kill -USR2 <pid> to toggle\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does is_linux() work in Hemlock?", "output": "**Returns:** `bool` - `true` if on Linux, `false` otherwise\n\n```hemlock\nimport { is_linux } from \"@stdlib/os\";\n\nif (is_linux()) {\n    print(\"Linux-specific code here\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does null comparison work in Hemlock?", "output": "```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does rsa_sign(data: string, keypair: rsakeypair): buffer work in Hemlock?", "output": "Sign data with RSA private key using SHA-256 digest.\n\n```hemlock\nimport { rsa_sign } from \"@stdlib/crypto\";\n\nlet data = \"Important message\";\nlet signature = rsa_sign(data, keypair);\n\nprint(\"Signature length: \" + typeof(signature.length));  // ~256 bytes for 2048-bit RSA\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does processing multi-line output work in Hemlock?", "output": "```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does 1. type safety work in Hemlock?", "output": "```hemlock\n// Be explicit about types\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does split & join work in Hemlock?", "output": "```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does working with strings work in Hemlock?", "output": "Strings in Hemlock are **mutable** and **UTF-8**:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // Now \"Hello\"\nprint(s);\n\n// String methods\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// Concatenation\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does meeting scheduler work in Hemlock?", "output": "```hemlock\nimport { now, parse_iso } from \"@stdlib/datetime\";\n\n// Parse meeting times from ISO strings\nlet meeting1 = parse_iso(\"2025-03-20T14:30:00\");\nlet meeting2 = parse_iso(\"2025-03-20T16:00:00\");\n\n// Calculate duration\nlet duration_minutes = meeting2.diff_minutes(meeting1);\nprint(\"Meeting duration: \" + typeof(duration_minutes) + \" minutes\");\n\n// Check if meeting is in the future\nlet current = now();\nif (meeting1.is_after(current)) {\n    let days_until = meeting1.diff_days(current);\n    print(\"Meeting in \" + typeof(days_until) + \" days\");\n    print(\"Meeting time: \" + meeting1.format(\"%A, %B %d at %I:%M %p\"));\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does testing success cases work in Hemlock?", "output": "**Example: tests/strings/methods.hml**\n\n```hemlock\n// Test substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Expect: world\n\n// Test find\nlet pos = s.find(\"world\");\nprint(pos);  // Expect: 6\n\n// Test contains\nlet has = s.contains(\"lo\");\nprint(has);  // Expect: true\n\n// Test trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Expect: hello\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does error: method 'first' not found on array work in Hemlock?", "output": "```hemlock\n**3. Implement the feature:**\n\nEdit `src/interpreter/builtins.c`:\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does 2. third-party libraries work in Hemlock?", "output": "**Example: Cryptography**\n\n```hemlock\n// Use OpenSSL or libsodium\n// Encryption/decryption via FFI\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does numeric types work in Hemlock?", "output": "```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Type alias\nlet byte_val: byte = 65;  // Same as u8\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does what to test work in Hemlock?", "output": "**Example test coverage:**\n\n```hemlock\n// Feature: String.substr(start, length)\n\n// Happy path\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Edge cases\nprint(\"hello\".substr(0, 0));  // \"\" (empty)\nprint(\"hello\".substr(5, 0));  // \"\" (at end)\nprint(\"hello\".substr(2, 100)); // \"llo\" (past end)\n\n// Error cases\n// \"hello\".substr(-1, 5);  // Error: negative index\n// \"hello\".substr(0, -1);  // Error: negative length\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does http methods work in Hemlock?", "output": "Perform an HTTP GET request.\n\n```hemlock\nimport { get } from \"@stdlib/http\";\n\n// Simple GET\nlet response = get(\"https://api.github.com/users/octocat\", null);\nprint(response.status_code);  // 200\nprint(response.body);          // JSON response\n\n// With custom headers\nlet headers = [\n    \"Authorization: Bearer token123\",\n    \"Accept: application/json\"\n];\nlet response = get(\"https://api.example.com/users\", headers);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "**5. Mission-critical error handling:**\n\n```hemlock\n// Bad - stderr not captured\nlet r = exec(\"critical_operation\");\n// Cannot see detailed error messages\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does objects work in Hemlock?", "output": "JavaScript-style objects:\n\n```hemlock\n// Object literal\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // Modify field\n\n// Methods with 'self'\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does convenience functions work in Hemlock?", "output": "Download a file from a URL and save it to disk.\n\n```hemlock\nimport { download } from \"@stdlib/http\";\n\nlet success = download(\"https://example.com/file.pdf\", \"/tmp/file.pdf\");\nif (success) {\n    print(\"Downloaded successfully\");\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test environment variable builtins\n\n// Set and get\nsetenv(\"TEST_VAR\", \"hello\");\nprint(getenv(\"TEST_VAR\"));\n\n// Overwrite\nsetenv(\"TEST_VAR\", \"world\");\nprint(getenv(\"TEST_VAR\"));\n\n// Non-existent (returns null)\nlet missing = getenv(\"NONEXISTENT_VAR_12345\");\nprint(missing == null);\n\n// Process ID (just check it returns a number > 0)\nlet pid = get_pid();\nprint(pid > 0);\n\nprint(\"done\");\n```", "output": "hello\nworld\ntrue\ntrue\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/env.hml"}
{"instruction": "How does pattern: array as queue work in Hemlock?", "output": "```hemlock\nlet queue = [];\n\n// Enqueue (add to end)\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dequeue (remove from front)\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport { getenv, setenv, exit } from \"@stdlib/env\";\n\nlet path = getenv(\"PATH\");\nif (path == null) {\n    print(\"PATH not set\");\n    exit(1);\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as strings from \"@stdlib/strings\";\nlet result = strings.reverse(\"hello\");\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does 6. capture stderr when needed work in Hemlock?", "output": "```hemlock\n// Redirect stderr to stdout\nlet r = exec(\"command 2>&1\");\n// Now r.output contains both stdout and stderr\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does exception assertions work in Hemlock?", "output": "Check if function throws an exception. Optionally verify error message.\n\n```hemlock\ntest(\"throw checks\", fn() {\n    // Check that function throws\n    expect(fn() {\n        throw \"error!\";\n    }).to_throw();\n\n    // Check specific error message\n    expect(fn() {\n        throw \"division by zero\";\n    }).to_throw(\"division by zero\");\n\n    // Function that doesn't throw\n    fn safe() {\n        return 42;\n    }\n\n    expect(safe).not_to_throw();\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Show an example of example: building strings from runes in Hemlock.", "output": "```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('â­', 5);  // \"â­â­â­â­â­\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does operator precedence work in Hemlock?", "output": "```hemlock\n// & has higher precedence than |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Shift has higher precedence than bitwise operators\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does case conversion work in Hemlock?", "output": "```hemlock\nstring.to_lower(): string\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does exit code patterns work in Hemlock?", "output": "Different exit codes indicate different conditions:\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does import shared library work in Hemlock?", "output": "```hemlock\nimport \"library_name.so\";\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does 4. fixed channel capacity work in Hemlock?", "output": "Channel capacity is set at creation and cannot be resized:\n\n```hemlock\nlet ch = channel(10);\n// Cannot dynamically resize to 20\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does type checking work in Hemlock?", "output": "Check if value is an array.\n\n```hemlock\nimport { is_array } from \"@stdlib/json\";\n\nprint(is_array([]));  // true\nprint(is_array([1, 2, 3]));  // true\nprint(is_array({}));  // false\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does declaration work in Hemlock?", "output": "Variables are declared with `let`:\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does copy file work in Hemlock?", "output": "```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does posix extended regular expression (ere) syntax work in Hemlock?", "output": "```hemlock\nimport { test } from \"@stdlib/regex\";\n\n// Email validation (simplified)\ntest(\"^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\\\.[a-z]+$\", \"user@example.com\");  // true\n\n// Phone number (US format)\ntest(\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\", \"555-123-4567\");  // true\n\n// Hexadecimal color code\ntest(\"^#[0-9a-fA-F]{6}$\", \"#FF5733\");  // true\n\n// URL protocol\ntest(\"^(http|https)://\", \"https://example.com\");  // true\n\n// Whitespace\ntest(\"^[[:space:]]+$\", \"   \\t\\n\");  // true\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does nested try/catch work in Hemlock?", "output": "```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Caught: \" + e);  // Prints: Caught: inner\n        throw \"outer\";  // Re-throw different error\n    }\n} catch (e) {\n    print(\"Caught: \" + e);  // Prints: Caught: outer\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does spawn work in Hemlock?", "output": "```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn single task\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// Spawn multiple tasks (run in parallel!)\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// All three are running simultaneously\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does u8 (byte) â†’ rune work in Hemlock?", "output": "Any u8 value (0-255) can convert to rune:\n\n```hemlock\n// ASCII range (0-127)\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// Extended ASCII / Latin-1 (128-255)\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8 (Ãˆ)\n\n// Note: Values 0-127 are ASCII, 128-255 are Latin-1\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test exec() builtin for command execution\n\n// Test basic command\nlet result = exec(\"echo hello\");\nprint(result.output);\nprint(result.exit_code);\n\n// Test command with newline stripped\nlet r2 = exec(\"echo -n world\");\nprint(r2.output);\n\n// Test exit code\nlet r3 = exec(\"exit 0\");\nprint(r3.exit_code);\n\n// Test command that fails\nlet r4 = exec(\"exit 42\");\nprint(r4.exit_code);\n\nprint(\"done\");\n```", "output": "hello\n\n0\nworld\n0\n42\ndone", "category": "tests/compiler", "source": "tests/compiler/exec.hml"}
{"instruction": "How does âŒ discouraged contributions work in Hemlock?", "output": "```hemlock\nWhy: Hides memory management, unpredictable performance\n\n**5. Complex macro system**\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\n// C-style for loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// For-in loop (arrays)\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(\"Item: \" + typeof(item));\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does sending messages work in Hemlock?", "output": "```hemlock\nlet success = ws.send_text(\"Hello, WebSocket!\");\nif (success) {\n    print(\"Message sent\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does pitfall: memory leaks work in Hemlock?", "output": "```hemlock\n// Objects must be manually freed\nfn create_objects() {\n    let obj = { data: alloc(1000) };\n    // obj never freed - memory leak\n    // Should call: free(obj);\n}\n\ncreate_objects();  // Leaks memory\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test variable scoping and shadowing\n\n// Basic shadowing in block\nlet x = 10;\nprint(x);\n{\n    let y = 20;\n    print(y);\n}\nprint(x);\n\n// Shadowing in nested blocks\nlet a = 1;\n{\n    let b = 2;\n    {\n        let c = 3;\n        print(c);\n    }\n    print(b);\n}\nprint(a);\n\n// Shadowing in loops\nlet outer_i = 100;\nfor (let i = 0; i < 3; i = i + 1) {\n    print(i);\n}\nprint(outer_i);\n\n// Shadowing in functions\nlet outer = \"outer\";\nfn test() {\n    let inner = \"inner\";\n    print(inner);\n}\ntest();\nprint(outer);\n\n// Function parameters (with different name to avoid shadowing issue)\nfn doubler(val) {\n    print(val);\n    let result = val * 2;\n    print(result);\n}\ndoubler(5);\n\n// Shadowing in if blocks\nlet cond = true;\nlet val2 = \"original\";\nif (cond) {\n    let inner_val = \"shadowed\";\n    print(inner_val);\n}\nprint(val2);\n\n// Shadowing in catch block\nlet err = \"outer error\";\ntry {\n    throw \"inner error\";\n} catch (e) {\n    print(e);\n}\nprint(err);\n\n// Closure captures outer scope\nlet captured = \"before\";\nlet capturer = fn() { return captured; };\n{\n    let different = \"after\";\n    print(capturer());\n}\n\n// Multiple levels with closures\nlet level = 0;\nfn makeGetter() {\n    let inner_level = 1;\n    return fn() {\n        let deepest = 2;\n        return deepest;\n    };\n}\nprint(makeGetter()());\nprint(level);\n\nprint(\"done\");\n```", "output": "10\n20\n10\n3\n2\n1\n0\n1\n2\n100\ninner\nouter\n5\n10\nshadowed\noriginal\ninner error\nouter error\nbefore\n2\n0\ndone", "category": "parity/language", "source": "tests/parity/language/scope_shadowing.hml"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test basic async spawn/join\n\n// Simple async function\nasync fn compute(n) {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn and join a task\nlet task = spawn(compute, 10);\nlet result = join(task);\nprint(result);\n\n// Multiple spawns\nlet t1 = spawn(compute, 5);\nlet t2 = spawn(compute, 10);\nlet t3 = spawn(compute, 15);\n\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n\nprint(r1);\nprint(r2);\nprint(r3);\n\nprint(\"done\");\n```", "output": "45\n10\n45\n105\ndone", "category": "tests/compiler", "source": "tests/compiler/async_basic.hml"}
{"instruction": "How does absolute_path(path) work in Hemlock?", "output": "**Throws:** Exception if path doesn't exist or cannot be resolved\n\n```hemlock\nimport { absolute_path } from \"@stdlib/fs\";\n\ntry {\n    let abs = absolute_path(\"../data/file.txt\");\n    print(\"Absolute path: \" + abs);\n\n    // Resolve current directory\n    let here = absolute_path(\".\");\n    print(\"Current directory (absolute): \" + here);\n} catch (e) {\n    print(\"Error resolving path: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does pattern: try/finally work in Hemlock?", "output": "```hemlock\nlet pattern = compile(\"test\");\ntry {\n    let result = pattern.test(\"testing\");\n    // ... process result\n} finally {\n    pattern.free();  // Always freed, even on exception\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does pitfall: reference vs. value work in Hemlock?", "output": "```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Shallow copy\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (surprise! both changed)\n\n// To avoid: Create new object\nlet obj3 = { x: obj1.x };  // Deep copy (manual)\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does 1. always check exit codes work in Hemlock?", "output": "```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Command failed!\");\n    // Handle error\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does progressbar(total, width?) work in Hemlock?", "output": "- `finish()` - Complete the bar and print newline\n\n```hemlock\nimport { ProgressBar } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nlet bar = ProgressBar(100, 50);\n\nlet i = 0;\nwhile (i <= 100) {\n    bar.update(i);\n    sleep(0.05);\n    i = i + 1;\n}\nbar.finish();\n\n// Output: [===========>                ] 23.4% 23/100\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does download file work in Hemlock?", "output": "```hemlock\nimport { download } from \"@stdlib/http\";\n\nprint(\"Downloading...\");\nlet success = download(\"https://httpbin.org/image/png\", \"/tmp/test.png\");\n\nif (success) {\n    print(\"Downloaded to /tmp/test.png\");\n} else {\n    print(\"Download failed\");\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does read binary file work in Hemlock?", "output": "```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Read\", binary.length, \"bytes\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Show an example of example: csv parser in Hemlock.", "output": "```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"apple, banana , cherry\";\nlet fields = parse_csv_line(csv);  // [\"apple\", \"banana\", \"cherry\"]\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does base64_decode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { base64_decode } from \"@stdlib/encoding\";\n\n// Basic decoding\nlet decoded1 = base64_decode(\"SGVsbG8sIFdvcmxkIQ==\");\nprint(decoded1);  // \"Hello, World!\"\n\n// Round-trip encoding/decoding\nlet original = \"The quick brown fox\";\nlet encoded = base64_encode(original);\nlet decoded2 = base64_decode(encoded);\nprint(decoded2 == original);  // true\n\n// Whitespace is automatically removed\nlet decoded3 = base64_decode(\"SGVs bG8s IFdv cmxk IQ==\");\nprint(decoded3);  // \"Hello, World!\"\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does 1. always close channels work in Hemlock?", "output": "```hemlock\nasync fn producer(ch) {\n    // ... send values\n    ch.close();  // Important: signal no more values\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does seeking work in Hemlock?", "output": "**Returns:** Current byte offset (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0 (at start)\n\nf.read(100);\nlet pos2 = f.tell();  // 100 (after reading 100 bytes)\n\nf.seek(500);\nlet pos3 = f.tell();  // 500 (after seeking)\n\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does arch() work in Hemlock?", "output": "- System requirements validation\n\n```hemlock\nimport { arch } from \"@stdlib/os\";\n\nlet a = arch();\nprint(\"CPU architecture: \" + a);  // e.g., \"x86_64\"\n\nif (a == \"x86_64\" || a == \"amd64\") {\n    print(\"64-bit x86 system\");\n} else if (a == \"aarch64\" || a == \"arm64\") {\n    print(\"64-bit ARM system\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does post json data work in Hemlock?", "output": "```hemlock\nimport { post_json } from \"@stdlib/http\";\n\nlet data = {\n    title: \"Buy groceries\",\n    completed: false,\n    userId: 1\n};\n\nlet response = post_json(\"https://jsonplaceholder.typicode.com/todos\", data);\nprint(response.body);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does concatenation work in Hemlock?", "output": "```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// String + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does type conversion work in Hemlock?", "output": "**Example type mappings:**\n\n```hemlock\n// Hemlock â†’ C\nlet i: i32 = 42;         // â†’ int32_t (4 bytes)\nlet f: f64 = 3.14;       // â†’ double (8 bytes)\nlet p: ptr = alloc(64);  // â†’ void* (8 bytes)\n\n// C â†’ Hemlock (return values)\n// int32_t foo() â†’ i32\n// double bar() â†’ f64\n// void* baz() â†’ ptr\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does mode: string work in Hemlock?", "output": "The mode the file was opened with.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does extraction operations work in Hemlock?", "output": "**`first()`** - Get first element (without removing):\n\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1 (without removing)\nprint(arr);                  // [1, 2, 3] (unchanged)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does atan(x) work in Hemlock?", "output": "**Returns:** `f64` - Arc tangent in range [-Ï€/2, Ï€/2]\n\n```hemlock\nimport { atan } from \"@stdlib/math\";\n\nlet angle = atan(1.0);  // Ï€/4\nlet angle2 = atan(0.0); // 0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does get_pid() work in Hemlock?", "output": "- Process management and monitoring\n\n```hemlock\nimport { get_pid } from \"@stdlib/env\";\n\nlet pid = get_pid();\nprint(\"Current process ID: \" + typeof(pid));\n\n// Create process-specific temp file\nlet temp_file = \"/tmp/myapp.\" + typeof(pid) + \".tmp\";\nprint(\"Using temp file: \" + temp_file);\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does type safety patterns work in Hemlock?", "output": "**Check before use:**\n\n```hemlock\nif (typeof(value) == \"i32\") {\n    // Safe to use as i32\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does hello world work in Hemlock?", "output": "```hemlock\nprint(\"Hello, World!\");\n```", "category": "docs", "source": "docs/README.md"}
{"instruction": "How does optimization tips work in Hemlock?", "output": "```hemlock\n// Bad - repeated checking in loop\nlet i = 0;\nwhile (i < items.length) {\n    if (is_digit(items[i])) {  // O(m) check per iteration\n        // ...\n    }\n    i = i + 1;\n}\n\n// Better - check once, cache result if needed\nlet i = 0;\nwhile (i < items.length) {\n    let item = items[i];\n    let is_num = is_digit(item);  // Cache result\n    if (is_num) {\n        // Use is_num multiple times\n    }\n    i = i + 1;\n}\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test: Nested try/catch blocks\ntry {\n    print(\"outer try\");\n    try {\n        print(\"inner try\");\n        throw \"inner error\";\n    } catch (e) {\n        print(\"inner catch: \" + e);\n    }\n    print(\"between\");\n    throw \"outer error\";\n} catch (e) {\n    print(\"outer catch: \" + e);\n}\n```", "output": "outer try\ninner try\ninner catch: inner error\nbetween\nouter catch: outer error", "category": "tests/exceptions", "source": "tests/exceptions/nested_try.hml"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as time from \"@stdlib/time\";\nlet timestamp = time.now();\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does pi work in Hemlock?", "output": "The mathematical constant Ï€ (pi) â‰ˆ 3.14159265358979323846\n\n```hemlock\nimport { PI } from \"@stdlib/math\";\nlet circumference = 2.0 * PI * radius;\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does basic structure work in Hemlock?", "output": "```hemlock\n// args[0] is always the script filename\n// args[1] through args[n-1] are the actual arguments\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Total number of arguments (including script name)\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does iteration work in Hemlock?", "output": "```hemlock\nlet items = [\"apple\", \"banana\", \"cherry\"];\n\n// For-in loop\nfor (let item in items) {\n    print(item);\n}\n\n// Manual iteration\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does reading work in Hemlock?", "output": "```hemlock\nfile.read_bytes(size: i32): buffer\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does pointer types work in Hemlock?", "output": "```hemlock\nlet p: ptr = alloc(64);\n// No bounds checking, manual lifetime management\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show an example of complete producer-consumer example in Hemlock.", "output": "```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel with buffer size\nlet ch = channel(10);\n\n// Spawn producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for completion\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does creating a thread pool work in Hemlock?", "output": "```hemlock\nlet pool = ThreadPool(num_workers: i32);\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test compression builtins\n\n// Create a buffer with test data for crc32/adler32\nlet buf = buffer(5);\nbuf[0] = 104; // 'h'\nbuf[1] = 101; // 'e'\nbuf[2] = 108; // 'l'\nbuf[3] = 108; // 'l'\nbuf[4] = 111; // 'o'\n\n// Test crc32 - buffer based\nlet crc = crc32(buf);\nprint(crc > 0);\n\n// Test adler32 - buffer based\nlet adler = adler32(buf);\nprint(adler > 0);\n\n// Test zlib_compress_bound\nlet bound = zlib_compress_bound(100);\nprint(bound > 100);\n\n// Test zlib compress/decompress roundtrip - string based\nlet original = \"Hello, World! This is a test string for compression testing.\";\nlet compressed = zlib_compress(original, 6);\nprint(compressed.length > 0);\n\nlet decompressed = zlib_decompress(compressed, 1000);\nprint(decompressed == original);\n\n// Test gzip compress/decompress roundtrip - string based\nlet gzip_compressed = gzip_compress(original, 6);\nprint(gzip_compressed.length > 0);\n\nlet gzip_decompressed = gzip_decompress(gzip_compressed, 1000);\nprint(gzip_decompressed == original);\n\n// Test that crc32 is deterministic\nlet buf2 = buffer(4);\nbuf2[0] = 116; // 't'\nbuf2[1] = 101; // 'e'\nbuf2[2] = 115; // 's'\nbuf2[3] = 116; // 't'\n\nlet crc1 = crc32(buf2);\nlet crc2 = crc32(buf2);\nprint(crc1 == crc2);\n\n// Test that adler32 is deterministic\nlet adler1 = adler32(buf2);\nlet adler2 = adler32(buf2);\nprint(adler1 == adler2);\n\nprint(\"done\");\n```", "output": "true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ndone", "category": "tests/compiler", "source": "tests/compiler/compression.hml"}
{"instruction": "How does now() work in Hemlock?", "output": "- Timestamping events\n\n```hemlock\nimport { now } from \"@stdlib/time\";\n\nlet timestamp = now();\nprint(\"Current timestamp: \" + typeof(timestamp));  // e.g., 1700000000\n\n// Measure elapsed time\nlet start = now();\n// ... do work ...\nlet end = now();\nlet seconds_elapsed = end - start;\nprint(\"Took \" + typeof(seconds_elapsed) + \" seconds\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test socket builtins for compiler\n\n// Test socket constants are available\nprint(AF_INET);\nprint(SOCK_STREAM);\nprint(SOCK_DGRAM);\nprint(SOL_SOCKET);\nprint(SO_REUSEADDR);\n\n// Test socket creation (TCP)\nlet tcp_sock = socket_create(AF_INET, SOCK_STREAM, 0);\nprint(typeof(tcp_sock));\n\n// Test socket properties\nlet fd = tcp_sock.fd;\nprint(fd > 0);\nprint(tcp_sock.closed);\n\n// Test socket close\ntcp_sock.close();\nprint(tcp_sock.closed);\n\n// Test UDP socket creation\nlet udp_sock = socket_create(AF_INET, SOCK_DGRAM, 0);\nprint(typeof(udp_sock));\nudp_sock.close();\nprint(udp_sock.closed);\n\n// Test DNS resolve\nlet ip = dns_resolve(\"localhost\");\nprint(ip);\n\nprint(\"done\");\n```", "output": "2\n1\n2\n1\n2\nsocket\ntrue\nfalse\ntrue\nsocket\ntrue\n127.0.0.1\ndone", "category": "tests/compiler", "source": "tests/compiler/sockets.hml"}
{"instruction": "How does .length work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// Length changes dynamically\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test string operations\nlet a = \"Hello\";\nlet b = \"World\";\n\nprint(a);\nprint(b);\nprint(a + \" \" + b);\nlet answer = 42;\nprint(\"The answer is: \" + answer);\n\n// Empty string\nlet empty = \"\";\nprint(empty);\nprint(\"prefix\" + empty + \"suffix\");\n```", "output": "Hello\nWorld\nHello World\nThe answer is: 42\n\nprefixsuffix", "category": "tests/compiler", "source": "tests/compiler/strings.hml"}
{"instruction": "How does pattern: validation work in Hemlock?", "output": "Use exceptions for validation:\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Name is required\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Invalid age\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Invalid email\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invalid\" });\n} catch (e) {\n    print(\"Validation failed: \" + e);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test: detach() cleanup verification\n// Tests that detached tasks properly clean up their memory when they complete\n\n// Create channel for thread-safe communication\nlet ch = channel(100);\n\nasync fn increment_task(id: i32, ch) {\n    // Simulate some work\n    let i = 0;\n    let sum = 0;\n    while (i < 100) {\n        sum = sum + i;\n        i = i + 1;\n    }\n\n    // Signal completion via channel (thread-safe)\n    ch.send(1);\n\n    return null;\n}\n\n// Detach many tasks to exercise cleanup mechanism\nlet num_tasks = 50;\nlet i = 0;\nwhile (i < num_tasks) {\n    detach(increment_task, i, ch);\n    i = i + 1;\n}\n\nprint(\"Detached tasks:\");\nprint(num_tasks);\n\n// Wait for all tasks to complete by receiving from channel\nlet completed = 0;\nlet j = 0;\nwhile (j < num_tasks) {\n    let val = ch.recv();\n    completed = completed + val;\n    j = j + 1;\n}\n\nprint(\"Tasks completed:\");\nprint(completed);\nprint(\"Test completed without crashes\");\n```", "output": "Detached tasks:\n50\nTasks completed:\n50\nTest completed without crashes", "category": "tests/async", "source": "tests/async/test_detach_cleanup.hml"}
{"instruction": "How does case conversion work in Hemlock?", "output": "```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does pitfall: memory leaks work in Hemlock?", "output": "```hemlock\n// Arrays must be manually freed\nfn create_large_array() {\n    let arr = [];\n    let i = 0;\n    while (i < 1000000) {\n        arr.push(i);\n        i = i + 1;\n    }\n    // Should call: free(arr);\n}\n\ncreate_large_array();  // Leaks memory without free()\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does uncaught exceptions work in Hemlock?", "output": "If an exception propagates to the top of the call stack without being caught:\n\n```hemlock\nfn foo() {\n    throw \"uncaught!\";\n}\n\nfoo();  // Crashes with: Runtime error: uncaught!\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does overview work in Hemlock?", "output": "```hemlock\n// Named function syntax\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Anonymous function\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// Closures\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does atan2(y, x) work in Hemlock?", "output": "**Returns:** `f64` - Arc tangent in range [-Ï€, Ï€]\n\n```hemlock\nimport { atan2, PI } from \"@stdlib/math\";\n\nlet angle = atan2(1.0, 1.0);    // Ï€/4 (45 degrees)\nlet angle2 = atan2(1.0, -1.0);  // 3Ï€/4 (135 degrees)\nlet angle3 = atan2(-1.0, -1.0); // -3Ï€/4 (-135 degrees)\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test that function parameters properly shadow global variables\n// This is a regression test for a bug where parameters with the same name\n// as global variables would incorrectly modify the global instead of\n// creating a local binding\n\nfn fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\n// Global variable named 'n' - same as parameter\nlet n = 10;\n\n// fib should work correctly without modifying global n\nprint(fib(n));  // Should print 55\n\n// Global n should be unchanged\nprint(n);  // Should still be 10\n\n// Also test with explicit different values (using smaller n to avoid timeout)\nlet x = 20;\nprint(fib(x));  // Should be 6765 (fib(20))\nprint(x);  // x should still be 20\n\n// Test that assignment inside function works with shadowed param\nfn modify_n(n) {\n    n = n + 1;\n    return n;\n}\n\nlet result = modify_n(5);\nprint(result);  // Should be 6\nprint(n);  // Global n should still be 10\n\nprint(\"PASS\");\n```", "output": "55\n10\n6765\n20\n6\n10\nPASS", "category": "tests/functions", "source": "tests/functions/param_shadowing.hml"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test: Channel stress test with multiple producers and consumers\n// Tests channel thread safety under high load\n\nasync fn producer(ch, start: i32, count: i32): i32 {\n    let i = 0;\n    while (i < count) {\n        ch.send(start + i);\n        i = i + 1;\n    }\n    return count;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel with buffer\nlet ch = channel(100);\n\n// Spawn 10 producers (each sends 100 messages)\nlet num_producers = 10;\nlet messages_per_producer = 100;\nlet producers = [];\nlet i = 0;\n\nwhile (i < num_producers) {\n    let task = spawn(producer, ch, i * messages_per_producer, messages_per_producer);\n    producers.push(task);\n    i = i + 1;\n}\n\n// Spawn 10 consumers (each receives 100 messages)\nlet num_consumers = 10;\nlet messages_per_consumer = 100;\nlet consumers = [];\ni = 0;\n\nwhile (i < num_consumers) {\n    let task = spawn(consumer, ch, messages_per_consumer);\n    consumers.push(task);\n    i = i + 1;\n}\n\n// Wait for all producers\nlet produced = 0;\ni = 0;\nwhile (i < producers.length) {\n    produced = produced + join(producers[i]);\n    i = i + 1;\n}\n\n// Wait for all consumers\nlet consumed_sum = 0;\ni = 0;\nwhile (i < consumers.length) {\n    consumed_sum = consumed_sum + join(consumers[i]);\n    i = i + 1;\n}\n\nprint(\"Produced messages:\");\nprint(produced);\nprint(\"Consumer sum:\");\nprint(consumed_sum);\n```", "output": "Produced messages:\n1000\nConsumer sum:\n499500", "category": "tests/async", "source": "tests/async/stress_channel_throughput.hml"}
{"instruction": "How does seeking work in Hemlock?", "output": "**Example - Random access:**\n\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// Read record at offset 1000\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// Read record at offset 2000\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does make_dir(path, mode?) work in Hemlock?", "output": "**Throws:** Exception if directory already exists or cannot be created\n\n```hemlock\nimport { make_dir } from \"@stdlib/fs\";\n\ntry {\n    // Create with default permissions (0755)\n    make_dir(\"new_directory\");\n\n    // Create with custom permissions (0700 - owner only)\n    let mode: u32 = 448;  // 0700 in octal = 448 in decimal\n    make_dir(\"private_dir\", mode);\n\n    print(\"Directories created\");\n} catch (e) {\n    print(\"Error creating directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does type promotion work in Hemlock?", "output": "Hemlock promotes types automatically in mixed operations:\n\n`i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64`\n\nFloats always win in mixed integer/float operations:\n\n```hemlock\nlet i: i32 = 10;\nlet f: f64 = 3.5;\nprint(i + f);  // 13.5 (f64)\n```", "category": "concepts/types", "source": "CLAUDE.md"}
{"instruction": "Show an example of example: case conversion in Hemlock.", "output": "```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // Convert to uppercase (subtract 32)\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // Convert to lowercase (add 32)\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does date arithmetic methods work in Hemlock?", "output": "Add (or subtract) seconds. Returns a new DateTime object.\n\n```hemlock\nlet dt = from_date(2025, 1, 15, 12, 0, 0);\n\nlet later = dt.add_seconds(30);\nprint(later.to_string());  // \"2025-01-15 12:00:30\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does e work in Hemlock?", "output": "The mathematical constant e (Euler's number) â‰ˆ 2.71828182845904523536\n\n```hemlock\nimport { E } from \"@stdlib/math\";\nlet growth = E * rate;\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test sizeof builtin\n\n// Integer types\nprint(sizeof(\"i8\"));\nprint(sizeof(\"i16\"));\nprint(sizeof(\"i32\"));\nprint(sizeof(\"i64\"));\n\n// Unsigned types\nprint(sizeof(\"u8\"));\nprint(sizeof(\"u16\"));\nprint(sizeof(\"u32\"));\nprint(sizeof(\"u64\"));\n\n// Float types\nprint(sizeof(\"f32\"));\nprint(sizeof(\"f64\"));\n\n// Other types\nprint(sizeof(\"bool\"));\nprint(sizeof(\"ptr\"));\nprint(sizeof(\"rune\"));\n\n// Aliases\nprint(sizeof(\"integer\"));\nprint(sizeof(\"number\"));\nprint(sizeof(\"byte\"));\n\n// Unknown type returns 0\nprint(sizeof(\"unknown\"));\n\nprint(\"done\");\n```", "output": "1\n2\n4\n8\n1\n2\n4\n8\n4\n8\n1\n8\n4\n4\n8\n1\n0\ndone", "category": "tests/compiler", "source": "tests/compiler/sizeof_builtin.hml"}
{"instruction": "How does channel methods work in Hemlock?", "output": "```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does good use cases work in Hemlock?", "output": "**5. Generating reports:**\n\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Running instances: \" + count);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does insertion & removal work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// Insert at end\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does split & join work in Hemlock?", "output": "```hemlock\nstring.split(delimiter: string): array\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does basic recursion work in Hemlock?", "output": "```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does is_windows() work in Hemlock?", "output": "**Returns:** `bool` - `true` if on Windows, `false` otherwise\n\n```hemlock\nimport { is_windows } from \"@stdlib/os\";\n\nif (is_windows()) {\n    print(\"Windows-specific code here\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does input validation work in Hemlock?", "output": "Always validate environment variable contents:\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nfn get_port(): i32 {\n    let port_str = getenv(\"PORT\");\n\n    if (port_str == null) {\n        return 8080;  // Default\n    }\n\n    // Validate: should be numeric, in valid range\n    let port: i32 = port_str;  // Type conversion (simplified)\n\n    if (port < 1 || port > 65535) {\n        print(\"Error: Invalid port \" + typeof(port));\n        return 8080;  // Fall back to default\n    }\n\n    return port;\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does command-line arguments work in Hemlock?", "output": "Access program arguments via the `args` array:\n\n```hemlock\n// script.hml\nprint(\"Script: \" + args[0]);\nprint(\"Arguments: \" + typeof(args.length - 1));\n\nlet i = 1;\nwhile (i < args.length) {\n    print(\"  arg \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "Show an example of example 2: file logging with error handling in Hemlock.", "output": "```hemlock\nimport { Logger, ERROR } from \"@stdlib/logging\";\n\nlet logger = Logger({\n    output: \"/var/log/myapp.log\",\n    level: ERROR\n});\ndefer logger.close();\n\ntry {\n    risky_operation();\n} catch (e) {\n    logger.error(\"Operation failed\", {\n        error: e,\n        timestamp: __now(),\n        context: \"main_loop\"\n    });\n}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does formatting methods work in Hemlock?", "output": "Format as \"YYYY-MM-DD HH:MM:SS\".\n\n```hemlock\nlet dt = from_date(2025, 3, 15, 14, 30, 45);\nprint(dt.to_string());  // \"2025-03-15 14:30:45\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does quick start work in Hemlock?", "output": "```hemlock\nRunning tests...\n\nMath operations\n  âœ“ addition works\n  âœ“ subtraction works\n\nString operations\n  âœ“ concatenation works\n  âœ“ length is correct\n\nTest Summary:\n  Total:  4\n  Passed: 4\n  Failed: 0\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does while loops work in Hemlock?", "output": "Condition-based iteration:\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does output redirects work in Hemlock?", "output": "```hemlock\n// Redirect stdout to file (within shell)\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// Redirect stderr to stdout (Note: stderr still not captured by Hemlock)\nlet r2 = exec(\"command 2>&1\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does method storage work in Hemlock?", "output": "Methods are just functions stored in fields:\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method is a function stored in obj.method\nprint(typeof(obj.method));  // \"function\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Show an example of example 5: http request logging in Hemlock.", "output": "```hemlock\nimport { Logger } from \"@stdlib/logging\";\n\nlet access_log = Logger({\n    output: \"access.log\",\n    format: \"{timestamp} {message}\"\n});\ndefer access_log.close();\n\nfn handle_request(request) {\n    let start = __time_ms();\n\n    // ... handle request ...\n\n    let elapsed = __time_ms() - start;\n\n    access_log.info(\"HTTP request\", {\n        method: request.method,\n        path: request.path,\n        status: 200,\n        duration_ms: elapsed,\n        ip: request.client_ip\n    });\n}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Show an example of example 3: debug logging during development in Hemlock.", "output": "```hemlock\nimport { Logger, DEBUG } from \"@stdlib/logging\";\n\nlet logger = Logger({ level: DEBUG });\n\nfn process_data(data: array) {\n    logger.debug(\"Processing started\", { size: data.length });\n\n    let i = 0;\n    while (i < data.length) {\n        logger.debug(\"Processing item\", { index: i, value: data[i] });\n        // ... process item ...\n        i = i + 1;\n    }\n\n    logger.debug(\"Processing completed\");\n    return null;\n}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does 4. performance-critical code work in Hemlock?", "output": "Call optimized C implementations:\n\n```hemlock\n// Use highly-optimized C libraries\n// SIMD operations, vectorized code\n// Hardware-accelerated functions\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does prefix/suffix checking work in Hemlock?", "output": "**`ends_with(suffix)`** - Check if ends with suffix:\n\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test array builtin functions\n\n// Length\nprint([1, 2, 3].length);\nprint([].length);\n\n// Array creation and access\nlet arr = [10, 20, 30, 40, 50];\nprint(arr[0]);\nprint(arr[4]);\nprint(arr.length);\n\n// Array modification\narr[2] = 300;\nprint(arr[2]);\n\n// Push and pop\narr.push(60);\nprint(arr.length);\nprint(arr.pop());\nprint(arr.length);\n\n// Shift and unshift\narr.unshift(0);\nprint(arr[0]);\nprint(arr.shift());\nprint(arr[0]);\n\n// Slice\nlet sliced = arr.slice(1, 3);\nprint(sliced.length);\nprint(sliced[0]);\nprint(sliced[1]);\n\n// Join\nlet strs = [\"a\", \"b\", \"c\"];\nprint(strs.join(\"-\"));\nprint(strs.join(\"\"));\n\n// Concat\nlet a1 = [1, 2];\nlet a2 = [3, 4];\nlet combined = a1.concat(a2);\nprint(combined.length);\nprint(combined[2]);\n\n// Reverse\nlet rev = [1, 2, 3];\nrev.reverse();\nprint(rev[0]);\nprint(rev[2]);\n\n// First and last\nlet fl = [10, 20, 30];\nprint(fl.first());\nprint(fl.last());\n\n// Contains\nprint([1, 2, 3].contains(2));\nprint([1, 2, 3].contains(5));\n\n// Find index\nprint([10, 20, 30].find(20));\nprint([10, 20, 30].find(99));\n\n// Insert and remove\nlet mod = [1, 2, 3];\nmod.insert(1, 99);\nprint(mod[1]);\nprint(mod.length);\nmod.remove(1);\nprint(mod[1]);\nprint(mod.length);\n\n// Clear\nlet toclear = [1, 2, 3];\ntoclear.clear();\nprint(toclear.length);\n\nprint(\"done\");\n```", "output": "3\n0\n10\n50\n5\n300\n6\n60\n5\n0\n0\n10\n2\n20\n300\na-b-c\nabc\n4\n3\n3\n1\n10\n30\ntrue\nfalse\n1\n-1\n99\n4\n2\n3\n0\ndone", "category": "parity/builtins", "source": "tests/parity/builtins/array_builtins.hml"}
{"instruction": "How does path types work in Hemlock?", "output": "```hemlock\nimport { foo } from \"./module.hml\";       // Same directory\nimport { bar } from \"../parent.hml\";      // Parent directory\nimport { baz } from \"./sub/nested.hml\";   // Subdirectory\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does character access work in Hemlock?", "output": "```hemlock\nstring.chars(): array\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "What does this Hemlock program output?\n\n```hemlock\n// Test basic FFI functionality with strlen\n\n// Import libc\nimport \"libc.so.6\";\n\n// Declare external function\nextern fn strlen(s: string): i32;\n\n// Test strlen\nlet len = strlen(\"hello\");\nprint(\"strlen test:\");\nprint(len);\n\n// Test with longer string\nlet len2 = strlen(\"hello world\");\nprint(len2);\n\nprint(\"done\");\n```", "output": "strlen test:\n5\n11\ndone", "category": "tests/compiler", "source": "tests/compiler/ffi_basic.hml"}
{"instruction": "How does string type work in Hemlock?", "output": "```hemlock\nlet text: string = \"Hello, World!\";\nlet empty: string = \"\";\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does join work in Hemlock?", "output": "```hemlock\njoin(task: task): any\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does return type annotations work in Hemlock?", "output": "Optional type annotation for return value:\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does multiple closures work in Hemlock?", "output": "```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does integer literal inference work in Hemlock?", "output": "Hemlock infers integer types based on value range:\n\n```hemlock\nlet a = 42;              // i32 (fits in 32-bit)\nlet b = 5000000000;      // i64 (> i32 max)\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8 (explicit annotation)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does byte access work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII 'h')\nlet byte2 = s.byte_at(1);       // 101 (ASCII 'e')\n\n// UTF-8 example\nlet emoji = \"ðŸš€\";\nlet byte3 = emoji.byte_at(0);   // 240 (first UTF-8 byte)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does exception handling patterns work in Hemlock?", "output": "**Pattern 1: Handle in task**\n\n```hemlock\nasync fn safe_task() {\n    try {\n        // risky operation\n    } catch (e) {\n        print(\"Error in task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // No exception propagated\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does log rotation work in Hemlock?", "output": "```hemlock\nimport { file_stat, rename, remove_file, exists } from \"@stdlib/fs\";\n\nfn rotate_log(log_path: string, max_size: i64): null {\n    if (!exists(log_path)) {\n        return null;\n    }\n\n    try {\n        let info = file_stat(log_path);\n\n        if (info.size >= max_size) {\n            // Rotate: log.txt -> log.txt.1 -> log.txt.2 -> ...\n            let i = 4;\n            while (i > 0) {\n                let old_name = log_path + \".\" + typeof(i);\n                let new_name = log_path + \".\" + typeof(i + 1);\n\n                if (exists(old_name)) {\n                    if (i == 4) {\n                        remove_file(old_name);  // Delete oldest\n                    } else {\n                        rename(old_name, new_name);\n                    }\n                }\n\n                i = i - 1;\n            }\n\n            rename(log_path, log_path + \".1\");\n            print(\"Log rotated\");\n        }\n    } catch (e) {\n        print(\"Error rotating log: \" + e);\n    }\n\n    return null;\n}\n\n// Check before each write\nrotate_log(\"app.log\", 10485760);  // 10 MB\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Show an example of memory layout examples in Hemlock.", "output": "```hemlock\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // Pointer to heap\n}\n\nHeap: \"hello\\0\" (6 bytes, null-terminated UTF-8)\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test if/else statements\n\nlet x = 10;\n\nif (x > 5) {\n    print(\"greater\");\n}\n\nif (x < 5) {\n    print(\"less\");\n} else {\n    print(\"not less\");\n}\n\nif (x == 0) {\n    print(\"zero\");\n} else if (x == 10) {\n    print(\"ten\");\n} else {\n    print(\"other\");\n}\n\n// Nested if\nif (x > 0) {\n    if (x < 20) {\n        print(\"between\");\n    }\n}\n\nprint(\"done\");\n```", "output": "greater\nnot less\nten\nbetween\ndone", "category": "parity/language", "source": "tests/parity/language/if_else.hml"}
{"instruction": "How does hex_decode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { hex_decode } from \"@stdlib/encoding\";\n\n// Basic decoding\nlet decoded1 = hex_decode(\"48656c6c6f\");\nprint(decoded1);  // \"Hello\"\n\n// Case-insensitive\nlet decoded2 = hex_decode(\"48656C6C6F\");\nprint(decoded2);  // \"Hello\" (uppercase works too)\n\nlet decoded3 = hex_decode(\"48656C6c6f\");\nprint(decoded3);  // \"Hello\" (mixed case works)\n\n// Whitespace is automatically removed\nlet decoded4 = hex_decode(\"48 65 6c 6c 6f\");\nprint(decoded4);  // \"Hello\"\n\n// Round-trip\nlet original = \"The quick brown fox\";\nlet encoded = hex_encode(original);\nlet decoded5 = hex_decode(encoded);\nprint(decoded5 == original);  // true\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does working with string indexing work in Hemlock?", "output": "String indexing returns runes, not bytes:\n\n```hemlock\nlet s = \"HelloðŸš€\";\nlet h = s[0];                   // 'H' (rune)\nlet rocket = s[5];              // 'ðŸš€' (rune)\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// Convert to string if needed\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"ðŸš€\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does check color support work in Hemlock?", "output": "```hemlock\nimport { supports_color, RED, RESET } from \"@stdlib/terminal\";\n\nif (supports_color()) {\n    print(RED + \"Error!\" + RESET);\n} else {\n    print(\"[ERROR] Error!\");\n}\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "What is the result of running this Hemlock code?\n\n```hemlock\n// Test null return type annotation\n\n// Function with null return type - no explicit return\nfn no_return(): null {\n    print(\"no_return called\");\n}\n\n// Function with null return type - bare return\nfn bare_return(): null {\n    print(\"bare_return called\");\n    return;\n}\n\n// Function with null return type - explicit return null\nfn explicit_return(): null {\n    print(\"explicit_return called\");\n    return null;\n}\n\n// Call all functions\nno_return();\nbare_return();\nexplicit_return();\n\n// Verify the return value is null\nlet result = no_return();\nprint(typeof(result));\n\nprint(\"all tests passed\");\n```", "output": "no_return called\nbare_return called\nexplicit_return called\nno_return called\nnull\nall tests passed", "category": "tests/functions", "source": "tests/functions/null_return_type.hml"}
{"instruction": "How does c code style work in Hemlock?", "output": "// Good: \"Error: Expected integer, got string\"\n\n```hemlock\n**Memory management:**\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does test failures work in Hemlock?", "output": "make clean && make test\n\n```hemlock\n3. On macOS, ensure you have the latest Xcode Command Line Tools:\n```", "category": "docs", "source": "docs/getting-started/installation.md"}
{"instruction": "How does password strength validation work in Hemlock?", "output": "```hemlock\nimport { test } from \"@stdlib/regex\";\n\nfn is_strong_password(password: string): bool {\n    // At least 8 chars, contains uppercase, lowercase, digit, special char\n    let has_length = test(\"^.{8,}$\", password);\n    let has_upper = test(\"[A-Z]\", password);\n    let has_lower = test(\"[a-z]\", password);\n    let has_digit = test(\"[0-9]\", password);\n    let has_special = test(\"[[:punct:]]\", password);\n\n    return has_length && has_upper && has_lower && has_digit && has_special;\n}\n\nprint(is_strong_password(\"Passw0rd!\"));    // true\nprint(is_strong_password(\"weak\"));         // false\nprint(is_strong_password(\"NoSpecial1\"));   // false\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Show an example of example: fizzbuzz in Hemlock.", "output": "```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Run this Hemlock code and show the output:\n\n```hemlock\n// Test task_debug_info builtin\n\nasync fn work(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn a task\nlet t = spawn(work, 10);\n\n// Wait for result first (makes state deterministic)\nlet result = join(t);\nprint(result);\n\n// Print debug info after join (state is now guaranteed COMPLETED+JOINED)\nprint(\"After join:\");\ntask_debug_info(t);\n\nprint(\"done\");\n```", "output": "45\nAfter join:\n=== Task Debug Info ===\nTask ID: 1\nState: COMPLETED\nJoined: true\nDetached: false\nRef Count: 3\nHas Result: true\n======================\ndone", "category": "tests/compiler", "source": "tests/compiler/task_debug_info.hml"}
{"instruction": "How does for-in iteration (including script name) work in Hemlock?", "output": "```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does when you need `free()` vs when it's automatic work in Hemlock?", "output": "1. **Raw pointers** - `alloc()` has no refcounting:\n\n```hemlock\nlet p = alloc(64);\n   // ... use p ...\n   free(p);  // Always required - will leak otherwise\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does exit_code field work in Hemlock?", "output": "```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0 (success)\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1 (failure)\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2 (file not found, varies by command)\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "**5. Dangling Pointers**\n\n```hemlock\n// BAD: Dangling pointer\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // CRASH: p2 is dangling\n\n// GOOD: Track ownership carefully\nlet p = alloc(100);\n// ... use p ...\nfree(p);\n// Don't keep other references to p\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does else-if chains work in Hemlock?", "output": "**Note:** `else if` is syntactic sugar for nested if statements. These are equivalent:\n\n```hemlock\n// else if (syntactic sugar)\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// Equivalent nested if\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does pointer types work in Hemlock?", "output": "```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does defining methods work in Hemlock?", "output": "Methods are functions stored in object fields:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does string + rune concatenation work in Hemlock?", "output": "Runes can be concatenated with strings:\n\n```hemlock\n// String + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + 'âœ“';       // \"Textâœ“\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = 'â€¢' + \" Item\";         // \"â€¢ Item\"\n\n// Multiple concatenations\nlet msg = \"Hi \" + 'ðŸ‘‹' + \" World \" + 'ðŸŒ';  // \"Hi ðŸ‘‹ World ðŸŒ\"\n\n// Method chaining works\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "What control flow statements does Hemlock have?", "output": "Hemlock has standard control flow with mandatory braces:\n\n```hemlock\n// Conditionals\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n\n// While loop\nwhile (condition) {\n    break;     // exit loop\n    continue;  // next iteration\n}\n\n// For loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// For-in loop\nfor (item in array) {\n    print(item);\n}\n\n// Switch\nswitch (x) {\n    case 1: print(\"one\"); break;\n    case 2: print(\"two\"); break;\n    default: print(\"other\"); break;\n}\n```", "category": "concepts/control-flow", "source": "CLAUDE.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1 (not found)\n\n// Find first duplicate\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1 (first occurrence)\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does basic iteration work in Hemlock?", "output": "Skip `args[0]` (script name) and process actual arguments:\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does testing exceptions work in Hemlock?", "output": "**Example: tests/exceptions/try_catch.hml**\n\n```hemlock\n// Test basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Expect: Caught: error message\n}\n\n// Test finally\nlet executed = false;\ntry {\n    print(\"try\");  // Expect: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Expect: finally\n}\n\n// Test exception propagation\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Expect: failure\n}\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How do you use usage in Hemlock?", "output": "```hemlock\nimport * as regex from \"@stdlib/regex\";\nlet pattern = regex.compile(\"hello.*world\");\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does best practices for safe signal handling work in Hemlock?", "output": "Simple boolean assignments are generally safe:\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // Simple assignment is safe\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // work...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does datetime constructor work in Hemlock?", "output": "Create a DateTime object from a Unix timestamp (seconds since epoch). If no timestamp is provided, uses the current time.\n\n```hemlock\nimport { DateTime } from \"@stdlib/datetime\";\n\n// From specific timestamp\nlet dt = DateTime(1737037845);\nprint(dt.to_string());  // \"2025-01-16 12:30:45\"\n\n// Current time (default)\nlet now_dt = DateTime();\nprint(now_dt.year);  // Current year\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does array type work in Hemlock?", "output": "```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];  // Mixed types allowed\nlet empty: array = [];\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Predict the output of this Hemlock program:\n\n```hemlock\n// Test talloc builtin - typed allocation\n\n// Allocate space for 10 i32 values (40 bytes)\nlet p1 = talloc(\"i32\", 10);\nprint(\"allocated i32 array\");\n\n// Allocate space for 5 i64 values (40 bytes)\nlet p2 = talloc(\"i64\", 5);\nprint(\"allocated i64 array\");\n\n// Allocate space for 100 bytes\nlet p3 = talloc(\"u8\", 100);\nprint(\"allocated u8 array\");\n\n// Allocate space for 8 pointers (64 bytes)\nlet p4 = talloc(\"ptr\", 8);\nprint(\"allocated ptr array\");\n\n// Free all allocated memory\nfree(p1);\nfree(p2);\nfree(p3);\nfree(p4);\n\nprint(\"freed all\");\nprint(\"done\");\n```", "output": "allocated i32 array\nallocated i64 array\nallocated u8 array\nallocated ptr array\nfreed all\ndone", "category": "tests/compiler", "source": "tests/compiler/talloc.hml"}
{"instruction": "How does âŒ discouraged contributions work in Hemlock?", "output": "**1. Automatic semicolon insertion**\n\n```hemlock\n// BAD: This would be rejected\nlet x = 5  // No semicolon\nlet y = 10 // No semicolon\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does spinner(frames?) work in Hemlock?", "output": "- `next()` - Advance to next frame without printing\n\n```hemlock\nimport { Spinner, SPINNER_DOTS } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nlet spinner = Spinner(SPINNER_DOTS());\n\nlet i = 0;\nwhile (i < 50) {\n    spinner.spin();\n    sleep(0.1);\n    i = i + 1;\n}\nspinner.finish(\"Done!\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "- Terminal size cannot be determined\n\n```hemlock\nimport { size, supports_color } from \"@stdlib/terminal\";\n\n// Check capabilities first\nif (!supports_color()) {\n    print(\"Warning: Color output disabled\");\n}\n\nlet term = size();\nif (term.rows == 24 && term.cols == 80) {\n    // Possibly default fallback values\n    print(\"Note: Using default terminal size\");\n}\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does future: direct ffi work in Hemlock?", "output": "FFI declarations to libcurl are included in the module for future implementation:\n\n```hemlock\n// Already declared (not yet fully implemented)\nextern fn curl_easy_init(): ptr;\nextern fn curl_easy_setopt(handle: ptr, option: i32, parameter: ptr): i32;\nextern fn curl_easy_perform(handle: ptr): i32;\n// ...\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "What does the following Hemlock code print?\n\n```hemlock\n// Test basic enum declaration and usage\n\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nprint(Color.RED);\nprint(Color.GREEN);\nprint(Color.BLUE);\n```", "output": "0\n1\n2", "category": "tests/enums", "source": "tests/enums/basic_enum.hml"}
{"instruction": "How does convenience constructors work in Hemlock?", "output": "Create a DateTime object from date/time components (local time).\n\n```hemlock\nimport { from_date } from \"@stdlib/datetime\";\n\n// Date only (time defaults to 00:00:00)\nlet date = from_date(2025, 12, 25);\nprint(date.to_string());  // \"2025-12-25 00:00:00\"\n\n// Date and time\nlet datetime = from_date(2025, 3, 15, 14, 30, 45);\nprint(datetime.to_string());  // \"2025-03-15 14:30:45\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does core allocation work in Hemlock?", "output": "**`buffer(size)` - Allocate safe buffer**\n\n```hemlock\nlet buf = buffer(256);  // Allocate 256-byte buffer\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does type queries work in Hemlock?", "output": "Use `typeof()` to check value types:\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hello\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does while loops work in Hemlock?", "output": "```hemlock\nwhile (true) {\n    // ... do work\n    if (should_exit) {\n        break;\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\nfor (initializer; condition; increment) {\n    // body\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does logical or (`||`) work in Hemlock?", "output": "**Short-circuit evaluation:**\n\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() never called\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does building path dynamically work in Hemlock?", "output": "```hemlock\nimport { getenv, setenv } from \"@stdlib/env\";\n\nfn add_to_path(directory: string): null {\n    let current_path = getenv(\"PATH\");\n\n    if (current_path == null) {\n        setenv(\"PATH\", directory);\n    } else {\n        // Check if already in PATH\n        if (!current_path.contains(directory)) {\n            setenv(\"PATH\", current_path + \":\" + directory);\n        }\n    }\n\n    return null;\n}\n\n// Add custom directories to PATH\nadd_to_path(\"/usr/local/myapp/bin\");\nadd_to_path(\"/opt/tools/bin\");\n\nprint(\"Updated PATH: \" + getenv(\"PATH\"));\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does 5. commit your changes work in Hemlock?", "output": "**Good commit messages:**\n\n```hemlock\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does environment implementation work in Hemlock?", "output": "```hemlock\n**Scope chain example:**\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "How does insertion & removal work in Hemlock?", "output": "```hemlock\narray.remove(index: i32): any\n```", "category": "docs", "source": "docs/reference/array-api.md"}
