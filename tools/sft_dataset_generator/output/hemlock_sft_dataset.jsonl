{"instruction": "How does performance testing work in Hemlock?", "output": "Measure execution time:\n\n```hemlock\nimport { time_ms } from \"@stdlib/time\";\n\ntest(\"operation is fast\", fn() {\n    let start = time_ms();\n    expensive_operation();\n    let elapsed = time_ms() - start;\n\n    expect(elapsed).to_be_less_than(1000);  // < 1 second\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Implement a Hemlock program that test array contains method.", "output": "```hemlock\n// Test array contains method\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.contains(3));\nprint(arr.contains(10));\n\nlet strings = [\"hello\", \"world\", \"foo\"];\nprint(strings.contains(\"world\"));\nprint(strings.contains(\"bar\"));\n```", "category": "tests/arrays", "source": "tests/arrays/contains.hml"}
{"instruction": "Create a Hemlock program that test file management: remove_file(), rename(), copy_file().", "output": "```hemlock\n// Test file management: remove_file(), rename(), copy_file()\nimport { write_file, exists, remove_file, rename, copy_file, read_file } from \"@stdlib/fs\";\n\nlet test_file1 = \"/tmp/test_file1.txt\";\nlet test_file2 = \"/tmp/test_file2.txt\";\nlet test_file3 = \"/tmp/test_file3.txt\";\nlet content = \"Test content for file management\";\n\n// Test remove_file()\nwrite_file(test_file1, content);\nassert(exists(test_file1) == true, \"File should exist after write\");\nremove_file(test_file1);\nassert(exists(test_file1) == false, \"File should not exist after remove\");\n\n// Test rename()\nwrite_file(test_file1, content);\nrename(test_file1, test_file2);\nassert(exists(test_file1) == false, \"Original file should not exist after rename\");\nassert(exists(test_file2) == true, \"New file should exist after rename\");\nlet renamed_content = read_file(test_file2);\nassert(renamed_content == content, \"Content should be preserved after rename\");\n\n// Test copy_file()\ncopy_file(test_file2, test_file3);\nassert(exists(test_file3) == true, \"Copied file should exist\");\nlet copied_content = read_file(test_file3);\nassert(copied_content == content, \"Content should match after copy\");\n\n// Verify both files exist\nassert(exists(test_file2) == true, \"Original file should still exist after copy\");\nassert(exists(test_file3) == true, \"Copied file should exist\");\n\n// Clean up\nremove_file(test_file2);\nremove_file(test_file3);\n\nprint(\"All file management tests passed!\");\n```", "category": "tests/io", "source": "tests/io/file_management.hml"}
{"instruction": "Create a Hemlock program that tests the ergonomic wrapper API from @stdlib/net.", "output": "```hemlock\n// Test: TcpListener and TcpStream basic functionality\n// Tests the ergonomic wrapper API from @stdlib/net\n\nimport { TcpListener, TcpStream } from \"@stdlib/net\";\n\nasync fn test_server(port: i32) {\n    let listener = TcpListener(\"127.0.0.1\", port);\n    defer listener.close();\n\n    print(\"Server bound to 127.0.0.1:\" + typeof(port));\n\n    let stream = listener.accept();\n    defer stream.close();\n\n    print(\"Server accepted connection from \" + stream.peer_addr);\n\n    // Read data\n    let data = stream.read(1024);\n    print(\"Server received \" + typeof(data.length) + \" bytes\");\n\n    // Echo back\n    let sent = stream.write(data);\n    print(\"Server sent \" + typeof(sent) + \" bytes\");\n\n    return null;\n}\n\nasync fn test_client(port: i32) {\n    // Give server time to start\n    __sleep(0.1);\n\n    let stream = TcpStream(\"127.0.0.1\", port);\n    defer stream.close();\n\n    print(\"Client connected to 127.0.0.1:\" + typeof(port));\n\n    // Send message\n    let message = \"Hello from stdlib/net!\";\n    let sent = stream.write(message);\n    print(\"Client sent \" + typeof(sent) + \" bytes\");\n\n    // Receive echo\n    let received = stream.read(1024);\n    print(\"Client received \" + typeof(received.length) + \" bytes\");\n\n    return null;\n}\n\nlet test_port = 19999;\n\n// Spawn server and client\nlet server_task = spawn(test_server, test_port);\nlet client_task = spawn(test_client, test_port);\n\n// Wait for completion\njoin(server_task);\njoin(client_task);\n\nprint(\"TcpListener/TcpStream test passed!\");\n```", "category": "tests/stdlib_net", "source": "tests/stdlib_net/tcp_listener_basic.hml"}
{"instruction": "How does don'ts work in Hemlock?", "output": "‚ùå Don't write tests that depend on each other\n\n```hemlock\n// BAD: test2.hml depends on test1.hml output\n// Tests should be independent\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Write a Hemlock program that compile once, use many times.", "output": "```hemlock\n// Test: Reusing compiled patterns\nimport { compile } from \"@stdlib/regex\";\n\n// Compile once, use many times\nlet pattern = compile(\"^[a-z]+@[a-z]+\\\\.[a-z]+$\", null);\n\n// Test multiple strings\nlet test_cases = [\n    \"user@example.com\",\n    \"admin@test.org\",\n    \"invalid.email\",\n    \"test@domain.co\",\n    \"@example.com\",\n    \"user@site.com\"\n];\n\nlet i = 0;\nwhile (i < test_cases.length) {\n    let result = pattern.test(test_cases[i]);\n    print(result);\n    i = i + 1;\n}\n\n// Free once when done\npattern.free();\n\nprint(\"Reuse pattern test passed\");\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/reuse_pattern.hml"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "```hemlock\nlet func = fn(params) {\n    // body\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does type promotion work in Hemlock?", "output": "Hemlock promotes types automatically in mixed operations:\n\ni8 ‚Üí i16 ‚Üí i32 ‚Üí i64 ‚Üí f32 ‚Üí f64\n\nFloats always win in mixed integer/float operations:\n\n```hemlock\nlet i: i32 = 10;\nlet f: f64 = 3.5;\nprint(i + f);  // 13.5 (f64)\n```", "category": "concepts/types", "source": "CLAUDE.md"}
{"instruction": "How does permission checks work in Hemlock?", "output": "Always check if operations succeed:\n\n```hemlock\ntry {\n    kill(target_pid, 15);\n    print(\"Signal sent successfully\");\n} catch (e) {\n    print(\"Failed to send signal: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Show me Hemlock code that test error cases for optional parameters.", "output": "```hemlock\n// Test error cases for optional parameters\n\n// Too few arguments (missing required param)\nfn test1(a: i32, b?: 5) {\n    return a + b;\n}\n\ntry {\n    test1();  // Error: Function expects 1-2 arguments, got 0\n} catch (e) {\n    print(\"Caught: Expected error for too few args\");\n}\n\n// Too many arguments\ntry {\n    test1(1, 2, 3);  // Error: Function expects 1-2 arguments, got 3\n} catch (e) {\n    print(\"Caught: Expected error for too many args\");\n}\n\n// Correct usage\nprint(test1(10));      // 15\nprint(test1(10, 20));  // 30\n\n// All optional parameters - 0 args is valid\nfn test2(a?: 1, b?: 2, c?: 3) {\n    return a + b + c;\n}\n\nprint(test2());            // 6\nprint(test2(10));          // 15\nprint(test2(10, 20));      // 33\nprint(test2(10, 20, 30));  // 60\n\n// Try to call with too many args\ntry {\n    test2(1, 2, 3, 4);  // Error: Function expects 0-3 arguments, got 4\n} catch (e) {\n    print(\"Caught: Expected error for too many args\");\n}\n```", "category": "tests/functions", "source": "tests/functions/optional_params_validation.hml"}
{"instruction": "How do you use defer in Hemlock?", "output": "`defer` schedules code to run when the function returns:\n\n```hemlock\nfn process_file(path: string) {\n    let f = open(path, \"r\");\n    defer f.close();  // runs when function returns\n    \n    // ... work with file ...\n    \n    if (error) {\n        return;  // f.close() still runs\n    }\n    \n    // f.close() runs here too\n}\n```\n\nDeferred statements run in reverse order (LIFO).", "category": "concepts/defer", "source": "CLAUDE.md"}
{"instruction": "Show me Hemlock code that tests to upper lower.", "output": "```hemlock\nlet s = \"Hello World\";\nprint(s.to_upper());\nprint(s.to_lower());\n\nlet s2 = \"ABC123xyz\";\nprint(s2.to_upper());\nprint(s2.to_lower());\n```", "category": "tests/strings", "source": "tests/strings/to_upper_lower.hml"}
{"instruction": "How does binary bitwise work in Hemlock?", "output": "Unsigned Example:*\n\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Write Hemlock code that tests run() function and result reporting.", "output": "```hemlock\n// Test: @stdlib/testing - Test runner\n// Tests run() function and result reporting\n\nimport {\n    describe, test, expect, run\n} from \"@stdlib/testing\";\nimport { exit } from \"@stdlib/env\";\n\ndescribe(\"Test runner results\", fn() {\n    test(\"run returns result object\", fn() {\n        // This will be tested after we run()\n        expect(true).to_be_true();\n    });\n\n    test(\"results have correct fields\", fn() {\n        expect(true).to_be_true();\n    });\n});\n\ndescribe(\"Array deep equality\", fn() {\n    test(\"empty arrays are equal\", fn() {\n        expect([]).to_equal([]);\n    });\n\n    test(\"nested arrays work\", fn() {\n        expect([[1, 2], [3, 4]]).to_equal([[1, 2], [3, 4]]);\n    });\n\n    test(\"different lengths are not equal\", fn() {\n        expect(fn() {\n            expect([1, 2]).to_equal([1, 2, 3]);\n        }).to_throw();\n    });\n\n    test(\"different values are not equal\", fn() {\n        expect(fn() {\n            expect([1, 2, 3]).to_equal([1, 5, 3]);\n        }).to_throw();\n    });\n});\n\ndescribe(\"Error messages\", fn() {\n    test(\"equality failures show values\", fn() {\n        expect(fn() {\n            expect(5).to_equal(10);\n        }).to_throw();\n    });\n\n    test(\"type failures show types\", fn() {\n        expect(fn() {\n            expect(42).to_be_type(\"string\");\n        }).to_throw();\n    });\n\n    test(\"comparison failures show values\", fn() {\n        expect(fn() {\n            expect(5).to_be_greater_than(10);\n        }).to_throw();\n    });\n});\n\ndescribe(\"Mixed type arrays\", fn() {\n    test(\"arrays with different types\", fn() {\n        let arr = [1, \"hello\", true, null];\n        expect(arr.length).to_equal(4);\n        expect(arr).to_contain(1);\n        expect(arr).to_contain(\"hello\");\n        expect(arr).to_contain(true);\n    });\n\n    test(\"mixed arrays equality\", fn() {\n        expect([1, \"two\", 3.0]).to_equal([1, \"two\", 3.0]);\n    });\n});\n\ndescribe(\"Edge cases\", fn() {\n    test(\"comparing null values\", fn() {\n        expect(null).to_equal(null);\n        expect(null).to_be_null();\n    });\n\n    test(\"empty string vs null\", fn() {\n        expect(\"\").not_to_equal(null);\n        expect(\"\").not_to_be_null();\n    });\n\n    test(\"zero vs false\", fn() {\n        expect(0).not_to_equal(false);\n    });\n\n    test(\"empty array is not null\", fn() {\n        expect([]).not_to_be_null();\n    });\n});\n\ndescribe(\"Numeric edge cases\", fn() {\n    test(\"negative numbers\", fn() {\n        expect(-5).to_be_less_than(0);\n        expect(-10).to_be_less_than(-5);\n    });\n\n    test(\"floating point\", fn() {\n        expect(3.14).to_be_greater_than(3.0);\n        expect(3.14).to_be_less_than(3.2);\n    });\n\n    test(\"comparing different numeric types\", fn() {\n        expect(42).to_equal(42);\n    });\n});\n\n// Run tests - this will execute all registered describe/test blocks above\nlet results = run({ no_color: true });\n\n// Exit with error if any tests failed\nif (!results.success) {\n    exit(1);\n}\n```", "category": "tests/stdlib_testing", "source": "tests/stdlib_testing/test_runner.hml"}
{"instruction": "Create a Hemlock program that test enum declarations and usage.", "output": "```hemlock\n// Test enum declarations and usage\n\n// Simple enum with auto values\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nprint(Color.RED);\nprint(Color.GREEN);\nprint(Color.BLUE);\n\n// Enum with explicit values\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 100\n}\n\nprint(Status.OK);\nprint(Status.ERROR);\nprint(Status.PENDING);\n\n// Enum comparison\nlet color = Color.GREEN;\nif (color == Color.GREEN) {\n    print(\"is green\");\n}\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/enums.hml"}
{"instruction": "How does switch statements work in Hemlock?", "output": "```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other day\");\n        break;\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Write Hemlock code that shallow copy test.", "output": "```hemlock\n// Shallow copy test\nlet a = { x: 10, nested: { y: 20 } };\nlet b = a;\n\n// Modify top-level field\nb.x = 99;\nprint(a.x);  // Should still be 10 (copied)\n\n// Modify nested field\nb.nested.y = 999;\nprint(a.nested.y);  // Should be 999 (shared)\n```", "category": "tests/objects", "source": "tests/objects/shallow_copy.hml"}
{"instruction": "How does basic parameters work in Hemlock?", "output": "```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show an example of example: adding a new operator in Hemlock.", "output": "6. Tests (tests/operators/modulo.hml):*\n\n```hemlock\n// Basic modulo\nprint(10 % 3);  // Expect: 2\n\n// Negative modulo\nprint(-10 % 3); // Expect: -1\n\n// Error case (should fail)\n// print(10 % 0);  // Division by zero\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does birthday calculator work in Hemlock?", "output": "```hemlock\nimport { from_date, now } from \"@stdlib/datetime\";\n\nlet birthday = from_date(1990, 5, 15, 0, 0, 0);\nlet today = now();\n\nlet days_old = today.diff_days(birthday);\nlet years_old = days_old / 365;\n\nprint(\"Born on: \" + birthday.format(\"%B %d, %Y\"));\nprint(\"Age: ~\" + typeof(years_old) + \" years\");\nprint(\"Days old: \" + typeof(days_old));\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Show me Hemlock code that test that let variables can still be reassigned.", "output": "```hemlock\n// Test that let variables can still be reassigned\nlet x = 10;\nprint(x);\n\nx = 20;\nprint(x);\n\nx = 30;\nprint(x);\n\n// Expected output:\n// 10\n// 20\n// 30\n```", "category": "tests/const", "source": "tests/const/let_still_works.hml"}
{"instruction": "Implement a Hemlock program that test string interpolation with backticks.", "output": "```hemlock\n// Test string interpolation with backticks\n\nlet name = \"Alice\";\nlet age = 30;\n\n// Basic interpolation\nprint(`Hello, ${name}!`);\n\n// Multiple interpolations\nprint(`${name} is ${age} years old.`);\n\n// Expressions\nlet x = 10;\nlet y = 20;\nprint(`Sum: ${x + y}`);\nprint(`Product: ${x * y}`);\n\n// Array access in interpolation\nlet arr = [1, 2, 3];\nprint(`First: ${arr[0]}, Last: ${arr[2]}`);\nprint(`Length: ${arr.length}`);\n\n// Escape sequences\nprint(`Price: \\$100`);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/string_interpolation.hml"}
{"instruction": "How does date range iteration work in Hemlock?", "output": "```hemlock\nimport { from_date } from \"@stdlib/datetime\";\n\nlet start = from_date(2025, 1, 1, 0, 0, 0);\nlet end = from_date(2025, 1, 7, 0, 0, 0);\n\nlet current = start;\nwhile (current.is_before(end) || current.is_equal(end)) {\n    print(current.format(\"%A, %B %d, %Y\"));\n    current = current.add_days(1);\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport { get_pid, getppid, exec, kill } from \"@stdlib/process\";\nimport { sleep } from \"@stdlib/time\";\n\n// Display process info\nprint(\"=== Process Info ===\");\nprint(\"PID: \" + typeof(get_pid()));\nprint(\"PPID: \" + typeof(getppid()));\n\n// Execute commands\nprint(\"\\n=== Command Execution ===\");\nlet result = exec(\"uname -s\");\nprint(\"OS: \" + result.output.trim());\n\nlet files = exec(\"ls -1 | wc -l\");\nprint(\"Files in directory: \" + files.output.trim());\n\n// Check process status\nprint(\"\\n=== Process Management ===\");\nfn check_process(name: string) {\n    let result = exec(\"pgrep \" + name);\n    if (result.exit_code == 0) {\n        print(name + \" is running (PID: \" + result.output.trim() + \")\");\n        return true;\n    } else {\n        print(name + \" is not running\");\n        return false;\n    }\n}\n\ncheck_process(\"ssh\");\ncheck_process(\"httpd\");\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does getegid(): i32 work in Hemlock?", "output": "Get the effective group ID of the current process.\n\n```hemlock\nlet egid = getegid();\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does reading elements work in Hemlock?", "output": "Zero-indexed access:\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10 (first element)\nprint(arr[4]);  // 50 (last element)\n\n// Out of bounds returns null (no error)\nprint(arr[10]);  // null\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does repl behavior work in Hemlock?", "output": "In the REPL, args.length is 0 (empty array):\n\n```hemlock\n# REPL session\n> print(args.length);\n0\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does duck typing (objects) work in Hemlock?", "output": "Objects use structural typing (duck typing):\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Has all required fields\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Extra fields allowed\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// ERROR: Missing 'age' field\nlet p3: Person = { name: \"Carol\" };\n\n// ERROR: Wrong type for 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does implicit conversions work in Hemlock?", "output": "```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result is i32 (promoted)\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does logical operators work in Hemlock?", "output": "```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Short-circuit\nif (x != 0 && (10 / x) > 2) {\n    print(\"safe\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"safe\");\n}\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does convenience functions work in Hemlock?", "output": "```hemlock\nimport { debug, info, warn, error, log } from \"@stdlib/logging\";\nimport { DEBUG } from \"@stdlib/logging\";\n\n// These use the default logger internally\ndebug(\"Debug message\");\ninfo(\"Info message\");\nwarn(\"Warning message\");\nerror(\"Error message\");\nlog(DEBUG, \"Custom level\");\n\n// With structured data\ninfo(\"User action\", { action: \"click\", button: \"submit\" });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Create a Hemlock program that tests nested try.", "output": "```hemlock\n// Test: Nested try/catch blocks\ntry {\n    print(\"outer try\");\n    try {\n        print(\"inner try\");\n        throw \"inner error\";\n    } catch (e) {\n        print(\"inner catch: \" + e);\n    }\n    print(\"between\");\n    throw \"outer error\";\n} catch (e) {\n    print(\"outer catch: \" + e);\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/nested_try.hml"}
{"instruction": "How does good use cases work in Hemlock?", "output": "4. File existence checks:*\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { getenv, setenv, exit } from \"@stdlib/env\";\n\nlet path = getenv(\"PATH\");\nif (path == null) {\n    print(\"PATH not set\");\n    exit(1);\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "Write a Hemlock program that test compound assignment operators.", "output": "```hemlock\n// Test compound assignment operators\n\n// Basic compound assignment\nlet a = 10;\na = a + 5;\nprint(a);\n\na = a - 3;\nprint(a);\n\na = a * 2;\nprint(a);\n\na = divi(a, 4);  // Use integer division to keep a as integer\nprint(a);\n\na = a % 5;\nprint(a);\n\n// With different types\nlet b = 3.14;\nb = b + 1.0;\nprint(b);\n\n// String concatenation\nlet s = \"Hello\";\ns = s + \" World\";\nprint(s);\n\n// Array modification through index\nlet arr = [1, 2, 3];\narr[0] = arr[0] + 10;\nprint(arr[0]);\n\narr[1] = arr[1] * 5;\nprint(arr[1]);\n\n// Object property modification\nlet obj = { x: 100, y: 200 };\nobj.x = obj.x + 50;\nprint(obj.x);\n\nobj.y = divi(obj.y, 2);  // Use integer division for integer result\nprint(obj.y);\n\n// Bitwise compound\nlet c = 0b1010;\nc = c | 0b0101;\nprint(c);\n\nc = c & 0b1100;\nprint(c);\n\nc = c ^ 0b1111;\nprint(c);\n\n// Shift compound\nlet d = 1;\nd = d << 4;\nprint(d);\n\nd = d >> 2;\nprint(d);\n\n// Nested object modification\nlet nested = { inner: { value: 10 } };\nnested.inner.value = nested.inner.value * 3;\nprint(nested.inner.value);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/compound_assignment.hml"}
{"instruction": "How does integer + float work in Hemlock?", "output": "```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does .length property work in Hemlock?", "output": "Returns the number of elements:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// Empty array\nlet empty = [];\nprint(empty.length);  // 0\n\n// After modifications\narr.push(6);\nprint(arr.length);  // 6\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Write a Hemlock program that tests loop write.", "output": "```hemlock\nlet b = buffer(5);\nlet i = 0;\nwhile (i < b.length) {\n    b[i] = i + 10;\n    i = i + 1;\n}\n\ni = 0;\nwhile (i < b.length) {\n    print(b[i]);\n    i = i + 1;\n}\n\nfree(b);\n```", "category": "tests/buffers", "source": "tests/buffers/loop_write.hml"}
{"instruction": "How does type conversion work in Hemlock?", "output": "Example type mappings:*\n\n```hemlock\n// Hemlock ‚Üí C\nlet i: i32 = 42;         // ‚Üí int32_t (4 bytes)\nlet f: f64 = 3.14;       // ‚Üí double (8 bytes)\nlet p: ptr = alloc(64);  // ‚Üí void* (8 bytes)\n\n// C ‚Üí Hemlock (return values)\n// int32_t foo() ‚Üí i32\n// double bar() ‚Üí f64\n// void* baz() ‚Üí ptr\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does logical not (!) work in Hemlock?", "output": "Negates boolean value:\n\n```hemlock\nif (!is_valid) {\n    print(\"invalid\");\n}\n\nif (!(x > 10)) {\n    // Same as: if (x <= 10)\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write a Hemlock program that test binary literals.", "output": "```hemlock\n// Test binary literals\n\n// Basic binary values\nlet a = 0b0;\nlet b = 0b1;\nlet c = 0b10;\nlet d = 0b1010;\nlet e = 0b11111111;\n\nprint(a);  // 0\nprint(b);  // 1\nprint(c);  // 2\nprint(d);  // 10\nprint(e);  // 255\n\n// Uppercase B\nlet f = 0B1100;\nprint(f);  // 12\n\n// Binary with type annotations\nlet g: u8 = 0b11111111;\nlet h: i32 = 0b10101010;\nlet i: u16 = 0b1111111111111111;\n\nprint(g);  // 255\nprint(h);  // 170\nprint(i);  // 65535\n\n// Binary in expressions\nlet j = 0b1010 + 0b0101;\nlet k = 0b1000 * 0b10;\nlet l = 0b10000 / 0b10;\n\nprint(j);  // 15\nprint(k);  // 16\nprint(l);  // 8\n\n// Binary with bitwise operations\nlet m = 0b1111 & 0b1010;\nlet n = 0b1100 | 0b0011;\nlet o = 0b1111 ^ 0b0101;\nlet p = 0b0001 << 4;\nlet q = 0b10000 >> 2;\n\nprint(m);  // 10\nprint(n);  // 15\nprint(o);  // 10\nprint(p);  // 16\nprint(q);  // 4\n\n// Large binary values (32-bit)\nlet r: u32 = 0b01111111111111111111111111111111;\nprint(r);  // 2147483647\n\n// Common patterns\nlet byte_mask = 0b11111111;\nlet nibble = 0b1111;\nlet msb = 0b10000000;\nlet lsb = 0b00000001;\n\nprint(byte_mask);  // 255\nprint(nibble);     // 15\nprint(msb);        // 128\nprint(lsb);        // 1\n```", "category": "tests/primitives", "source": "tests/primitives/binary_literals.hml"}
{"instruction": "What integer types are available in Hemlock?", "output": "Hemlock provides signed and unsigned integers:\n\n**Signed:** i8, i16, i32, i64\n**Unsigned:** u8, u16, u32, u64\n\nType aliases: `integer` (i32), `byte` (u8)\n\nLiterals auto-detect size:\n```hemlock\nlet x = 42;           // i32\nlet big = 5000000000; // i64 (exceeds i32 max)\nlet hex = 0xDEADBEEF; // hex literal\nlet bin = 0b1010;     // binary literal\n```", "category": "concepts/types", "source": "CLAUDE.md"}
{"instruction": "How does pointer arithmetic work in Hemlock?", "output": "Use buffers for bounds checking:*\n\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // ERROR: Bounds check prevents overflow\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does hex_encode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { hex_encode } from \"@stdlib/encoding\";\n\n// Basic encoding\nlet hex1 = hex_encode(\"Hello\");\nprint(hex1);  // \"48656c6c6f\"\n\n// Binary data\nlet data = \"\";\nlet b1: rune = 0;\nlet b2: rune = 255;\ndata = data + b1 + b2;\nlet hex2 = hex_encode(data);\nprint(hex2);  // \"00ff\"\n\n// Unicode (UTF-8 bytes are hex-encoded)\nlet hex3 = hex_encode(\"üöÄ\");\nprint(hex3);  // UTF-8 encoding of rocket emoji\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "Write a Hemlock program that test that signal constants are defined and have expected values Note: Some signal values differ between Linux and macOS We test portable signals with known values, and just verify others exist.", "output": "```hemlock\n// Test that signal constants are defined and have expected values\n// Note: Some signal values differ between Linux and macOS\n// We test portable signals with known values, and just verify others exist\n\n// These signals have the same values on Linux and macOS\nassert(SIGINT == 2);\nassert(SIGTERM == 15);\nassert(SIGHUP == 1);\nassert(SIGQUIT == 3);\nassert(SIGABRT == 6);\nassert(SIGALRM == 14);\nassert(SIGPIPE == 13);\n\n// These signals exist but have platform-specific values\n// SIGUSR1: Linux=10, macOS=30\n// SIGUSR2: Linux=12, macOS=31\n// Just verify they are defined and positive\nassert(SIGUSR1 > 0);\nassert(SIGUSR2 > 0);\nassert(SIGUSR1 != SIGUSR2);\n\nprint(\"PASS: signal_constants\");\n```", "category": "tests/signals", "source": "tests/signals/signal_constants.hml"}
{"instruction": "How does asserttrue(value) / assertfalse(value) work in Hemlock?", "output": "Assert boolean values.\n\n```hemlock\ntest(\"boolean assertions\", fn() {\n    assert_true(10 > 5);\n    assert_false(10 < 5);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does pitfall: modifying captured variables work in Hemlock?", "output": "```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Can read and modify captured variables\n        return count;\n    };\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show an example of example: function pipeline in Hemlock.", "output": "```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    // Note: variadic functions not supported yet\n    // This is conceptual\n    return result;\n}\n\n// Workaround: manual composition\nfn process(value) {\n    return increment(double(trim(value)));\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does explicit conversions work in Hemlock?", "output": "```hemlock\n// Integer to float\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Float to integer (truncates)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Integer to rune\nlet code: rune = 65;    // 'A'\n\n// Rune to integer\nlet value: i32 = 'Z';   // 90\n\n// Rune to string\nlet s: string = 'H';    // \"H\"\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Write Hemlock code that test that alloc returns non-null for successful allocations and that the null-check pattern works correctly Expected: PASS.", "output": "```hemlock\n// Test that alloc returns non-null for successful allocations\n// and that the null-check pattern works correctly\n// Expected: PASS\n\n// Test alloc with null check\nlet p = alloc(64);\nif (p == null) {\n    print(\"ERROR: alloc returned null unexpectedly\");\n} else {\n    print(\"PASS: alloc returned valid pointer\");\n    memset(p, 0, 64);\n    free(p);\n}\n\n// Test buffer with null check\nlet buf = buffer(128);\nif (buf == null) {\n    print(\"ERROR: buffer returned null unexpectedly\");\n} else {\n    print(\"PASS: buffer returned valid buffer\");\n    buf[0] = 65;\n    free(buf);\n}\n\n// Test talloc with null check\nlet arr = talloc(i32, 10);\nif (arr == null) {\n    print(\"ERROR: talloc returned null unexpectedly\");\n} else {\n    print(\"PASS: talloc returned valid pointer\");\n    free(arr);\n}\n\n// Test realloc with null check\nlet p2 = alloc(32);\nif (p2 == null) {\n    print(\"ERROR: alloc for realloc test returned null\");\n} else {\n    let p3 = realloc(p2, 64);\n    if (p3 == null) {\n        print(\"ERROR: realloc returned null unexpectedly\");\n        free(p2);  // Original still valid on realloc failure\n    } else {\n        print(\"PASS: realloc returned valid pointer\");\n        free(p3);\n    }\n}\n\nprint(\"All null-check pattern tests passed\");\n```", "category": "tests/memory", "source": "tests/memory/alloc_null_check.hml"}
{"instruction": "Implement a Hemlock program that test primitives: integers, strings, booleans.", "output": "```hemlock\n// Test primitives: integers, strings, booleans\nlet x = 42;\nprint(x);\n\nlet y = -10;\nprint(y);\n\nlet s = \"Hello, World!\";\nprint(s);\n\nlet b = true;\nprint(b);\n\nlet f = false;\nprint(f);\n\nlet n = null;\nprint(n);\n```", "category": "tests/compiler", "source": "tests/compiler/primitives.hml"}
{"instruction": "How does asyncmakedir work in Hemlock?", "output": "```hemlock\nimport { async_make_dir } from \"@stdlib/async_fs\";\n\nlet future = async_make_dir(\"./output\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does configuration file manager work in Hemlock?", "output": "```hemlock\nimport { exists, read_file, write_file } from \"@stdlib/fs\";\n\nfn load_config(path: string, defaults: object): object {\n    if (!exists(path)) {\n        print(\"Config not found, creating default\");\n        let json = defaults.serialize();\n        write_file(path, json);\n        return defaults;\n    }\n\n    try {\n        let json = read_file(path);\n        let config = json.deserialize();\n        return config;\n    } catch (e) {\n        print(\"Error loading config: \" + e);\n        return defaults;\n    }\n}\n\nfn save_config(path: string, config: object): bool {\n    try {\n        let json = config.serialize();\n        write_file(path, json);\n        return true;\n    } catch (e) {\n        print(\"Error saving config: \" + e);\n        return false;\n    }\n}\n\n// Usage\nlet defaults = { port: 8080, debug: false };\nlet config = load_config(\"config.json\", defaults);\nconfig.debug = true;\nsave_config(\"config.json\", config);\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does standard library versioning work in Hemlock?", "output": "The standard library (@stdlib/*) is versioned with the main release:\n\n```hemlock\n// Always uses the stdlib bundled with your Hemlock installation\nimport { HashMap } from \"@stdlib/collections\";\nimport { sin, cos } from \"@stdlib/math\";\n```", "category": "docs", "source": "docs/versioning.md"}
{"instruction": "How does object type work in Hemlock?", "output": "Type Definitions:*\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Optional field\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Implement a Hemlock program that closure test - validates closures work correctly.", "output": "```hemlock\n// Closure test - validates closures work correctly\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));\nprint(add5(10));\n```", "category": "tests/manual", "source": "tests/manual/valgrind_test_closures.hml"}
{"instruction": "Show an example of example: multi-module project in Hemlock.", "output": "```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```", "category": "docs", "source": "docs/advanced/bundling-packaging.md"}
{"instruction": "How does terminal dashboard work in Hemlock?", "output": "```hemlock\nimport { clear, move_to, color, GREEN, YELLOW, RED, size } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nfn dashboard(): null {\n    let running = true;\n    let counter = 0;\n\n    while (running && counter < 50) {\n        clear();\n\n        let term = size();\n\n        // Title\n        exec(\"printf '\" + move_to(1, 1) + \"'\");\n        print(color(\"=== System Dashboard ===\", GREEN));\n\n        // Stats\n        print(\"\");\n        print(\"Counter: \" + typeof(counter));\n        print(\"Terminal: \" + typeof(term.rows) + \"x\" + typeof(term.cols));\n\n        // Status indicators\n        if (counter % 2 == 0) {\n            print(color(\"‚óè Service A: Running\", GREEN));\n        } else {\n            print(color(\"‚óè Service A: Idle\", YELLOW));\n        }\n\n        if (counter % 3 == 0) {\n            print(color(\"‚óè Service B: Active\", GREEN));\n        } else {\n            print(color(\"‚óè Service B: Waiting\", RED));\n        }\n\n        sleep(0.5);\n        counter = counter + 1;\n    }\n\n    return null;\n}\n\ndashboard();\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does race conditions work in Hemlock?", "output": "Handlers can be called at any time, interrupting normal execution:\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // Race condition if called during counter update\n}\n\nsignal(SIGUSR1, increment);\n\n// Main code also modifies counter\ncounter = counter + 1;  // Could be interrupted by signal handler\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does getgid(): i32 work in Hemlock?", "output": "Get the real group ID of the current process.\n\n```hemlock\nlet gid = getgid();\nprint(\"Group ID: \" + typeof(gid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does retry with exponential backoff work in Hemlock?", "output": "```hemlock\nimport { sleep } from \"@stdlib/time\";\n\nfn retry_with_backoff(operation: function, max_attempts: i32): bool {\n    let attempt = 0;\n    let delay = 0.1;  // Start with 100ms\n\n    while (attempt < max_attempts) {\n        try {\n            operation();\n            return true;  // Success\n        } catch (e) {\n            print(\"Attempt \" + typeof(attempt + 1) + \" failed: \" + e);\n            if (attempt < max_attempts - 1) {\n                print(\"Retrying in \" + typeof(delay) + \"s...\");\n                sleep(delay);\n                delay = delay * 2.0;  // Double delay each time\n            }\n        }\n        attempt = attempt + 1;\n    }\n\n    return false;  // All attempts failed\n}\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does pattern: factory functions work in Hemlock?", "output": "```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show an example of example 2: batch file processor in Hemlock.", "output": "```hemlock\n// Usage: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Processing: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // Process content...\n            print(\"    \" + typeof(content.length) + \" bytes\");\n        } catch (e) {\n            print(\"    Error: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Done!\");\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does asyncfilestat work in Hemlock?", "output": "```hemlock\nasync_file_stat(path: string): Future<object>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All functions include comprehensive error checking:\n\n```hemlock\nimport { base64_encode, base64_decode, hex_decode, url_decode } from \"@stdlib/encoding\";\n\n// Type checking\ntry {\n    base64_encode(123);  // ERROR: not a string\n} catch (e) {\n    print(\"Error: \" + e);  // \"base64_encode() requires string argument\"\n}\n\n// Invalid Base64\ntry {\n    base64_decode(\"ABC\");  // ERROR: not multiple of 4\n} catch (e) {\n    print(\"Error: \" + e);  // \"Invalid Base64 string: length must be multiple of 4\"\n}\n\n// Invalid hex\ntry {\n    hex_decode(\"XYZ\");  // ERROR: invalid characters\n} catch (e) {\n    print(\"Error: \" + e);  // \"Invalid hex string: invalid character\"\n}\n\n// Invalid URL encoding\ntry {\n    url_decode(\"Hello%2\");  // ERROR: incomplete percent sequence\n} catch (e) {\n    print(\"Error: \" + e);  // \"Invalid URL encoding: incomplete percent sequence\"\n}\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does concatenation work in Hemlock?", "output": "```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// String + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does finally block work in Hemlock?", "output": "Finally with return:*\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // ‚úÖ Returns 1 after finally runs\n    } finally {\n        print(\"cleanup\");  // Runs before returning\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // ‚ö†Ô∏è Finally return overrides - returns 2\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does path types work in Hemlock?", "output": "Relative Paths:*\n\n```hemlock\nimport { foo } from \"./module.hml\";       // Same directory\nimport { bar } from \"../parent.hml\";      // Parent directory\nimport { baz } from \"./sub/nested.hml\";   // Subdirectory\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does basic syntax work in Hemlock?", "output": "Single quotes denote rune literals:\n\n```hemlock\nlet a = 'A';            // ASCII character\nlet b = '0';            // Digit character\nlet c = '!';            // Punctuation\nlet d = ' ';            // Space\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does safe buffer pattern work in Hemlock?", "output": "```hemlock\n// Allocate buffer\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"buffer allocation failed\");\n}\n\n// Use with bounds checking\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Free\nfree(buf);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does sending messages work in Hemlock?", "output": "```hemlock\nlet success = ws.send_text(\"Hello, WebSocket!\");\nif (success) {\n    print(\"Message sent\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does basic colors (foreground) work in Hemlock?", "output": "```hemlock\nimport { BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE } from \"@stdlib/terminal\";\n\nprint(RED + \"Red text\" + RESET);\nprint(GREEN + \"Green text\" + RESET);\nprint(BLUE + \"Blue text\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How do you provide usage information in Hemlock?", "output": "```hemlock\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show help\");\n    print(\"  -v, --verbose  Verbose output\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does unary arithmetic work in Hemlock?", "output": "```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (no change)\n\nlet x = -3.14;         // -3.14\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does filter pattern work in Hemlock?", "output": "```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does type definitions (duck typing) work in Hemlock?", "output": "```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // Optional with default\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // Duck typing validates structure\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true (default applied)\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does rgb(r, g, b) work in Hemlock?", "output": "Returns:* string - RGB color code\n\n```hemlock\nimport { rgb, RESET } from \"@stdlib/terminal\";\n\nprint(rgb(255, 100, 50) + \"Custom orange\" + RESET);\nprint(rgb(75, 0, 130) + \"Indigo text\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Create a Hemlock program that accessing different types of fields.", "output": "```hemlock\n// Accessing different types of fields\nlet obj = {\n    num: 42,\n    str: \"hello\",\n    flag: true,\n    flt: 3.14,\n};\nprint(obj.num);\nprint(obj.str);\nprint(obj.flag);\nprint(obj.flt);\n```", "category": "tests/objects", "source": "tests/objects/field_access_types.hml"}
{"instruction": "Create a Hemlock program that test gzip compression and decompression.", "output": "```hemlock\n// Test gzip compression and decompression\nimport { gzip, gunzip } from \"@stdlib/compression\";\n\n// Test basic gzip\nlet original = \"Hello, World! This is a test for gzip compression.\";\nlet compressed = gzip(original);\n\n// Verify gzip magic bytes\nprint(compressed[0] == 31);   // 0x1f\nprint(compressed[1] == 139);  // 0x8b\n\n// Decompress\nlet restored = gunzip(compressed);\nprint(restored == original);  // true\n\n// Test with compression level 9 (best)\nlet original2 = \"Testing gzip with maximum compression level.\";\nlet compressed2 = gzip(original2, 9);\nlet restored2 = gunzip(compressed2);\nprint(restored2 == original2);  // true\n\n// Test with compression level 1 (fastest)\nlet original3 = \"Testing gzip with fastest compression level.\";\nlet compressed3 = gzip(original3, 1);\nlet restored3 = gunzip(compressed3);\nprint(restored3 == original3);  // true\n\nprint(\"Gzip tests passed!\");\n```", "category": "tests/stdlib_compression", "source": "tests/stdlib_compression/gzip_test.hml"}
{"instruction": "How does always check exit codes work in Hemlock?", "output": "```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Command failed!\");\n    // Handle error\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does detach only when necessary work in Hemlock?", "output": "Prefer join() over detach() for better resource management:\n\n```hemlock\n// Good: Join and get result\nlet task = spawn(work);\nlet result = join(task);\n\n// Use detach only for true fire-and-forget\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // Will run independently\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Write a Hemlock program that test @stdlib/math imports.", "output": "```hemlock\n// Test @stdlib/math imports\nimport { PI, sqrt, abs, sin, cos, floor, ceil, min, max } from \"@stdlib/math\";\n\n// Test constants\nprint(PI);\n\n// Test single-arg functions\nprint(sqrt(16.0));\nprint(abs(-42));\nprint(floor(3.7));\nprint(ceil(3.2));\n\n// Test two-arg functions\nprint(min(10, 5));\nprint(max(10, 5));\n\n// Test trig\nlet angle = PI / 2.0;\nprint(floor(sin(angle) * 100.0));\nprint(floor(cos(0.0) * 100.0));\n```", "category": "tests/parity", "source": "tests/parity/modules/stdlib_math.hml"}
{"instruction": "Implement a Hemlock program that test append_file() function.", "output": "```hemlock\n// Test append_file() function\nimport { write_file, append_file, read_file, remove_file } from \"@stdlib/fs\";\n\nlet test_file = \"/tmp/test_append.txt\";\n\n// Write initial content\nwrite_file(test_file, \"Line 1\\n\");\n\n// Append more content\nappend_file(test_file, \"Line 2\\n\");\nappend_file(test_file, \"Line 3\\n\");\n\n// Read and verify\nlet content = read_file(test_file);\nlet expected = \"Line 1\\nLine 2\\nLine 3\\n\";\nassert(content == expected, \"append_file() should append content correctly\");\n\n// Clean up\nremove_file(test_file);\n\nprint(\"All append_file() tests passed!\");\n```", "category": "tests/io", "source": "tests/io/append_file.hml"}
{"instruction": "Show an example of complete producer-consumer example in Hemlock.", "output": "```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel with buffer size\nlet ch = channel(10);\n\n// Spawn producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for completion\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does type definitions work in Hemlock?", "output": "```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does creating a server work in Hemlock?", "output": "```hemlock\nimport { WebSocketServer } from \"@stdlib/websocket\";\n\nlet server = WebSocketServer(\"0.0.0.0\", 8080);\ndefer server.close();\n\nprint(\"Server listening on :8080\");\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Write a Hemlock program that nested objects.", "output": "```hemlock\n// Nested objects\nlet outer = {\n    x: 10,\n    inner: {\n        y: 20,\n    },\n};\n\nprint(outer.x);\nprint(outer.inner);\n```", "category": "tests/objects", "source": "tests/objects/nested_basic.hml"}
{"instruction": "How does else-if chains work in Hemlock?", "output": "Note:* else if is syntactic sugar for nested if statements. These are equivalent:\n\n```hemlock\n// else if (syntactic sugar)\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// Equivalent nested if\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does copyfilesparallel work in Hemlock?", "output": "```hemlock\ncopy_files_parallel(copies: array<object>): null\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Show me Hemlock code that test const with type annotation.", "output": "```hemlock\n// Test const with type annotation\nconst x: i32 = 100;\nprint(x);\n\nconst y: f64 = 3.14;\nprint(y);\n\nconst z: string = \"hello\";\nprint(z);\n\n// Expected output:\n// 100\n// 3.14\n// hello\n```", "category": "tests/const", "source": "tests/const/const_with_type.hml"}
{"instruction": "How does prefix/suffix checking work in Hemlock?", "output": "starts_with(prefix)* - Check if starts with prefix:\n\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does type safety patterns work in Hemlock?", "output": "Validate function arguments:*\n\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"arguments must be integers\";\n    }\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Write Hemlock code that test for loop with empty clauses.", "output": "```hemlock\n// Test for loop with empty clauses\nlet i = 0;\nfor (; i < 3; ) {\n    print(i);\n    i = i + 1;\n}\n```", "category": "tests/loops", "source": "tests/loops/for_empty.hml"}
{"instruction": "Write a Hemlock program that tests strlen test.", "output": "```hemlock\n// Test: FFI strlen function\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\n\nlet msg = \"Hello, Hemlock!\";\nlet len = strlen(msg);\n\nprint(len);\n```", "category": "tests/ffi", "source": "tests/ffi/strlen_test.hml"}
{"instruction": "Show an example of complete example: secure file storage in Hemlock.", "output": "Encrypt a file with AES and sign it with ECDSA to ensure authenticity and integrity.\n\n```hemlock\nimport { generate_aes_key, generate_iv, aes_encrypt, aes_decrypt } from \"@stdlib/crypto\";\nimport { ecdsa_generate_key, ecdsa_sign, ecdsa_verify, ecdsa_free_keys } from \"@stdlib/crypto\";\nimport { buffer_to_hex, hex_to_buffer } from \"@stdlib/crypto\";\nimport { write_file, read_file } from \"@stdlib/fs\";\n\n// Step 1: Generate keys\nlet aes_key = generate_aes_key();\nlet aes_iv = generate_iv();\nlet signing_key = ecdsa_generate_key();\ndefer ecdsa_free_keys(signing_key);\n\nprint(\"Keys generated\");\n\n// Step 2: Encrypt data\nlet plaintext = \"Sensitive financial data: $1,000,000 transaction\";\nlet ciphertext = aes_encrypt(plaintext, aes_key, aes_iv);\n\nprint(\"Data encrypted (\" + typeof(ciphertext.length) + \" bytes)\");\n\n// Step 3: Sign ciphertext\nlet ciphertext_hex = buffer_to_hex(ciphertext);\nlet signature = ecdsa_sign(ciphertext_hex, signing_key);\n\nprint(\"Data signed (\" + typeof(signature.length) + \" bytes)\");\n\n// Step 4: Save to file (in real app, you'd save key/IV securely)\nwrite_file(\"encrypted.bin\", ciphertext_hex);\nwrite_file(\"signature.bin\", buffer_to_hex(signature));\n\nprint(\"Files saved\");\n\n// Step 5: Load and verify\nlet loaded_ciphertext_hex = read_file(\"encrypted.bin\");\nlet loaded_signature_hex = read_file(\"signature.bin\");\n\nlet loaded_ciphertext = hex_to_buffer(loaded_ciphertext_hex);\nlet loaded_signature = hex_to_buffer(loaded_signature_hex);\n\n// Step 6: Verify signature\nlet valid = ecdsa_verify(loaded_ciphertext_hex, loaded_signature, signing_key);\n\nif (!valid) {\n    panic(\"Signature verification failed! File may be tampered.\");\n}\n\nprint(\"‚úì Signature verified\");\n\n// Step 7: Decrypt\nlet decrypted = aes_decrypt(loaded_ciphertext, aes_key, aes_iv);\n\nprint(\"Decrypted: \" + decrypted);\n\nif (decrypted == plaintext) {\n    print(\"‚úì File integrity verified!\");\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does floor(x) work in Hemlock?", "output": "Returns:* f64 - Floor of x\n\n```hemlock\nimport { floor } from \"@stdlib/math\";\n\nlet result = floor(3.7);   // 3.0\nlet result2 = floor(-2.3); // -3.0\nlet result3 = floor(5.0);  // 5.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Write a Hemlock program that zero or more (*).", "output": "```hemlock\n// Test: Quantifiers\nimport { test } from \"@stdlib/regex\";\n\n// Zero or more (*)\nprint(test(\"^ab*c$\", \"ac\", null));        // true\nprint(test(\"^ab*c$\", \"abc\", null));       // true\nprint(test(\"^ab*c$\", \"abbc\", null));      // true\n\n// One or more (+)\nprint(test(\"^ab+c$\", \"ac\", null));        // false\nprint(test(\"^ab+c$\", \"abc\", null));       // true\nprint(test(\"^ab+c$\", \"abbc\", null));      // true\n\n// Zero or one (?)\nprint(test(\"^ab?c$\", \"ac\", null));        // true\nprint(test(\"^ab?c$\", \"abc\", null));       // true\nprint(test(\"^ab?c$\", \"abbc\", null));      // false\n\n// Exact count {n}\nprint(test(\"^a{3}$\", \"aaa\", null));       // true\nprint(test(\"^a{3}$\", \"aa\", null));        // false\nprint(test(\"^a{3}$\", \"aaaa\", null));      // false\n\n// At least {n,}\nprint(test(\"^a{2,}$\", \"a\", null));        // false\nprint(test(\"^a{2,}$\", \"aa\", null));       // true\nprint(test(\"^a{2,}$\", \"aaaa\", null));     // true\n\n// Range {n,m}\nprint(test(\"^a{2,4}$\", \"a\", null));       // false\nprint(test(\"^a{2,4}$\", \"aa\", null));      // true\nprint(test(\"^a{2,4}$\", \"aaa\", null));     // true\nprint(test(\"^a{2,4}$\", \"aaaa\", null));    // true\nprint(test(\"^a{2,4}$\", \"aaaaa\", null));   // false\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/quantifiers.hml"}
{"instruction": "How does string type work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (codepoints)\nprint(s.byte_length);   // 5 (bytes)\n\nlet emoji = \"üöÄ\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Show me Hemlock code that test import with aliases.", "output": "```hemlock\n// Test import with aliases\nimport { add as sum, subtract as diff } from \"./math.hml\";\n\nlet result1 = sum(10, 20);\nlet result2 = diff(50, 15);\n\nprint(\"sum(10, 20) = \" + typeof(result1));  // Should print 30\nprint(\"diff(50, 15) = \" + typeof(result2));  // Should print 35\n```", "category": "tests/modules", "source": "tests/modules/test_import_alias.hml"}
{"instruction": "How does exists(path) work in Hemlock?", "output": "Returns:* bool - True if path exists, false otherwise\n\n```hemlock\nimport { exists } from \"@stdlib/fs\";\n\nif (exists(\"/etc/passwd\")) {\n    print(\"File exists\");\n}\n\nif (!exists(\"missing.txt\")) {\n    print(\"File does not exist\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does always close channels work in Hemlock?", "output": "```hemlock\nasync fn producer(ch) {\n    // ... send values\n    ch.close();  // Important: signal no more values\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does range checking work in Hemlock?", "output": "Valid Assignments:*\n\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Write a Hemlock program that test env module environment variable functions.", "output": "```hemlock\n// Test env module environment variable functions\n\nimport * as env from \"@stdlib/env\";\n\n// Test getenv for existing variable (PATH should exist on all systems)\nlet path = env.getenv(\"PATH\");\nassert(typeof(path) == \"string\", \"getenv should return a string for PATH\");\n\n// Test getenv for non-existent variable\nlet nonexistent = env.getenv(\"HEMLOCK_TEST_NONEXISTENT_VAR_12345\");\nassert(typeof(nonexistent) == \"null\", \"getenv should return null for non-existent variable\");\n\n// Test setenv and getenv\nenv.setenv(\"HEMLOCK_TEST_VAR\", \"test_value_123\");\nlet value = env.getenv(\"HEMLOCK_TEST_VAR\");\nassert(value == \"test_value_123\", \"setenv/getenv should work correctly\");\n\n// Test setenv overwrite\nenv.setenv(\"HEMLOCK_TEST_VAR\", \"new_value_456\");\nlet new_value = env.getenv(\"HEMLOCK_TEST_VAR\");\nassert(new_value == \"new_value_456\", \"setenv should overwrite existing value\");\n\n// Test unsetenv\nenv.unsetenv(\"HEMLOCK_TEST_VAR\");\nlet after_unset = env.getenv(\"HEMLOCK_TEST_VAR\");\nassert(typeof(after_unset) == \"null\", \"unsetenv should remove the variable\");\n\n// Test with special characters\nenv.setenv(\"HEMLOCK_TEST_SPECIAL\", \"value with spaces and symbols!\");\nlet special = env.getenv(\"HEMLOCK_TEST_SPECIAL\");\nassert(special == \"value with spaces and symbols!\", \"setenv/getenv should handle special characters\");\n\n// Cleanup\nenv.unsetenv(\"HEMLOCK_TEST_SPECIAL\");\n\nprint(\"All environment variable tests passed!\");\n```", "category": "tests/stdlib_env", "source": "tests/stdlib_env/test_env_vars.hml"}
{"instruction": "How does write text file work in Hemlock?", "output": "```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Create a Hemlock program that test multiple cases with same behavior using fall-through.", "output": "```hemlock\n// Test multiple cases with same behavior using fall-through\n\nlet grade = 85;\nlet letter = \"\";\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        letter = \"A\";\n        break;\n    case 85:\n    case 80:\n        letter = \"B\";\n        break;\n    case 75:\n    case 70:\n        letter = \"C\";\n        break;\n    default:\n        letter = \"F\";\n        break;\n}\n\nprint(letter);\n\n// Expected: B\n```", "category": "tests/switch", "source": "tests/switch/multiple_cases.hml"}
{"instruction": "How does variables work in Hemlock?", "output": "```hemlock\n// Variables are declared with 'let'\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// Type annotations are optional\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does clear line work in Hemlock?", "output": "```hemlock\nimport { CLEAR_LINE, CLEAR_LINE_TO_END } from \"@stdlib/terminal\";\n\n// Clear entire line\nexec(\"printf '\\r\" + CLEAR_LINE + \"'\");\n\n// Clear from cursor to end of line\nexec(\"printf '\" + CLEAR_LINE_TO_END + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Write a Hemlock program that tests set_nonblocking() and recv/send behavior in non-blocking mode.", "output": "```hemlock\n// Test: Non-blocking socket operations\n// Tests set_nonblocking() and recv/send behavior in non-blocking mode\n\n// Create a socket and test non-blocking mode\nlet sock = socket_create(AF_INET, SOCK_STREAM, 0);\n\n// Initially should be blocking mode\nassert(sock.nonblocking == false);\n\n// Enable non-blocking mode\nsock.set_nonblocking(true);\nassert(sock.nonblocking == true);\n\n// Disable non-blocking mode\nsock.set_nonblocking(false);\nassert(sock.nonblocking == false);\n\nsock.close();\nprint(\"PASS: set_nonblocking basic\");\n\n// Test non-blocking accept with server\nasync fn test_nonblocking_accept() {\n    let listener = socket_create(AF_INET, SOCK_STREAM, 0);\n    listener.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);\n    listener.bind(\"127.0.0.1\", 19850);\n    listener.listen(5);\n\n    // Set to non-blocking\n    listener.set_nonblocking(true);\n\n    // accept() should return null when no connections pending\n    let client = listener.accept();\n    assert(client == null);\n\n    listener.close();\n    return \"accept_ok\";\n}\n\nlet result = join(spawn(test_nonblocking_accept));\nassert(result == \"accept_ok\");\nprint(\"PASS: non-blocking accept returns null\");\n\n// Test non-blocking recv\nasync fn test_nonblocking_recv_send() {\n    let server = socket_create(AF_INET, SOCK_STREAM, 0);\n    server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);\n    server.bind(\"127.0.0.1\", 19851);\n    server.listen(1);\n\n    // Spawn a client in background\n    let client_task = spawn(async fn() {\n        __sleep(0.05);  // Give server time to accept\n        let client = socket_create(AF_INET, SOCK_STREAM, 0);\n        client.connect(\"127.0.0.1\", 19851);\n        __sleep(0.1);  // Wait before sending\n        client.send(\"hello\");\n        __sleep(0.05);\n        client.close();\n        return \"client_done\";\n    });\n\n    let conn = server.accept();\n\n    // Set connection to non-blocking\n    conn.set_nonblocking(true);\n\n    // First recv should return null (no data yet)\n    let data = conn.recv(1024);\n    let first_recv_null = (data == null);\n\n    // Wait for data to arrive\n    __sleep(0.15);\n\n    // Now recv should return data\n    let data2 = conn.recv(1024);\n    let second_recv_has_data = (data2 != null && data2.length > 0);\n\n    conn.close();\n    server.close();\n    join(client_task);\n\n    return { first_null: first_recv_null, second_has_data: second_recv_has_data };\n}\n\nlet recv_result = join(spawn(test_nonblocking_recv_send));\nassert(recv_result.first_null == true);\nassert(recv_result.second_has_data == true);\nprint(\"PASS: non-blocking recv returns null when no data\");\n\nprint(\"All non-blocking socket tests passed!\");\n```", "category": "tests/async_io", "source": "tests/async_io/nonblocking_socket.hml"}
{"instruction": "Show me Hemlock code that test FFI callbacks with qsort from libc.", "output": "```hemlock\n// Test FFI callbacks with qsort from libc\n\n// Import libc for qsort\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Comparison function for integers (ascending order)\n// qsort passes pointers to elements, so we need to dereference them\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) {\n        return -1;\n    }\n    if (va > vb) {\n        return 1;\n    }\n    return 0;\n}\n\n// Test basic qsort with callback\nfn test_qsort() {\n    print(\"Testing qsort with FFI callback...\");\n\n    // Allocate array of 5 integers (4 bytes each)\n    let arr = alloc(20);  // 5 * 4 bytes\n\n    // Initialize array: [5, 2, 8, 1, 9]\n    ptr_write_i32(arr, 5);\n    ptr_write_i32(ptr_offset(arr, 1, 4), 2);\n    ptr_write_i32(ptr_offset(arr, 2, 4), 8);\n    ptr_write_i32(ptr_offset(arr, 3, 4), 1);\n    ptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n    // Print before sorting\n    print(\"Before sort:\");\n    let i = 0;\n    while (i < 5) {\n        let val = ptr_deref_i32(ptr_offset(arr, i, 4));\n        print(`  arr[${i}] = ${val}`);\n        i = i + 1;\n    }\n\n    // Create callback from comparison function\n    let cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\n\n    // Sort the array\n    qsort(arr, 5, 4, cmp);\n\n    // Print after sorting\n    print(\"After sort:\");\n    i = 0;\n    while (i < 5) {\n        let val = ptr_deref_i32(ptr_offset(arr, i, 4));\n        print(`  arr[${i}] = ${val}`);\n        i = i + 1;\n    }\n\n    // Verify sorted order\n    let sorted = true;\n    i = 0;\n    while (i < 4) {\n        let current = ptr_deref_i32(ptr_offset(arr, i, 4));\n        let next = ptr_deref_i32(ptr_offset(arr, i + 1, 4));\n        if (current > next) {\n            sorted = false;\n        }\n        i = i + 1;\n    }\n\n    if (sorted) {\n        print(\"PASS: Array is sorted correctly\");\n    } else {\n        print(\"FAIL: Array is not sorted correctly\");\n    }\n\n    // Clean up\n    callback_free(cmp);\n    free(arr);\n}\n\n// Comparison function for descending order\nfn compare_ints_desc(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va > vb) {\n        return -1;\n    }\n    if (va < vb) {\n        return 1;\n    }\n    return 0;\n}\n\n// Test descending sort\nfn test_qsort_desc() {\n    print(\"\\nTesting qsort descending with FFI callback...\");\n\n    // Allocate array of 5 integers\n    let arr = alloc(20);\n\n    // Initialize array: [3, 1, 4, 1, 5]\n    ptr_write_i32(arr, 3);\n    ptr_write_i32(ptr_offset(arr, 1, 4), 1);\n    ptr_write_i32(ptr_offset(arr, 2, 4), 4);\n    ptr_write_i32(ptr_offset(arr, 3, 4), 1);\n    ptr_write_i32(ptr_offset(arr, 4, 4), 5);\n\n    // Create callback\n    let cmp = callback(compare_ints_desc, [\"ptr\", \"ptr\"], \"i32\");\n\n    // Sort\n    qsort(arr, 5, 4, cmp);\n\n    // Verify descending order\n    let sorted = true;\n    let i = 0;\n    while (i < 4) {\n        let current = ptr_deref_i32(ptr_offset(arr, i, 4));\n        let next = ptr_deref_i32(ptr_offset(arr, i + 1, 4));\n        if (current < next) {\n            sorted = false;\n        }\n        i = i + 1;\n    }\n\n    if (sorted) {\n        print(\"PASS: Array is sorted in descending order\");\n    } else {\n        print(\"FAIL: Array is not sorted correctly\");\n    }\n\n    // Verify first and last elements\n    let first = ptr_deref_i32(arr);\n    let last = ptr_deref_i32(ptr_offset(arr, 4, 4));\n    print(`First element: ${first} (expected: 5)`);\n    print(`Last element: ${last} (expected: 1)`);\n\n    // Clean up\n    callback_free(cmp);\n    free(arr);\n}\n\n// Run tests\ntest_qsort();\ntest_qsort_desc();\nprint(\"\\nAll callback tests completed!\");\n```", "category": "tests/ffi_callbacks", "source": "tests/ffi_callbacks/qsort_test.hml"}
{"instruction": "How does rsa_sign(data: string, keypair: rsakeypair): buffer work in Hemlock?", "output": "Sign data with RSA private key using SHA-256 digest.\n\n```hemlock\nimport { rsa_sign } from \"@stdlib/crypto\";\n\nlet data = \"Important message\";\nlet signature = rsa_sign(data, keypair);\n\nprint(\"Signature length: \" + typeof(signature.length));  // ~256 bytes for 2048-bit RSA\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "Write Hemlock code that test optional chaining with null values.", "output": "```hemlock\n// Test optional chaining with null values\n\n// Property access on null\nlet obj = null;\nlet result = obj?.name;\nprint(result == null);  // true\n\n// Indexing on null\nlet arr = null;\nlet item = arr?.[0];\nprint(item == null);  // true\n\n// Chaining on null\nlet nested = null;\nlet deep = nested?.field?.value;\nprint(deep == null);  // true\n```", "category": "tests/optional_chaining", "source": "tests/optional_chaining/null_check.hml"}
{"instruction": "How does create argument objects work in Hemlock?", "output": "```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Input: \" + arguments.input);\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Show me Hemlock code that tests switch statements.", "output": "```hemlock\nlet grade = 85;\nlet letter = \"\";\n\nswitch (grade) {\n    case 100:\n    case 90:\n    case 85:\n        letter = \"A\";\n        break;\n}\n\nprint(letter);\n```", "category": "tests/manual", "source": "tests/manual/test_switch3.hml"}
{"instruction": "Implement a Hemlock program that tests binary.", "output": "```hemlock\n// Test: Binary read/write\nlet buf = buffer(10);\nlet i = 0;\nwhile (i < 10) {\n    buf[i] = 65 + i;\n    i = i + 1;\n}\n\nlet fw = open(\"tests/temp/test_binary.dat\", \"w\");\nfw.write_bytes(buf);\nfw.close();\n\nlet fr = open(\"tests/temp/test_binary.dat\", \"r\");\nlet data = fr.read_bytes(10);\nfr.close();\n\nprint(\"Length:\");\nprint(data.length);\nprint(\"First byte:\");\nprint(data[0]);\nprint(\"Last byte:\");\nprint(data[9]);\nfree(buf);\nfree(data);\n```", "category": "tests/io", "source": "tests/io/binary.hml"}
{"instruction": "How does best practices for safe signal handling work in Hemlock?", "output": "3. Defer Complex Operations*\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // Just set flag\n}\n\nsignal(SIGHUP, signal_reload);\n\n// In main loop:\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // Do complex work here\n        pending_reload = false;\n    }\n\n    // Normal work...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Create a Hemlock program that test joining a detached task Expected: ERROR.", "output": "```hemlock\n// Test joining a detached task\n// Expected: ERROR\n\nimport { sleep } from \"@stdlib/time\";\n\nasync fn compute(n: i32): i32 {\n    return n * 2;\n}\n\nlet task = spawn(compute, 21);\ndetach(task);\n\n// Try to join detached task\ntry {\n    let result = join(task);\n    print(\"ERROR: Should not be able to join detached task\");\n} catch (e) {\n    print(\"PASS: Caught join on detached task: \" + e);\n}\n\n// Give detached task time to complete before program exits\nsleep(0.05);\n```", "category": "tests/async", "source": "tests/async/edge_detach_then_join.hml"}
{"instruction": "Create a Hemlock program that tests arithmetic operations.", "output": "```hemlock\nlet p = alloc(10);\nlet p2 = p + 5;\nlet p3 = p2 - 3;\nprint(p);\nprint(p2);\nprint(p3);\nfree(p);\n```", "category": "tests/pointers", "source": "tests/pointers/arithmetic.hml"}
{"instruction": "How does mixed value types work in Hemlock?", "output": "```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does get_pid(): i32 work in Hemlock?", "output": "Get the current process ID.\n\n```hemlock\nlet pid = get_pid();\nprint(\"Current PID: \" + typeof(pid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does braces are always required work in Hemlock?", "output": "All control flow blocks must use braces, even for single statements:\n\n```hemlock\n// ‚úÖ CORRECT\nif (x > 0) {\n    print(\"positive\");\n}\n\n// ‚ùå ERROR: Missing braces\nif (x > 0)\n    print(\"positive\");\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does is_unix() work in Hemlock?", "output": "Returns:* bool - true if on Linux or macOS, false otherwise\n\n```hemlock\nimport { is_unix } from \"@stdlib/os\";\n\nif (is_unix()) {\n    // Use Unix-style paths and commands\n    let config_dir = homedir() + \"/.config/myapp\";\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Create a Hemlock program that test reduce() - accumulate values into single result.", "output": "```hemlock\n// Test reduce() - accumulate values into single result\n\n// Basic reduce - sum\nlet nums = [1, 2, 3, 4, 5];\nlet sum = nums.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(sum);  // 15\n\n// Reduce without initial value - uses first element\nlet sum2 = [10, 20, 30].reduce(fn(acc, x) {\n    return acc + x;\n});\nprint(sum2);  // 60\n\n// Reduce - product\nlet product = [1, 2, 3, 4, 5].reduce(fn(acc, x) {\n    return acc * x;\n}, 1);\nprint(product);  // 120\n\n// Reduce - find maximum\nlet max = [3, 7, 2, 9, 5].reduce(fn(acc, x) {\n    if (x > acc) {\n        return x;\n    } else {\n        return acc;\n    }\n}, 0);\nprint(max);  // 9\n\n// Reduce - concatenate strings\nlet words = [\"Hello\", \"world\", \"from\", \"Hemlock\"];\nlet sentence = words.reduce(fn(acc, word) {\n    return acc + \" \" + word;\n}, \"\");\nprint(sentence.trim());  // Hello world from Hemlock\n\n// Reduce with single element array\nlet single = [42].reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(single);  // 42\n\n// Reduce with single element, no initial value\nlet single2 = [42].reduce(fn(acc, x) {\n    return acc + x;\n});\nprint(single2);  // 42 (first element becomes accumulator)\n\n// Reduce - count occurrences\nlet items = [1, 2, 1, 3, 2, 1];\nlet count_ones = items.reduce(fn(count, x) {\n    if (x == 1) {\n        return count + 1;\n    } else {\n        return count;\n    }\n}, 0);\nprint(count_ones);  // 3\n\n// Reduce with closure\nlet multiplier = 2;\nlet result = [1, 2, 3].reduce(fn(acc, x) {\n    return acc + (x * multiplier);\n}, 0);\nprint(result);  // 12 (2+4+6)\n\n// Reduce preserves original array\nlet original = [1, 2, 3];\nlet reduced = original.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(original.length);  // 3 (unchanged)\nprint(reduced);  // 6\n\n// Reduce - build new array (flatten)\nlet nested = [1, 2, 3];\nlet doubled_via_reduce = nested.reduce(fn(acc, x) {\n    acc.push(x * 2);\n    return acc;\n}, []);\nprint(doubled_via_reduce[0]);  // 2\nprint(doubled_via_reduce[1]);  // 4\nprint(doubled_via_reduce[2]);  // 6\n\n// Reduce to accumulate string length\nlet strings = [\"a\", \"bb\", \"ccc\"];\nlet total_len = strings.reduce(fn(acc, s) {\n    return acc + s.length;\n}, 0);\nprint(total_len);  // 6\n```", "category": "tests/arrays", "source": "tests/arrays/reduce.hml"}
{"instruction": "How does block scope work in Hemlock?", "output": "Variables are scoped to the nearest enclosing block:\n\n```hemlock\nlet x = 1;  // Outer scope\n\nif (true) {\n    let x = 2;  // Inner scope (shadows outer)\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does while loops work in Hemlock?", "output": "```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(\"Count: \" + typeof(count));\n    count = count + 1;\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does utility operations work in Hemlock?", "output": "clear()* - Remove all elements:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does compiled regex (reusable) work in Hemlock?", "output": "```hemlock\nimport { compile } from \"@stdlib/regex\";\n\n// Compile pattern once\nlet email_pattern = compile(\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\");\n\n// Reuse for multiple tests\nprint(email_pattern.test(\"user@example.com\"));    // true\nprint(email_pattern.test(\"invalid.email\"));       // false\nprint(email_pattern.test(\"another@test.org\"));    // true\n\n// Must manually free when done\nemail_pattern.free();\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Show me Hemlock code that test reading zero bytes Expected: PASS.", "output": "```hemlock\n// Test reading zero bytes\n// Expected: PASS\n\nlet f = open(\"/tmp/test_read_zero.txt\", \"w\");\nf.write(\"test data\");\nf.close();\n\nlet f2 = open(\"/tmp/test_read_zero.txt\", \"r\");\nlet content = f2.read(0);\nassert(content == \"\", \"read(0) should return empty string\");\n\nf2.close();\n\nprint(\"PASS\");\n```", "category": "tests/io", "source": "tests/io/edge_read_zero_bytes.hml"}
{"instruction": "Show an example of multiple tasks example in Hemlock.", "output": "```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Spawn multiple tasks (run in parallel!)\nlet t1 = spawn(factorial, 5);   // Thread 1\nlet t2 = spawn(factorial, 6);   // Thread 2\nlet t3 = spawn(factorial, 7);   // Thread 3\nlet t4 = spawn(factorial, 8);   // Thread 4\n\n// All four are computing simultaneously!\n\n// Wait for results\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does ‚ùå discouraged contributions work in Hemlock?", "output": "5. Complex macro system*\n\n```hemlock\n// BAD: This would be rejected\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does handler limitations work in Hemlock?", "output": "```hemlock\nfn complex_handler(sig) {\n    // Avoid these in signal handlers:\n\n    // ‚ùå Long-running operations\n    // process_large_file();\n\n    // ‚ùå Blocking I/O\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal received\\n\");\n\n    // ‚ùå Complex state changes\n    // rebuild_entire_data_structure();\n\n    // ‚úÖ Simple flag setting is safe\n    let should_stop = true;\n\n    // ‚úÖ Simple counter updates are usually safe\n    let signal_count = signal_count + 1;\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does extraction operations work in Hemlock?", "output": "first()* - Get first element (without removing):\n\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1 (without removing)\nprint(arr);                  // [1, 2, 3] (unchanged)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Write Hemlock code that test scientific notation support.", "output": "```hemlock\n// Test scientific notation support\n\n// Basic scientific notation\nprint(1e0);\nprint(1e1);\nprint(1e2);\n\n// Negative exponents\nprint(1e-1);\nprint(1e-2);\n\n// With decimal point\nprint(3.14e2);\nprint(2.5e-3);\n\n// Case insensitive\nprint(1E10 == 1e10);\n\n// Explicit positive exponent\nprint(1e+5);\n\n// Type inference (always f64)\nprint(typeof(1e5));\nprint(typeof(1e-12));\n\n// Arithmetic with scientific notation\nprint(1e3 + 1e2);\nprint(1e6 / 1e3);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/scientific_notation.hml"}
{"instruction": "Implement a Hemlock program that test filesystem builtins.", "output": "```hemlock\n// Test filesystem builtins\n\nlet test_dir = \"/tmp/hemlock_fs_test\";\nlet test_file = \"/tmp/hemlock_fs_test/test.txt\";\n\n// Clean up any previous test artifacts\nif (exists(test_dir)) {\n    if (exists(test_file)) {\n        remove_file(test_file);\n    }\n    remove_dir(test_dir);\n}\n\n// Test cwd() - returns current working directory\nlet current = cwd();\nprint(typeof(current) == \"string\");  // true\nprint(current.length > 0);  // true\n\n// Test exists() - check if path exists\nprint(exists(\"/tmp\"));  // true\nprint(exists(\"/nonexistent_path_12345\"));  // false\n\n// Test is_dir()\nprint(is_dir(\"/tmp\"));  // true\nprint(is_dir(\"/etc/passwd\"));  // false (it's a file)\n\n// Test is_file()\nprint(is_file(\"/etc/passwd\"));  // true\nprint(is_file(\"/tmp\"));  // false (it's a directory)\n\n// Test make_dir()\nmake_dir(test_dir);\nprint(exists(test_dir));  // true\nprint(is_dir(test_dir));  // true\n\n// Test write_file()\nwrite_file(test_file, \"Hello, World!\");\nprint(exists(test_file));  // true\nprint(is_file(test_file));  // true\n\n// Test read_file()\nlet content = read_file(test_file);\nprint(content == \"Hello, World!\");  // true\n\n// Test append_file()\nappend_file(test_file, \"\\nGoodbye!\");\nlet updated = read_file(test_file);\nprint(updated == \"Hello, World!\\nGoodbye!\");  // true\n\n// Test copy_file()\nlet copy_path = \"/tmp/hemlock_fs_test/copy.txt\";\ncopy_file(test_file, copy_path);\nprint(exists(copy_path));  // true\nlet copied = read_file(copy_path);\nprint(copied == updated);  // true\n\n// Test rename()\nlet renamed_path = \"/tmp/hemlock_fs_test/renamed.txt\";\nrename(copy_path, renamed_path);\nprint(exists(renamed_path));  // true\nprint(exists(copy_path));  // false\n\n// Test list_dir()\nlet entries = list_dir(test_dir);\nprint(entries.length == 2);  // true (test.txt and renamed.txt)\n\n// Test file_stat()\nlet stat = file_stat(test_file);\nprint(stat.size > 0);  // true\nprint(stat.is_file == true);  // true\nprint(stat.is_dir == false);  // true\n\n// Test absolute_path()\nlet abs = absolute_path(test_file);\nprint(abs.starts_with(\"/\"));  // true\n\n// Test chdir()\nlet original_dir = cwd();\nchdir(\"/tmp\");\nprint(cwd() == \"/tmp\");  // true\nchdir(original_dir);  // restore\n\n// Clean up\nremove_file(test_file);\nremove_file(renamed_path);\nremove_dir(test_dir);\nprint(exists(test_dir));  // false\n\nprint(\"All filesystem tests passed!\");\n```", "category": "tests/compiler", "source": "tests/compiler/filesystem.hml"}
{"instruction": "How does explicit type conversion work in Hemlock?", "output": "Integer ‚Üî Float:*\n\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32 ‚Üí f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64 ‚Üí i32 (3, truncated)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does check color support work in Hemlock?", "output": "```hemlock\nimport { supports_color, RED, RESET } from \"@stdlib/terminal\";\n\nif (supports_color()) {\n    print(RED + \"Error!\" + RESET);\n} else {\n    print(\"[ERROR] Error!\");\n}\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Write Hemlock code that test 1: Generate RSA key pair.", "output": "```hemlock\n// Test: @stdlib/crypto - RSA signatures\n\nimport { rsa_generate_key, rsa_sign, rsa_verify, rsa_free_keys } from \"@stdlib/crypto\";\n\nprint(\"Testing RSA signatures...\");\n\n// Test 1: Generate RSA key pair\nprint(\"Generating RSA-2048 key pair (this may take a moment)...\");\nlet keypair = rsa_generate_key();\ndefer rsa_free_keys(keypair);\n\nif (typeof(keypair) != \"RSAKeyPair\") {\n    throw \"Expected RSAKeyPair type, got \" + typeof(keypair);\n}\nprint(\"‚úì RSA key generation\");\n\n// Test 2: Sign a message\nlet message = \"This is a test message\";\nlet signature = rsa_sign(message, keypair);\n\nif (typeof(signature) != \"buffer\") {\n    throw \"Expected buffer signature, got \" + typeof(signature);\n}\n\n// RSA-2048 signature should be ~256 bytes\nif (signature.length < 200 || signature.length > 300) {\n    throw \"Unexpected signature length: \" + typeof(signature.length);\n}\nprint(\"‚úì RSA signing (signature: \" + typeof(signature.length) + \" bytes)\");\n\n// Test 3: Verify signature\nlet valid = rsa_verify(message, signature, keypair);\n\nif (valid != true) {\n    throw \"Signature verification failed\";\n}\nprint(\"‚úì RSA signature verification\");\n\n// Test 4: Tampered message fails verification\nlet tampered = \"This is a test messag3\";  // Changed last character\nlet tampered_valid = rsa_verify(tampered, signature, keypair);\n\nif (tampered_valid != false) {\n    throw \"Tampered message should fail verification\";\n}\nprint(\"‚úì Tampered message fails verification\");\n\n// Test 5: Tampered signature fails verification\n// Flip a bit in the signature\nsignature[0] = signature[0] ^ 1;\nlet tampered_sig_valid = rsa_verify(message, signature, keypair);\n\nif (tampered_sig_valid != false) {\n    throw \"Tampered signature should fail verification\";\n}\nprint(\"‚úì Tampered signature fails verification\");\n\n// Test 6: Sign again (regenerate signature)\nlet signature2 = rsa_sign(message, keypair);\nlet valid2 = rsa_verify(message, signature2, keypair);\n\nif (valid2 != true) {\n    throw \"Second signature verification failed\";\n}\nprint(\"‚úì Multiple signatures work\");\n\n// Test 7: Different messages produce different signatures\nlet message2 = \"This is a different message\";\nlet signature3 = rsa_sign(message2, keypair);\n\nlet same = true;\nlet i = 0;\nlet min_len = signature2.length;\nif (signature3.length < min_len) {\n    min_len = signature3.length;\n}\n\nwhile (i < min_len) {\n    if (signature2[i] != signature3[i]) {\n        same = false;\n    }\n    i = i + 1;\n}\n\nif (same) {\n    throw \"Different messages should produce different signatures\";\n}\nprint(\"‚úì Different messages produce different signatures\");\n\n// Test 8: Long message\nlet long_message = \"This is a very long message that will test RSA signing with larger inputs. \";\ni = 0;\nwhile (i < 10) {\n    long_message = long_message + long_message;\n    i = i + 1;\n}\n\nlet long_sig = rsa_sign(long_message, keypair);\nlet long_valid = rsa_verify(long_message, long_sig, keypair);\n\nif (long_valid != true) {\n    throw \"Long message signature verification failed\";\n}\nprint(\"‚úì Long message signing/verification\");\n\n// Test 9: Empty string\nlet empty = \"\";\nlet empty_sig = rsa_sign(empty, keypair);\nlet empty_valid = rsa_verify(empty, empty_sig, keypair);\n\nif (empty_valid != true) {\n    throw \"Empty string signature verification failed\";\n}\nprint(\"‚úì Empty string signing/verification\");\n\n// Test 10: Unicode/UTF-8\nlet unicode = \"Hello üåç! RSA signatures with Hemlock üöÄ\";\nlet unicode_sig = rsa_sign(unicode, keypair);\nlet unicode_valid = rsa_verify(unicode, unicode_sig, keypair);\n\nif (unicode_valid != true) {\n    throw \"Unicode signature verification failed\";\n}\nprint(\"‚úì Unicode signing/verification\");\n\nprint(\"All RSA tests passed!\");\n```", "category": "tests/stdlib_crypto", "source": "tests/stdlib_crypto/test_rsa.hml"}
{"instruction": "Write Hemlock code that test array indexing (read).", "output": "```hemlock\n// Test array indexing (read)\nlet arr = [10, 20, 30, 40, 50];\nprint(arr[0]);\nprint(arr[2]);\nprint(arr[4]);\n```", "category": "tests/arrays", "source": "tests/arrays/index_read.hml"}
{"instruction": "Implement a Hemlock program that test that reassigning const in nested scope causes error.", "output": "```hemlock\n// Test that reassigning const in nested scope causes error\nconst x = 10;\n\n{\n    print(x);\n    x = 20;  // Should error: Cannot assign to const variable 'x'\n}\n```", "category": "tests/const", "source": "tests/const/const_reassign_in_scope_error.hml"}
{"instruction": "Show me Hemlock code that tests nested if.", "output": "```hemlock\nlet x = 10;\nif (x > 5) {\n    print(1);\n    if (x > 8) {\n        print(2);\n    }\n}\n```", "category": "tests/control", "source": "tests/control/nested_if.hml"}
{"instruction": "How does what is panic? work in Hemlock?", "output": "panic() is for unrecoverable errors that should immediately terminate the program:\n\n```hemlock\npanic();                    // Default message: \"panic!\"\npanic(\"custom message\");    // Custom message\npanic(42);                  // Non-string values are printed\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does helper function pattern work in Hemlock?", "output": "```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// Usage:\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Show an example of example 3: advanced argument parser in Hemlock.", "output": "```hemlock\n// Usage: ./hemlock app.hml [OPTIONS] <files...>\n// Options:\n//   --verbose, -v     Enable verbose output\n//   --output, -o FILE Set output file\n//   --help, -h        Show help\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Error: --output requires a value\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Error: Unknown option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options:\");\n    print(\"  --verbose, -v     Enable verbose output\");\n    print(\"  --output, -o FILE Set output file\");\n    print(\"  --help, -h        Show this help\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Error: No input files specified\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Verbose mode enabled\");\n        print(\"Output file: \" + config.output);\n        print(\"Input files: \" + typeof(config.files.length));\n    }\n\n    // Process files\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Processing: \" + file);\n        }\n        // ... process file\n    }\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Write a Hemlock program that test JSON serialization and deserialization.", "output": "```hemlock\n// Test JSON serialization and deserialization\n\n// Basic object serialization\nlet obj = { x: 10, y: 20 };\nlet json = obj.serialize();\nprint(json);\n\n// Deserialize back\nlet restored = json.deserialize();\nprint(restored.x);\nprint(restored.y);\n\n// Nested object\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nlet json2 = nested.serialize();\nprint(json2);\n\n// Object with array\nlet with_arr = { items: [1, 2, 3] };\nprint(with_arr.serialize());\n\n// Round-trip\nlet data = { name: \"test\", values: [1, 2, 3] };\nlet roundtrip = data.serialize().deserialize();\nprint(roundtrip.name);\nprint(roundtrip.values[1]);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/serialization.hml"}
{"instruction": "How does return type annotations work in Hemlock?", "output": "Optional type annotation for return value:\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show an example of complete example: verify file integrity in Hemlock.", "output": "```hemlock\nimport { file_sha256 } from \"@stdlib/hash\";\n\n// Compute checksum of downloaded file\nlet downloaded_file = \"download.zip\";\nlet expected_checksum = \"a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3\";\n\nlet actual_checksum = file_sha256(downloaded_file);\n\nif (actual_checksum == expected_checksum) {\n    print(\"‚úì File integrity verified!\");\n} else {\n    print(\"‚úó File corrupted or tampered!\");\n    print(\"Expected: \" + expected_checksum);\n    print(\"Actual:   \" + actual_checksum);\n}\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does memory_info() work in Hemlock?", "output": "Returns:* object - Object with total, free, and used memory in bytes\n\n```hemlock\nimport { memory_info, format_bytes } from \"@stdlib/os\";\n\nlet mem = memory_info();\n\nprint(\"Total: \" + format_bytes(mem.total));\nprint(\"Free: \" + format_bytes(mem.free));\nprint(\"Used: \" + format_bytes(mem.used));\n\n// Calculate usage percentage\nlet usage = (mem.used * 100) / mem.total;\nprint(\"Usage: \" + typeof(usage) + \"%\");\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Show me Hemlock code that test @stdlib/json clone() and equals().", "output": "```hemlock\n// Test @stdlib/json clone() and equals()\n\nimport { clone, equals } from \"@stdlib/json\";\n\n// Test clone() with primitives\nlet num_clone = clone(42);\nassert(num_clone == 42, \"clone number\");\n\nlet str_clone = clone(\"hello\");\nassert(str_clone == \"hello\", \"clone string\");\n\nlet bool_clone = clone(true);\nassert(bool_clone == true, \"clone bool\");\n\nlet null_clone = clone(null);\nassert(null_clone == null, \"clone null\");\n\n// Test clone() with array\nlet arr = [1, 2, 3];\nlet arr_clone = clone(arr);\nassert(arr_clone.length == 3, \"clone array length\");\nassert(arr_clone[0] == 1, \"clone array element 0\");\nassert(arr_clone[1] == 2, \"clone array element 1\");\nassert(arr_clone[2] == 3, \"clone array element 2\");\n\n// Verify array clone is independent\narr_clone.push(4);\nassert(arr.length == 3, \"original array unchanged after clone modification\");\nassert(arr_clone.length == 4, \"cloned array modified\");\n\n// Test clone() with object\nlet obj = { x: 10, y: 20 };\nlet obj_clone = clone(obj);\nassert(obj_clone.x == 10, \"clone object x\");\nassert(obj_clone.y == 20, \"clone object y\");\n\n// Verify object clone is independent\nobj_clone.x = 99;\nassert(obj.x == 10, \"original object unchanged after clone modification\");\nassert(obj_clone.x == 99, \"cloned object modified\");\n\n// Test clone() with nested structure\nlet nested = {\n    user: { name: \"Alice\", age: 30 },\n    items: [1, 2, 3]\n};\nlet nested_clone = clone(nested);\n\nassert(nested_clone.user.name == \"Alice\", \"clone nested user.name\");\nassert(nested_clone.user.age == 30, \"clone nested user.age\");\nassert(nested_clone.items.length == 3, \"clone nested items length\");\n\n// Verify nested clone is independent (deep copy)\nnested_clone.user.name = \"Bob\";\nnested_clone.items.push(4);\n\nassert(nested.user.name == \"Alice\", \"original nested object unchanged\");\nassert(nested.items.length == 3, \"original nested array unchanged\");\nassert(nested_clone.user.name == \"Bob\", \"cloned nested object modified\");\nassert(nested_clone.items.length == 4, \"cloned nested array modified\");\n\n// Test equals() with primitives\nassert(equals(42, 42) == true, \"equals same numbers\");\nassert(equals(42, 43) == false, \"equals different numbers\");\nassert(equals(\"hello\", \"hello\") == true, \"equals same strings\");\nassert(equals(\"hello\", \"world\") == false, \"equals different strings\");\nassert(equals(true, true) == true, \"equals same bools\");\nassert(equals(true, false) == false, \"equals different bools\");\nassert(equals(null, null) == true, \"equals null\");\n\n// Test equals() with type mismatch\nassert(equals(42, \"42\") == false, \"equals number vs string\");\nassert(equals(true, 1) == false, \"equals bool vs number\");\nassert(equals(null, 0) == false, \"equals null vs zero\");\n\n// Test equals() with arrays\nassert(equals([1, 2, 3], [1, 2, 3]) == true, \"equals same arrays\");\nassert(equals([1, 2, 3], [1, 2]) == false, \"equals different length arrays\");\nassert(equals([1, 2, 3], [1, 2, 4]) == false, \"equals different array elements\");\nassert(equals([], []) == true, \"equals empty arrays\");\n\n// Test equals() with nested arrays\nassert(equals([[1, 2], [3, 4]], [[1, 2], [3, 4]]) == true, \"equals nested arrays\");\nassert(equals([[1, 2], [3, 4]], [[1, 2], [3, 5]]) == false, \"equals different nested arrays\");\n\nprint(\"All clone and equals tests passed!\");\n```", "category": "tests/stdlib_json", "source": "tests/stdlib_json/clone_equals_test.hml"}
{"instruction": "Write Hemlock code that tests structured logging.", "output": "```hemlock\n// Test: Structured logging (key-value pairs)\nimport { Logger, INFO } from \"@stdlib/logging\";\n\nlet logger = Logger({ level: INFO });\n\nprint(\"=== Test 1: Basic structured data ===\");\nlogger.info(\"User login\", {\n    user_id: 12345,\n    username: \"alice\"\n});\n\nprint(\"\\n=== Test 2: Nested objects ===\");\nlogger.warn(\"API error\", {\n    endpoint: \"/api/users\",\n    status: 500,\n    error: {\n        code: \"TIMEOUT\",\n        message: \"Request timed out\"\n    }\n});\n\nprint(\"\\n=== Test 3: Arrays in structured data ===\");\nlogger.error(\"Validation errors\", {\n    field: \"email\",\n    errors: [\"Invalid format\", \"Domain not allowed\"]\n});\n\nprint(\"\\n=== Test 4: Mixed types ===\");\nlogger.info(\"Mixed data\", {\n    string: \"test\",\n    number: 42,\n    float: 3.14,\n    bool: true,\n    null_val: null\n});\n\nprint(\"\\n=== Test 5: Empty object ===\");\nlogger.info(\"Empty data\", {});\n\nprint(\"\\n=== Test 6: Without structured data ===\");\nlogger.info(\"Just a message\");\n\nprint(\"\\nPASS: Structured logging test completed\");\n```", "category": "tests/stdlib_logging", "source": "tests/stdlib_logging/structured_logging.hml"}
{"instruction": "How does progressbar(total, width?) work in Hemlock?", "output": "finish() - Complete the bar and print newline\n\n```hemlock\nimport { ProgressBar } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nlet bar = ProgressBar(100, 50);\n\nlet i = 0;\nwhile (i <= 100) {\n    bar.update(i);\n    sleep(0.05);\n    i = i + 1;\n}\nbar.finish();\n\n// Output: [===========>                ] 23.4% 23/100\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Write a Hemlock program that test null coalescing operator.", "output": "```hemlock\n// Test null coalescing operator\n\n// Basic null coalescing\nlet a = null;\nlet b = 10;\nprint(a ?? b);  // 10\n\n// Non-null value\nlet c = 20;\nlet d = 30;\nprint(c ?? d);  // 20\n\n// Multiple null coalescing\nlet e = null;\nlet f = null;\nlet g = 40;\nprint(e ?? f ?? g);  // 40\n\n// Null coalescing with expressions\nlet obj = null;\nlet fallback = { name: \"Default\" };\nlet result = obj ?? fallback;\nprint(result.name);  // Default\n\n// Null coalescing with zero (should NOT treat zero as null)\nlet zero = 0;\nprint(zero ?? 100);  // 0\n\n// Null coalescing with false (should NOT treat false as null)\nlet bool_val = false;\nprint(bool_val ?? true);  // false\n\n// Null coalescing with empty string (should NOT treat \"\" as null)\nlet empty = \"\";\nprint(empty ?? \"default\");  // \"\" (empty string)\n```", "category": "tests/optional_chaining", "source": "tests/optional_chaining/null_coalesce.hml"}
{"instruction": "How does multiple files work in Hemlock?", "output": "```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Write Hemlock code that test time.sleep() function.", "output": "```hemlock\n// Test time.sleep() function\n\nimport * as time from \"@stdlib/time\";\n\n// Test short sleep\nlet t1 = time.time_ms();\ntime.sleep(0.1);  // Sleep for 100ms\nlet t2 = time.time_ms();\n\nlet elapsed = t2 - t1;\nassert(elapsed >= 95, \"sleep(0.1) should sleep at least 95ms\");\nassert(elapsed < 200, \"sleep(0.1) should sleep less than 200ms\");\n\n// Test zero sleep (should not error)\ntime.sleep(0.0);\n\n// Test that sleep doesn't consume excessive CPU time\nlet c1 = time.clock();\ntime.sleep(0.05);\nlet c2 = time.clock();\nlet cpu_time = c2 - c1;\n// CPU time should be minimal during sleep (less than 10ms worth)\nassert(cpu_time < 0.01, \"sleep() should not consume significant CPU time\");\n\nprint(\"All sleep tests passed!\");\n```", "category": "tests/stdlib_time", "source": "tests/stdlib_time/test_sleep.hml"}
{"instruction": "Implement a Hemlock program that test increment and decrement operators.", "output": "```hemlock\n// Test increment and decrement operators\n\n// Basic prefix increment\nlet a = 5;\nprint(++a);\nprint(a);\n\n// Basic prefix decrement\nlet b = 10;\nprint(--b);\nprint(b);\n\n// Basic postfix increment\nlet c = 5;\nprint(c++);\nprint(c);\n\n// Basic postfix decrement\nlet d = 10;\nprint(d--);\nprint(d);\n\n// Increment in expressions\nlet e = 1;\nlet f = ++e + 10;\nprint(f);\nprint(e);\n\n// Postfix in expressions\nlet g = 1;\nlet h = g++ + 10;\nprint(h);\nprint(g);\n\n// Array index increment\nlet arr = [10, 20, 30];\nprint(++arr[0]);\nprint(arr[0]);\n\n// Array index postfix\nprint(arr[1]++);\nprint(arr[1]);\n\n// Object property increment\nlet obj = { x: 100 };\nprint(++obj.x);\nprint(obj.x);\n\n// Object property postfix\nprint(obj.x--);\nprint(obj.x);\n\n// Multiple increments\nlet i = 0;\ni++;\ni++;\ni++;\nprint(i);\n\n// Decrement in loop\nlet j = 5;\nwhile (j > 0) {\n    print(j);\n    j--;\n}\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/increment_decrement.hml"}
{"instruction": "Write Hemlock code that test Stack collection.", "output": "```hemlock\n// Test Stack collection\n\nimport { Stack } from \"@stdlib/collections\";\n\nlet s = Stack();\n\n// Test initial state\nassert(s.size == 0, \"Initial size should be 0\");\nassert(s.is_empty() == true, \"Stack should be empty initially\");\nassert(s.peek() == null, \"Peek should return null for empty stack\");\n\n// Test push\ns.push(10);\nassert(s.size == 1, \"Size should be 1 after push\");\nassert(s.is_empty() == false, \"Stack should not be empty\");\nassert(s.peek() == 10, \"Peek should return top element\");\n\ns.push(20);\ns.push(30);\nassert(s.size == 3, \"Size should be 3\");\nassert(s.peek() == 30, \"Peek should return most recently pushed element\");\n\n// Test pop (LIFO behavior)\nlet val = s.pop();\nassert(val == 30, \"First pop should return 30\");\nassert(s.size == 2, \"Size should be 2 after pop\");\nassert(s.peek() == 20, \"Peek should now return 20\");\n\nlet val2 = s.pop();\nassert(val2 == 20, \"Second pop should return 20\");\nassert(s.size == 1, \"Size should be 1\");\n\nlet val3 = s.pop();\nassert(val3 == 10, \"Third pop should return 10\");\nassert(s.size == 0, \"Size should be 0\");\nassert(s.is_empty() == true, \"Stack should be empty\");\n\n// Test pop on empty stack (should throw)\nlet caught = false;\ntry {\n    s.pop();\n} catch (e) {\n    caught = true;\n}\nassert(caught == true, \"Pop on empty stack should throw\");\n\n// Test with different types\ns.push(\"first\");\ns.push(\"second\");\ns.push(42);\ns.push(true);\ns.push(null);\n\nassert(s.size == 5, \"Should handle mixed types\");\nassert(s.pop() == null, \"Should pop null\");\nassert(s.pop() == true, \"Should pop boolean\");\nassert(s.pop() == 42, \"Should pop number\");\nassert(s.pop() == \"second\", \"Should pop string\");\nassert(s.pop() == \"first\", \"Should pop string\");\n\n// Test clear\ns.push(1);\ns.push(2);\ns.push(3);\nassert(s.size == 3, \"Size should be 3\");\n\ns.clear();\nassert(s.size == 0, \"Size should be 0 after clear\");\nassert(s.is_empty() == true, \"Stack should be empty after clear\");\n\n// Test to_array\ns.push(\"a\");\ns.push(\"b\");\ns.push(\"c\");\n\nlet arr = s.to_array();\nassert(arr.length == 3, \"Array length should be 3\");\nassert(arr[0] == \"a\", \"Array should preserve insertion order\");\nassert(arr[1] == \"b\", \"Array should preserve insertion order\");\nassert(arr[2] == \"c\", \"Array should preserve insertion order\");\n\n// Ensure to_array doesn't mutate stack\nassert(s.size == 3, \"to_array should not mutate stack\");\n\n// Test stack operations sequence\ns.clear();\ns.push(1);\ns.push(2);\nassert(s.pop() == 2, \"Pop should return 2\");\ns.push(3);\ns.push(4);\nassert(s.pop() == 4, \"Pop should return 4\");\nassert(s.pop() == 3, \"Pop should return 3\");\nassert(s.pop() == 1, \"Pop should return 1\");\nassert(s.is_empty() == true, \"Stack should be empty\");\n\n// Test large stack\nlet i = 0;\nwhile (i < 1000) {\n    s.push(i);\n    i = i + 1;\n}\n\nassert(s.size == 1000, \"Should handle large stack\");\n\ni = 999;\nwhile (i >= 0) {\n    let val = s.pop();\n    assert(val == i, \"Should pop in LIFO order\");\n    i = i - 1;\n}\n\nassert(s.is_empty() == true, \"Stack should be empty after popping all\");\n\n// Test classic use case: reversing\ns.push(\"first\");\ns.push(\"second\");\ns.push(\"third\");\n\nlet reversed = [];\nwhile (!s.is_empty()) {\n    reversed.push(s.pop());\n}\n\nassert(reversed[0] == \"third\", \"Stack reverses order\");\nassert(reversed[1] == \"second\", \"Stack reverses order\");\nassert(reversed[2] == \"first\", \"Stack reverses order\");\n\nprint(\"All Stack tests passed!\");\n```", "category": "tests/stdlib_collections", "source": "tests/stdlib_collections/test_stack.hml"}
{"instruction": "How does rsa_verify(data: string, signature: buffer, keypair: rsakeypair): bool work in Hemlock?", "output": "Verify RSA signature with public key using SHA-256 digest.\n\n```hemlock\nimport { rsa_verify } from \"@stdlib/crypto\";\n\nlet valid = rsa_verify(data, signature, keypair);\n\nif (valid) {\n    print(\"‚úì Signature is valid\");\n} else {\n    print(\"‚úó Signature is invalid\");\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "Show an example of example 4: dynamic log level in Hemlock.", "output": "```hemlock\nimport { Logger, DEBUG, INFO, getenv } from \"@stdlib/logging\";\nimport { getenv } from \"@stdlib/env\";\n\n// Set log level from environment variable\nlet log_level = INFO;\nlet env_level = getenv(\"LOG_LEVEL\");\n\nif (env_level == \"DEBUG\") {\n    log_level = DEBUG;\n}\n\nlet logger = Logger({ level: log_level });\n\nlogger.debug(\"This shows only if LOG_LEVEL=DEBUG\");\nlogger.info(\"This always shows\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does run(options?) work in Hemlock?", "output": "Returns:* Object with test statistics:\n\n```hemlock\n{\n    total: i32,      // Total tests run\n    passed: i32,     // Tests that passed\n    failed: i32,     // Tests that failed\n    success: bool    // true if all tests passed\n}\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does replacement work in Hemlock?", "output": "replace(old, new)* - Replace first occurrence:\n\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\" (first only)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does exit(code?) work in Hemlock?", "output": "Example - Configuration validation:*\n\n```hemlock\nimport { getenv, exit } from \"@stdlib/env\";\n\nfn validate_config(): null {\n    let required_vars = [\"API_KEY\", \"DATABASE_URL\", \"PORT\"];\n\n    let i = 0;\n    while (i < required_vars.length) {\n        let var_name = required_vars[i];\n        let value = getenv(var_name);\n\n        if (value == null) {\n            print(\"Error: Required environment variable \" + var_name + \" is not set\");\n            exit(1);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Configuration valid\");\n    return null;\n}\n\nvalidate_config();\n// Program continues only if all variables are set\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does event countdown work in Hemlock?", "output": "```hemlock\nimport { from_date, now } from \"@stdlib/datetime\";\n\nlet event = from_date(2025, 12, 25, 0, 0, 0);\nlet current = now();\n\nif (event.is_after(current)) {\n    let days_until = event.diff_days(current);\n    print(\"Days until event: \" + typeof(days_until));\n} else {\n    print(\"Event has already occurred\");\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Show me Hemlock code that test optional chaining with indexing.", "output": "```hemlock\n// Test optional chaining with indexing\n\n// Array indexing\nlet arr = [1, 2, 3, 4, 5];\nprint(arr?.[0]);  // 1\nprint(arr?.[2]);  // 3\nprint(arr?.[4]);  // 5\n\n// String indexing\nlet str = \"hello\";\nprint(str?.[0]);  // 'h'\nprint(str?.[1]);  // 'e'\nprint(str?.[4]);  // 'o'\n\n// Null array indexing\nlet null_arr = null;\nprint(null_arr?.[0] == null);  // true\n\n// Null string indexing\nlet null_str = null;\nprint(null_str?.[0] == null);  // true\n```", "category": "tests/optional_chaining", "source": "tests/optional_chaining/indexing.hml"}
{"instruction": "How does stack operations work in Hemlock?", "output": "push(value)* - Add element to end:\n\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does import statements work in Hemlock?", "output": "```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Implement a Hemlock program that verifies that values are properly freed when environments go out of scope and when variables are reassigned.", "output": "```hemlock\n// Test: Environment value cleanup\n// Verifies that values are properly freed when environments go out of scope\n// and when variables are reassigned\n\n// Test 1: Basic scope cleanup\n{\n    let s = \"This string should be freed when scope exits\";\n    let arr = [1, 2, 3, 4, 5];\n    let obj = {name: \"test\", value: 42};\n    print(\"Scope 1: Variables created\");\n}\nprint(\"Scope 1 exited - values should be freed\");\n\n// Test 2: Nested scopes\n{\n    let outer = \"outer scope string\";\n    {\n        let inner = \"inner scope string\";\n        let nested_arr = [10, 20, 30];\n        print(\"Inner scope\");\n    }\n    print(\"Inner scope exited - inner values freed\");\n}\nprint(\"Outer scope exited - outer values freed\");\n\n// Test 3: Variable reassignment should free old values\n{\n    let x = \"original string\";\n    print(x);\n    x = \"reassigned string\";  // Old value should be freed\n    print(x);\n    x = \"third value\";  // Second value should be freed\n    print(x);\n}\nprint(\"Reassignment test completed\");\n\n// Test 4: Array reassignment\n{\n    let arr2 = [1, 2, 3];\n    print(\"Original array created\");\n    arr2 = [4, 5, 6, 7, 8];  // Old array should be freed\n    print(\"Array reassigned\");\n}\nprint(\"Array reassignment test completed\");\n\n// Test 5: Object reassignment\n{\n    let obj2 = {x: 10, y: 20};\n    print(\"Original object created\");\n    obj2 = {a: 100, b: 200, c: 300};  // Old object should be freed\n    print(\"Object reassigned\");\n}\nprint(\"Object reassignment test completed\");\n\n// Test 6: Mixed types with nested data\n{\n    let data = {\n        name: \"Test\",\n        values: [1, 2, 3],\n        nested: {x: 10, y: 20}\n    };\n    print(\"Complex nested structure created\");\n}\nprint(\"Nested structure freed\");\n\n// Test 7: String concatenation creates new strings\n{\n    let str1 = \"Hello\";\n    let str2 = \"World\";\n    let str3 = str1 + \" \" + str2;\n    print(str3);\n}\nprint(\"String concatenation test completed\");\n\n// Test 8: Buffer cleanup\n{\n    let buf = buffer(1024);\n    print(\"Buffer allocated\");\n}\nprint(\"Buffer freed\");\n\n// Test 9: Function with local variables\nfn test_function() {\n    let local1 = \"local string 1\";\n    let local2 = [100, 200, 300];\n    let local3 = {msg: \"local object\"};\n    print(\"Function locals created\");\n    return \"function result\";\n}\n\nlet result = test_function();\nprint(result);\nprint(\"Function exited - local variables freed\");\n\n// Test 10: Loop with reassignment (variables persist across iterations in Hemlock)\nlet loop_counter = 0;\nlet loop_var = \"initial\";\nlet loop_arr = [0];\nwhile (loop_counter < 3) {\n    loop_var = \"iteration\";  // Reassigns, old value freed\n    loop_arr = [loop_counter, loop_counter+1, loop_counter+2];  // Old array freed\n    print(loop_var);\n    loop_counter = loop_counter + 1;\n}\nprint(\"Loop completed - loop variables will be freed when scope exits\");\n\n// Test 11: Parent scope variable reassignment\n{\n    let outer_var = \"outer value\";\n    {\n        // Reassign outer scope variable - old value should be freed\n        outer_var = \"modified from inner scope\";\n        print(outer_var);\n    }\n    print(outer_var);\n}\nprint(\"Parent scope reassignment test completed\");\n\n// Test 12: Closure environment cleanup (closures keep reference)\nfn make_closure() {\n    let captured = \"captured value\";\n    return fn() {\n        return captured;\n    };\n}\n\nlet closure = make_closure();\nprint(closure());  // captured value still accessible\nprint(\"Closure test completed\");\n\nprint(\"All environment cleanup tests passed!\");\n```", "category": "tests/memory", "source": "tests/memory/test_env_value_cleanup.hml"}
{"instruction": "How does continue work in Hemlock?", "output": "Skip to next iteration of loop:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // Skip iteration when i is 5\n    }\n    print(i);  // Prints 0,1,2,3,4,6,7,8,9\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does cursor visibility work in Hemlock?", "output": "```hemlock\nimport { HIDE_CURSOR, SHOW_CURSOR } from \"@stdlib/terminal\";\n\n// Hide cursor (useful for animations)\nexec(\"printf '\" + HIDE_CURSOR + \"'\");\n\n// ... do animation ...\n\n// Show cursor again\nexec(\"printf '\" + SHOW_CURSOR + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Create a Hemlock program that tests serialize cycle error.", "output": "```hemlock\n// Test: Cycle detection in serialization\nlet obj = { x: 10 };\nobj.me = obj;  // Create circular reference\nprint(obj.serialize());  // Should error\n```", "category": "tests/objects", "source": "tests/objects/serialize_cycle_error.hml"}
{"instruction": "How does crc32(data) -> u32 work in Hemlock?", "output": "```hemlock\nimport { crc32 } from \"@stdlib/compression\";\n\nlet data = buffer(5);\ndata[0] = 72; data[1] = 101; data[2] = 108; data[3] = 108; data[4] = 111;  // \"Hello\"\nlet checksum = crc32(data);\nprint(checksum);\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does logical or (||) work in Hemlock?", "output": "Short-circuit evaluation:*\n\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() never called\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does good use cases work in Hemlock?", "output": "6. Automation scripts:*\n\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push failed\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does function call operator work in Hemlock?", "output": "```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Method call\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Builtin call\nprint(\"message\");\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does multi-byte utf-8 characters work in Hemlock?", "output": "Runes can represent any Unicode character:\n\n```hemlock\n// Emoji\nlet rocket = 'üöÄ';      // Emoji (U+1F680)\nlet heart = '‚ù§';        // Heart (U+2764)\nlet smile = 'üòÄ';       // Grinning face (U+1F600)\n\n// CJK characters\nlet chinese = '‰∏≠';     // Chinese (U+4E2D)\nlet japanese = '„ÅÇ';    // Hiragana (U+3042)\nlet korean = 'Ìïú';      // Hangul (U+D55C)\n\n// Symbols\nlet check = '‚úì';        // Checkmark (U+2713)\nlet arrow = '‚Üí';        // Rightwards arrow (U+2192)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does pattern: state machine work in Hemlock?", "output": "```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Starting...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Stopped\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does avoid reading large files entirely work in Hemlock?", "output": "```hemlock\n// Bad for large files\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // Loads entire file into memory\nf.close();\n\n// Good - process in chunks\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Show an example of example: nested error handling in Hemlock.", "output": "```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Failed to process user: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Processed: \" + typeof(success_count) + \" success, \" + typeof(error_count) + \" errors\");\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does control flow work in Hemlock?", "output": "```hemlock\n// If statements\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n\n// While loops\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// For loops\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "Show an example of example in Hemlock.", "output": "```hemlock\nimport { HashMap } from \"@stdlib/collections\";\n\nlet map = HashMap();\n\n// Set values\nmap.set(\"name\", \"Alice\");\nmap.set(\"age\", 30);\nmap.set(\"active\", true);\n\n// Get values\nprint(map.get(\"name\"));  // \"Alice\"\nprint(map.get(\"age\"));   // 30\n\n// Check existence\nif (map.has(\"active\")) {\n    print(\"User is active\");\n}\n\n// Delete\nmap.delete(\"age\");\n\n// Get all keys/values\nlet keys = map.keys();\nlet values = map.values();\n\nprint(\"Size: \" + typeof(map.size));  // 2\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does pitfall: mutation surprises work in Hemlock?", "output": "```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // Shallow copy\ns1[0] = 'H';       // Mutates s1\nprint(s2);         // Still \"hello\" (strings are value types)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does declaration work in Hemlock?", "output": "Variables are declared with let:\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does logical and (&&) work in Hemlock?", "output": "Short-circuit evaluation:*\n\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() never called\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does safety tools provided work in Hemlock?", "output": "3. Type annotations:*\n\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // ERROR: out of range\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Show me Hemlock code that lexical scoping.", "output": "```hemlock\n// Lexical scoping\nlet x = 10;\n\nfn useOuter() {\n    return x + 5;\n}\n\nprint(useOuter());\n```", "category": "tests/functions", "source": "tests/functions/lexical_scope.hml"}
{"instruction": "Write a Hemlock program that test string + rune concatenation.", "output": "```hemlock\n// Test string + rune concatenation\n\n// String + ASCII rune\nlet hello = \"Hello\";\nlet exclaim = hello + '!';\nprint(\"String + ASCII rune:\");\nprint(exclaim);\n\n// String + emoji rune\nlet rocket = \"Rocket \";\nlet rocket_emoji = rocket + 'üöÄ';\nprint(\"\\nString + emoji rune:\");\nprint(rocket_emoji);\n\n// Rune + string\nlet prefix = '>' + \" Message\";\nprint(\"\\nRune + string:\");\nprint(prefix);\n\n// Emoji rune + string\nlet smile = 'üòä' + \" Happy!\";\nprint(\"\\nEmoji rune + string:\");\nprint(smile);\n\n// Chain concatenation\nlet chain = \"Hi \" + 'üëã' + \" World \" + 'üåç';\nprint(\"\\nChained concatenation:\");\nprint(chain);\n\n// Unicode escape rune\nlet heart = \"Love \" + '\\u{2764}';\nprint(\"\\nWith Unicode escape:\");\nprint(heart);\n\nprint(\"\\nString + rune concatenation working!\");\n```", "category": "tests/strings", "source": "tests/strings/string_rune_concat.hml"}
{"instruction": "How does higher-order functions work in Hemlock?", "output": "```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does print work in Hemlock?", "output": "```hemlock\nprint(...values): null\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "Implement a Hemlock program that test type promotion with modulo.", "output": "```hemlock\n// Test type promotion with modulo\n\n// i8 + i32 -> i32\nlet a: i8 = 10;\nlet b: i32 = 3;\nlet c = a % b;\nprint(typeof(c));  // i32\nprint(c);  // 1\n\n// u8 + u16 -> u16\nlet d: u8 = 20;\nlet e: u16 = 7;\nlet f = d % e;\nprint(typeof(f));  // u16\nprint(f);  // 6\n\n// i32 + i64 -> i64\nlet g: i32 = 100;\nlet h: i64 = 13;\nlet i = g % h;\nprint(typeof(i));  // i64\nprint(i);  // 9\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_type_promotion.hml"}
{"instruction": "Write a Hemlock program that multiple objects and arrays with various circular paths.", "output": "```hemlock\n// Test: Complex nested circular references\n// Multiple objects and arrays with various circular paths\n\nlet root = { name: \"root\" };\nlet child1 = { name: \"child1\", parent: root };\nlet child2 = { name: \"child2\", parent: root };\n\nroot.children = [child1, child2];\nchild1.sibling = child2;\nchild2.sibling = child1;\n\n// Add array with self-reference\nlet arr = [root, child1, child2];\narr.push(arr);\nroot.allNodes = arr;\n\n// Free root - this recursively frees everything without stack overflow!\n// The cycle detection ensures that circular references don't cause infinite recursion\nfree(root);\n\nprint(\"PASS: Complex nested cycles handled correctly\");\n```", "category": "tests/circular_refs", "source": "tests/circular_refs/test_complex_nested.hml"}
{"instruction": "How does performance-critical code work in Hemlock?", "output": "Call optimized C implementations:\n\n```hemlock\n// Use highly-optimized C libraries\n// SIMD operations, vectorized code\n// Hardware-accelerated functions\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Show an example of combined example: tar.gz archives in Hemlock.", "output": "```hemlock\nimport { gzip, gunzip, TarWriter, TarReader } from \"@stdlib/compression\";\n\n// Create compressed archive\nfn create_tarball(output_path: string, files: array) {\n    let writer = TarWriter();\n\n    let i = 0;\n    while (i < files.length) {\n        let file = files[i];\n        writer.add_file(file.name, file.content);\n        i = i + 1;\n    }\n\n    let tar_data = writer.build();\n\n    // Convert buffer to string for gzip\n    let tar_str = \"\";\n    i = 0;\n    while (i < tar_data.length) {\n        let ch: rune = tar_data[i];\n        tar_str = tar_str + ch;\n        i = i + 1;\n    }\n\n    let compressed = gzip(tar_str, 9);\n\n    let f = open(output_path, \"w\");\n    f.write_bytes(compressed);\n    f.close();\n\n    free(tar_data);\n    free(compressed);\n}\n\n// Extract compressed archive\nfn extract_tarball(input_path: string): array {\n    let f = open(input_path, \"r\");\n    let content = f.read();\n    f.close();\n\n    // Convert to buffer\n    let bytes = content.bytes();\n    let compressed = buffer(bytes.length);\n    let i = 0;\n    while (i < bytes.length) {\n        compressed[i] = bytes[i];\n        i = i + 1;\n    }\n\n    // Decompress\n    let tar_str = gunzip(compressed);\n\n    // Convert to buffer\n    let tar_bytes = tar_str.bytes();\n    let tar_data = buffer(tar_bytes.length);\n    i = 0;\n    while (i < tar_bytes.length) {\n        tar_data[i] = tar_bytes[i];\n        i = i + 1;\n    }\n\n    // Parse tar\n    let reader = TarReader(tar_data);\n    let entries = reader.entries();\n\n    free(compressed);\n    free(tar_data);\n\n    return entries;\n}\n\n// Usage\nlet files = [\n    { name: \"hello.txt\", content: \"Hello, World!\" },\n    { name: \"data.json\", content: \"{\\\"key\\\": \\\"value\\\"}\" },\n];\n\ncreate_tarball(\"archive.tar.gz\", files);\n\nlet extracted = extract_tarball(\"archive.tar.gz\");\nprint(\"Extracted \" + typeof(extracted.length) + \" files\");\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does switch with return work in Hemlock?", "output": "In functions, return exits the switch immediately:\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        default:\n            return \"Unknown\";\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does closure with parameters work in Hemlock?", "output": "```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does always use try/finally work in Hemlock?", "output": "```hemlock\n// Good\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// Bad - file might not close on error\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // If this throws, file leaks\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does output field work in Hemlock?", "output": "```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // Directory listing with newlines\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\" (empty string)\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does safety tools provided work in Hemlock?", "output": "2. Unsafe raw pointers:*\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // You must remember to free\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Write Hemlock code that test command execution.", "output": "```hemlock\n// Test command execution\n\n// Simple echo command\nlet r = exec(\"echo hello\");\nprint(r.output);\nprint(r.exit_code);\n\n// Command with exit code\nlet r2 = exec(\"true\");\nprint(r2.exit_code);\n\nlet r3 = exec(\"false\");\nprint(r3.exit_code);\n\n// Multiple words\nlet r4 = exec(\"echo one two three\");\nprint(r4.output);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/exec.hml"}
{"instruction": "How does phone number validation work in Hemlock?", "output": "```hemlock\nimport { compile } from \"@stdlib/regex\";\n\nfn validate_phone(phone: string): bool {\n    // Match formats: 555-123-4567 or (555) 123-4567\n    let pattern = compile(\"^(\\\\([0-9]{3}\\\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$\");\n    let valid = pattern.test(phone);\n    pattern.free();\n    return valid;\n}\n\nprint(validate_phone(\"555-123-4567\"));    // true\nprint(validate_phone(\"(555) 123-4567\"));  // true\nprint(validate_phone(\"555.123.4567\"));    // false\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does trim output when needed work in Hemlock?", "output": "```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // Remove trailing newline\nprint(clean);  // \"test\" (no newline)\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show me how to performs mixed arithmetic operations in Hemlock.", "output": "```hemlock\nlet tiny: u8 = 5;\nlet small: i16 = -10;\nlet big: i32 = 100;\nlet precise: f64 = 3.14;\n\nlet result1 = tiny + small;\nprint(result1);\n\nlet result2 = big + precise;\nprint(result2);\n\nlet result3 = tiny + small + big;\nprint(result3);\n\nlet result4 = tiny + small + big + precise;\nprint(result4);\n```", "category": "examples", "source": "examples/mixed_math.hml"}
{"instruction": "Write a Hemlock program that very simple test.", "output": "```hemlock\n// Very simple test\nlet x = 5;\nlet s = \"Value: ${x}\";\nprint(s);\n```", "category": "tests/interpolation", "source": "tests/interpolation/simple.hml"}
{"instruction": "Write a Hemlock program that test const captured in closure.", "output": "```hemlock\n// Test const captured in closure\nconst x = 10;\n\nfn makeAdder() {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add = makeAdder();\nprint(add(5));\n\n// Expected output: 15\n```", "category": "tests/const", "source": "tests/const/const_closure.hml"}
{"instruction": "How does test organization work in Hemlock?", "output": "Use hooks for setup:*\n\n```hemlock\ndescribe(\"Database\", fn() {\n    let db = null;\n\n    before_each(fn() {\n        db = create_test_db();\n    });\n\n    after_each(fn() {\n        db.destroy();\n    });\n\n    // Tests use db...\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Show me Hemlock code that test type promotion: smaller types promote to i64.", "output": "```hemlock\n// Test type promotion: smaller types promote to i64\nlet small: i32 = 100;\nlet large: i64 = 5000;\nlet result = small + large;\nprint(result);\nprint(typeof(result));\n\n// Test that i64 is higher rank than i32\nlet a: i32 = 42;\nlet b: i64 = 58;\nlet c = a + b;\nprint(c);\nprint(typeof(c));\n```", "category": "tests/primitives", "source": "tests/primitives/i64_arithmetic.hml"}
{"instruction": "Write Hemlock code that test @stdlib/json pretty() formatting.", "output": "```hemlock\n// Test @stdlib/json pretty() formatting\n\nimport { parse, pretty } from \"@stdlib/json\";\n\n// Test simple object formatting\nlet obj = { x: 10, y: 20 };\nlet formatted = pretty(obj);\n\nassert(formatted.contains(\"{\\n\"), \"pretty object starts with open brace + newline\");\nassert(formatted.contains(\"\\\"x\\\": 10\"), \"pretty object contains formatted x\");\nassert(formatted.contains(\"\\\"y\\\": 20\"), \"pretty object contains formatted y\");\nassert(formatted.contains(\"\\n}\"), \"pretty object ends with newline + close brace\");\n\n// Test array formatting\nlet arr = [1, 2, 3];\nlet arr_formatted = pretty(arr);\n\nassert(arr_formatted.contains(\"[\\n\"), \"pretty array starts correctly\");\nassert(arr_formatted.contains(\"  1\"), \"pretty array indents element 1\");\nassert(arr_formatted.contains(\"  2\"), \"pretty array indents element 2\");\nassert(arr_formatted.contains(\"  3\"), \"pretty array indents element 3\");\nassert(arr_formatted.contains(\"\\n]\"), \"pretty array ends correctly\");\n\n// Test nested object\nlet nested = {\n    user: { name: \"Alice\", age: 30 },\n    active: true\n};\nlet nested_formatted = pretty(nested);\n\nassert(nested_formatted.contains(\"\\\"user\\\": {\"), \"pretty nested contains user object\");\nassert(nested_formatted.contains(\"\\\"name\\\": \\\"Alice\\\"\"), \"pretty nested contains name\");\nassert(nested_formatted.contains(\"\\\"age\\\": 30\"), \"pretty nested contains age\");\nassert(nested_formatted.contains(\"\\\"active\\\": true\"), \"pretty nested contains active\");\n\n// Test custom indentation (4 spaces)\nlet custom_indent = pretty(obj, 4);\nassert(custom_indent.contains(\"    \"), \"custom indent uses 4 spaces\");\n\n// Test tab indentation\nlet tab_indent = pretty(obj, \"\\t\");\nassert(tab_indent.contains(\"\\t\"), \"tab indent uses tabs\");\n\n// Test empty object\nlet empty_obj = {};\nlet empty_formatted = pretty(empty_obj);\nassert(empty_formatted == \"{}\", \"empty object formatted as {}\");\n\n// Test empty array\nlet empty_arr = [];\nlet empty_arr_formatted = pretty(empty_arr);\nassert(empty_arr_formatted == \"[]\", \"empty array formatted as []\");\n\n// Test string escaping in pretty format\nlet str_obj = { message: \"Hello\\n\\\"World\\\"\" };\nlet str_formatted = pretty(str_obj);\nassert(str_formatted.contains(\"\\\\n\"), \"pretty escapes newlines\");\nassert(str_formatted.contains(\"\\\\\\\"\"), \"pretty escapes quotes\");\n\nprint(\"All pretty printing tests passed!\");\n```", "category": "tests/stdlib_json", "source": "tests/stdlib_json/pretty_test.hml"}
{"instruction": "Implement a Hemlock program that tests empty.", "output": "```hemlock\nlet s = \"\";\nprint(s);\nprint(s.length);\n```", "category": "tests/strings", "source": "tests/strings/empty.hml"}
{"instruction": "Write Hemlock code that test map, filter, and reduce array methods.", "output": "```hemlock\n// Test map, filter, and reduce array methods\n\n// Basic map\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) { return x * 2; });\nprint(doubled[0]);\nprint(doubled[1]);\nprint(doubled[2]);\nprint(doubled[3]);\nprint(doubled[4]);\n\n// Map with multiplication\nlet indexed = nums.map(fn(x) { return x * 10; });\nprint(indexed.join(\",\"));\n\n// Basic filter\nlet filtered = nums.filter(fn(x) { return x > 2; });\nprint(filtered.length);\nprint(filtered[0]);\nprint(filtered[1]);\nprint(filtered[2]);\n\n// Filter even numbers\nlet evens = nums.filter(fn(x) { return x % 2 == 0; });\nprint(evens.join(\",\"));\n\n// Filter odd numbers\nlet odds = nums.filter(fn(x) { return x % 2 != 0; });\nprint(odds.join(\",\"));\n\n// Basic reduce (sum)\nlet sum = nums.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);\n\n// Reduce (product)\nlet product = nums.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);\n\n// Reduce to find max\nlet max = nums.reduce(fn(acc, x) { return acc > x ? acc : x; }, nums[0]);\nprint(max);\n\n// Reduce to find min\nlet min = nums.reduce(fn(acc, x) { return acc < x ? acc : x; }, nums[0]);\nprint(min);\n\n// Chained operations: filter then map\nlet processed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })\n    .map(fn(x) { return x * x; });\nprint(processed.join(\",\"));\n\n// Map then reduce\nlet sumOfSquares = [1, 2, 3, 4]\n    .map(fn(x) { return x * x; })\n    .reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sumOfSquares);\n\n// Filter with objects\nlet people = [\n    { name: \"Alice\", age: 30 },\n    { name: \"Bob\", age: 25 },\n    { name: \"Charlie\", age: 35 }\n];\n\nlet adults = people.filter(fn(p) { return p.age >= 30; });\nprint(adults.length);\nprint(adults[0].name);\nprint(adults[1].name);\n\n// Map to extract property\nlet names = people.map(fn(p) { return p.name; });\nprint(names.join(\", \"));\n\n// Reduce to sum ages\nlet totalAge = people.reduce(fn(acc, p) { return acc + p.age; }, 0);\nprint(totalAge);\n\n// Empty array handling\nlet empty = [];\nlet emptyMapped = empty.map(fn(x) { return x * 2; });\nprint(emptyMapped.length);\n\nlet emptyFiltered = empty.filter(fn(x) { return true; });\nprint(emptyFiltered.length);\n\nlet emptyReduced = empty.reduce(fn(acc, x) { return acc + x; }, 42);\nprint(emptyReduced);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/methods/map_filter_reduce.hml"}
{"instruction": "Write Hemlock code that test recursive functions.", "output": "```hemlock\n// Test recursive functions\nfn factorial(n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nfn fibonacci(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nfn sum_to(n) {\n    if (n <= 0) {\n        return 0;\n    }\n    return n + sum_to(n - 1);\n}\n\nprint(factorial(5));\nprint(factorial(6));\nprint(fibonacci(10));\nprint(sum_to(10));\n```", "category": "tests/compiler", "source": "tests/compiler/recursion.hml"}
{"instruction": "How does rune type work in Hemlock?", "output": "```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = 'üöÄ';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Create a Hemlock program that test named imports.", "output": "```hemlock\n// Test named imports\nimport { add, multiply, PI } from \"./helper.hml\";\n\n// Test imported function\nlet sum = add(2, 3);\nprint(sum);\n\n// Test another imported function\nlet product = multiply(4, 5);\nprint(product);\n\n// Test imported constant\nprint(PI);\n```", "category": "tests/parity", "source": "tests/parity/modules/named_import.hml"}
{"instruction": "Show an example of example: memory pool pattern in Hemlock.", "output": "```hemlock\n// Simple memory pool (simplified)\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool exhausted\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// Use pool\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// Free entire pool at once\nfree(pool);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does empty arrays work in Hemlock?", "output": "```hemlock\nlet arr = [];  // Empty array\n\n// Add elements later\narr.push(1);\narr.push(2);\narr.push(3);\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does safe buffers (recommended) work in Hemlock?", "output": "```hemlock\n// Allocate buffer\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// Set values (bounds-checked)\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Access values\nprint(buf[0]);  // 65\n\n// Must free when done\nfree(buf);\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Show an example of example 7: custom format in Hemlock.", "output": "```hemlock\nimport { Logger } from \"@stdlib/logging\";\n\nlet logger = Logger({\n    format: \"[{level}] {message}\",\n    include_timestamp: false\n});\n\nlogger.info(\"Clean output without timestamp\");\n// Output: [INFO] Clean output without timestamp\n\nlet logger2 = Logger({\n    format: \"{level}: {message}\"\n});\n\nlogger2.warn(\"Custom separator\");\n// Output: WARN: Custom separator\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does simple timer class work in Hemlock?", "output": "```hemlock\nimport { time_ms } from \"@stdlib/time\";\n\nfn Timer() {\n    let start_time = 0;\n    let is_running = false;\n\n    return {\n        start: fn() {\n            start_time = time_ms();\n            is_running = true;\n            return null;\n        },\n\n        stop: fn(): i64 {\n            if (!is_running) {\n                return 0;\n            }\n            let elapsed = time_ms() - start_time;\n            is_running = false;\n            return elapsed;\n        },\n\n        elapsed: fn(): i64 {\n            if (!is_running) {\n                return 0;\n            }\n            return time_ms() - start_time;\n        },\n\n        reset: fn() {\n            start_time = time_ms();\n            return null;\n        }\n    };\n}\n\n// Usage\nlet timer = Timer();\ntimer.start();\n\n// ... do work ...\n\nprint(\"Elapsed so far: \" + typeof(timer.elapsed()) + \"ms\");\n\n// ... more work ...\n\nlet total = timer.stop();\nprint(\"Total time: \" + typeof(total) + \"ms\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does i/o signals work in Hemlock?", "output": "```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does print_styled(text, style) work in Hemlock?", "output": "```hemlock\nimport { print_styled, BOLD, UNDERLINE, ITALIC } from \"@stdlib/terminal\";\n\nprint_styled(\"Important!\", BOLD);\nprint_styled(\"Emphasized\", UNDERLINE);\nprint_styled(\"Note\", ITALIC);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Show me Hemlock code that tests the poll() builtin for waiting on multiple sockets.", "output": "```hemlock\n// Test: poll() for I/O multiplexing\n// Tests the poll() builtin for waiting on multiple sockets\n\n// Test poll constants are defined\nassert(POLLIN > 0);\nassert(POLLOUT > 0);\nassert(POLLERR > 0);\nassert(POLLHUP > 0);\nprint(\"PASS: poll constants defined\");\n\n// Test poll with empty array\nlet empty_result = poll([], 0);\nassert(empty_result.length == 0);\nprint(\"PASS: poll with empty array\");\n\n// Test poll with timeout on socket with no events\nasync fn test_poll_timeout() {\n    let sock = socket_create(AF_INET, SOCK_STREAM, 0);\n    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);\n    sock.bind(\"127.0.0.1\", 19860);\n    sock.listen(1);\n    sock.set_nonblocking(true);\n\n    // Poll for incoming connections with short timeout\n    let start = __time_ms();\n    let result = poll([{ fd: sock, events: POLLIN }], 50);\n    let elapsed = __time_ms() - start;\n\n    // Should timeout (no connections)\n    let timed_out = (result.length == 0);\n    // Should have waited approximately 50ms\n    let waited = (elapsed >= 40);\n\n    sock.close();\n    return { timed_out: timed_out, waited: waited };\n}\n\nlet timeout_result = join(spawn(test_poll_timeout));\nassert(timeout_result.timed_out == true);\nassert(timeout_result.waited == true);\nprint(\"PASS: poll timeout works\");\n\n// Test poll detects readable socket\nasync fn test_poll_readable() {\n    let server = socket_create(AF_INET, SOCK_STREAM, 0);\n    server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);\n    server.bind(\"127.0.0.1\", 19861);\n    server.listen(1);\n\n    // Spawn client that connects\n    let client_task = spawn(async fn() {\n        __sleep(0.02);\n        let client = socket_create(AF_INET, SOCK_STREAM, 0);\n        client.connect(\"127.0.0.1\", 19861);\n        __sleep(0.1);\n        client.close();\n        return \"done\";\n    });\n\n    // Poll for incoming connection\n    let result = poll([{ fd: server, events: POLLIN }], 1000);\n\n    // Should detect the incoming connection\n    let detected = (result.length > 0);\n    let has_pollin = false;\n    if (result.length > 0) {\n        has_pollin = (result[0].revents & POLLIN) != 0;\n    }\n\n    // Accept and clean up\n    if (detected) {\n        let conn = server.accept();\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    server.close();\n    join(client_task);\n\n    return { detected: detected, has_pollin: has_pollin };\n}\n\nlet readable_result = join(spawn(test_poll_readable));\nassert(readable_result.detected == true);\nassert(readable_result.has_pollin == true);\nprint(\"PASS: poll detects readable socket\");\n\n// Test poll with multiple sockets\nasync fn test_poll_multiple() {\n    let s1 = socket_create(AF_INET, SOCK_STREAM, 0);\n    s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);\n    s1.bind(\"127.0.0.1\", 19862);\n    s1.listen(1);\n\n    let s2 = socket_create(AF_INET, SOCK_STREAM, 0);\n    s2.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);\n    s2.bind(\"127.0.0.1\", 19863);\n    s2.listen(1);\n\n    // Connect to second socket only\n    let client_task = spawn(async fn() {\n        __sleep(0.02);\n        let client = socket_create(AF_INET, SOCK_STREAM, 0);\n        client.connect(\"127.0.0.1\", 19863);  // Connect to s2\n        __sleep(0.1);\n        client.close();\n        return \"done\";\n    });\n\n    // Poll both sockets\n    let result = poll([\n        { fd: s1, events: POLLIN },\n        { fd: s2, events: POLLIN }\n    ], 1000);\n\n    // Should detect exactly one socket ready (s2)\n    let one_ready = (result.length == 1);\n\n    // Clean up\n    if (result.length > 0) {\n        let conn = s2.accept();\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    s1.close();\n    s2.close();\n    join(client_task);\n\n    return { one_ready: one_ready };\n}\n\nlet multi_result = join(spawn(test_poll_multiple));\nassert(multi_result.one_ready == true);\nprint(\"PASS: poll with multiple sockets\");\n\nprint(\"All poll tests passed!\");\n```", "category": "tests/async_io", "source": "tests/async_io/poll_basic.hml"}
{"instruction": "How does closed: bool work in Hemlock?", "output": "Whether the file is closed.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does good use cases work in Hemlock?", "output": "2. Quick data processing with Unix tools:*\n\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Unique lines: \" + r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Write a Hemlock program that test if/else statements.", "output": "```hemlock\n// Test if/else statements\n\nlet x = 10;\n\nif (x > 5) {\n    print(\"greater\");\n}\n\nif (x < 5) {\n    print(\"less\");\n} else {\n    print(\"not less\");\n}\n\nif (x == 0) {\n    print(\"zero\");\n} else if (x == 10) {\n    print(\"ten\");\n} else {\n    print(\"other\");\n}\n\n// Nested if\nif (x > 0) {\n    if (x < 20) {\n        print(\"between\");\n    }\n}\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/if_else.hml"}
{"instruction": "Write Hemlock code that test memset with size 0 Expected: PASS.", "output": "```hemlock\n// Test memset with size 0\n// Expected: PASS\n\nlet p = alloc(10);\nmemset(p, 0, 0);  // Should do nothing\nfree(p);\n\nprint(\"PASS: memset with size 0 completed\");\n```", "category": "tests/memory", "source": "tests/memory/edge_memset_zero.hml"}
{"instruction": "How does scrolling work in Hemlock?", "output": "```hemlock\nimport { scroll_up, scroll_down } from \"@stdlib/terminal\";\n\n// Scroll entire display up 3 lines\nexec(\"printf '\" + scroll_up(3) + \"'\");\n\n// Scroll entire display down 2 lines\nexec(\"printf '\" + scroll_down(2) + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Give me Hemlock code that shows tests range error3.", "output": "```hemlock\nlet x: i8 = 128;\n```", "category": "examples", "source": "examples/range_error3.hml"}
{"instruction": "How does task type work in Hemlock?", "output": "```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Write a Hemlock program that test that redeclaring a variable in the same scope causes error.", "output": "```hemlock\n// Test that redeclaring a variable in the same scope causes error\nconst x = 10;\nconst x = 20;  // Should error: Variable 'x' already defined in this scope\n```", "category": "tests/const", "source": "tests/const/redeclare_error.hml"}
{"instruction": "How does error handling work in Hemlock?", "output": "All fs functions use exception-based error handling:\n\n```hemlock\nimport { read_file, write_file } from \"@stdlib/fs\";\n\ntry {\n    let content = read_file(\"config.json\");\n    // Process content...\n    write_file(\"output.json\", content);\n} catch (e) {\n    print(\"Filesystem error: \" + e);\n    // e contains descriptive error message with filename\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\n// Import specific functions\nimport { base64_encode, base64_decode } from \"@stdlib/encoding\";\nimport { hex_encode, hex_decode } from \"@stdlib/encoding\";\nimport { url_encode, url_decode } from \"@stdlib/encoding\";\n\n// Import all functions\nimport * as encoding from \"@stdlib/encoding\";\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does binary arithmetic work in Hemlock?", "output": "```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Float division\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Mixed types\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promoted)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "4. Real-time streaming:*\n\n```hemlock\n// Bad - cannot process output incrementally\nlet r = exec(\"tail -f /var/log/app.log\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does pitfall: byte vs. codepoint confusion work in Hemlock?", "output": "```hemlock\nlet emoji = \"üöÄ\";\nprint(emoji.length);        // 1 (codepoint)\nprint(emoji.byte_length);   // 4 (bytes)\n\n// Don't mix byte and codepoint operations\nlet byte = emoji.byte_at(0);  // 240 (first byte)\nlet char = emoji.char_at(0);  // 'üöÄ' (full codepoint)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "Exceptions thrown in tasks are captured and re-thrown when get() or get_timeout() is called:\n\n```hemlock\nfn failing_task() {\n    throw \"Something went wrong\";\n}\n\nlet pool = ThreadPool(2);\nlet future = pool.submit(failing_task);\n\ntry {\n    let result = future.get();\n} catch (e) {\n    print(\"Task failed: \" + e);  // \"Task failed: Something went wrong\"\n}\n\npool.shutdown();\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does extraction operations work in Hemlock?", "output": "slice(start, end)* - Extract subarray (end exclusive):\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (indices 1, 2, 3)\nlet first = arr.slice(0, 2); // [1, 2]\n\n// Original unchanged\nprint(arr);                  // [1, 2, 3, 4, 5]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Provide a Hemlock example of converts between different types.", "output": "```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;\nprint(c);\n\nlet x: i32 = 5;\nlet y: f64 = 3.14;\nlet z = x + y;\nprint(z);\n\nlet p: u8 = 100;\nlet q: u16 = 200;\nlet r = p + q;\nprint(r);\n\nlet m: f32 = 2.5;\nlet n: f64 = 1.5;\nlet o = m + n;\nprint(o);\n```", "category": "examples", "source": "examples/conversions.hml"}
{"instruction": "How does output redirects work in Hemlock?", "output": "```hemlock\n// Redirect stdout to file (within shell)\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// Redirect stderr to stdout (Note: stderr still not captured by Hemlock)\nlet r2 = exec(\"command 2>&1\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does split & trim work in Hemlock?", "output": "trim()* - Remove leading/trailing whitespace:\n\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Write Hemlock code that tests throw any type.", "output": "```hemlock\n// Test: Throwing different types\ntry {\n    throw 42;\n} catch (e) {\n    print(e);\n}\n\ntry {\n    throw true;\n} catch (e) {\n    print(e);\n}\n\ntry {\n    throw null;\n} catch (e) {\n    print(e);\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/throw_any_type.hml"}
{"instruction": "How does join work in Hemlock?", "output": "```hemlock\njoin(task: task): any\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Show me Hemlock code that basic string interpolation tests.", "output": "```hemlock\n// Basic string interpolation tests\n\n// Simple variable interpolation\nlet name = \"Alice\";\nlet greeting = `Hello, ${name}!`;\nprint(greeting);\n\n// Multiple interpolations\nlet age = 30;\nlet msg = `Hello, ${name}! You are ${age} years old.`;\nprint(msg);\n\n// Expected output:\n// Hello, Alice!\n// Hello, Alice! You are 30 years old.\n```", "category": "tests/interpolation", "source": "tests/interpolation/basic.hml"}
{"instruction": "How does read_file(path) work in Hemlock?", "output": "Throws:* Exception if file doesn't exist or cannot be read\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\n\ntry {\n    let content = read_file(\"data.txt\");\n    print(\"File contents: \" + content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Write Hemlock code that test type definitions with duck typing.", "output": "```hemlock\n// Test type definitions with duck typing\n\n// Define a simple type\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// Create an object that matches the type\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(p.name);\nprint(p.age);\n\n// Define a type with optional field\ndefine Config {\n    host: string,\n    port?: 8080,\n}\n\n// Create config with optional field defaulted\nlet c1: Config = { host: \"localhost\" };\nprint(c1.host);\nprint(c1.port);\n\n// Create config with optional field specified\nlet c2: Config = { host: \"example.com\", port: 3000 };\nprint(c2.host);\nprint(c2.port);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/type_definitions.hml"}
{"instruction": "How does convenience functions work in Hemlock?", "output": "Pre-configured file checksum functions for common use cases:\n\n```hemlock\nimport {\n    file_sha256,\n    file_sha512,\n    file_md5,\n    file_djb2,\n    file_fnv1a,\n    file_murmur3\n} from \"@stdlib/hash\";\n\n// Cryptographic checksums\nlet sha256_sum = file_sha256(\"data.txt\");\nlet sha512_sum = file_sha512(\"important.pdf\");\nlet md5_sum = file_md5(\"legacy.zip\");  // Legacy only!\n\n// Fast non-crypto checksums\nlet fast_sum = file_djb2(\"config.json\");\nlet better_sum = file_murmur3(\"database.db\");\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "1. Memory Leaks*\n\n```hemlock\n// BAD: Memory leak\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // Memory leaked!\n}\n\n// GOOD: Proper cleanup\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... use memory ...\n    free(p);\n    return null;\n}\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does finally block work in Hemlock?", "output": "The finally block always executes:\n\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"error\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");  // Always runs\n}\nprint(\"4: after\");\n\n// Output: 1: try, 2: catch, 3: finally, 4: after\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Show me Hemlock code that test string and array methods.", "output": "```hemlock\n// Test string and array methods\n\n// String methods\nlet s = \"hello world\";\nprint(s.length);\n\nlet sub = s.substr(0, 5);\nprint(sub);\n\nlet upper = s.to_upper();\nprint(upper);\n\nlet idx = s.find(\"world\");\nprint(idx);\n\nlet has = s.contains(\"ell\");\nprint(has);\n\nlet trimmed = \"  hi  \".trim();\nprint(trimmed);\n\n// Array methods\nlet arr = [1, 2, 3];\nprint(arr.length);\n\narr.push(4);\nprint(arr.length);\n\nlet first = arr.first();\nprint(first);\n\nlet last = arr.last();\nprint(last);\n\nlet found = arr.find(3);\nprint(found);\n\nlet has_two = arr.contains(2);\nprint(has_two);\n\n// Slice\nlet slice = arr.slice(1, 3);\nprint(slice.length);\n\n// Join\nlet words = [\"a\", \"b\", \"c\"];\nlet joined = words.join(\"-\");\nprint(joined);\n```", "category": "tests/compiler", "source": "tests/compiler/methods.hml"}
{"instruction": "Show me Hemlock code that test joining a task twice Expected: ERROR or specific behavior.", "output": "```hemlock\n// Test joining a task twice\n// Expected: ERROR or specific behavior\n\nasync fn compute(n: i32): i32 {\n    return n * 2;\n}\n\nlet task = spawn(compute, 21);\nlet result1 = join(task);\n\n// Try to join again\ntry {\n    let result2 = join(task);\n    print(\"Joining twice did not error, result: \" + typeof(result2));\n} catch (e) {\n    print(\"PASS: Caught double join: \" + e);\n}\n```", "category": "tests/async", "source": "tests/async/edge_join_twice.hml"}
{"instruction": "How does import shared library work in Hemlock?", "output": "```hemlock\nimport \"library_name.so\";\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show an example of example: simple database in Hemlock.", "output": "```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does type checking work in Hemlock?", "output": "```hemlock\n// Check types with typeof()\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Write Hemlock code that tests talloc with memset.", "output": "```hemlock\nlet numbers = talloc(i32, 10);\nlet size = sizeof(i32);\nlet total = size * 10;\n\nmemset(numbers, 0, total);\nprint(numbers);\n\nfree(numbers);\n```", "category": "tests/memory", "source": "tests/memory/talloc_with_memset.hml"}
{"instruction": "How does break/continue inside try/catch/finally work in Hemlock?", "output": "```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // ‚úÖ Breaks after finally runs\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Implement a Hemlock program that tests substr.", "output": "```hemlock\nlet s = \"hello world\";\nlet sub1 = s.substr(0, 5);\nprint(sub1);\n\nlet sub2 = s.substr(6, 5);\nprint(sub2);\n\nlet sub3 = s.substr(6, 100);\nprint(sub3);\n```", "category": "tests/strings", "source": "tests/strings/substr.hml"}
{"instruction": "Show me Hemlock code that test array methods.", "output": "```hemlock\n// Test array methods\n\nlet arr = [1, 2, 3];\n\n// Push/pop\narr.push(4);\nprint(arr.length);\nlet popped = arr.pop();\nprint(popped);\nprint(arr.length);\n\n// Shift/unshift\narr.unshift(0);\nprint(arr[0]);\nlet shifted = arr.shift();\nprint(shifted);\n\n// First/last\nprint(arr.first());\nprint(arr.last());\n\n// Find/contains\nprint(arr.find(2));\nprint(arr.find(99));\nprint(arr.contains(3));\nprint(arr.contains(99));\n\n// Slice\nlet sliced = arr.slice(0, 2);\nprint(sliced.length);\nprint(sliced[0]);\nprint(sliced[1]);\n\n// Join\nlet joined = arr.join(\"-\");\nprint(joined);\n\n// Concat\nlet arr2 = [4, 5];\nlet combined = arr.concat(arr2);\nprint(combined.length);\n\n// Reverse (in-place)\nlet rev = [1, 2, 3];\nrev.reverse();\nprint(rev[0]);\nprint(rev[2]);\n\n// Insert/remove\nlet arr3 = [1, 3];\narr3.insert(1, 2);\nprint(arr3[1]);\nlet removed = arr3.remove(1);\nprint(removed);\n\n// Clear\nlet arr4 = [1, 2, 3];\narr4.clear();\nprint(arr4.length);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/methods/array_methods.hml"}
{"instruction": "Write a Hemlock example that demonstrates manipulates strings.", "output": "```hemlock\nlet name = \"alice\";\nprint(name);\nprint(name.length);\n\nname[0] = 65;\nprint(name);\n\nlet i = 0;\nwhile (i < name.length) {\n    print(name[i]);\n    i = i + 1;\n}\n```", "category": "examples", "source": "examples/string_manip.hml"}
{"instruction": "How does asyncremovedir work in Hemlock?", "output": "```hemlock\nimport { async_remove_dir } from \"@stdlib/async_fs\";\n\nlet future = async_remove_dir(\"./temp\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Create a Hemlock program that tests exception handling.", "output": "```hemlock\n// Test: Basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(e);\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/basic_try_catch.hml"}
{"instruction": "Write a Hemlock program that test modulo by zero (should error).", "output": "```hemlock\n// Test modulo by zero (should error)\n\nlet a = 10 % 0;\nprint(a);\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_zero_error.hml"}
{"instruction": "How does division (always float) work in Hemlock?", "output": "The / operator always returns a float (f64), regardless of operand types:\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does exception handling patterns work in Hemlock?", "output": "Pattern 3: Detached tasks with exceptions*\n\n```hemlock\nasync fn detached_task() {\n    try {\n        // work\n    } catch (e) {\n        // Must handle internally - cannot propagate\n        print(\"Error: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // Cannot catch exceptions from detached tasks\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Write a Hemlock program that test optional parameters.", "output": "```hemlock\n// Test optional parameters\n\n// Function with one optional parameter\nfn greet(name, greeting?: \"Hello\") {\n    print(greeting + \" \" + name);\n}\n\ngreet(\"Alice\");              // Hello Alice\ngreet(\"Bob\", \"Hi\");          // Hi Bob\n\n// Function with multiple optional parameters\nfn format(value, prefix?: \"[\", suffix?: \"]\") {\n    print(prefix + value + suffix);\n}\n\nformat(\"test\");              // [test]\nformat(\"test\", \"(\");         // (test]\nformat(\"test\", \"<\", \">\");    // <test>\n\n// Optional parameter with numeric default\nfn multiply(x, factor?: 2) {\n    return x * factor;\n}\n\nprint(multiply(5));      // 10\nprint(multiply(5, 3));   // 15\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/optional_params.hml"}
{"instruction": "How does download file work in Hemlock?", "output": "```hemlock\nimport { download } from \"@stdlib/http\";\n\nprint(\"Downloading...\");\nlet success = download(\"https://httpbin.org/image/png\", \"/tmp/test.png\");\n\nif (success) {\n    print(\"Downloaded to /tmp/test.png\");\n} else {\n    print(\"Download failed\");\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does get_pid() work in Hemlock?", "output": "Process management and monitoring\n\n```hemlock\nimport { get_pid } from \"@stdlib/env\";\n\nlet pid = get_pid();\nprint(\"Current process ID: \" + typeof(pid));\n\n// Create process-specific temp file\nlet temp_file = \"/tmp/myapp.\" + typeof(pid) + \".tmp\";\nprint(\"Using temp file: \" + temp_file);\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does ‚ùå discouraged contributions work in Hemlock?", "output": "3. Implicit type coercion that loses data*\n\n```hemlock\n// BAD: This would be rejected\nlet x: i32 = 3.14;  // Silently truncates to 3\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does async echo server work in Hemlock?", "output": "```hemlock\nimport { TcpListener } from \"@stdlib/net\";\n\nasync fn handle_client(stream) {\n    defer stream.close();\n\n    while (true) {\n        let data = stream.read(1024);\n        if (data.length == 0) {\n            break;  // Client disconnected\n        }\n        stream.write(data);\n    }\n}\n\nlet listener = TcpListener(\"0.0.0.0\", 8080);\ndefer listener.close();\n\nprint(\"Echo server listening on port 8080\");\n\nwhile (true) {\n    let stream = listener.accept();\n    spawn(handle_client, stream);\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does processing multi-line output work in Hemlock?", "output": "```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Create a Hemlock program that nested ternary operator tests.", "output": "```hemlock\n// Nested ternary operator tests\n\n// Test 1: Simple nesting (right associative)\nlet a = 5;\nlet result1 = a > 10 ? \"very big\" : a > 3 ? \"big\" : \"small\";\nprint(result1);\n\n// Test 2: Different nesting level\nlet b = 15;\nlet result2 = b > 10 ? \"very big\" : b > 3 ? \"big\" : \"small\";\nprint(result2);\n\n// Test 3: Another nesting level\nlet c = 2;\nlet result3 = c > 10 ? \"very big\" : c > 3 ? \"big\" : \"small\";\nprint(result3);\n\n// Test 4: Multiple levels\nlet d = 25;\nlet result4 = d > 30 ? \"huge\" : d > 20 ? \"very big\" : d > 10 ? \"big\" : \"small\";\nprint(result4);\n\n// Test 5: Nested in true branch (using parens for clarity)\nlet e = 15;\nlet result5 = e > 10 ? (e > 20 ? \"huge\" : \"big\") : \"small\";\nprint(result5);\n```", "category": "tests/control", "source": "tests/control/ternary_nested.hml"}
{"instruction": "How does is_alnum(str) work in Hemlock?", "output": "Returns:* bool - True if all characters are alphanumeric\n\n```hemlock\nimport { is_alnum } from \"@stdlib/strings\";\n\nprint(is_alnum(\"hello123\"));  // true\nprint(is_alnum(\"ABC123\"));    // true\nprint(is_alnum(\"test\"));      // true\nprint(is_alnum(\"123\"));       // true\nprint(is_alnum(\"a1b2c3\"));    // true\n\nprint(is_alnum(\"hello world\"));  // false (space)\nprint(is_alnum(\"test!\"));        // false (punctuation)\nprint(is_alnum(\"a-b\"));          // false (hyphen)\nprint(is_alnum(\"\"));             // false (empty)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does import statements work in Hemlock?", "output": "Namespace Import:*\n\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does quick start work in Hemlock?", "output": "```hemlock\nimport { describe, test, expect, run } from \"@stdlib/testing\";\n\ndescribe(\"Math operations\", fn() {\n    test(\"addition works\", fn() {\n        expect(2 + 2).to_equal(4);\n    });\n\n    test(\"subtraction works\", fn() {\n        expect(10 - 5).to_equal(5);\n    });\n});\n\ndescribe(\"String operations\", fn() {\n    test(\"concatenation works\", fn() {\n        expect(\"hello\" + \" world\").to_equal(\"hello world\");\n    });\n\n    test(\"length is correct\", fn() {\n        expect(\"test\".length).to_equal(4);\n    });\n});\n\n// Run all tests\nlet results = run();\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does reading characters work in Hemlock?", "output": "Indexing returns a rune (Unicode codepoint):\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H' (rune)\nlet last = s[4];       // 'o' (rune)\n\n// UTF-8 example\nlet emoji = \"HiüöÄ!\";\nlet rocket = emoji[2];  // 'üöÄ' (rune at codepoint index 2)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does operator precedence work in Hemlock?", "output": "```hemlock\n// & has higher precedence than |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Shift has higher precedence than bitwise operators\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Show me Hemlock code that test HTTP/WebSocket builtins codegen Without libwebsockets installed, actual calls exit with error. This test verifies function-as-value (EXPR_IDENT) codegen works.", "output": "```hemlock\n// Test HTTP/WebSocket builtins codegen\n// Without libwebsockets installed, actual calls exit with error.\n// This test verifies function-as-value (EXPR_IDENT) codegen works.\n\n// Test that HTTP functions are recognized as function values\nlet get_fn = __lws_http_get;\nprint(typeof(get_fn) == \"function\");\n\nlet post_fn = __lws_http_post;\nprint(typeof(post_fn) == \"function\");\n\nlet status_fn = __lws_response_status;\nprint(typeof(status_fn) == \"function\");\n\nlet body_fn = __lws_response_body;\nprint(typeof(body_fn) == \"function\");\n\nlet headers_fn = __lws_response_headers;\nprint(typeof(headers_fn) == \"function\");\n\nlet free_fn = __lws_response_free;\nprint(typeof(free_fn) == \"function\");\n\n// Test that functions can be stored in arrays\nlet funcs = [get_fn, post_fn, status_fn, body_fn, headers_fn, free_fn];\nprint(funcs.length == 6);\n\n// Verify functions stored in array are still functions\nprint(typeof(funcs[0]) == \"function\");\nprint(typeof(funcs[5]) == \"function\");\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/http_websocket.hml"}
{"instruction": "How does transformation operations work in Hemlock?", "output": "reverse()* - Reverse array in-place:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1] (modified)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Write a Hemlock program that test hex literals.", "output": "```hemlock\n// Test hex literals\n\n// Basic hex values\nlet a = 0xFF;\nlet b = 0x10;\nlet c = 0x0;\nlet d = 0xDEADBEEF;\n\nprint(a);  // 255\nprint(b);  // 16\nprint(c);  // 0\nprint(d);  // 3735928559\n\n// Uppercase X\nlet e = 0X1A;\nprint(e);  // 26\n\n// Mixed case digits\nlet f = 0xAbCdEf;\nprint(f);  // 11259375\n\n// Hex with type annotations\nlet g: u8 = 0xFF;\nlet h: i32 = 0xCAFE;\nlet i: u32 = 0x7FFFFFFF;\n\nprint(g);  // 255\nprint(h);  // 51966\nprint(i);  // 2147483647\n\n// Hex in expressions\nlet j = 0xFF + 1;\nlet k = 0x10 * 2;\nlet l = 0x100 / 0x10;\n\nprint(j);  // 256\nprint(k);  // 32\nprint(l);  // 16\n\n// Hex with bitwise operations\nlet m = 0xFF & 0x0F;\nlet n = 0xF0 | 0x0F;\nlet o = 0xFF ^ 0x0F;\n\nprint(m);  // 15\nprint(n);  // 255\nprint(o);  // 240\n\n// Large hex values auto-infer to i64\nlet p = 0x100000000;\nprint(p);  // 4294967296 (larger than i32 max, infers i64)\n```", "category": "tests/primitives", "source": "tests/primitives/hex_literals.hml"}
{"instruction": "Write a Hemlock program that test nested arrays.", "output": "```hemlock\n// Test nested arrays\nlet matrix = [[1, 2], [3, 4], [5, 6]];\nprint(matrix);\nprint(matrix[1][1]);\n```", "category": "tests/arrays", "source": "tests/arrays/nested.hml"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Writes line followed by newline (\\n). Returns number of bytes written.\n\n```hemlock\nstream.write_line(\"GET / HTTP/1.1\");\nstream.write_line(\"Host: example.com\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How do you handle errors in Hemlock?", "output": "Hemlock uses try/catch/finally for error handling:\n\n```hemlock\ntry {\n    throw \"something went wrong\";\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    cleanup();\n}\n\n// Unrecoverable errors\npanic(\"fatal error\");  // exits immediately, not catchable\n```\n\nUse `throw` for recoverable errors, `panic` for unrecoverable ones.", "category": "concepts/errors", "source": "CLAUDE.md"}
{"instruction": "Create a Hemlock program that expect: 8 Expect: 15 Expect: 14 Expect: 2 Expect: 6 Expect: 254.", "output": "```hemlock\n// Test: Bitwise operations with mixed types\n// Expect: 8\n// Expect: 15\n// Expect: 14\n// Expect: 2\n// Expect: 6\n// Expect: 254\n\n// i32 promoted from smaller types\nlet a: i8 = 12;\nlet b: i16 = 10;\nprint(a & b);  // Both promoted to i16, result: 8\n\n// u8 and u16 mix\nlet c: u8 = 15;\nlet d: u16 = 7;\nprint(c | d);  // Both promoted to u16, result: 15... wait that's not 14\n// Let me recalculate: 15 | 7 = 15\n// To get 14 I need different values\nlet e: u8 = 12;\nlet f: u16 = 10;\nprint(e | f);  // 12 | 10 = 14\n\n// i32 and u8 mix\nlet g: i32 = 6;\nlet h: u8 = 4;\nprint(g ^ h);  // 6 ^ 4 = 2... that's not 6\n// Let me recalculate: 6 = 110, 4 = 100, 6 ^ 4 = 010 = 2\n// To get 6: 2 ^ 4 = 6\nlet i: i32 = 2;\nlet j: u8 = 4;\nprint(i ^ j);  // 2 ^ 4 = 6\n\n// Bitwise NOT preserves type\nlet k: u8 = 1;\nprint(~k);  // ~1 in u8 = 254\n```", "category": "tests/bitwise", "source": "tests/bitwise/mixed_types.hml"}
{"instruction": "Create a Hemlock program that tests basic channel operations.", "output": "```hemlock\n// Test: Channel send and recv\n// Tests basic channel operations\n\nlet ch = channel(5);\n\n// Send messages\nch.send(10);\nch.send(20);\nch.send(30);\n\n// Receive messages\nlet val1 = ch.recv();\nlet val2 = ch.recv();\nlet val3 = ch.recv();\n\nprint(val1);  // 10\nprint(val2);  // 20\nprint(val3);  // 30\n\n// Test close\nch.close();\nlet val4 = ch.recv();  // Should return null\nprint(val4);  // null\n```", "category": "tests/async", "source": "tests/async/test_channel.hml"}
{"instruction": "How does is_ipv4 work in Hemlock?", "output": "Note:* Current implementation is simplified. Returns true for basic validation.\n\n```hemlock\nimport { is_ipv4 } from \"@stdlib/net\";\n\nprint(is_ipv4(\"127.0.0.1\"));     // true\nprint(is_ipv4(\"example.com\"));   // false (simplified check)\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Write Hemlock code that invalid regex pattern - unclosed bracket.", "output": "```hemlock\n// Test: Invalid regex pattern should throw proper exception\nimport { compile } from \"@stdlib/regex\";\n\nlet caught = false;\nlet error_msg = \"\";\n\ntry {\n    // Invalid regex pattern - unclosed bracket\n    let regex = compile(\"[invalid\");\n} catch (e) {\n    caught = true;\n    error_msg = e;\n}\n\nprint(caught);           // true - exception should be caught\nprint(error_msg);        // Should be \"Regex compilation failed\"\nprint(\"PASSED\");\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/bad_pattern_skipped.hml"}
{"instruction": "Write a Hemlock program that method modifying self.", "output": "```hemlock\n// Method modifying self\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    getCount: fn() {\n        return self.count;\n    },\n};\n\nprint(counter.getCount());\ncounter.increment();\nprint(counter.getCount());\ncounter.increment();\nprint(counter.getCount());\n```", "category": "tests/objects", "source": "tests/objects/method_self_modify.hml"}
{"instruction": "How does else-if chains work in Hemlock?", "output": "```hemlock\nif (x > 100) {\n    print(\"very large\");\n} else if (x > 50) {\n    print(\"large\");\n} else if (x > 10) {\n    print(\"medium\");\n} else {\n    print(\"small\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does setenv(name, value) work in Hemlock?", "output": "Setting feature flags\n\n```hemlock\nimport { setenv, getenv } from \"@stdlib/env\";\n\n// Set a new environment variable\nsetenv(\"MY_APP_CONFIG\", \"/etc/myapp/config.json\");\n\n// Update existing variable\nlet path = getenv(\"PATH\");\nsetenv(\"PATH\", path + \":/usr/local/myapp/bin\");\n\n// Set debugging flag\nsetenv(\"DEBUG\", \"1\");\n\n// Verify\nprint(\"Config: \" + getenv(\"MY_APP_CONFIG\"));\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does try/catch work in Hemlock?", "output": "```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n// Output: Error: division by zero\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Create a Hemlock program that clean up.", "output": "```hemlock\n// Test: Edge cases and error handling\nimport { Logger, INFO } from \"@stdlib/logging\";\nimport { exists, remove_file } from \"@stdlib/fs\";\n\nprint(\"=== Test 1: Invalid file path fallback ===\");\nlet logger1 = Logger({\n    output: \"/invalid/path/that/does/not/exist/log.txt\",\n    level: INFO\n});\nlogger1.info(\"This should fallback to stdout\");\n\nprint(\"\\n=== Test 2: Close logger multiple times ===\");\nlet log_file = \"/tmp/hemlock_edge_test.log\";\nif (exists(log_file)) {\n    remove_file(log_file);\n}\n\nlet logger2 = Logger({ output: log_file });\nlogger2.info(\"Test message\");\nlogger2.close();\nlogger2.close();  // Should be safe\nlogger2.close();  // Should be safe\nprint(\"PASS: Multiple close calls handled\");\n\n// Clean up\nif (exists(log_file)) {\n    remove_file(log_file);\n}\n\nprint(\"\\n=== Test 3: Very long message ===\");\nlet logger3 = Logger();\nlet long_msg = \"This is a very long message that repeats: \";\nlet i = 0;\nwhile (i < 50) {\n    long_msg = long_msg + \"repeat \";\n    i = i + 1;\n}\nlogger3.info(long_msg);\nprint(\"PASS: Long message handled\");\n\nprint(\"\\n=== Test 4: Special characters in message ===\");\nlet logger4 = Logger();\nlogger4.info(\"Message with special chars: \\n\\t\\r\");\nlogger4.info(\"Unicode: ‰Ω†Â•Ω‰∏ñÁïå üöÄ\");\nprint(\"PASS: Special characters handled\");\n\nprint(\"\\n=== Test 5: Null and empty messages ===\");\nlet logger5 = Logger();\nlogger5.info(\"\");\nlogger5.info(null);\nprint(\"PASS: Null and empty messages handled\");\n\nprint(\"\\n=== Test 6: Circular reference in structured data ===\");\nlet logger6 = Logger();\nlet obj = { x: 10 };\nobj.me = obj;  // Circular reference\ntry {\n    logger6.info(\"Circular data\", obj);\n    print(\"FAIL: Should have thrown error for circular reference\");\n} catch (e) {\n    print(\"PASS: Circular reference detected\");\n}\n\nprint(\"\\nPASS: Edge cases test completed\");\n```", "category": "tests/stdlib_logging", "source": "tests/stdlib_logging/edge_cases.hml"}
{"instruction": "How does nan work in Hemlock?", "output": "Not-a-Number (IEEE 754 floating point NaN)\n\n```hemlock\nimport { NAN } from \"@stdlib/math\";\nlet undefined_result = NAN;\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does include context with structured data work in Hemlock?", "output": "```hemlock\n// Good: Provides context\nlogger.error(\"Database query failed\", {\n    query: \"SELECT * FROM users\",\n    duration_ms: 5000,\n    error: \"Timeout\"\n});\n\n// Less useful: No context\nlogger.error(\"Query failed\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does basic syntax work in Hemlock?", "output": "```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Write Hemlock code that test empty switch (no cases, no default) Expected: PASS (should do nothing).", "output": "```hemlock\n// Test empty switch (no cases, no default)\n// Expected: PASS (should do nothing)\n\nlet x = 5;\n\nswitch (x) {\n}\n\nprint(\"PASS: Empty switch completed\");\n```", "category": "tests/switch", "source": "tests/switch/edge_empty_switch.hml"}
{"instruction": "How does resource management work in Hemlock?", "output": "Always use defer to ensure sockets are closed:\n\n```hemlock\nlet listener = TcpListener(\"0.0.0.0\", 8080);\ndefer listener.close();  // Guaranteed cleanup\n\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();    // Guaranteed cleanup\n\nlet sock = UdpSocket(\"0.0.0.0\", 5000);\ndefer sock.close();      // Guaranteed cleanup\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does info() work in Hemlock?", "output": "Returns:* object - Object containing all system information\n\n```hemlock\nimport { info } from \"@stdlib/os\";\n\nlet sys = info();\n\nprint(\"Platform: \" + sys.platform);\nprint(\"Architecture: \" + sys.arch);\nprint(\"OS Name: \" + sys.os_name);\nprint(\"OS Version: \" + sys.os_version);\nprint(\"Hostname: \" + sys.hostname);\nprint(\"Username: \" + sys.username);\nprint(\"Home Dir: \" + sys.homedir);\nprint(\"Temp Dir: \" + sys.tmpdir);\nprint(\"CPU Cores: \" + typeof(sys.cpu_count));\nprint(\"Total Memory: \" + typeof(sys.total_memory));\nprint(\"Free Memory: \" + typeof(sys.free_memory));\nprint(\"Uptime: \" + typeof(sys.uptime) + \" seconds\");\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does channel work in Hemlock?", "output": "```hemlock\nchannel(capacity: i32): channel\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does memcpy work in Hemlock?", "output": "```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Initialize source\nmemset(src, 65, 100);\n\n// Copy to destination\nmemcpy(dest, src, 100);\n\n// dest now contains same data as src\n\nfree(src);\nfree(dest);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does throw work in Hemlock?", "output": "```hemlock\nthrow expression;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does implicit type promotion work in Hemlock?", "output": "Larger size wins:*\n\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum is i64 (300)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does working with strings work in Hemlock?", "output": "Strings in Hemlock are mutable and UTF-8:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // Now \"Hello\"\nprint(s);\n\n// String methods\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// Concatenation\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does switch statements work in Hemlock?", "output": "```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does no process control work in Hemlock?", "output": "Cannot interact with command after starting:\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// Cannot send input to the program\n// Cannot control execution\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does if without else work in Hemlock?", "output": "```hemlock\nif (x > 0) {\n    print(\"positive\");\n}\n// No else branch needed\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write a Hemlock program that case-insensitive one-shot.", "output": "```hemlock\n// Test: Case-insensitive matching\nimport { test, compile, REG_EXTENDED, REG_ICASE } from \"@stdlib/regex\";\n\n// Case-insensitive one-shot\nprint(test(\"HELLO\", \"hello world\", REG_ICASE));     // true\nprint(test(\"hello\", \"HELLO WORLD\", REG_ICASE));     // true\nprint(test(\"WoRlD\", \"hello world\", REG_ICASE));     // true\n\n// Case-insensitive compiled\nlet pattern = compile(\"^[A-Z]+$\", REG_EXTENDED | REG_ICASE);\nprint(pattern.test(\"hello\"));        // true\nprint(pattern.test(\"HELLO\"));        // true\nprint(pattern.test(\"HeLLo\"));        // true\nprint(pattern.test(\"hello123\"));     // false\npattern.free();\n\nprint(\"Case-insensitive test passed\");\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/case_insensitive.hml"}
{"instruction": "Write Hemlock code that tests assert_eq, assert_ne, assert_true, assert_false, assert_throws.", "output": "```hemlock\n// Test: @stdlib/testing - Simple assertions\n// Tests assert_eq, assert_ne, assert_true, assert_false, assert_throws\n\nimport {\n    describe, test, expect,\n    assert_eq, assert_ne, assert_true, assert_false, assert_throws,\n    run\n} from \"@stdlib/testing\";\nimport { exit } from \"@stdlib/env\";\n\ndescribe(\"assert_eq()\", fn() {\n    test(\"passes for equal integers\", fn() {\n        assert_eq(42, 42);\n    });\n\n    test(\"passes for equal strings\", fn() {\n        assert_eq(\"hello\", \"hello\");\n    });\n\n    test(\"passes for equal arrays\", fn() {\n        assert_eq([1, 2, 3], [1, 2, 3]);\n    });\n\n    test(\"passes for equal booleans\", fn() {\n        assert_eq(true, true);\n        assert_eq(false, false);\n    });\n\n    test(\"throws on inequality\", fn() {\n        expect(fn() {\n            assert_eq(5, 10);\n        }).to_throw();\n    });\n});\n\ndescribe(\"assert_ne()\", fn() {\n    test(\"passes for unequal values\", fn() {\n        assert_ne(5, 10);\n        assert_ne(\"foo\", \"bar\");\n    });\n\n    test(\"throws on equality\", fn() {\n        expect(fn() {\n            assert_ne(42, 42);\n        }).to_throw();\n    });\n});\n\ndescribe(\"assert_true()\", fn() {\n    test(\"passes for true\", fn() {\n        assert_true(true);\n        assert_true(5 > 3);\n    });\n\n    test(\"throws for false\", fn() {\n        expect(fn() {\n            assert_true(false);\n        }).to_throw();\n    });\n\n    test(\"throws for non-boolean\", fn() {\n        expect(fn() {\n            assert_true(1);\n        }).to_throw();\n    });\n});\n\ndescribe(\"assert_false()\", fn() {\n    test(\"passes for false\", fn() {\n        assert_false(false);\n        assert_false(10 < 5);\n    });\n\n    test(\"throws for true\", fn() {\n        expect(fn() {\n            assert_false(true);\n        }).to_throw();\n    });\n\n    test(\"throws for non-boolean\", fn() {\n        expect(fn() {\n            assert_false(0);\n        }).to_throw();\n    });\n});\n\ndescribe(\"assert_throws()\", fn() {\n    test(\"passes when function throws\", fn() {\n        assert_throws(fn() {\n            throw \"error!\";\n        });\n    });\n\n    test(\"passes with correct message\", fn() {\n        assert_throws(fn() {\n            throw \"specific error\";\n        }, \"specific error\");\n    });\n\n    test(\"throws when function doesn't throw\", fn() {\n        expect(fn() {\n            assert_throws(fn() {\n                return 42;\n            });\n        }).to_throw();\n    });\n\n    test(\"throws on wrong message\", fn() {\n        expect(fn() {\n            assert_throws(fn() {\n                throw \"actual error\";\n            }, \"expected error\");\n        }).to_throw();\n    });\n});\n\n// Run tests\nlet results = run();\n\nif (!results.success) {\n    exit(1);\n}\n```", "category": "tests/stdlib_testing", "source": "tests/stdlib_testing/test_assertions.hml"}
{"instruction": "Write Hemlock code that test optional chaining with property access.", "output": "```hemlock\n// Test optional chaining with property access\n\n// Object property access\nlet person = { name: \"Alice\", age: 30 };\nprint(person?.name);  // Alice\nprint(person?.age);   // 30\n\n// Array length property\nlet arr = [1, 2, 3];\nprint(arr?.length);  // 3\n\n// String length property\nlet str = \"hello\";\nprint(str?.length);  // 5\n\n// Nested object property access\nlet user = { info: { name: \"Bob\", email: \"bob@example.com\" } };\nprint(user?.info?.name);  // Bob\nprint(user?.info?.email);  // bob@example.com\n```", "category": "tests/optional_chaining", "source": "tests/optional_chaining/property_access.hml"}
{"instruction": "Implement a Hemlock program that test array method chaining.", "output": "```hemlock\n// Test array method chaining\nlet arr = [1, 2, 3];\nlet result = arr.concat([4, 5, 6]).slice(2, 5);\nprint(result);\n\nlet arr2 = [5, 4, 3, 2, 1];\narr2.reverse();\nprint(arr2);\nprint(arr2.first());\nprint(arr2.last());\n\nlet strings = [\"hello\", \"world\", \"foo\", \"bar\"];\nprint(strings.slice(1, 3).join(\" \"));\n```", "category": "tests/arrays", "source": "tests/arrays/chaining.hml"}
{"instruction": "How does unix/linux vs windows work in Hemlock?", "output": "Cross-platform patterns:*\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nfn get_home_directory(): string {\n    // Try Unix first\n    let home = getenv(\"HOME\");\n    if (home != null) {\n        return home;\n    }\n\n    // Fall back to Windows\n    let userprofile = getenv(\"USERPROFILE\");\n    if (userprofile != null) {\n        return userprofile;\n    }\n\n    return \"/tmp\";  // Last resort\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does homedir() work in Hemlock?", "output": "Application data storage\n\n```hemlock\nimport { homedir } from \"@stdlib/os\";\n\nlet home = homedir();\nprint(\"Home directory: \" + home);  // e.g., \"/home/john\"\n\n// Create user-specific paths\nlet config_file = home + \"/.myapp/config.json\";\nlet data_dir = home + \"/.local/share/myapp\";\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does graceful process termination work in Hemlock?", "output": "```hemlock\nfn terminate_gracefully(pid: i32) {\n    // Try SIGTERM first\n    try {\n        kill(pid, 15);  // SIGTERM\n        let i = 0;\n        while (i < 10) {\n            if (!process_exists(pid)) {\n                return true;\n            }\n            import { sleep } from \"@stdlib/time\";\n            sleep(0.1);\n            i = i + 1;\n        }\n        // Force kill if still running\n        kill(pid, 9);  // SIGKILL\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does hello world work in Hemlock?", "output": "```hemlock\nprint(\"Hello, World!\");\n```", "category": "docs", "source": "docs/README.md"}
{"instruction": "Implement a Hemlock program that tests the print function.", "output": "```hemlock\n// Test: eprint (prints to stderr)\neprint(\"This goes to stderr\");\neprint(42);\neprint(true);\neprint(null);\n```", "category": "tests/io", "source": "tests/io/eprint.hml"}
{"instruction": "How does colored logger work in Hemlock?", "output": "```hemlock\nimport { RED, YELLOW, GREEN, BLUE, BOLD, RESET } from \"@stdlib/terminal\";\n\nfn log_error(msg: string): null {\n    print(RED + BOLD + \"[ERROR]\" + RESET + \" \" + msg);\n    return null;\n}\n\nfn log_warning(msg: string): null {\n    print(YELLOW + BOLD + \"[WARN]\" + RESET + \" \" + msg);\n    return null;\n}\n\nfn log_info(msg: string): null {\n    print(BLUE + BOLD + \"[INFO]\" + RESET + \" \" + msg);\n    return null;\n}\n\nfn log_success(msg: string): null {\n    print(GREEN + BOLD + \"[OK]\" + RESET + \" \" + msg);\n    return null;\n}\n\n// Usage\nlog_error(\"Connection failed\");\nlog_warning(\"Low disk space\");\nlog_info(\"Starting service...\");\nlog_success(\"Operation complete\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does exception propagation work in Hemlock?", "output": "Exceptions thrown in spawned tasks are propagated when joined:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught: \" + e);  // \"Caught: Task failed!\"\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Write Hemlock code that test switch with no cases (only default) Expected: PASS.", "output": "```hemlock\n// Test switch with no cases (only default)\n// Expected: PASS\n\nlet x = 5;\nlet matched = false;\n\nswitch (x) {\n    default:\n        matched = true;\n        break;\n}\n\nassert(matched == true, \"default should match when no cases present\");\n\nprint(\"PASS\");\n```", "category": "tests/switch", "source": "tests/switch/edge_no_cases.hml"}
{"instruction": "Write a Hemlock program that test process management builtins.", "output": "```hemlock\n// Test process management builtins\n\n// Test process ID functions\nlet pid = get_pid();\nprint(pid > 0);\n\nlet ppid = getppid();\nprint(ppid > 0);\n\nlet uid = getuid();\nprint(uid >= 0);\n\nlet euid = geteuid();\nprint(euid >= 0);\n\nlet gid = getgid();\nprint(gid >= 0);\n\nlet egid = getegid();\nprint(egid >= 0);\n\n// Test that IDs are consistent\nprint(uid == getuid());\nprint(gid == getgid());\nprint(pid == get_pid());\n\n// Test exec\nlet result = exec(\"echo hello\");\nprint(result.exit_code == 0);\nprint(result.output == \"hello\\n\");\n\n// Note: fork/wait/waitpid/kill not tested here as they're\n// complex to test reliably in a test harness\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/process.hml"}
{"instruction": "How does blocking i/o safe work in Hemlock?", "output": "Blocking operations in one task don't block others:\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // Blocks this thread only\n    let content = f.read();       // Blocks this thread only\n    f.close();\n    return content;\n}\n\n// Both read concurrently (on different threads)\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does tarwriter() -> object work in Hemlock?", "output": "```hemlock\nimport { TarWriter, TarReader } from \"@stdlib/compression\";\n\n// Create tar archive\nlet writer = TarWriter();\nwriter.add_directory(\"myproject/\");\nwriter.add_file(\"myproject/README.md\", \"# My Project\\n\\nWelcome!\");\nwriter.add_file(\"myproject/main.hml\", \"print(\\\"Hello!\\\");\");\n\nlet tar_data = writer.build();\nprint(\"Archive size: \" + typeof(tar_data.length));\n\n// Save to file\nlet f = open(\"myproject.tar\", \"w\");\nf.write_bytes(tar_data);\nf.close();\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does producer-consumer pattern work in Hemlock?", "output": "```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Producing:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consuming:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel\nlet ch = channel(10);\n\n// Spawn producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for completion\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Write a Hemlock program that test different compression levels.", "output": "```hemlock\n// Test different compression levels\nimport { compress, decompress, LEVEL_NONE, LEVEL_FASTEST, LEVEL_DEFAULT, LEVEL_BEST } from \"@stdlib/compression\";\n\n// Create a compressible string\nlet original = \"\";\nlet i = 0;\nwhile (i < 50) {\n    original = original + \"AAAAAAAAAA BBBBBBBBBB CCCCCCCCCC DDDDDDDDDD \";\n    i = i + 1;\n}\n\n// Test no compression (level 0)\nlet compressed_none = compress(original, LEVEL_NONE);\nlet restored_none = decompress(compressed_none);\nprint(restored_none == original);  // true\n\n// Test fastest compression (level 1)\nlet compressed_fast = compress(original, LEVEL_FASTEST);\nlet restored_fast = decompress(compressed_fast);\nprint(restored_fast == original);  // true\n\n// Test default compression (level 6)\nlet compressed_default = compress(original, LEVEL_DEFAULT);\nlet restored_default = decompress(compressed_default);\nprint(restored_default == original);  // true\n\n// Test best compression (level 9)\nlet compressed_best = compress(original, LEVEL_BEST);\nlet restored_best = decompress(compressed_best);\nprint(restored_best == original);  // true\n\n// Level 0 should be larger than level 9 for compressible data\nprint(compressed_none.length >= compressed_best.length);  // true\n\n// All should decompress correctly\nprint(restored_none == restored_fast);  // true\nprint(restored_fast == restored_default);  // true\nprint(restored_default == restored_best);  // true\n\nprint(\"Compression levels tests passed!\");\n```", "category": "tests/stdlib_compression", "source": "tests/stdlib_compression/compression_levels_test.hml"}
{"instruction": "Write a Hemlock program that test that reassigning const causes error.", "output": "```hemlock\n// Test that reassigning const causes error\nconst x = 10;\nprint(x);\n\nx = 20;  // Should error: Cannot assign to const variable 'x'\nprint(x);\n```", "category": "tests/const", "source": "tests/const/const_reassign_error.hml"}
{"instruction": "Implement a Hemlock program that test @stdlib/json parse() and stringify() functions.", "output": "```hemlock\n// Test @stdlib/json parse() and stringify() functions\n\nimport { parse, stringify } from \"@stdlib/json\";\n\n// Test parsing primitives\nlet null_val = parse(\"null\");\nassert(null_val == null, \"parse null\");\n\nlet bool_true = parse(\"true\");\nassert(bool_true == true, \"parse true\");\n\nlet bool_false = parse(\"false\");\nassert(bool_false == false, \"parse false\");\n\nlet num = parse(\"42\");\nassert(num == 42, \"parse number\");\n\nlet float_val = parse(\"3.14\");\nassert(float_val == 3.14, \"parse float\");\n\nlet str = parse(\"\\\"hello\\\"\");\nassert(str == \"hello\", \"parse string\");\n\n// Test parsing arrays\nlet arr = parse(\"[1,2,3]\");\nassert(arr.length == 3, \"parse array length\");\nassert(arr[0] == 1, \"parse array element 0\");\nassert(arr[1] == 2, \"parse array element 1\");\nassert(arr[2] == 3, \"parse array element 2\");\n\n// Test parsing objects\nlet obj = parse(\"{\\\"x\\\":10,\\\"y\\\":20}\");\nassert(obj.x == 10, \"parse object x\");\nassert(obj.y == 20, \"parse object y\");\n\n// Test parsing nested structures\nlet nested = parse(\"{\\\"user\\\":{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30},\\\"items\\\":[1,2,3]}\");\nassert(nested.user.name == \"Alice\", \"parse nested user.name\");\nassert(nested.user.age == 30, \"parse nested user.age\");\nassert(nested.items.length == 3, \"parse nested items\");\n\n// Test stringify primitives\nassert(stringify(null) == \"null\", \"stringify null\");\nassert(stringify(true) == \"true\", \"stringify true\");\nassert(stringify(false) == \"false\", \"stringify false\");\nassert(stringify(42) == \"42\", \"stringify number\");\nassert(stringify(\"hello\") == \"\\\"hello\\\"\", \"stringify string\");\n\n// Test stringify arrays\nlet arr_json = stringify([1, 2, 3]);\nassert(arr_json == \"[1,2,3]\", \"stringify array\");\n\n// Test stringify objects\nlet obj_json = stringify({ x: 10, y: 20 });\nassert(obj_json.contains(\"\\\"x\\\":10\"), \"stringify object contains x:10\");\nassert(obj_json.contains(\"\\\"y\\\":20\"), \"stringify object contains y:20\");\n\n// Test round-trip (parse -> stringify -> parse)\nlet original = { name: \"Bob\", age: 25, active: true };\nlet json_str = stringify(original);\nlet restored = parse(json_str);\nassert(restored.name == \"Bob\", \"round-trip name\");\nassert(restored.age == 25, \"round-trip age\");\nassert(restored.active == true, \"round-trip active\");\n\n// Test error handling - invalid JSON\nlet error_caught = false;\ntry {\n    parse(\"{\\\"unclosed\\\"\");\n} catch (e) {\n    error_caught = true;\n}\nassert(error_caught, \"parse error on invalid JSON\");\n\n// Test error handling - circular reference in stringify\nlet circular = {};\ncircular.circ = circular;\nlet circular_error = false;\ntry {\n    stringify(circular);\n} catch (e) {\n    circular_error = true;\n}\nassert(circular_error, \"stringify error on circular reference\");\n\nprint(\"All parse/stringify tests passed!\");\n```", "category": "tests/stdlib_json", "source": "tests/stdlib_json/parse_stringify_test.hml"}
{"instruction": "How does accepting connections work in Hemlock?", "output": "Blocking accept:*\n\n```hemlock\nwhile (true) {\n    let conn = server.accept(-1);  // Block forever\n    if (conn != null) {\n        spawn(handle_client, conn);\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Implement a Hemlock program that test math module random functions.", "output": "```hemlock\n// Test math module random functions\n\nimport * as math from \"@stdlib/math\";\n\n// Seed for reproducibility\nmath.seed(42);\n\n// Test rand - should return value between 0 and 1\nlet r1 = math.rand();\nassert(r1 >= 0.0 && r1 < 1.0, \"rand() should return value in [0, 1)\");\n\nlet r2 = math.rand();\nassert(r2 >= 0.0 && r2 < 1.0, \"rand() should return value in [0, 1)\");\n\n// Test rand_range\nlet r3 = math.rand_range(10.0, 20.0);\nassert(r3 >= 10.0 && r3 < 20.0, \"rand_range(10, 20) should return value in [10, 20)\");\n\nlet r4 = math.rand_range(0.0, 100.0);\nassert(r4 >= 0.0 && r4 < 100.0, \"rand_range(0, 100) should return value in [0, 100)\");\n\nlet r5 = math.rand_range(-10.0, 10.0);\nassert(r5 >= -10.0 && r5 < 10.0, \"rand_range(-10, 10) should return value in [-10, 10)\");\n\n// Test that seeding gives consistent results\nmath.seed(123);\nlet s1 = math.rand();\nlet s2 = math.rand();\n\nmath.seed(123);\nlet s3 = math.rand();\nlet s4 = math.rand();\n\nassert(s1 == s3, \"Same seed should give same first random number\");\nassert(s2 == s4, \"Same seed should give same second random number\");\n\nprint(\"All random function tests passed!\");\n```", "category": "tests/stdlib_math", "source": "tests/stdlib_math/test_random.hml"}
{"instruction": "Give me Hemlock code that shows demonstrates boolean operations.", "output": "```hemlock\nlet x = true;\nlet y = false;\n\nprint(x);\nprint(y);\nprint(!x);\nprint(x && y);\nprint(x || y);\n\nlet a = 5;\nlet b = 10;\nprint(a < b && b < 20);\n```", "category": "examples", "source": "examples/bools.hml"}
{"instruction": "Write a Hemlock program that resolve localhost and check result.", "output": "```hemlock\n// Test: DNS resolution\n// Resolve localhost and check result\n\nlet ip = dns_resolve(\"localhost\");\nprint(\"localhost resolves to: \" + ip);\n\n// Should resolve to 127.0.0.1\nif (ip != \"127.0.0.1\") {\n    print(\"ERROR: localhost should resolve to 127.0.0.1\");\n} else {\n    print(\"DNS resolution test passed\");\n}\n```", "category": "tests/networking", "source": "tests/networking/dns_resolve.hml"}
{"instruction": "How does error handling work in Hemlock?", "output": "Pattern compilation errors throw exceptions:\n\n```hemlock\nimport { compile } from \"@stdlib/regex\";\n\ntry {\n    let pattern = compile(\"[invalid\");  // Unbalanced bracket\n} catch (e) {\n    print(\"Regex error: \" + e);\n    // \"Regex compilation failed: error code 7\" (REG_EBRACK)\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does mode: string work in Hemlock?", "output": "The mode the file was opened with.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Write Hemlock code that test exception thrown from switch case.", "output": "```hemlock\n// Test exception thrown from switch case\n\nfn test_exception(x: i32) {\n    try {\n        switch (x) {\n            case 1:\n                print(\"case 1\");\n                break;\n            case 2:\n                print(\"case 2 - about to throw\");\n                throw \"error in case 2\";\n            case 3:\n                print(\"case 3 - should not reach\");\n                break;\n        }\n        print(\"after switch - should not reach if exception thrown\");\n    } catch (e) {\n        print(\"Caught: \" + e);\n    }\n}\n\ntest_exception(1);\ntest_exception(2);\ntest_exception(3);\n\n// Expected output:\n// case 1\n// after switch - should not reach if exception thrown\n// case 2 - about to throw\n// Caught: error in case 2\n// case 3 - should not reach\n// after switch - should not reach if exception thrown\n```", "category": "tests/switch", "source": "tests/switch/with_exception.hml"}
{"instruction": "How does multiple signal handlers work in Hemlock?", "output": "Different handlers for different signals:\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does clear screen work in Hemlock?", "output": "```hemlock\nimport { CLEAR_SCREEN, CLEAR_TO_END, CLEAR_TO_START } from \"@stdlib/terminal\";\n\n// Clear entire screen\nexec(\"printf '\" + CLEAR_SCREEN + \"'\");\n\n// Clear from cursor to end of screen\nexec(\"printf '\" + CLEAR_TO_END + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does testing edge cases work in Hemlock?", "output": "Example: tests/arrays/edge_cases.hml*\n\n```hemlock\n// Empty array\nlet empty = [];\nprint(empty.length);  // Expect: 0\n\n// Single element\nlet single = [42];\nprint(single[0]);  // Expect: 42\n\n// Negative index (should error in separate test file)\n// print(single[-1]);  // Error\n\n// Past-end index (should error)\n// print(single[100]);  // Error\n\n// Boundary conditions\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Expect: [] (empty)\nprint(arr.slice(3, 3));  // Expect: [] (empty)\nprint(arr.slice(1, 2));  // Expect: [2]\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does .length work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// Length changes dynamically\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Show an example of example: safe array operations in Hemlock.", "output": "```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // Fill array\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // Process\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // Always cleanup\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does api response processing work in Hemlock?", "output": "```hemlock\nimport { parse, get, is_array } from \"@stdlib/json\";\n\nlet response = parse(http_response_body);\n\n// Extract data safely\nlet users = get(response, \"data.users\", []);\n\nif (is_array(users)) {\n    print(\"Found \" + typeof(users.length) + \" users\");\n\n    let i = 0;\n    while (i < users.length) {\n        let name = get(users[i], \"name\", \"Unknown\");\n        let email = get(users[i], \"email\", \"N/A\");\n        print(name + \" <\" + email + \">\");\n        i = i + 1;\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How do you define a function in Hemlock?", "output": "Functions use the `fn` keyword:\n\n```hemlock\n// Basic function with types\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Optional parameters with defaults\nfn greet(name: string, msg?: \"Hello\") {\n    print(msg + \" \" + name);\n}\n\n// Anonymous function / closure\nlet double = fn(x) { return x * 2; };\n\n// Usage\nprint(add(2, 3));     // 5\ngreet(\"Alice\");       // Hello Alice\nprint(double(5));     // 10\n```", "category": "concepts/functions", "source": "CLAUDE.md"}
{"instruction": "How does nested objects work in Hemlock?", "output": "```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does comparison with shell-based tests work in Hemlock?", "output": "New style (@stdlib/testing):*\n\n```hemlock\nimport { describe, test, expect, run } from \"@stdlib/testing\";\n\ndescribe(\"Arithmetic\", fn() {\n    test(\"addition\", fn() {\n        expect(2 + 2).to_equal(4);\n    });\n});\n\nrun();\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does asyncreadfile work in Hemlock?", "output": "```hemlock\nimport { async_read_file } from \"@stdlib/async_fs\";\n\nlet future = async_read_file(\"data.txt\");\n// Do other work...\nlet content = future.get();\nprint(content);\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Show me Hemlock code that test CRC32 and Adler-32 checksums.", "output": "```hemlock\n// Test CRC32 and Adler-32 checksums\nimport { crc32, adler32, compress_bound } from \"@stdlib/compression\";\n\n// Helper to create buffer from string\nfn string_to_buffer(s) {\n    let bytes = s.bytes();\n    let buf = buffer(bytes.length);\n    let i = 0;\n    while (i < bytes.length) {\n        buf[i] = bytes[i];\n        i = i + 1;\n    }\n    return buf;\n}\n\n// Test CRC32\nlet data = string_to_buffer(\"Hello\");\nlet checksum = crc32(data);\nprint(checksum != 0);  // true (non-zero checksum)\n\n// Same data should produce same checksum\nlet data2 = string_to_buffer(\"Hello\");\nlet checksum2 = crc32(data2);\nprint(checksum == checksum2);  // true\n\n// Different data should produce different checksum\nlet data3 = string_to_buffer(\"World\");\nlet checksum3 = crc32(data3);\nprint(checksum != checksum3);  // true\n\n// Test Adler-32\nlet adler = adler32(data);\nprint(adler != 0);  // true (non-zero checksum)\n\n// Same data should produce same checksum\nlet adler2 = adler32(data2);\nprint(adler == adler2);  // true\n\n// Different data should produce different checksum\nlet adler3 = adler32(data3);\nprint(adler != adler3);  // true\n\n// Test compress_bound\nlet bound = compress_bound(1000);\nprint(bound > 1000);  // true (always larger than input for worst case)\n\nlet bound2 = compress_bound(0);\nprint(bound2 > 0);  // true (even empty input has some bound)\n\nprint(\"Checksum tests passed!\");\n```", "category": "tests/stdlib_compression", "source": "tests/stdlib_compression/checksums_test.hml"}
{"instruction": "Show me Hemlock code that tests if false.", "output": "```hemlock\nif (false) {\n    print(\"yes\");\n} else {\n    print(\"no\");\n}\n```", "category": "tests/control", "source": "tests/control/if_false.hml"}
{"instruction": "Create a Hemlock program that tests async/await functionality.", "output": "```hemlock\nasync fn simple_task(id: i32): i32 {\n    return id * 2;\n}\n\nlet tasks = [];\nlet i = 0;\nwhile (i < 5) {\n    tasks.push(spawn(simple_task, i));\n    i = i + 1;\n}\n\nprint(\"Spawned 5 tasks\");\n\ni = 0;\nwhile (i < tasks.length) {\n    let result = join(tasks[i]);\n    print(\"Task \" + typeof(i) + \" result: \" + typeof(result));\n    i = i + 1;\n}\n\nprint(\"All done!\");\n```", "category": "tests/manual", "source": "tests/manual/test_minimal_async.hml"}
{"instruction": "How does time_ms() work in Hemlock?", "output": "Timestamping with millisecond precision\n\n```hemlock\nimport { time_ms } from \"@stdlib/time\";\n\nlet start = time_ms();\n// ... do work ...\nlet end = time_ms();\nlet ms_elapsed = end - start;\nprint(\"Took \" + typeof(ms_elapsed) + \"ms\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does moveup(n), movedown(n), moveleft(n), moveright(n) work in Hemlock?", "output": "Returns:* string - ANSI escape sequence\n\n```hemlock\nimport { move_up, move_down, move_left, move_right } from \"@stdlib/terminal\";\n\n// Move cursor up 3 lines\nexec(\"printf '\" + move_up(3) + \"'\");\n\n// Move cursor right 5 columns\nexec(\"printf '\" + move_right(5) + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does mixed positional and named arguments work in Hemlock?", "output": "```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // Treat as positional argument\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// Assign positional arguments\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does describe(name, fn) work in Hemlock?", "output": "Create a test suite (group of related tests).\n\n```hemlock\ndescribe(\"Array methods\", fn() {\n    test(\"push adds element\", fn() {\n        let arr = [1, 2, 3];\n        arr.push(4);\n        expect(arr.length).to_equal(4);\n    });\n\n    test(\"pop removes element\", fn() {\n        let arr = [1, 2, 3];\n        let last = arr.pop();\n        expect(last).to_equal(3);\n        expect(arr.length).to_equal(2);\n    });\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does tcp echo server work in Hemlock?", "output": "```hemlock\nimport { TcpListener } from \"@stdlib/net\";\n\nasync fn handle_client(stream) {\n    defer stream.close();\n\n    let data = stream.read(1024);\n    stream.write(data);  // Echo back\n}\n\nlet listener = TcpListener(\"0.0.0.0\", 8080);\ndefer listener.close();\n\nwhile (true) {\n    let stream = listener.accept();\n    spawn(handle_client, stream);  // Handle concurrently\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Show me Hemlock code that expect: 8 Expect: 14 Expect: 6 Expect: 48 Expect: 6 Expect: -13.", "output": "```hemlock\n// Test: Basic bitwise operations\n// Expect: 8\n// Expect: 14\n// Expect: 6\n// Expect: 48\n// Expect: 6\n// Expect: -13\n\nlet a = 12;\nlet b = 10;\n\n// Bitwise AND\nprint(a & b);  // 12 & 10 = 8\n\n// Bitwise OR\nprint(a | b);  // 12 | 10 = 14\n\n// Bitwise XOR\nprint(a ^ b);  // 12 ^ 10 = 6\n\n// Left shift\nprint(a << 2);  // 12 << 2 = 48\n\n// Right shift\nprint(a >> 1);  // 12 >> 1 = 6\n\n// Bitwise NOT\nprint(~a);  // ~12 = -13\n```", "category": "tests/bitwise", "source": "tests/bitwise/basic.hml"}
{"instruction": "How does pattern: array as queue work in Hemlock?", "output": "```hemlock\nlet queue = [];\n\n// Enqueue (add to end)\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dequeue (remove from front)\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Write a Hemlock program that test date/time parsing.", "output": "```hemlock\n// Test date/time parsing\nimport { parse_iso } from \"@stdlib/datetime\";\n\n// Test 1: Parse ISO date (YYYY-MM-DD)\nlet dt1 = parse_iso(\"2025-01-15\");\nprint(\"Test 1: parse_iso('2025-01-15')\");\nprint(\"  Year: \" + typeof(dt1.year));\nprint(\"  Month: \" + typeof(dt1.month));\nprint(\"  Day: \" + typeof(dt1.day));\nprint(\"  Expected: 2025, 1, 15\");\n\n// Test 2: Parse ISO datetime (YYYY-MM-DDTHH:MM:SS)\nlet dt2 = parse_iso(\"2025-03-20T14:30:45\");\nprint(\"Test 2: parse_iso('2025-03-20T14:30:45')\");\nprint(\"  Date: \" + dt2.to_date_string());\nprint(\"  Time: \" + dt2.to_time_string());\nprint(\"  Expected: 2025-03-20, 14:30:45\");\n\n// Test 3: Parse ISO datetime with Z suffix\nlet dt3 = parse_iso(\"2025-12-31T23:59:59Z\");\nprint(\"Test 3: parse_iso('2025-12-31T23:59:59Z')\");\nprint(\"  Year: \" + typeof(dt3.year));\nprint(\"  Month: \" + typeof(dt3.month));\nprint(\"  Day: \" + typeof(dt3.day));\nprint(\"  Hour: \" + typeof(dt3.hour));\nprint(\"  Minute: \" + typeof(dt3.minute));\nprint(\"  Second: \" + typeof(dt3.second));\n\nprint(\"All parsing tests passed!\");\n```", "category": "tests/stdlib_datetime", "source": "tests/stdlib_datetime/test_parsing.hml"}
{"instruction": "Write a Hemlock program that test that shebang works with real code.", "output": "```hemlock\n#!/usr/bin/env hemlock\n// Test that shebang works with real code\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(10, 32);\nprint(result);\n```", "category": "tests/shebang", "source": "tests/shebang/shebang_with_code.hml"}
{"instruction": "Write Hemlock code that test typed arrays.", "output": "```hemlock\n// Test typed arrays\n\n// Basic typed array\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nprint(nums[0]);\nprint(nums.length);\n\nnums.push(6);\nprint(nums[5]);\n\n// String typed array\nlet names: array<string> = [\"Alice\", \"Bob\"];\nprint(names[0]);\nnames.push(\"Charlie\");\nprint(names[2]);\n\n// Explicit untyped array\nlet mixed: array = [1, \"hello\", true];\nprint(mixed[0]);\nprint(mixed[1]);\nprint(mixed[2]);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/typed_arrays.hml"}
{"instruction": "Show me Hemlock code that tests assertions.", "output": "```hemlock\n// Test: Basic assert with truthy values\nassert(true);\nprint(\"assert(true) passed\");\n\nassert(1);\nprint(\"assert(1) passed\");\n\nassert(42);\nprint(\"assert(42) passed\");\n\nassert(\"non-empty\");\nprint(\"assert with non-empty string passed\");\n\n// Test: Assert with falsy values (should throw)\ntry {\n    assert(false);\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\ntry {\n    assert(0);\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\ntry {\n    assert(null);\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\ntry {\n    assert(\"\");\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Assert with custom message\ntry {\n    assert(false, \"custom error message\");\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\ntry {\n    assert(0, \"number was zero\");\n    print(\"This should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/assert_basic.hml"}
{"instruction": "How does reference semantics work in Hemlock?", "output": "```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Shallow copy (same reference)\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (both refer to same object)\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does maybe add (under discussion) work in Hemlock?", "output": "1. defer for cleanup*\n\n```hemlock\nlet f = open(\"file.txt\");\ndefer f.close();  // Explicit, not automatic\n// ... use file\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Show an example of complete server example in Hemlock.", "output": "```hemlock\nimport { WebSocketServer } from \"@stdlib/websocket\";\n\nasync fn handle_client(conn, client_id) {\n    defer conn.close();\n    print(\"Client \" + typeof(client_id) + \" connected\");\n\n    while (true) {\n        let msg = conn.recv(10000);\n        if (msg == null || msg.type == \"close\") {\n            break;\n        }\n\n        if (msg.type == \"text\") {\n            print(\"Client \" + typeof(client_id) + \": \" + msg.data);\n            conn.send_text(\"Received: \" + msg.data);\n        }\n    }\n\n    print(\"Client \" + typeof(client_id) + \" disconnected\");\n}\n\ntry {\n    let server = WebSocketServer(\"0.0.0.0\", 8080);\n    defer server.close();\n\n    print(\"Server started on :8080\");\n\n    let client_id = 0;\n    while (true) {\n        let conn = server.accept(-1);\n        if (conn != null) {\n            client_id = client_id + 1;\n            spawn(handle_client, conn, client_id);\n        }\n    }\n} catch (e) {\n    print(\"Server error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Create a Hemlock program that tests deserialize basic.", "output": "```hemlock\n// Test: Basic JSON deserialization via round-trip\nlet original = { x: 10, y: 20, name: \"test\" };\nlet json = original.serialize();\nlet obj = json.deserialize();\nprint(obj.x);\nprint(obj.y);\nprint(obj.name);\n```", "category": "tests/objects", "source": "tests/objects/deserialize_basic.hml"}
{"instruction": "How does .path work in Hemlock?", "output": "```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does core allocation work in Hemlock?", "output": "buffer(size) - Allocate safe buffer*\n\n```hemlock\nlet buf = buffer(256);  // Allocate 256-byte buffer\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does color(text, code) work in Hemlock?", "output": "Returns:* string - Colorized text with reset\n\n```hemlock\nimport { color, RED, GREEN, BLUE } from \"@stdlib/terminal\";\n\nprint(color(\"Error\", RED));\nprint(color(\"Success\", GREEN));\nprint(color(\"Info\", BLUE));\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Show me Hemlock code that test switch with floating point values.", "output": "```hemlock\n// Test switch with floating point values\n\nlet pi = 3.14;\n\nswitch (pi) {\n    case 2.71:\n        print(\"euler\");\n        break;\n    case 3.14:\n        print(\"pi\");\n        break;\n    default:\n        print(\"other\");\n        break;\n}\n\n// Test with other float values\nlet x = 1.5;\n\nswitch (x) {\n    case 1.0:\n        print(\"one\");\n        break;\n    case 1.5:\n        print(\"one and a half\");\n        break;\n    case 2.0:\n        print(\"two\");\n        break;\n}\n\n// Expected output:\n// pi\n// one and a half\n```", "category": "tests/switch", "source": "tests/switch/floats.hml"}
{"instruction": "How does good use cases work in Hemlock?", "output": "5. Generating reports:*\n\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Running instances: \" + count);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does logger.set_level(level) work in Hemlock?", "output": "```hemlock\nimport { Logger, DEBUG, INFO, ERROR } from \"@stdlib/logging\";\n\nlet logger = Logger({ level: INFO });\n\nlogger.debug(\"Not shown\");   // Filtered\nlogger.info(\"Shown\");        // ‚úì\n\n// Change to DEBUG level\nlogger.set_level(DEBUG);\n\nlogger.debug(\"Now shown\");   // ‚úì\nlogger.info(\"Still shown\");  // ‚úì\n\n// Change to ERROR only\nlogger.set_level(ERROR);\n\nlogger.info(\"Not shown\");    // Filtered\nlogger.warn(\"Not shown\");    // Filtered\nlogger.error(\"Shown\");       // ‚úì\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does assert_eq(actual, expected) work in Hemlock?", "output": "Assert deep equality.\n\n```hemlock\ntest(\"simple equality\", fn() {\n    assert_eq(2 + 2, 4);\n    assert_eq(\"hello\", \"hello\");\n    assert_eq([1, 2, 3], [1, 2, 3]);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does always present work in Hemlock?", "output": "args is a global array available in all Hemlock programs:\n\n```hemlock\n// No need to declare or import\nprint(args.length);  // Works immediately\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does ceil(x) work in Hemlock?", "output": "Returns:* f64 - Ceiling of x\n\n```hemlock\nimport { ceil } from \"@stdlib/math\";\n\nlet result = ceil(3.2);   // 4.0\nlet result2 = ceil(-2.7); // -2.0\nlet result3 = ceil(5.0);  // 5.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does panic work in Hemlock?", "output": "```hemlock\npanic();                          // Default: \"panic!\"\npanic(\"unreachable code reached\");\npanic(42);\n\n// Common use case\nfn process_state(state: i32): string {\n    if (state == 1) { return \"ready\"; }\n    if (state == 2) { return \"running\"; }\n    panic(\"invalid state: \" + typeof(state));\n}\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "Create a Hemlock program that test u64 type annotation and typeof.", "output": "```hemlock\n// Test u64 type annotation and typeof\nlet a: u64 = 0;\nlet b: u64 = 2147483647;\nlet c: u64 = 1000000;\nprint(a);\nprint(b);\nprint(c);\nprint(typeof(a));\nprint(typeof(b));\nprint(typeof(c));\n```", "category": "tests/primitives", "source": "tests/primitives/u64_valid.hml"}
{"instruction": "How does aes_encrypt(plaintext: string, key: buffer, iv: buffer): buffer work in Hemlock?", "output": "Encrypt plaintext using AES-256-CBC with PKCS#7 padding.\n\n```hemlock\nimport { generate_aes_key, generate_iv, aes_encrypt } from \"@stdlib/crypto\";\n\nlet plaintext = \"Secret message!\";\nlet key = generate_aes_key();\nlet iv = generate_iv();\n\nlet ciphertext = aes_encrypt(plaintext, key, iv);\nprint(\"Encrypted \" + typeof(plaintext.length) + \" bytes to \" + typeof(ciphertext.length));\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does conditional read/write work in Hemlock?", "output": "```hemlock\nfn update_file(path: string, condition, new_content: string) {\n    let f = open(path, \"r+\");\n    try {\n        let content = f.read();\n\n        if (condition(content)) {\n            f.seek(0);  // Reset to beginning\n            f.write(new_content);\n        }\n    } finally {\n        f.close();\n    }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Show me Hemlock code that passing objects to functions.", "output": "```hemlock\n// Passing objects to functions\nfn printX(obj) {\n    print(obj.x);\n}\n\nlet myObj = { x: 42, y: 99 };\nprintX(myObj);\n```", "category": "tests/objects", "source": "tests/objects/object_as_value.hml"}
{"instruction": "Show me Hemlock code that test for-in loops.", "output": "```hemlock\n// Test for-in loops\n\n// Array iteration\nlet arr = [10, 20, 30, 40];\nfor (let x in arr) {\n    print(x);\n}\n\n// Nested for-in\nlet matrix = [[1, 2], [3, 4]];\nfor (let row in matrix) {\n    for (let val in row) {\n        print(val);\n    }\n}\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/for_in.hml"}
{"instruction": "Show me Hemlock code that test integer overflow behavior for various types Expected: PASS (testing overflow detection).", "output": "```hemlock\n// Test integer overflow behavior for various types\n// Expected: PASS (testing overflow detection)\n\n// i8 overflow\ntry {\n    let x: i8 = 127;\n    let y: i8 = x + 1;\n    print(\"ERROR: i8 overflow should have been caught\");\n} catch (e) {\n    print(\"i8 overflow caught: \" + e);\n}\n\n// i8 underflow\ntry {\n    let x: i8 = -128;\n    let y: i8 = x - 1;\n    print(\"ERROR: i8 underflow should have been caught\");\n} catch (e) {\n    print(\"i8 underflow caught: \" + e);\n}\n\n// i16 overflow\ntry {\n    let x: i16 = 32767;\n    let y: i16 = x + 1;\n    print(\"ERROR: i16 overflow should have been caught\");\n} catch (e) {\n    print(\"i16 overflow caught: \" + e);\n}\n\n// i32 overflow - test if detected\ntry {\n    let x: i32 = 2147483647;\n    let y: i32 = x + 1;\n    print(\"i32 overflow not caught, result: \" + typeof(y));\n} catch (e) {\n    print(\"i32 overflow caught: \" + e);\n}\n\n// u8 overflow\ntry {\n    let x: u8 = 255;\n    let y: u8 = x + 1;\n    print(\"ERROR: u8 overflow should have been caught\");\n} catch (e) {\n    print(\"u8 overflow caught: \" + e);\n}\n\n// u16 overflow\ntry {\n    let x: u16 = 65535;\n    let y: u16 = x + 1;\n    print(\"ERROR: u16 overflow should have been caught\");\n} catch (e) {\n    print(\"u16 overflow caught: \" + e);\n}\n\n// u32 overflow\ntry {\n    let x: u32 = 4294967295;\n    let y: u32 = x + 1;\n    print(\"u32 overflow not caught or detected\");\n} catch (e) {\n    print(\"u32 overflow caught: \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/primitives", "source": "tests/primitives/edge_integer_overflow.hml"}
{"instruction": "Implement a Hemlock program that test arithmetic operations.", "output": "```hemlock\n// Test arithmetic operations\nlet a = 10;\nlet b = 3;\n\nprint(a + b);\nprint(a - b);\nprint(a * b);\nprint(a / b);\n\n// Negative numbers\nprint(-5 + 2);\nprint(10 - 15);\n\n// Complex expressions\nprint((a + b) * 2);\nprint(a + b * 2);\n```", "category": "tests/compiler", "source": "tests/compiler/arithmetic.hml"}
{"instruction": "Show an example of example in Hemlock.", "output": "```hemlock\nimport { Set } from \"@stdlib/collections\";\n\nlet s = Set();\n\n// Add values\ns.add(10);\ns.add(20);\ns.add(10);  // Duplicate, ignored\n\nprint(s.size);  // 2\n\n// Check membership\nif (s.has(10)) {\n    print(\"10 is in the set\");\n}\n\n// Set operations\nlet s1 = Set();\ns1.add(1);\ns1.add(2);\ns1.add(3);\n\nlet s2 = Set();\ns2.add(2);\ns2.add(3);\ns2.add(4);\n\nlet union = s1.union(s2);         // {1, 2, 3, 4}\nlet inter = s1.intersection(s2);  // {2, 3}\nlet diff = s1.difference(s2);     // {1}\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does null literal work in Hemlock?", "output": "```hemlock\nlet nothing = null;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does is_alnum(str) work in Hemlock?", "output": "Common use case - validating identifiers:*\n\n```hemlock\nimport { is_alnum } from \"@stdlib/strings\";\n\nfn is_valid_identifier(name: string): bool {\n    if (name.length == 0) {\n        return false;\n    }\n    // First char must be alpha, rest can be alnum\n    let first = name.slice(0, 1);\n    if (!is_alpha(first)) {\n        return false;\n    }\n    return is_alnum(name);\n}\n\nprint(is_valid_identifier(\"myVar123\"));  // true\nprint(is_valid_identifier(\"123var\"));    // false\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Show me Hemlock code that test object literals and methods.", "output": "```hemlock\n// Test object literals and methods\n\n// Basic object\nlet point = { x: 10, y: 20 };\nprint(point.x);\nprint(point.y);\n\n// Object with method using self\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n\ncounter.increment();\ncounter.increment();\nprint(counter.get());\n\n// Nested objects\nlet person = {\n    name: \"Alice\",\n    address: {\n        city: \"NYC\",\n        zip: 10001\n    }\n};\nprint(person.name);\nprint(person.address.city);\n\n// Object field assignment\npoint.z = 30;\nprint(point.z);\n```", "category": "tests/compiler", "source": "tests/compiler/objects.hml"}
{"instruction": "How does type checking work in Hemlock?", "output": "Use typeof() to check if a value is a rune:\n\n```hemlock\nlet r = 'üöÄ';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (indexing returns runes)\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport {\n    base64_encode, base64_decode,\n    hex_encode, hex_decode,\n    url_encode, url_decode\n} from \"@stdlib/encoding\";\n\n// Base64 example\nlet data = \"Hello, World!\";\nlet b64 = base64_encode(data);\nprint(\"Base64: \" + b64);\nprint(\"Decoded: \" + base64_decode(b64));\n\n// Hex example\nlet hex = hex_encode(data);\nprint(\"\\nHex: \" + hex);\nprint(\"Decoded: \" + hex_decode(hex));\n\n// URL example\nlet url_data = \"hello@example.com?query=value\";\nlet url_enc = url_encode(url_data);\nprint(\"\\nURL Encoded: \" + url_enc);\nprint(\"Decoded: \" + url_decode(url_enc));\n\n// Working with binary data\nlet binary = \"\";\nlet i = 0;\nwhile (i < 10) {\n    let b: rune = i * 25;\n    binary = binary + b;\n    i = i + 1;\n}\n\nprint(\"\\nBinary data (10 bytes):\");\nprint(\"  Base64: \" + base64_encode(binary));\nprint(\"  Hex: \" + hex_encode(binary));\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does rsageneratekey(): rsakeypair work in Hemlock?", "output": "Generate a 2048-bit RSA key pair for signing and verification.\n\n```hemlock\nimport { rsa_generate_key, rsa_free_keys } from \"@stdlib/crypto\";\n\nlet keypair = rsa_generate_key();\ndefer rsa_free_keys(keypair);  // Always free keys when done\n\nprint(typeof(keypair));  // \"RSAKeyPair\"\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does closure environment access work in Hemlock?", "output": "However, modifying variables from the parent scope is undefined behavior:\n\n```hemlock\nlet x = 10;\n\nasync fn read_only(): i32 {\n    return x;  // OK: reading closure variable\n}\n\nasync fn modify_closure() {\n    x = 20;  // UNDEFINED BEHAVIOR: don't do this!\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does command chaining work in Hemlock?", "output": "With ; (sequence):*\n\n```hemlock\nlet r = exec(\"command1; command2\");\n// Runs both regardless of success/failure\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does type: array of strings work in Hemlock?", "output": "All arguments are stored as strings:\n\n```hemlock\n// Arguments: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\" (string, not number)\nprint(args[2]);  // \"3.14\" (string, not number)\nprint(args[3]);  // \"true\" (string, not boolean)\n\n// Convert as needed:\nlet num = 42;  // Parse manually if needed\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Write Hemlock code that comprehensive arithmetic operations test Tests: +, -, *, /, %, negation, precedence.", "output": "```hemlock\n// Comprehensive arithmetic operations test\n// Tests: +, -, *, /, %, negation, precedence\n\n// Basic operations\nprint(5 + 3);    // 8\nprint(10 - 4);   // 6\nprint(3 * 4);    // 12\nprint(20 / 4);   // 5\nprint(17 % 5);   // 2\n\n// Negation\nprint(-5);       // -5\nprint(-(-3));    // 3\n\n// Precedence\nprint(2 + 3 * 4);      // 14\nprint((2 + 3) * 4);    // 20\nprint(10 - 4 / 2);     // 8\nprint(10 / 2 + 3);     // 8\n\n// Mixed types (type promotion)\nlet i: i32 = 10;\nlet f: f64 = 3.5;\nprint(i + f);    // 13.5\n\n// Large numbers\nlet big: i64 = 5000000000;\nprint(big + 1);  // 5000000001\n\n// Float operations\nprint(3.14 + 2.86);   // 6\nprint(10.5 - 3.5);    // 7\nprint(2.5 * 4.0);     // 10\nprint(15.0 / 3.0);    // 5\n\n// Compound expressions\nlet x = 10;\nlet y = 3;\nprint((x + y) * (x - y));  // 91\n```", "category": "tests/parity", "source": "tests/parity/language/arithmetic.hml"}
{"instruction": "Implement a Hemlock program that test datetime builtins.", "output": "```hemlock\n// Test datetime builtins\n\n// Get current timestamp\nlet ts = now();\nprint(ts > 0);\n\n// localtime - convert timestamp to time object\nlet local = localtime(ts);\nprint(local.year >= 2024);\nprint(local.month >= 1 && local.month <= 12);\nprint(local.day >= 1 && local.day <= 31);\nprint(local.hour >= 0 && local.hour <= 23);\nprint(local.minute >= 0 && local.minute <= 59);\nprint(local.second >= 0 && local.second <= 60);\n\n// gmtime - convert timestamp to UTC time object\nlet utc = gmtime(ts);\nprint(utc.year >= 2024);\nprint(utc.month >= 1 && utc.month <= 12);\n\n// mktime - convert time object back to timestamp\nlet ts2 = mktime(local);\nprint(ts2 > 0);\n\n// strftime - format time\nlet formatted = strftime(\"%Y\", local);\nprint(formatted.length == 4);\n\n// Test with fixed timestamp (2024-01-01 00:00:00 UTC approximately)\nlet fixed_ts = 1704067200;\nlet fixed_local = gmtime(fixed_ts);\nprint(fixed_local.year == 2024);\nprint(fixed_local.month == 1);\nprint(fixed_local.day == 1);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/datetime.hml"}
{"instruction": "How does known acceptable leaks work in Hemlock?", "output": "Global built-ins:*\n\n```hemlock\n// Built-in functions, FFI types, and constants are allocated at startup\n// and not freed at exit (typically ~200 bytes)\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Write Hemlock code that spawns 100 concurrent tasks to test thread safety.", "output": "```hemlock\n// Test: High concurrency stress test\n// Spawns 100 concurrent tasks to test thread safety\n\nasync fn compute_sum(start: i32, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        sum = sum + (start + i);\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn 100 tasks\nlet num_tasks = 100;\nlet tasks = [];\nlet i = 0;\n\nwhile (i < num_tasks) {\n    let task = spawn(compute_sum, i * 100, 100);\n    tasks.push(task);\n    i = i + 1;\n}\n\n// Join all tasks and compute total\nlet total = 0;\ni = 0;\nwhile (i < tasks.length) {\n    let result = join(tasks[i]);\n    total = total + result;\n    i = i + 1;\n}\n\nprint(\"Completed:\");\nprint(num_tasks);\nprint(\"Total sum:\");\nprint(total);\n```", "category": "tests/async", "source": "tests/async/stress_concurrent_tasks.hml"}
{"instruction": "Implement a Hemlock program that basic method call with self.", "output": "```hemlock\n// Basic method call with self\nlet obj = {\n    value: 42,\n    getValue: fn() {\n        return self.value;\n    },\n};\n\nprint(obj.getValue());\n```", "category": "tests/objects", "source": "tests/objects/method_basic.hml"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "Bitwise AND (&)*\n\n```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\nprint(a & b);   // 8 (1000)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does generateaeskey(): buffer work in Hemlock?", "output": "Generate a secure 256-bit (32-byte) AES key.\n\n```hemlock\nimport { generate_aes_key } from \"@stdlib/crypto\";\n\nlet key = generate_aes_key();\nprint(key.length);  // 32 bytes\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "Write Hemlock code that test exists() function.", "output": "```hemlock\n// Test exists() function\nimport { exists, write_file, remove_file } from \"@stdlib/fs\";\n\nlet test_file = \"/tmp/test_exists.txt\";\n\n// Create a test file\nwrite_file(test_file, \"test content\");\n\n// Test that file exists\nassert(exists(test_file) == true, \"exists() should return true for existing file\");\n\n// Test that non-existent file returns false\nassert(exists(\"/tmp/nonexistent_file_12345.txt\") == false, \"exists() should return false for non-existent file\");\n\n// Clean up\nremove_file(test_file);\n\n// Verify file no longer exists\nassert(exists(test_file) == false, \"exists() should return false after file removal\");\n\nprint(\"All exists() tests passed!\");\n```", "category": "tests/io", "source": "tests/io/exists.hml"}
{"instruction": "How does url_decode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { url_decode } from \"@stdlib/encoding\";\n\n// Basic decoding\nlet decoded1 = url_decode(\"Hello+World\");\nprint(decoded1);  // \"Hello World\"\n\n// %20 also decodes to space\nlet decoded2 = url_decode(\"Hello%20World\");\nprint(decoded2);  // \"Hello World\"\n\n// Percent-encoded characters\nlet decoded3 = url_decode(\"hello%40example.com\");\nprint(decoded3);  // \"hello@example.com\"\n\n// Complex URL\nlet decoded4 = url_decode(\"key%3Dvalue%26foo%3Dbar\");\nprint(decoded4);  // \"key=value&foo=bar\"\n\n// Unicode\nlet decoded5 = url_decode(\"Hello+%E4%B8%96%E7%95%8C\");\nprint(decoded5);  // \"Hello ‰∏ñÁïå\"\n\n// Round-trip\nlet original = \"Hello, World! 100% sure?\";\nlet encoded = url_encode(original);\nlet decoded6 = url_decode(encoded);\nprint(decoded6 == original);  // true\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "Write Hemlock code that test const in function.", "output": "```hemlock\n// Test const in function\nfn test() {\n    const x = 42;\n    print(x);\n    return x;\n}\n\nlet result = test();\nprint(result);\n\n// Expected output:\n// 42\n// 42\n```", "category": "tests/const", "source": "tests/const/const_in_function.hml"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does case conversion work in Hemlock?", "output": "to_upper()* - Convert to uppercase:\n\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// Preserves non-ASCII\nlet s2 = \"caf√©\";\nlet upper2 = s2.to_upper();     // \"CAF√â\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does execution order work in Hemlock?", "output": "Understanding the execution order:\n\n```hemlock\ntry {\n    print(\"1: try block start\");\n    throw \"error\";\n    print(\"2: never reached\");\n} catch (e) {\n    print(\"3: catch block\");\n} finally {\n    print(\"4: finally block\");\n}\nprint(\"5: after try/catch/finally\");\n\n// Output:\n// 1: try block start\n// 3: catch block\n// 4: finally block\n// 5: after try/catch/finally\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Create a Hemlock program that basic closure.", "output": "```hemlock\n// Basic closure\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));\n```", "category": "tests/functions", "source": "tests/functions/closure_basic.hml"}
{"instruction": "Show an example of example 3: worker pool controller in Hemlock.", "output": "```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Shutting down...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Main loop adjusts worker pool based on worker_count\nwhile (!should_exit) {\n    // Manage workers based on worker_count\n    // ...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Write a Hemlock program that tests channel thread safety under high load.", "output": "```hemlock\n// Test: Channel stress test with multiple producers and consumers\n// Tests channel thread safety under high load\n\nasync fn producer(ch, start: i32, count: i32): i32 {\n    let i = 0;\n    while (i < count) {\n        ch.send(start + i);\n        i = i + 1;\n    }\n    return count;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel with buffer\nlet ch = channel(100);\n\n// Spawn 10 producers (each sends 100 messages)\nlet num_producers = 10;\nlet messages_per_producer = 100;\nlet producers = [];\nlet i = 0;\n\nwhile (i < num_producers) {\n    let task = spawn(producer, ch, i * messages_per_producer, messages_per_producer);\n    producers.push(task);\n    i = i + 1;\n}\n\n// Spawn 10 consumers (each receives 100 messages)\nlet num_consumers = 10;\nlet messages_per_consumer = 100;\nlet consumers = [];\ni = 0;\n\nwhile (i < num_consumers) {\n    let task = spawn(consumer, ch, messages_per_consumer);\n    consumers.push(task);\n    i = i + 1;\n}\n\n// Wait for all producers\nlet produced = 0;\ni = 0;\nwhile (i < producers.length) {\n    produced = produced + join(producers[i]);\n    i = i + 1;\n}\n\n// Wait for all consumers\nlet consumed_sum = 0;\ni = 0;\nwhile (i < consumers.length) {\n    consumed_sum = consumed_sum + join(consumers[i]);\n    i = i + 1;\n}\n\nprint(\"Produced messages:\");\nprint(produced);\nprint(\"Consumer sum:\");\nprint(consumed_sum);\n```", "category": "tests/async", "source": "tests/async/stress_channel_throughput.hml"}
{"instruction": "How does pattern: iteration with filtering work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Print only even numbers\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // Skip odd numbers\n    }\n    print(arr[i]);\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does pointer types work in Hemlock?", "output": "```hemlock\nlet p: ptr = alloc(64);\n// No bounds checking, manual lifetime management\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Write Hemlock code that tests catch scope.", "output": "```hemlock\n// Test: Catch parameter is scoped to catch block\nlet e = \"outer\";\ntry {\n    throw \"inner\";\n} catch (e) {\n    print(\"In catch: \" + e);\n}\nprint(\"After catch: \" + e);\n```", "category": "tests/exceptions", "source": "tests/exceptions/catch_scope.hml"}
{"instruction": "Show me Hemlock code that multiple defers - should execute in LIFO order.", "output": "```hemlock\n// Multiple defers - should execute in LIFO order\nfn test_multiple() {\n    defer print(\"first\");\n    defer print(\"second\");\n    defer print(\"third\");\n    print(\"body\");\n}\n\ntest_multiple();\n```", "category": "tests/defer", "source": "tests/defer/multiple_defers.hml"}
{"instruction": "Show an example of examples in Hemlock.", "output": "Creating a new file for writing:*\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // Creates or truncates\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does status reporting work in Hemlock?", "output": "```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" requests handled\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// From shell: kill -USR1 <pid>\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does asyncwritefile work in Hemlock?", "output": "```hemlock\nimport { async_write_file } from \"@stdlib/async_fs\";\n\nlet future = async_write_file(\"output.txt\", \"Hello, World!\");\nfuture.get();  // Wait for write to complete\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does mixed integer types work in Hemlock?", "output": "```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Implement a Hemlock program that test basic compression and decompression.", "output": "```hemlock\n// Test basic compression and decompression\nimport { compress, decompress } from \"@stdlib/compression\";\n\n// Test basic compression (small strings may have overhead, so just test round-trip)\nlet original = \"Hello, World! This is a test string to compress.\";\nlet compressed = compress(original);\n\n// Compressed should be a buffer\nprint(typeof(compressed) == \"buffer\");  // true\n\n// Decompress should restore original\nlet restored = decompress(compressed);\nprint(restored == original);  // true\n\n// Test with longer string (more compression opportunity)\nlet long_string = \"\";\nlet i = 0;\nwhile (i < 100) {\n    long_string = long_string + \"The quick brown fox jumps over the lazy dog. \";\n    i = i + 1;\n}\n\nlet long_compressed = compress(long_string);\n// Long repetitive strings should compress well\nprint(long_compressed.length < long_string.byte_length);  // true\n\nlet long_restored = decompress(long_compressed);\nprint(long_restored == long_string);  // true\n\nprint(\"Basic compression tests passed!\");\n```", "category": "tests/stdlib_compression", "source": "tests/stdlib_compression/basic_compress.hml"}
{"instruction": "Implement a Hemlock program that test UTF-8 string indexing.", "output": "```hemlock\n// Test UTF-8 string indexing\n\nlet s = \"Hi üöÄ!\";\n\nprint(\"String: \");\nprint(s);\nprint(\"Length: \");\nprint(s.length);\n\nprint(\"\\nIndexing:\");\nprint(\"s[0] = \");\nprint(s[0]);  // Should be 'H'\n\nprint(\"s[1] = \");\nprint(s[1]);  // Should be 'i'\n\nprint(\"s[2] = \");\nprint(s[2]);  // Should be ' ' (space)\n\nprint(\"s[3] = \");\nprint(s[3]);  // Should be rocket emoji\n\nprint(\"s[4] = \");\nprint(s[4]);  // Should be '!'\n\nprint(\"\\nIndexing works!\");\n```", "category": "tests/strings", "source": "tests/strings/utf8_indexing.hml"}
{"instruction": "Implement a Hemlock program that test null return type annotation.", "output": "```hemlock\n// Test null return type annotation\n\n// Function with null return type - no explicit return\nfn no_return(): null {\n    print(\"no_return called\");\n}\n\n// Function with null return type - bare return\nfn bare_return(): null {\n    print(\"bare_return called\");\n    return;\n}\n\n// Function with null return type - explicit return null\nfn explicit_return(): null {\n    print(\"explicit_return called\");\n    return null;\n}\n\n// Call all functions\nno_return();\nbare_return();\nexplicit_return();\n\n// Verify the return value is null\nlet result = no_return();\nprint(typeof(result));\n\nprint(\"all tests passed\");\n```", "category": "tests/functions", "source": "tests/functions/null_return_type.hml"}
{"instruction": "Write a Hemlock program that test exception occurring in finally block Expected: PASS.", "output": "```hemlock\n// Test exception occurring in finally block\n// Expected: PASS\n\nlet cleanup_ran = false;\n\ntry {\n    try {\n        print(\"try block\");\n    } finally {\n        cleanup_ran = true;\n        throw \"error in finally\";\n    }\n} catch (e) {\n    assert(cleanup_ran == true, \"finally should have run\");\n    assert(e == \"error in finally\", \"should catch finally exception\");\n    print(\"PASS\");\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/edge_exception_in_finally.hml"}
{"instruction": "How does api work in Hemlock?", "output": "```hemlock\nlet map = HashMap();\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does fnv1a(input: string): i32 work in Hemlock?", "output": "FNV-1a hash algorithm - better avalanche properties than djb2 for certain data patterns.\n\n```hemlock\nlet h = fnv1a(\"hello world\");\nprint(h);  // -1382160680\n\n// FNV-1a is deterministic\nlet h2 = fnv1a(\"hello world\");\nassert(h == h2, \"Same input = same hash\");\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "Write a Hemlock program that test @stdlib/json validation and type checking.", "output": "```hemlock\n// Test @stdlib/json validation and type checking\n\nimport {\n    is_valid, validate,\n    is_object, is_array, is_string, is_number, is_bool, is_null,\n    type_of\n} from \"@stdlib/json\";\n\n// Test is_valid() with valid JSON\nassert(is_valid(\"{\\\"x\\\":10}\") == true, \"is_valid object\");\nassert(is_valid(\"[1,2,3]\") == true, \"is_valid array\");\nassert(is_valid(\"\\\"hello\\\"\") == true, \"is_valid string\");\nassert(is_valid(\"42\") == true, \"is_valid number\");\nassert(is_valid(\"true\") == true, \"is_valid bool\");\nassert(is_valid(\"null\") == true, \"is_valid null\");\n\n// Test is_valid() with invalid JSON\nassert(is_valid(\"{\\\"unclosed\\\"\") == false, \"is_valid unclosed object\");\nassert(is_valid(\"[1,2,\") == false, \"is_valid unclosed array\");\nassert(is_valid(\"invalid\") == false, \"is_valid invalid text\");\nassert(is_valid(\"\") == false, \"is_valid empty string\");\n\n// Test validate() with valid JSON\nlet result1 = validate(\"{\\\"x\\\":10}\");\nassert(result1.valid == true, \"validate valid JSON\");\nassert(result1.message == \"Valid JSON\", \"validate valid message\");\n\n// Test validate() with invalid JSON\nlet result2 = validate(\"{\\\"unclosed\\\"\");\nassert(result2.valid == false, \"validate invalid JSON\");\nassert(typeof(result2.message) == \"string\", \"validate error message is string\");\n\n// Test type checking - is_object()\nassert(is_object({}) == true, \"is_object empty object\");\nassert(is_object({ x: 10 }) == true, \"is_object with properties\");\nassert(is_object([]) == false, \"is_object rejects array\");\nassert(is_object(\"text\") == false, \"is_object rejects string\");\nassert(is_object(42) == false, \"is_object rejects number\");\nassert(is_object(null) == false, \"is_object rejects null\");\n\n// Test type checking - is_array()\nassert(is_array([]) == true, \"is_array empty array\");\nassert(is_array([1, 2, 3]) == true, \"is_array with elements\");\nassert(is_array({}) == false, \"is_array rejects object\");\nassert(is_array(\"text\") == false, \"is_array rejects string\");\nassert(is_array(42) == false, \"is_array rejects number\");\n\n// Test type checking - is_string()\nassert(is_string(\"hello\") == true, \"is_string with text\");\nassert(is_string(\"\") == true, \"is_string empty\");\nassert(is_string(42) == false, \"is_string rejects number\");\nassert(is_string(true) == false, \"is_string rejects bool\");\nassert(is_string([]) == false, \"is_string rejects array\");\n\n// Test type checking - is_number()\nassert(is_number(42) == true, \"is_number integer\");\nassert(is_number(3.14) == true, \"is_number float\");\nassert(is_number(0) == true, \"is_number zero\");\nassert(is_number(\"42\") == false, \"is_number rejects string\");\nassert(is_number(true) == false, \"is_number rejects bool\");\n\n// Test type checking - is_bool()\nassert(is_bool(true) == true, \"is_bool true\");\nassert(is_bool(false) == true, \"is_bool false\");\nassert(is_bool(1) == false, \"is_bool rejects number\");\nassert(is_bool(\"true\") == false, \"is_bool rejects string\");\n\n// Test type checking - is_null()\nassert(is_null(null) == true, \"is_null null\");\nassert(is_null(0) == false, \"is_null rejects zero\");\nassert(is_null(\"\") == false, \"is_null rejects empty string\");\nassert(is_null(false) == false, \"is_null rejects false\");\n\n// Test type_of()\nassert(type_of({}) == \"object\", \"type_of object\");\nassert(type_of([]) == \"array\", \"type_of array\");\nassert(type_of(\"text\") == \"string\", \"type_of string\");\nassert(type_of(42) == \"number\", \"type_of number\");\nassert(type_of(3.14) == \"number\", \"type_of float\");\nassert(type_of(true) == \"bool\", \"type_of bool\");\nassert(type_of(null) == \"null\", \"type_of null\");\n\nprint(\"All validation and type checking tests passed!\");\n```", "category": "tests/stdlib_json", "source": "tests/stdlib_json/validation_test.hml"}
{"instruction": "How does error handling work in Hemlock?", "output": "Errors in async operations are captured and re-thrown when get() is called:\n\n```hemlock\nimport { async_read_file } from \"@stdlib/async_fs\";\n\nlet future = async_read_file(\"nonexistent.txt\");\n\ntry {\n    let content = future.get();\n} catch (e) {\n    print(\"Failed to read file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Write a Hemlock program that test channel with capacity 0 Expected: Testing behavior (may error or have specific semantics).", "output": "```hemlock\n// Test channel with capacity 0\n// Expected: Testing behavior (may error or have specific semantics)\n\ntry {\n    let ch = channel(0);\n    print(\"Channel with capacity 0 was created\");\n\n    // Try to send - should block or error\n    // This would require async send/recv to test properly\n    ch.close();\n    print(\"PASS\");\n} catch (e) {\n    print(\"PASS: Channel with capacity 0 threw error: \" + e);\n}\n```", "category": "tests/async", "source": "tests/async/edge_channel_capacity_zero.hml"}
{"instruction": "How does username() work in Hemlock?", "output": "Multi-user applications\n\n```hemlock\nimport { username } from \"@stdlib/os\";\n\nlet user = username();\nprint(\"Current user: \" + user);  // e.g., \"john\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Write a Hemlock program that test cryptographic hash functions.", "output": "```hemlock\n// Test cryptographic hash functions\n\nimport { sha256, sha512, md5 } from \"@stdlib/hash\";\n\n// ========== SHA-256 TESTS ==========\n\n// Test basic sha256\nlet s1 = sha256(\"hello\");\nassert(typeof(s1) == \"string\", \"sha256 should return string\");\nassert(s1.length == 64, \"sha256 should return 64-character hex string (32 bytes)\");\n\n// Test empty string (known SHA-256 hash)\nlet s2 = sha256(\"\");\nassert(s2 == \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n       \"sha256 of empty string should match known value\");\n\n// Test \"hello\" (known SHA-256 hash)\nlet s3 = sha256(\"hello\");\nassert(s3 == \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\",\n       \"sha256 of 'hello' should match known value\");\n\n// Test deterministic\nlet s4a = sha256(\"test\");\nlet s4b = sha256(\"test\");\nassert(s4a == s4b, \"sha256 should be deterministic\");\n\n// Test different inputs produce different hashes\nlet s5a = sha256(\"hello\");\nlet s5b = sha256(\"world\");\nassert(s5a != s5b, \"sha256 should produce different hashes for different inputs\");\n\n// Test UTF-8 strings\nlet s6 = sha256(\"Hello üåç\");\nassert(s6.length == 64, \"sha256 should handle UTF-8\");\n\n// Test longer strings\nlet s7 = sha256(\"The quick brown fox jumps over the lazy dog\");\nassert(s7 == \"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\",\n       \"sha256 of pangram should match known value\");\n\n// ========== SHA-512 TESTS ==========\n\n// Test basic sha512\nlet h1 = sha512(\"hello\");\nassert(typeof(h1) == \"string\", \"sha512 should return string\");\nassert(h1.length == 128, \"sha512 should return 128-character hex string (64 bytes)\");\n\n// Test empty string (known SHA-512 hash)\nlet h2 = sha512(\"\");\nassert(h2 == \"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\",\n       \"sha512 of empty string should match known value\");\n\n// Test deterministic\nlet h3a = sha512(\"test\");\nlet h3b = sha512(\"test\");\nassert(h3a == h3b, \"sha512 should be deterministic\");\n\n// Test different inputs\nlet h4a = sha512(\"hello\");\nlet h4b = sha512(\"world\");\nassert(h4a != h4b, \"sha512 should produce different hashes for different inputs\");\n\n// Test UTF-8 strings\nlet h5 = sha512(\"Hello üöÄ\");\nassert(h5.length == 128, \"sha512 should handle UTF-8\");\n\n// ========== MD5 TESTS ==========\n\n// Test basic md5\nlet m1 = md5(\"hello\");\nassert(typeof(m1) == \"string\", \"md5 should return string\");\nassert(m1.length == 32, \"md5 should return 32-character hex string (16 bytes)\");\n\n// Test empty string (known MD5 hash)\nlet m2 = md5(\"\");\nassert(m2 == \"d41d8cd98f00b204e9800998ecf8427e\",\n       \"md5 of empty string should match known value\");\n\n// Test \"hello\" (known MD5 hash)\nlet m3 = md5(\"hello\");\nassert(m3 == \"5d41402abc4b2a76b9719d911017c592\",\n       \"md5 of 'hello' should match known value\");\n\n// Test deterministic\nlet m4a = md5(\"test\");\nlet m4b = md5(\"test\");\nassert(m4a == m4b, \"md5 should be deterministic\");\n\n// Test different inputs\nlet m5a = md5(\"hello\");\nlet m5b = md5(\"world\");\nassert(m5a != m5b, \"md5 should produce different hashes for different inputs\");\n\n// Test UTF-8 strings\nlet m6 = md5(\"Hello ‰∏ñÁïå\");\nassert(m6.length == 32, \"md5 should handle UTF-8\");\n\n// Test longer strings\nlet m7 = md5(\"The quick brown fox jumps over the lazy dog\");\nassert(m7 == \"9e107d9d372bb6826bd81d3542a419d6\",\n       \"md5 of pangram should match known value\");\n\n// ========== CROSS-ALGORITHM TESTS ==========\n\n// Test that all three algorithms produce different results\nlet input = \"hash comparison test\";\nlet sha256_hash = sha256(input);\nlet sha512_hash = sha512(input);\nlet md5_hash = md5(input);\n\nassert(sha256_hash != md5_hash, \"sha256 and md5 should differ (different lengths)\");\nassert(sha512_hash != md5_hash, \"sha512 and md5 should differ (different lengths)\");\nassert(sha256_hash.length == 64, \"sha256 output length check\");\nassert(sha512_hash.length == 128, \"sha512 output length check\");\nassert(md5_hash.length == 32, \"md5 output length check\");\n\nprint(\"All crypto hash tests passed!\");\n```", "category": "tests/stdlib_hash", "source": "tests/stdlib_hash/test_crypto.hml"}
{"instruction": "How does deserialize from json work in Hemlock?", "output": "Parse JSON strings back to objects:\n\n```hemlock\n// json.deserialize() - Parse JSON string to object\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does pi work in Hemlock?", "output": "The mathematical constant œÄ (pi) ‚âà 3.14159265358979323846\n\n```hemlock\nimport { PI } from \"@stdlib/math\";\nlet circumference = 2.0 * PI * radius;\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does array literals work in Hemlock?", "output": "```hemlock\nlet arr = [element1, element2, element3];\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does cwd() work in Hemlock?", "output": "Throws:* Exception if current directory cannot be determined\n\n```hemlock\nimport { cwd } from \"@stdlib/fs\";\n\ntry {\n    let current = cwd();\n    print(\"Current directory: \" + current);\n} catch (e) {\n    print(\"Error getting current directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Write a Hemlock program that tests test buffer refcount.", "output": "```hemlock\nlet buf = buffer(10);\nprint(\"After buffer creation\");\n\nlet fw = open(\"tests/temp/test_binary.dat\", \"w\");\nprint(\"Before write_bytes\");\nfw.write_bytes(buf);\nprint(\"After write_bytes\");\nfw.close();\n\nprint(\"Before free\");\nfree(buf);\nprint(\"After free\");\n```", "category": "tests/manual", "source": "tests/manual/test_buffer_refcount.hml"}
{"instruction": "How does memset work in Hemlock?", "output": "```hemlock\nlet p = alloc(100);\n\n// Zero out memory\nmemset(p, 0, 100);\n\n// Fill with specific value\nmemset(p, 0xFF, 100);\n\n// Initialize buffer\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Fill with 'A'\n\nfree(p);\nfree(buf);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does tmpdir() work in Hemlock?", "output": "Intermediate processing files\n\n```hemlock\nimport { tmpdir, get_pid } from \"@stdlib/os\";\nimport { get_pid } from \"@stdlib/env\";\n\nlet tmp = tmpdir();\nprint(\"Temp directory: \" + tmp);  // e.g., \"/tmp\"\n\n// Create unique temp file path\nlet temp_file = tmp + \"/myapp.\" + typeof(get_pid()) + \".tmp\";\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does free_memory() work in Hemlock?", "output": "Note:* On Linux, this includes buffers/cache as \"available\" memory.\n\n```hemlock\nimport { free_memory, format_bytes } from \"@stdlib/os\";\n\nlet free = free_memory();\nprint(\"Available memory: \" + format_bytes(free));  // e.g., \"8 GB\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does system monitoring work in Hemlock?", "output": "```hemlock\nimport * as os from \"@stdlib/os\";\nimport { sleep } from \"@stdlib/time\";\n\nfn monitor_system(interval_seconds: i32, iterations: i32): null {\n    print(\"=== System Monitor ===\");\n    print(\"Host: \" + os.hostname());\n    print(\"Platform: \" + os.platform() + \" \" + os.arch());\n    print(\"CPUs: \" + typeof(os.cpu_count()));\n    print(\"\");\n\n    let i = 0;\n    while (i < iterations) {\n        let mem = os.memory_info();\n        let usage_percent = (mem.used * 100) / mem.total;\n\n        print(\"[\" + typeof(i + 1) + \"] Memory: \" +\n              os.format_bytes(mem.used) + \" / \" +\n              os.format_bytes(mem.total) +\n              \" (\" + typeof(usage_percent) + \"%)\");\n\n        sleep(interval_seconds);\n        i = i + 1;\n    }\n\n    return null;\n}\n\n// Monitor every 5 seconds, 10 times\nmonitor_system(5, 10);\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does make_dir(path, mode?) work in Hemlock?", "output": "Throws:* Exception if directory already exists or cannot be created\n\n```hemlock\nimport { make_dir } from \"@stdlib/fs\";\n\ntry {\n    // Create with default permissions (0755)\n    make_dir(\"new_directory\");\n\n    // Create with custom permissions (0700 - owner only)\n    let mode: u32 = 448;  // 0700 in octal = 448 in decimal\n    make_dir(\"private_dir\", mode);\n\n    print(\"Directories created\");\n} catch (e) {\n    print(\"Error creating directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does methods with parameters work in Hemlock?", "output": "```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Create a Hemlock program that tests memset.", "output": "```hemlock\nlet p = alloc(4);\nmemset(p, 65, 4);\nprint(p);\nfree(p);\n```", "category": "tests/pointers", "source": "tests/pointers/memset.hml"}
{"instruction": "How does spinner(frames?) work in Hemlock?", "output": "next() - Advance to next frame without printing\n\n```hemlock\nimport { Spinner, SPINNER_DOTS } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nlet spinner = Spinner(SPINNER_DOTS());\n\nlet i = 0;\nwhile (i < 50) {\n    spinner.spin();\n    sleep(0.1);\n    i = i + 1;\n}\nspinner.finish(\"Done!\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does rand() work in Hemlock?", "output": "Returns:* f64 - Random value in [0.0, 1.0)\n\n```hemlock\nimport { rand } from \"@stdlib/math\";\n\nlet random = rand();  // e.g., 0.7382491...\nlet random2 = rand(); // e.g., 0.2194837...\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does logger.debug(message, data?) work in Hemlock?", "output": "```hemlock\nlogger.debug(\"Variable value\", { x: 42, y: 100 });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Show an example of basic example in Hemlock.", "output": "```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show an example of complete example: hash table with murmurhash3 in Hemlock.", "output": "```hemlock\nimport { murmur3 } from \"@stdlib/hash\";\n\n// Simple hash table implementation\nfn create_hash_table(size: i32) {\n    let buckets = [];\n    let i = 0;\n    while (i < size) {\n        buckets.push([]);\n        i = i + 1;\n    }\n    return buckets;\n}\n\nfn hash_insert(table, key: string, value) {\n    let hash = murmur3(key);\n    let bucket_index = (hash % table.length);\n    if (bucket_index < 0) {\n        bucket_index = bucket_index + table.length;\n    }\n    table[bucket_index].push({key: key, value: value});\n    return null;\n}\n\n// Usage\nlet table = create_hash_table(16);\nhash_insert(table, \"name\", \"Alice\");\nhash_insert(table, \"age\", 30);\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport { pad_left, pad_right, center } from \"@stdlib/strings\";\nimport { is_alpha, is_digit, is_alnum } from \"@stdlib/strings\";\nimport { reverse, lines, words } from \"@stdlib/strings\";\n\n// Create formatted table\nfn format_table(data: array): null {\n    let header = center(\"USER DATA\", 40, \"=\");\n    print(header);\n\n    let i = 0;\n    while (i < data.length) {\n        let item = data[i];\n        let id_str = pad_left(typeof(item.id), 5);\n        let name_str = pad_right(item.name, 20);\n        print(id_str + \" | \" + name_str);\n        i = i + 1;\n    }\n\n    return null;\n}\n\n// Validate user input\nfn validate_username(name: string): bool {\n    // Must be 3-20 characters, alphanumeric only\n    if (name.length < 3 || name.length > 20) {\n        return false;\n    }\n    return is_alnum(name);\n}\n\n// Parse multi-line config\nfn parse_config(text: string): array {\n    let config_lines = lines(text);\n    let result: array = [];\n\n    let i = 0;\n    while (i < config_lines.length) {\n        let line = config_lines[i].trim();\n        if (line.length > 0) {\n            let parts = words(line);\n            if (parts.length == 2) {\n                result.push({ key: parts[0], value: parts[1] });\n            }\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\n// Example usage\nlet users = [\n    { id: 1, name: \"Alice\" },\n    { id: 42, name: \"Bob\" },\n    { id: 999, name: \"Carol\" }\n];\n\nformat_table(users);\n\nprint(validate_username(\"alice123\"));  // true\nprint(validate_username(\"ab\"));        // false (too short)\nprint(validate_username(\"alice!\"));    // false (not alnum)\n\nlet config_text = \"host localhost\\nport 8080\\nssl true\";\nlet config = parse_config(config_text);\nprint(config.length);  // 3\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does reading entire file work in Hemlock?", "output": "```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does c-style for work in Hemlock?", "output": "Classic three-part for loop:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write Hemlock code that test type mismatch when unshifting to typed array.", "output": "```hemlock\n// Test type mismatch when unshifting to typed array\n\nlet arr: array<bool> = [true, false];\narr.unshift(42);  // Should error: type mismatch\n```", "category": "tests/typed_arrays", "source": "tests/typed_arrays/type_mismatch_unshift_error.hml"}
{"instruction": "Write Hemlock code that tests that await automatically joins task handles.", "output": "```hemlock\n// Test: Basic await functionality\n// Tests that await automatically joins task handles\n\nasync fn compute_sum(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Test 1: await on spawned task\nprint(\"Test 1: await on spawned task\");\nlet task1 = spawn(compute_sum, 10);\nlet result1 = await task1;\nprint(result1);  // Should print 45\n\n// Test 2: Multiple awaits\nprint(\"Test 2: Multiple awaits\");\nlet task2 = spawn(compute_sum, 5);\nlet task3 = spawn(compute_sum, 6);\nlet result2 = await task2;  // 10\nlet result3 = await task3;  // 15\nprint(result2);\nprint(result3);\n\n// Test 3: await on non-task value (should just return the value)\nprint(\"Test 3: await on non-task value\");\nlet x = 42;\nlet result4 = await x;\nprint(result4);  // Should print 42\n\n// Test 4: await on expression that evaluates to task\nprint(\"Test 4: await on expression\");\nlet result5 = await spawn(compute_sum, 7);\nprint(result5);  // Should print 21\n\nprint(\"All tests passed!\");\n```", "category": "tests/async", "source": "tests/async/await_basic.hml"}
{"instruction": "Create a Hemlock program that test named imports.", "output": "```hemlock\n// Test named imports\nimport { add, subtract } from \"./math.hml\";\n\nlet result1 = add(2, 3);\nlet result2 = subtract(10, 4);\n\nprint(\"add(2, 3) = \" + typeof(result1));  // Should print 5\nprint(\"subtract(10, 4) = \" + typeof(result2));  // Should print 6\n```", "category": "tests/modules", "source": "tests/modules/test_import_named.hml"}
{"instruction": "How does pass-by-value work in Hemlock?", "output": "All arguments are copied (pass-by-value):\n\n```hemlock\nfn modify(x) {\n    x = 100;  // Only modifies local copy\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // Still 10 (unchanged)\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does pitfall: direct index out of bounds work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\n\n// No bounds checking!\narr[10] = 99;  // Creates sparse array with nulls\nprint(arr.length);  // 11 (not 3!)\n\n// Better: Use push() or check length\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Create a Hemlock program that test for-in loop on null value Expected: ERROR.", "output": "```hemlock\n// Test for-in loop on null value\n// Expected: ERROR\n\ntry {\n    for (let x in null) {\n        print(\"ERROR: Should not iterate on null\");\n    }\n    print(\"ERROR: for-in on null should have thrown\");\n} catch (e) {\n    print(\"PASS: Caught for-in on null: \" + e);\n}\n```", "category": "tests/control", "source": "tests/control/edge_for_in_null.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as collections from \"@stdlib/collections\";\nlet map = collections.HashMap();\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does asyncreadfile work in Hemlock?", "output": "```hemlock\nasync_read_file(path: string): Future<string>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does array type work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// Empty array\nlet empty = [];\nprint(empty.length);   // 0\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { HashMap, Queue, Stack, Set, LinkedList } from \"@stdlib/collections\";\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "Write a Hemlock program that test type checking builtins.", "output": "```hemlock\n// Test type checking builtins\n\n// Basic types\nprint(typeof(42));\nprint(typeof(3.14));\nprint(typeof(\"hello\"));\nprint(typeof(true));\nprint(typeof(false));\nprint(typeof(null));\n\n// Complex types\nprint(typeof([1, 2, 3]));\nprint(typeof({ x: 1 }));\n\n// Function type\nlet f = fn(x) { return x; };\nprint(typeof(f));\n\n// Specific numeric types\nlet i8v: i8 = 1;\nlet i16v: i16 = 1;\nlet i32v: i32 = 1;\nlet i64v: i64 = 1;\nlet u8v: u8 = 1;\nlet u16v: u16 = 1;\nlet u32v: u32 = 1;\nlet u64v: u64 = 1;\nlet f32v: f32 = 1.0;\nlet f64v: f64 = 1.0;\n\nprint(typeof(i8v));\nprint(typeof(i16v));\nprint(typeof(i32v));\nprint(typeof(i64v));\nprint(typeof(u8v));\nprint(typeof(u16v));\nprint(typeof(u32v));\nprint(typeof(u64v));\nprint(typeof(f32v));\nprint(typeof(f64v));\n\n// Rune type\nlet ch = 'A';\nprint(typeof(ch));\n\n// After operations\nlet sum = i32v + i64v;\nprint(typeof(sum));\n\n// Typed array\nlet arr: array<i32> = [1, 2, 3];\nprint(typeof(arr));\n\n// Buffer type\nlet buf = buffer(10);\nprint(typeof(buf));\nfree(buf);\n\n// Pointer type\nlet p = alloc(10);\nprint(typeof(p));\nfree(p);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/type_checking.hml"}
{"instruction": "How does duck typing work in Hemlock?", "output": "Objects are validated against define using structural compatibility:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// ‚úÖ OK: Has all required fields\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// ‚úÖ OK: Extra fields are allowed\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// ‚ùå ERROR: Missing required field 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// ‚ùå ERROR: Wrong type for 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Implement a Hemlock program that test basic typed array functionality with i32.", "output": "```hemlock\n// Test basic typed array functionality with i32\n\n// Test 1: Create a typed array and assign it\nlet arr: array<i32> = [1, 2, 3];\nprint(arr[0]);  // 1\nprint(arr[1]);  // 2\nprint(arr[2]);  // 3\nprint(arr.length);  // 3\n\n// Test 2: Push to typed array\narr.push(4);\nprint(arr[3]);  // 4\nprint(arr.length);  // 4\n\n// Test 3: Array methods with typed arrays\narr.unshift(0);\nprint(arr[0]);  // 0\nprint(arr.length);  // 5\n\narr.insert(2, 10);\nprint(arr[2]);  // 10\nprint(arr.length);  // 6\n\n// Test 4: Index assignment\narr[0] = 99;\nprint(arr[0]);  // 99\n```", "category": "tests/typed_arrays", "source": "tests/typed_arrays/basic.hml"}
{"instruction": "How does the self keyword work in Hemlock?", "output": "When a function is called as a method, self is automatically bound to the object:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self refers to counter\n    }\n};\n\ncounter.increment();  // self is bound to counter\nprint(counter.count);  // 1\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Write a Hemlock example that demonstrates demonstrates all Hemlock data types.", "output": "```hemlock\nlet a: i8 = -128;\nlet b: i16 = 30000;\nlet c: i32 = 2000000;\nlet d: u8 = 255;\nlet e: u16 = 65535;\nlet f: u32 = 100000;\nlet g: f32 = 3.14;\nlet h: f64 = 2.71828;\n\nprint(a);\nprint(b);\nprint(c);\nprint(d);\nprint(e);\nprint(f);\nprint(g);\nprint(h);\n```", "category": "examples", "source": "examples/alltypes.hml"}
{"instruction": "How does async function declaration work in Hemlock?", "output": "```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Processing:\", data);\n    return null;\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Write Hemlock code that defer with closure - should capture variables at defer time.", "output": "```hemlock\n// Defer with closure - should capture variables at defer time\nfn test_closure() {\n    let x = 10;\n    defer print(\"x = \" + typeof(x));\n    x = 20;\n    defer print(\"x = \" + typeof(x));\n    x = 30;\n    print(\"final x = \" + typeof(x));\n}\n\ntest_closure();\n```", "category": "tests/defer", "source": "tests/defer/defer_closure.hml"}
{"instruction": "Write Hemlock code that tests exception in loop.", "output": "```hemlock\n// Test: Exception breaks out of loop\nlet i = 0;\ntry {\n    while (i < 10) {\n        print(i);\n        i = i + 1;\n        if (i == 3) {\n            throw \"break at 3\";\n        }\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\nprint(\"Final i: \" + typeof(i));\n```", "category": "tests/exceptions", "source": "tests/exceptions/exception_in_loop.hml"}
{"instruction": "Create a Hemlock program that test recursive functions.", "output": "```hemlock\n// Test recursive functions\n\n// Factorial\nfn factorial(n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));\nprint(factorial(6));\n\n// Fibonacci\nfn fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\nprint(fib(10));\n\n// Sum of array (recursive)\nfn sum_arr(arr, i) {\n    if (i >= arr.length) {\n        return 0;\n    }\n    return arr[i] + sum_arr(arr, i + 1);\n}\n\nprint(sum_arr([1, 2, 3, 4, 5], 0));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/recursion.hml"}
{"instruction": "How does style constants work in Hemlock?", "output": "```hemlock\nimport { BOLD, ITALIC, UNDERLINE, DIM } from \"@stdlib/terminal\";\n\nprint(BOLD + \"Bold text\" + RESET);\nprint(ITALIC + \"Italic text\" + RESET);\nprint(UNDERLINE + \"Underlined text\" + RESET);\nprint(DIM + \"Dim text\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does asyncwritefile work in Hemlock?", "output": "```hemlock\nasync_write_file(path: string, content: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does system apis work in Hemlock?", "output": "Example: POSIX APIs*\n\n```hemlock\n// Call getpid, getuid, etc.\n// Access low-level system functionality\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does exec(command: string): object work in Hemlock?", "output": "exit_code (i32) - Command's exit status\n\n```hemlock\nlet result = exec(\"echo 'Hello World'\");\nprint(result.output);        // \"Hello World\\n\"\nprint(result.exit_code);     // 0\n\n// Check exit code\nlet result2 = exec(\"grep pattern file.txt\");\nif (result2.exit_code == 0) {\n    print(\"Found: \" + result2.output);\n} else {\n    print(\"Pattern not found\");\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does asyncmakedir work in Hemlock?", "output": "```hemlock\nasync_make_dir(path: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does argument isolation work in Hemlock?", "output": "When you spawn a task, arguments are deep-copied to prevent data races:\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // Modifies the COPY, not original\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - unchanged!\nprint(modified.length);  // 4 - has new element\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does buffer (safe buffer) work in Hemlock?", "output": "```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Bounds checked\nprint(b.length);        // 64\nfree(b);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does atan(x) work in Hemlock?", "output": "Returns:* f64 - Arc tangent in range [-œÄ/2, œÄ/2]\n\n```hemlock\nimport { atan } from \"@stdlib/math\";\n\nlet angle = atan(1.0);  // œÄ/4\nlet angle2 = atan(0.0); // 0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Write Hemlock code that test string operations.", "output": "```hemlock\n// Test string operations\nlet a = \"Hello\";\nlet b = \"World\";\n\nprint(a);\nprint(b);\nprint(a + \" \" + b);\nlet answer = 42;\nprint(\"The answer is: \" + answer);\n\n// Empty string\nlet empty = \"\";\nprint(empty);\nprint(\"prefix\" + empty + \"suffix\");\n```", "category": "tests/compiler", "source": "tests/compiler/strings.hml"}
{"instruction": "How does words(str) work in Hemlock?", "output": "Use case - word counting:*\n\n```hemlock\nimport { words } from \"@stdlib/strings\";\n\nfn word_count(text: string): i32 {\n    return words(text).length;\n}\n\nlet text = \"The quick brown fox jumps over the lazy dog\";\nprint(word_count(text));  // 9\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Show me Hemlock code that test array length property.", "output": "```hemlock\n// Test array length property\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);\n```", "category": "tests/arrays", "source": "tests/arrays/length.hml"}
{"instruction": "How does tan(x) work in Hemlock?", "output": "Returns:* f64 - Tangent of x\n\n```hemlock\nimport { tan, PI } from \"@stdlib/math\";\n\nlet result = tan(0.0);        // 0.0\nlet result2 = tan(PI / 4.0);  // 1.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Show me Hemlock code that tests thread pool for efficient task execution.", "output": "```hemlock\n// Test: ThreadPool from @stdlib/async\n// Tests thread pool for efficient task execution\n\nimport { ThreadPool, parallel_map } from \"@stdlib/async\";\n\n// Test basic ThreadPool creation\nlet pool = ThreadPool(4);\nassert(pool.num_workers == 4);\nprint(\"PASS: ThreadPool created with 4 workers\");\n\n// Test submit and get result\nfn square(n) {\n    return n * n;\n}\n\nlet future = pool.submit1(square, 5);\nlet result = future.get();\nassert(result == 25);\nprint(\"PASS: submit and get result\");\n\n// Test multiple concurrent tasks\nlet futures = [];\nlet i = 0;\nwhile (i < 10) {\n    futures.push(pool.submit1(square, i));\n    i = i + 1;\n}\n\n// Collect results\ni = 0;\nwhile (i < 10) {\n    let res = futures[i].get();\n    assert(res == i * i);\n    i = i + 1;\n}\nprint(\"PASS: multiple concurrent tasks\");\n\n// Test task that takes time\nfn slow_task(n) {\n    __sleep(0.01);\n    return n * 2;\n}\n\nlet f1 = pool.submit1(slow_task, 10);\nlet f2 = pool.submit1(slow_task, 20);\nlet f3 = pool.submit1(slow_task, 30);\n\nassert(f1.get() == 20);\nassert(f2.get() == 40);\nassert(f3.get() == 60);\nprint(\"PASS: slow tasks complete correctly\");\n\n// Shutdown the pool\npool.shutdown();\nprint(\"PASS: pool shutdown\");\n\n// Test parallel_map helper\nfn double(x) {\n    return x * 2;\n}\n\nlet input = [1, 2, 3, 4, 5];\nlet output = parallel_map(input, double, 2);\n\nassert(output.length == 5);\nassert(output[0] == 2);\nassert(output[1] == 4);\nassert(output[2] == 6);\nassert(output[3] == 8);\nassert(output[4] == 10);\nprint(\"PASS: parallel_map works\");\n\nprint(\"All ThreadPool tests passed!\");\n```", "category": "tests/async_io", "source": "tests/async_io/thread_pool.hml"}
{"instruction": "How does exec work in Hemlock?", "output": "Error Handling:*\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Failed to execute:\", e);\n}\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does don'ts work in Hemlock?", "output": "‚ùå Don't use random values in tests\n\n```hemlock\n// BAD: Non-deterministic\nlet x = random();\nprint(x);  // Can't predict output\n\n// GOOD: Deterministic\nlet x = 42;\nprint(x);  // Expect: 42\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Write a Hemlock program that test that variables starting with runtime prefixes don't conflict This tests the compiler's identifier sanitization for runtime prefixes.", "output": "```hemlock\n// Test that variables starting with runtime prefixes don't conflict\n// This tests the compiler's identifier sanitization for runtime prefixes\n\n// Test local variables with names that start with runtime prefixes\nfn test_runtime_prefixes() {\n    // Variables starting with hml_ prefix (Hemlock runtime functions)\n    let hml_test = 42;\n    let hml_print = \"not the builtin\";\n    let hml_val_i32 = 100;\n\n    // Variables starting with Hml prefix (Hemlock types)\n    let HmlValue = \"type name\";\n\n    // Variables starting with codegen internal prefixes\n    let _tmp = \"temp var\";\n    let _tmp0 = \"temp var 0\";\n    let _main_var = \"main var\";\n    let _mod0_test = \"module test\";\n    let _env_0 = \"env var\";\n    let _v_test = \"sanitized var\";\n    let _ex_ctx = \"exception context\";\n\n    print(hml_test);\n    print(hml_print);\n    print(hml_val_i32);\n    print(HmlValue);\n    print(_tmp);\n    print(_tmp0);\n    print(_main_var);\n    print(_mod0_test);\n    print(_env_0);\n    print(_v_test);\n    print(_ex_ctx);\n}\n\n// Test function parameters with runtime prefix names\nfn test_param_prefixes(hml_x, _tmp1, _main_y) {\n    print(hml_x);\n    print(_tmp1);\n    print(_main_y);\n}\n\n// Run all tests\ntest_runtime_prefixes();\ntest_param_prefixes(\"param1\", \"param2\", \"param3\");\n\n// Verify that actual print builtin still works\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/runtime_prefix_names.hml"}
{"instruction": "How does concatenation work in Hemlock?", "output": "String + String:*\n\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Implement a Hemlock program that tests non-blocking file I/O using ThreadPool.", "output": "```hemlock\n// Test: Async File System operations\n// Tests non-blocking file I/O using ThreadPool\n\nimport {\n    async_read_file,\n    async_write_file,\n    async_exists,\n    async_remove_file,\n    read_files_parallel,\n    write_files_parallel,\n    shutdown_async_fs\n} from \"@stdlib/async_fs\";\n\n// Test 1: async_write_file and async_read_file\nprint(\"Test: async write and read file\");\nlet test_path = \"/tmp/hemlock_async_test.txt\";\nlet content = \"Hello from async file I/O!\";\n\nlet write_future = async_write_file(test_path, content);\nwrite_future.get();  // Wait for write to complete\nprint(\"  Written file\");\n\nlet read_future = async_read_file(test_path);\nlet read_content = read_future.get();\nprint(\"  Read content: \" + read_content);\nassert(read_content == content);\nprint(\"PASS: async write and read file\");\n\n// Test 2: async_exists\nprint(\"Test: async exists\");\nlet exists_future = async_exists(test_path);\nlet exists = exists_future.get();\nassert(exists == true);\n\nlet not_exists_future = async_exists(\"/tmp/nonexistent_file_12345.txt\");\nlet not_exists = not_exists_future.get();\nassert(not_exists == false);\nprint(\"PASS: async exists\");\n\n// Test 3: async_remove_file\nprint(\"Test: async remove file\");\nlet remove_future = async_remove_file(test_path);\nremove_future.get();\n\nlet after_remove = async_exists(test_path).get();\nassert(after_remove == false);\nprint(\"PASS: async remove file\");\n\n// Test 4: Multiple async operations in parallel\nprint(\"Test: parallel async operations\");\n\n// Write 3 files\nlet f1 = async_write_file(\"/tmp/hemlock_async_1.txt\", \"content1\");\nlet f2 = async_write_file(\"/tmp/hemlock_async_2.txt\", \"content2\");\nlet f3 = async_write_file(\"/tmp/hemlock_async_3.txt\", \"content3\");\n\n// Wait for all writes\nf1.get();\nf2.get();\nf3.get();\n\n// Read all in parallel\nlet r1 = async_read_file(\"/tmp/hemlock_async_1.txt\");\nlet r2 = async_read_file(\"/tmp/hemlock_async_2.txt\");\nlet r3 = async_read_file(\"/tmp/hemlock_async_3.txt\");\n\nassert(r1.get() == \"content1\");\nassert(r2.get() == \"content2\");\nassert(r3.get() == \"content3\");\n\n// Cleanup\nasync_remove_file(\"/tmp/hemlock_async_1.txt\").get();\nasync_remove_file(\"/tmp/hemlock_async_2.txt\").get();\nasync_remove_file(\"/tmp/hemlock_async_3.txt\").get();\n\nprint(\"PASS: parallel async operations\");\n\n// Test 5: read_files_parallel helper\nprint(\"Test: read_files_parallel\");\n\n// Create test files first\nasync_write_file(\"/tmp/hemlock_batch_1.txt\", \"batch1\").get();\nasync_write_file(\"/tmp/hemlock_batch_2.txt\", \"batch2\").get();\nasync_write_file(\"/tmp/hemlock_batch_3.txt\", \"batch3\").get();\n\nlet paths = [\n    \"/tmp/hemlock_batch_1.txt\",\n    \"/tmp/hemlock_batch_2.txt\",\n    \"/tmp/hemlock_batch_3.txt\"\n];\n\nlet contents = read_files_parallel(paths);\nassert(contents.length == 3);\nassert(contents[0] == \"batch1\");\nassert(contents[1] == \"batch2\");\nassert(contents[2] == \"batch3\");\n\n// Cleanup\nasync_remove_file(\"/tmp/hemlock_batch_1.txt\").get();\nasync_remove_file(\"/tmp/hemlock_batch_2.txt\").get();\nasync_remove_file(\"/tmp/hemlock_batch_3.txt\").get();\n\nprint(\"PASS: read_files_parallel\");\n\n// Test 6: write_files_parallel helper\nprint(\"Test: write_files_parallel\");\n\nlet files = [\n    { path: \"/tmp/hemlock_write_1.txt\", content: \"write1\" },\n    { path: \"/tmp/hemlock_write_2.txt\", content: \"write2\" }\n];\n\nwrite_files_parallel(files);\n\n// Verify\nassert(async_read_file(\"/tmp/hemlock_write_1.txt\").get() == \"write1\");\nassert(async_read_file(\"/tmp/hemlock_write_2.txt\").get() == \"write2\");\n\n// Cleanup\nasync_remove_file(\"/tmp/hemlock_write_1.txt\").get();\nasync_remove_file(\"/tmp/hemlock_write_2.txt\").get();\n\nprint(\"PASS: write_files_parallel\");\n\n// Shutdown the thread pool\nshutdown_async_fs();\n\nprint(\"All async file I/O tests passed!\");\n```", "category": "tests/async_io", "source": "tests/async_io/async_fs.hml"}
{"instruction": "Write a Hemlock program that test type mismatch when assigning to typed array.", "output": "```hemlock\n// Test type mismatch when assigning to typed array\n\nlet arr: array<i32> = [10, 20, 30];\narr[0] = \"wrong\";  // Should error: type mismatch\n```", "category": "tests/typed_arrays", "source": "tests/typed_arrays/type_mismatch_assignment_error.hml"}
{"instruction": "Write a Hemlock program that test basic const declaration.", "output": "```hemlock\n// Test basic const declaration\nconst x = 42;\nprint(x);\n\n// Expected output: 42\n```", "category": "tests/const", "source": "tests/const/basic_const.hml"}
{"instruction": "Write a Hemlock program that should not cause stack overflow when freed.", "output": "```hemlock\n// Test: Circular chain - A -> B -> C -> A\n// Should not cause stack overflow when freed\n\nlet objA = { name: \"A\" };\nlet objB = { name: \"B\" };\nlet objC = { name: \"C\" };\n\nobjA.next = objB;\nobjB.next = objC;\nobjC.next = objA;\n\n// Free objA - this recursively frees objB and objC without stack overflow!\nfree(objA);\n\nprint(\"PASS: Circular chain handled correctly\");\n```", "category": "tests/circular_refs", "source": "tests/circular_refs/test_circular_chain.hml"}
{"instruction": "Implement a Hemlock program that test modulo edge cases Expected: PASS (modulo operator now implemented).", "output": "```hemlock\n// Test modulo edge cases\n// Expected: PASS (modulo operator now implemented)\n\n// Note: Modulo by zero is tested separately as an error test (modulo_zero_error.hml)\n\n// Modulo with negative numbers\nlet m1 = -10 % 3;\nprint(\"-10 % 3 = \" + typeof(m1));\n\nlet m2 = 10 % -3;\nprint(\"10 % -3 = \" + typeof(m2));\n\nlet m3 = -10 % -3;\nprint(\"-10 % -3 = \" + typeof(m3));\n\n// Modulo with result of 0\nlet m4 = 10 % 5;\nassert(m4 == 0, \"10 % 5 should be 0\");\n\n// Modulo with same numbers\nlet m5 = 7 % 7;\nassert(m5 == 0, \"7 % 7 should be 0\");\n\n// Modulo with larger divisor\nlet m6 = 5 % 10;\nassert(m6 == 5, \"5 % 10 should be 5\");\n\n// Modulo with 1\nlet m7 = 100 % 1;\nassert(m7 == 0, \"100 % 1 should be 0\");\n\n// Modulo in expressions\nlet m8 = (10 % 3) + (15 % 4);\nassert(m8 == 4, \"(10 % 3) + (15 % 4) should be 4\");\n\n// Modulo with different integer types\nlet a: i8 = 10;\nlet b: i8 = 3;\nlet m9 = a % b;\nassert(m9 == 1, \"i8 modulo should work\");\n\nlet c: u8 = 20;\nlet d: u8 = 6;\nlet m10 = c % d;\nassert(m10 == 2, \"u8 modulo should work\");\n\nprint(\"PASS\");\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/edge_modulo.hml"}
{"instruction": "Implement a Hemlock program that minimal test for assert.", "output": "```hemlock\n// Minimal test for assert\nassert(true);\nprint(\"assert(true) passed\");\n\ntry {\n    assert(false);\n    print(\"Should not print\");\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n```", "category": "tests/manual", "source": "tests/manual/test_assert_simple.hml"}
{"instruction": "Write a Hemlock program that tests else if chain.", "output": "```hemlock\nlet x = 15;\nif (x < 10) {\n    print(1);\n} else if (x < 20) {\n    print(2);\n} else if (x < 30) {\n    print(3);\n} else if (x < 40) {\n    print(4);\n} else {\n    print(5);\n}\n```", "category": "tests/control", "source": "tests/control/else_if_chain.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as os from \"@stdlib/os\";\n\nif (os.is_linux()) {\n    print(\"Running on Linux\");\n}\n\nlet info = os.info();\nprint(\"Memory: \" + os.format_bytes(info.total_memory));\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Show me Hemlock code that test switch inside function with return.", "output": "```hemlock\n// Test switch inside function with return\n\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        case 4:\n            return \"Thursday\";\n        case 5:\n            return \"Friday\";\n        default:\n            return \"Weekend\";\n    }\n}\n\nprint(get_day_name(1));\nprint(get_day_name(3));\nprint(get_day_name(5));\nprint(get_day_name(7));\n\n// Expected: Monday, Wednesday, Friday, Weekend\n```", "category": "tests/switch", "source": "tests/switch/in_function.hml"}
{"instruction": "How does arrays work in Hemlock?", "output": "Dynamic arrays with mixed types:\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Array methods\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// Mixed types allowed\nlet mixed = [1, \"two\", true, null];\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does spawn work in Hemlock?", "output": "```hemlock\nspawn(async_fn: function, ...args): task\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Write a Hemlock program that test time module functions.", "output": "```hemlock\n// Test time module functions\n\nimport * as time from \"@stdlib/time\";\n\n// Test now - should return a positive timestamp\nlet t1 = time.now();\nassert(t1 > 0, \"now() should return positive timestamp\");\n\n// Test time_ms - should return milliseconds (larger than seconds)\nlet ms1 = time.time_ms();\nassert(ms1 > t1, \"time_ms() should return value larger than now()\");\nassert(ms1 > 1000000000000, \"time_ms() should be in milliseconds since epoch\");\n\n// Test clock - should return non-negative CPU time\nlet c1 = time.clock();\nassert(c1 >= 0.0, \"clock() should return non-negative value\");\n\n// Test that time progresses\nlet t2 = time.now();\nassert(t2 >= t1, \"time should not go backwards\");\n\nlet ms2 = time.time_ms();\nassert(ms2 >= ms1, \"milliseconds should not go backwards\");\n\n// Test clock progresses with computation\nlet c2 = time.clock();\nlet sum = 0;\nlet i = 0;\nwhile (i < 10000) {\n    sum = sum + i;\n    i = i + 1;\n}\nlet c3 = time.clock();\nassert(c3 >= c2, \"clock should progress during computation\");\n\nprint(\"All time function tests passed!\");\n```", "category": "tests/stdlib_time", "source": "tests/stdlib_time/test_time.hml"}
{"instruction": "How does return statement work in Hemlock?", "output": "```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does file backup system work in Hemlock?", "output": "```hemlock\nimport { exists, copy_file } from \"@stdlib/fs\";\nimport { now } from \"@stdlib/time\";\n\nfn backup_file(filepath: string): bool {\n    if (!exists(filepath)) {\n        print(\"File not found: \" + filepath);\n        return false;\n    }\n\n    let timestamp = now();\n    let backup_path = filepath + \".backup.\" + typeof(timestamp);\n\n    try {\n        copy_file(filepath, backup_path);\n        print(\"Backup created: \" + backup_path);\n        return true;\n    } catch (e) {\n        print(\"Backup failed: \" + e);\n        return false;\n    }\n}\n\nbackup_file(\"important.txt\");\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does free work in Hemlock?", "output": "```hemlock\nfree(ptr: ptr | buffer): null\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does transformation operations work in Hemlock?", "output": "join(delimiter)* - Join elements into string:\n\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Works with mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does string + rune concatenation work in Hemlock?", "output": "Runes can be concatenated with strings:\n\n```hemlock\n// String + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + '‚úì';       // \"Text‚úì\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = '‚Ä¢' + \" Item\";         // \"‚Ä¢ Item\"\n\n// Multiple concatenations\nlet msg = \"Hi \" + 'üëã' + \" World \" + 'üåç';  // \"Hi üëã World üåç\"\n\n// Method chaining works\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does cos(x) work in Hemlock?", "output": "Returns:* f64 - Cosine of x in range [-1, 1]\n\n```hemlock\nimport { cos, PI } from \"@stdlib/math\";\n\nlet result = cos(0.0);        // 1.0\nlet result2 = cos(PI / 2.0);  // ~0.0\nlet result3 = cos(PI);        // -1.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does exit(code?) work in Hemlock?", "output": "Early exit on fatal errors\n\n```hemlock\nimport { exit } from \"@stdlib/env\";\n\n// Exit with success\nexit(0);\n\n// Exit with error\nexit(1);\n\n// Exit with default (0)\nexit();\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "Implement a Hemlock program that tests floats.", "output": "```hemlock\nlet a: f64 = 3.14;\nlet b: f32 = 2.5;\nlet c: number = 0.0;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/primitives", "source": "tests/primitives/floats.hml"}
{"instruction": "How does abs(x) work in Hemlock?", "output": "Returns:* f64 - |x|\n\n```hemlock\nimport { abs } from \"@stdlib/math\";\n\nlet result = abs(-5.0);  // 5.0\nlet result2 = abs(3.2);  // 3.2\nlet result3 = abs(0.0);  // 0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does error handling in callbacks work in Hemlock?", "output": "The exception is logged but not propagated\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Something went wrong\";  // Warning printed, returns 0\n}\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does mixed types work in Hemlock?", "output": "Arrays can contain different types:\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3] (nested array)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Show an example of example: sorting with custom comparator in Hemlock.", "output": "```hemlock\nfn sort(arr, compare) {\n    // Bubble sort with custom comparator\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Write Hemlock code that tests define duck typing missing field error.", "output": "```hemlock\n// Test: Duck typing fails when required field is missing\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p = { name: \"Alice\" };\nlet typed_p: Person = p;  // Should error: missing 'age'\n```", "category": "tests/objects", "source": "tests/objects/define_duck_typing_missing_field_error.hml"}
{"instruction": "How does good use cases work in Hemlock?", "output": "1. Running system utilities:*\n\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Write Hemlock code that test different typed array types.", "output": "```hemlock\n// Test different typed array types\n\n// i32 array\nlet ints: array<i32> = [1, 2, 3, 4, 5];\nprint(ints[0]);\nints.push(6);\nprint(ints.length);\n\n// string array\nlet strings: array<string> = [\"foo\", \"bar\", \"baz\"];\nprint(strings[1]);\nstrings.push(\"qux\");\nprint(strings.length);\n\n// bool array\nlet bools: array<bool> = [true, false, true];\nprint(bools[2]);\nbools.push(false);\nprint(bools.length);\n```", "category": "tests/typed_arrays", "source": "tests/typed_arrays/different_types.hml"}
{"instruction": "How does file not found work in Hemlock?", "output": "```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Write a Hemlock program that should fail: u64 cannot be negative.", "output": "```hemlock\n// Should fail: u64 cannot be negative\nlet a: u64 = -1;\nprint(a);\n```", "category": "tests/primitives", "source": "tests/primitives/u64_negative.hml"}
{"instruction": "How does uncaught exceptions work in Hemlock?", "output": "If an exception propagates to the top of the call stack without being caught:\n\n```hemlock\nfn foo() {\n    throw \"uncaught!\";\n}\n\nfoo();  // Crashes with: Runtime error: uncaught!\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does memcpy work in Hemlock?", "output": "```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as env from \"@stdlib/env\";\nlet home = env.getenv(\"HOME\");\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does explicit over implicit work in Hemlock?", "output": "Good (explicit):*\n\n```hemlock\nlet x = 5;\nfree(ptr);  // You allocated it, you free it\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Implement a Hemlock program that test bitwise operators.", "output": "```hemlock\n// Test bitwise operators\n\n// Basic bitwise operations\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\n// AND\nprint(a & b);   // 8  (1000)\n\n// OR\nprint(a | b);   // 14 (1110)\n\n// XOR\nprint(a ^ b);   // 6  (0110)\n\n// Left shift\nprint(a << 2);  // 48 (110000)\n\n// Right shift\nprint(a >> 1);  // 6  (110)\n\n// NOT (bitwise complement) - signed int gives -16 for 15\nlet c = 15;\nprint(~c);        // -16 (for signed i32)\n\n// Combined operations\nprint((5 & 3) | 8);  // 1 | 8 = 9\n\n// Shift with addition\nprint(1 << 3);  // 8\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/bitwise.hml"}
{"instruction": "How does return type requirements work in Hemlock?", "output": "Functions with return type annotation must return a value:\n\n```hemlock\nfn get_value(): i32 {\n    // ERROR: Missing return statement\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does os_name() work in Hemlock?", "output": "Returns:* string - Kernel name (e.g., \"Linux\", \"Darwin\", \"Windows_NT\")\n\n```hemlock\nimport { os_name } from \"@stdlib/os\";\n\nlet name = os_name();\nprint(\"OS kernel: \" + name);  // e.g., \"Linux\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Show me how to creates a WebSocket echo client in Hemlock.", "output": "```hemlock\n// WebSocket Echo Client Example\n// Demonstrates @stdlib/websocket_pure (pure Hemlock implementation)\n\nimport { WebSocket } from \"@stdlib/websocket_pure\";\n\nprint(\"=== Hemlock WebSocket Echo Client ===\");\nprint(\"\");\n\n// Note: This uses the pure Hemlock implementation\n// For production with SSL, use @stdlib/websocket (requires libwebsockets)\n\nprint(\"Connecting to ws://echo.websocket.org...\");\n\ntry {\n    let ws = WebSocket(\"ws://echo.websocket.org\");\n    defer ws.close();\n\n    print(\"‚úì Connected!\");\n    print(\"\");\n\n    // Send a few test messages\n    print(\"Sending: 'Hello WebSocket!'\");\n    ws.send_text(\"Hello WebSocket!\");\n\n    print(\"Waiting for echo...\");\n    let msg1 = ws.recv();\n\n    if (msg1 != null && msg1.type == \"text\") {\n        print(\"‚úì Received: \" + msg1.data);\n    } else {\n        print(\"‚úó No response or wrong type\");\n    }\n\n    print(\"\");\n\n    // Send another message\n    print(\"Sending: 'Hemlock WebSocket Test'\");\n    ws.send_text(\"Hemlock WebSocket Test\");\n\n    print(\"Waiting for echo...\");\n    let msg2 = ws.recv();\n\n    if (msg2 != null && msg2.type == \"text\") {\n        print(\"‚úì Received: \" + msg2.data);\n    } else {\n        print(\"‚úó No response or wrong type\");\n    }\n\n    print(\"\");\n    print(\"Closing connection...\");\n\n} catch (e) {\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"- Message >125 bytes (not yet supported in pure implementation)\");\n    print(\"- Network connectivity\");\n    print(\"- echo.websocket.org is down\");\n    print(\"\");\n    print(\"Limitations of pure Hemlock implementation:\");\n    print(\"- No wss:// (SSL) support\");\n    print(\"- Messages limited to <126 bytes\");\n    print(\"- Simplified masking and validation\");\n    print(\"\");\n    print(\"For production use, install libwebsockets and use @stdlib/websocket\");\n}\n\nprint(\"Done!\");\n```", "category": "examples", "source": "examples/websocket_echo_client.hml"}
{"instruction": "How does forgetting to free memory work in Hemlock?", "output": "```hemlock\n// ‚ùå MEMORY LEAK\nlet buf = buffer(100);\n// ... use buf ...\n// Forgot to call free(buf)!\n\n// ‚úÖ CORRECT\nlet buf = buffer(100);\n// ... use buf ...\nfree(buf);\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does temporary file naming work in Hemlock?", "output": "```hemlock\nimport { get_pid } from \"@stdlib/env\";\n\nfn create_temp_filename(prefix: string, extension: string): string {\n    let pid = get_pid();\n    let timestamp = now();  // From time module\n    return \"/tmp/\" + prefix + \".\" + typeof(pid) + \".\" + typeof(timestamp) + extension;\n}\n\nlet temp_log = create_temp_filename(\"myapp\", \".log\");\nprint(\"Temporary log: \" + temp_log);\n// e.g., \"/tmp/myapp.12345.1700000000.log\"\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does raise work in Hemlock?", "output": "```hemlock\nraise(signum: i32): null\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does custom headers & authentication work in Hemlock?", "output": "```hemlock\nimport { get } from \"@stdlib/http\";\n\nlet headers = [\n    \"User-Agent: My-App/1.0\",\n    \"Accept: application/json\",\n    \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n];\n\nlet response = get(\"https://api.example.com/protected\", headers);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does when you need free() vs when it's automatic work in Hemlock?", "output": "Automatic (no free() needed):* Local variables of refcounted types are freed when scope exits:\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... use them ...\n}  // All automatically freed when function returns - no free() needed\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does file permissions work in Hemlock?", "output": "‚ö†Ô∏è WARNING:* Be careful with file permissions:\n\n```hemlock\nimport { make_dir } from \"@stdlib/fs\";\n\n// Create directory with restrictive permissions (owner only)\nlet mode: u32 = 448;  // 0700 in octal\nmake_dir(\"private_data\", mode);\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does re-throwing work in Hemlock?", "output": "Catch and re-throw errors:\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logging error: \" + e);\n        throw e;  // Re-throw to caller\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Caught in main: \" + e);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Show me Hemlock code that basic test - variables and arithmetic.", "output": "```hemlock\n// Basic test - variables and arithmetic\nlet x = 10;\nlet y = 20;\nlet z = x + y;\nprint(\"Sum: \" + typeof(z));\n```", "category": "tests/manual", "source": "tests/manual/valgrind_test_basic.hml"}
{"instruction": "How does common errors work in Hemlock?", "output": "Reading from closed file:*\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { djb2, fnv1a, murmur3, sha256, sha512, md5, file_checksum } from \"@stdlib/hash\";\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does asyncremovefile work in Hemlock?", "output": "```hemlock\nasync_remove_file(path: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does semicolons are mandatory work in Hemlock?", "output": "Unlike JavaScript or Python, semicolons are always required at the end of statements:\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does integer types work in Hemlock?", "output": "```hemlock\nlet i: integer = 42;   // Alias for i32\nlet b: byte = 255;     // Alias for u8\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does null comparison work in Hemlock?", "output": "```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does level hierarchy work in Hemlock?", "output": "```hemlock\nimport { Logger, DEBUG, INFO, WARN, ERROR } from \"@stdlib/logging\";\n\nlet logger = Logger({ level: WARN });  // Only WARN and ERROR\n\nlogger.debug(\"This is filtered\");      // Not shown\nlogger.info(\"This is filtered\");       // Not shown\nlogger.warn(\"This is shown\");          // ‚úì Shown\nlogger.error(\"This is shown\");         // ‚úì Shown\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Write a Hemlock program that tests test simple.", "output": "```hemlock\nlet x = 5;\nlet y = 3;\nlet z = x + y;\nprint(z);\n```", "category": "tests/manual", "source": "tests/manual/test_simple.hml"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport {\n    sin, cos, tan, sqrt, pow,\n    PI, abs, min, max,\n    rand_range, seed\n} from \"@stdlib/math\";\n\n// Trigonometry: Calculate point on unit circle\nfn point_on_circle(angle: f64): object {\n    return {\n        x: cos(angle),\n        y: sin(angle)\n    };\n}\n\nlet p = point_on_circle(PI / 4.0);\nprint(\"Point at 45¬∞: (\" + typeof(p.x) + \", \" + typeof(p.y) + \")\");\n\n// Distance formula\nfn distance(x1: f64, y1: f64, x2: f64, y2: f64): f64 {\n    let dx = x2 - x1;\n    let dy = y2 - y1;\n    return sqrt(dx * dx + dy * dy);\n}\n\nlet dist = distance(0.0, 0.0, 3.0, 4.0);\nprint(\"Distance: \" + typeof(dist));  // 5.0\n\n// Random dice roller\nfn roll_dice(sides: i32): i32 {\n    let result: i32 = rand_range(1.0, sides + 1.0);\n    return result;\n}\n\nseed(42);  // Reproducible results\nlet roll = roll_dice(6);\nprint(\"Dice roll: \" + typeof(roll));\n\n// Find max of three values\nfn max3(a: f64, b: f64, c: f64): f64 {\n    return max(max(a, b), c);\n}\n\nprint(\"Max: \" + typeof(max3(5.0, 12.0, 8.0)));  // 12.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does geteuid(): i32 work in Hemlock?", "output": "Get the effective user ID of the current process.\n\n```hemlock\nlet euid = geteuid();\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does pipeline architecture work in Hemlock?", "output": "```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// Create pipeline\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// Feed input\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// Collect output\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Create a Hemlock program that tests seek tell.", "output": "```hemlock\n// Test: Seek and tell\nlet fw = open(\"tests/temp/test_seek.txt\", \"w\");\nfw.write(\"ABCDEFGHIJ\");\nfw.close();\n\nlet f = open(\"tests/temp/test_seek.txt\", \"r\");\nprint(\"Position:\");\nprint(f.tell());\nf.seek(5);\nprint(\"After seek(5):\");\nprint(f.tell());\nlet data = f.read(3);\nprint(data);\nf.close();\n```", "category": "tests/io", "source": "tests/io/seek_tell.hml"}
{"instruction": "Show an example of example: resource management in Hemlock.", "output": "```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"File copied successfully\");\n    } catch (e) {\n        print(\"Failed to copy file: \" + e);\n        throw e;  // Re-throw\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Implement a Hemlock program that should not cause stack overflow when freed.", "output": "```hemlock\n// Test: Simple self-reference - object points to itself\n// Should not cause stack overflow when freed\n\nlet obj = {};\nobj.me = obj;\n\n// Manual free should work without crashing\nfree(obj);\n\nprint(\"PASS: Self-reference handled correctly\");\n```", "category": "tests/circular_refs", "source": "tests/circular_refs/test_self_reference.hml"}
{"instruction": "Show me Hemlock code that test date/time comparison.", "output": "```hemlock\n// Test date/time comparison\nimport { from_date } from \"@stdlib/datetime\";\n\nlet dt1 = from_date(2025, 1, 15, 12, 0, 0);\nlet dt2 = from_date(2025, 1, 20, 12, 0, 0);\nlet dt3 = from_date(2025, 1, 15, 12, 0, 0);\n\n// Test 1: is_before\nlet before_result = dt1.is_before(dt2);\nprint(\"Test 1: Jan 15 is_before Jan 20 -> \" + typeof(before_result));\nprint(\"  Expected: true\");\n\n// Test 2: is_after\nlet after_result = dt2.is_after(dt1);\nprint(\"Test 2: Jan 20 is_after Jan 15 -> \" + typeof(after_result));\nprint(\"  Expected: true\");\n\n// Test 3: is_equal\nlet equal_result = dt1.is_equal(dt3);\nprint(\"Test 3: Jan 15 is_equal Jan 15 -> \" + typeof(equal_result));\nprint(\"  Expected: true\");\n\n// Test 4: is_equal (different dates)\nlet not_equal_result = dt1.is_equal(dt2);\nprint(\"Test 4: Jan 15 is_equal Jan 20 -> \" + typeof(not_equal_result));\nprint(\"  Expected: false\");\n\n// Test 5: is_before (same date)\nlet same_before = dt1.is_before(dt3);\nprint(\"Test 5: Jan 15 is_before Jan 15 -> \" + typeof(same_before));\nprint(\"  Expected: false\");\n\nprint(\"All comparison tests passed!\");\n```", "category": "tests/stdlib_datetime", "source": "tests/stdlib_datetime/test_comparison.hml"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\n// Import specific functions\nimport { get_pid, getppid, exec, kill } from \"@stdlib/process\";\n\n// Import all as namespace\nimport * as process from \"@stdlib/process\";\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does argument parser helper function work in Hemlock?", "output": "```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // Positional argument\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Output: \" + opts.output);\nprint(\"Files: \" + typeof(opts.files.length));\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does hextobuffer(hex: string): buffer work in Hemlock?", "output": "Convert hexadecimal string to buffer.\n\n```hemlock\nimport { hex_to_buffer } from \"@stdlib/crypto\";\n\nlet hex = \"48656c6c6f\";  // \"Hello\" in hex\nlet buf = hex_to_buffer(hex);\nprint(buf.length);  // 5\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does your first program work in Hemlock?", "output": "Create a file called hello.hml:\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does test file format work in Hemlock?", "output": "Example: tests/primitives/integers.hml*\n\n```hemlock\n// Test basic integer literals\nlet x = 42;\nprint(x);  // Expect: 42\n\nlet y: i32 = 100;\nprint(y);  // Expect: 100\n\n// Test arithmetic\nlet sum = x + y;\nprint(sum);  // Expect: 142\n\n// Test type inference\nlet small = 10;\nprint(typeof(small));  // Expect: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Expect: i64\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Write Hemlock code that test array indexing out of bounds Expected: ERROR.", "output": "```hemlock\n// Test array indexing out of bounds\n// Expected: ERROR\n\nlet arr = [1, 2, 3];\n\n// Test reading out of bounds\ntry {\n    let val = arr[10];\n    print(\"ERROR: Should have thrown on out of bounds read\");\n} catch (e) {\n    print(\"PASS: Caught out of bounds read: \" + e);\n}\n```", "category": "tests/arrays", "source": "tests/arrays/edge_out_of_bounds.hml"}
{"instruction": "How does third-party libraries work in Hemlock?", "output": "Example: Image processing*\n\n```hemlock\n// Load libpng or libjpeg\n// Process images using C library functions\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does expect(value) work in Hemlock?", "output": "Create an expectation object for assertions. Returns an object with assertion methods.\n\n```hemlock\ntest(\"expect API\", fn() {\n    expect(42).to_equal(42);\n    expect(\"hello\").to_contain(\"ell\");\n    expect(true).to_be_true();\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does export statements work in Hemlock?", "output": "Inline Named Exports:*\n\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does implicit return work in Hemlock?", "output": "Functions without return type annotation implicitly return null:\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // Implicitly returns null\n}\n\nlet result = print_message(\"hello\");  // result is null\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Write Hemlock code that tests write read.", "output": "```hemlock\n// Test: Write and read file\nlet f = open(\"tests/temp/test_output.txt\", \"w\");\nf.write(\"Hello, Hemlock!\");\nf.close();\n\nlet f2 = open(\"tests/temp/test_output.txt\", \"r\");\nlet content = f2.read();\nf2.close();\nprint(content);\n```", "category": "tests/io", "source": "tests/io/write_read.hml"}
{"instruction": "How does test(name, fn) work in Hemlock?", "output": "Define a test case within a suite.\n\n```hemlock\ndescribe(\"Calculator\", fn() {\n    test(\"adds positive numbers\", fn() {\n        expect(add(2, 3)).to_equal(5);\n    });\n\n    test(\"handles negative numbers\", fn() {\n        expect(add(-5, 3)).to_equal(-2);\n    });\n\n    test(\"handles zero\", fn() {\n        expect(add(0, 0)).to_equal(0);\n    });\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Show an example of example: event handler in Hemlock.", "output": "```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show me Hemlock code that test math module utility functions.", "output": "```hemlock\n// Test math module utility functions\n\nimport * as math from \"@stdlib/math\";\n\n// Test abs\nassert(math.abs(5.0) == 5.0, \"abs(5) should be 5\");\nassert(math.abs(-5.0) == 5.0, \"abs(-5) should be 5\");\nassert(math.abs(0.0) == 0.0, \"abs(0) should be 0\");\nassert(math.abs(-3.7) == 3.7, \"abs(-3.7) should be 3.7\");\n\n// Test min\nassert(math.min(3.0, 5.0) == 3.0, \"min(3, 5) should be 3\");\nassert(math.min(5.0, 3.0) == 3.0, \"min(5, 3) should be 3\");\nassert(math.min(-2.0, 2.0) == -2.0, \"min(-2, 2) should be -2\");\nassert(math.min(7.5, 7.5) == 7.5, \"min(7.5, 7.5) should be 7.5\");\n\n// Test max\nassert(math.max(3.0, 5.0) == 5.0, \"max(3, 5) should be 5\");\nassert(math.max(5.0, 3.0) == 5.0, \"max(5, 3) should be 5\");\nassert(math.max(-2.0, 2.0) == 2.0, \"max(-2, 2) should be 2\");\nassert(math.max(7.5, 7.5) == 7.5, \"max(7.5, 7.5) should be 7.5\");\n\n// Test clamp\nassert(math.clamp(5.0, 0.0, 10.0) == 5.0, \"clamp(5, 0, 10) should be 5\");\nassert(math.clamp(-5.0, 0.0, 10.0) == 0.0, \"clamp(-5, 0, 10) should be 0\");\nassert(math.clamp(15.0, 0.0, 10.0) == 10.0, \"clamp(15, 0, 10) should be 10\");\nassert(math.clamp(0.0, 0.0, 10.0) == 0.0, \"clamp(0, 0, 10) should be 0\");\nassert(math.clamp(10.0, 0.0, 10.0) == 10.0, \"clamp(10, 0, 10) should be 10\");\n\nprint(\"All utility function tests passed!\");\n```", "category": "tests/stdlib_math", "source": "tests/stdlib_math/test_utility.hml"}
{"instruction": "How does syntax work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} finally {\n    // always executes, even if exception thrown\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does handler function signature work in Hemlock?", "output": "Signal handlers receive one argument: the signal number (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signum contains the signal number (e.g., 2 for SIGINT)\n\n    if (signum == SIGINT) {\n        print(\"This is SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // Same handler for multiple signals\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does use try/catch for critical operations work in Hemlock?", "output": "```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Command failed\";\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    // Cleanup or recovery\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show an example of example 2: file logging with error handling in Hemlock.", "output": "```hemlock\nimport { Logger, ERROR } from \"@stdlib/logging\";\n\nlet logger = Logger({\n    output: \"/var/log/myapp.log\",\n    level: ERROR\n});\ndefer logger.close();\n\ntry {\n    risky_operation();\n} catch (e) {\n    logger.error(\"Operation failed\", {\n        error: e,\n        timestamp: __now(),\n        context: \"main_loop\"\n    });\n}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does is_dir(path) work in Hemlock?", "output": "Returns:* bool - True if path is a directory, false otherwise\n\n```hemlock\nimport { is_dir } from \"@stdlib/fs\";\n\nif (is_dir(\".\")) {\n    print(\"Current directory exists\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Show an example of example 3: debug logging during development in Hemlock.", "output": "```hemlock\nimport { Logger, DEBUG } from \"@stdlib/logging\";\n\nlet logger = Logger({ level: DEBUG });\n\nfn process_data(data: array) {\n    logger.debug(\"Processing started\", { size: data.length });\n\n    let i = 0;\n    while (i < data.length) {\n        logger.debug(\"Processing item\", { index: i, value: data[i] });\n        // ... process item ...\n        i = i + 1;\n    }\n\n    logger.debug(\"Processing completed\");\n    return null;\n}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does string type work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\ns[0] = 'H';             // Set with rune\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Write Hemlock code that adding fields dynamically.", "output": "```hemlock\n// Adding fields dynamically\nlet obj = { x: 10 };\nprint(obj.x);\n\nobj.y = 20;\nprint(obj.y);\n\nobj.z = 30;\nprint(obj.z);\n```", "category": "tests/objects", "source": "tests/objects/dynamic_field_add.hml"}
{"instruction": "Show an example of example: sorting (bubble sort) in Hemlock.", "output": "```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // Modifies in-place\nprint(numbers);  // [1, 2, 5, 8, 9]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does kill(pid: i32, signal: i32) work in Hemlock?", "output": "Send a signal to a process.\n\n```hemlock\n// Send SIGTERM (15) to process\nkill(target_pid, 15);\n\n// Send signal 0 to check if process exists\ntry {\n    kill(target_pid, 0);\n    print(\"Process exists\");\n} catch (e) {\n    print(\"Process does not exist\");\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Implement a Hemlock program that tests convenience.", "output": "```hemlock\n// Test: Convenience functions (default logger)\nimport { debug, info, warn, error, log, DEBUG, INFO } from \"@stdlib/logging\";\n\nprint(\"=== Test 1: Convenience functions without structured data ===\");\ndebug(\"Debug from convenience function\");\ninfo(\"Info from convenience function\");\nwarn(\"Warning from convenience function\");\nerror(\"Error from convenience function\");\n\nprint(\"\\n=== Test 2: Convenience functions with structured data ===\");\ninfo(\"User action\", { action: \"click\", button: \"submit\" });\nwarn(\"Low disk space\", { available_gb: 5, threshold_gb: 10 });\nerror(\"Connection failed\", { host: \"example.com\", port: 443 });\n\nprint(\"\\n=== Test 3: log() function with explicit level ===\");\nlog(DEBUG, \"Debug via log()\");\nlog(INFO, \"Info via log()\");\n\nprint(\"\\n=== Test 4: Different message types ===\");\ninfo(123);\ninfo(true);\ninfo([1, 2, 3]);\n\nprint(\"\\nPASS: Convenience functions test completed\");\n```", "category": "tests/stdlib_logging", "source": "tests/stdlib_logging/convenience.hml"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "2. Interactive commands:*\n\n```hemlock\n// Bad - cannot provide input\nlet r = exec(\"ssh user@host\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does what reference counting handles work in Hemlock?", "output": "Scopes exit* - local variables are released:\n\n```hemlock\nfn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // arr released when function returns\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does buffer - safe wrapper (recommended) work in Hemlock?", "output": "Bounds checking:*\n\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // ERROR: Index out of bounds\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Create a Hemlock program that test comparisons involving null Expected: PASS.", "output": "```hemlock\n// Test comparisons involving null\n// Expected: PASS\n\n// null == null\nif (null == null) {\n    print(\"null == null: true\");\n} else {\n    print(\"ERROR: null should equal null\");\n}\n\n// null with other values\nif (null != 0) {\n    print(\"null != 0: true\");\n}\nif (null != false) {\n    print(\"null != false: true\");\n}\nif (null != \"\") {\n    print(\"null != empty string: true\");\n}\n\n// null in array\nlet arr = [1, null, 3];\nif (arr[1] == null) {\n    print(\"null in array: true\");\n}\n\n// null in object\nlet obj = { x: null };\nif (obj.x == null) {\n    print(\"null in object: true\");\n}\n\nprint(\"PASS\");\n```", "category": "tests/comparisons", "source": "tests/comparisons/edge_null_comparisons.hml"}
{"instruction": "Show an example of bitwise examples in Hemlock.", "output": "With unsigned types:*\n\n```hemlock\nlet c: u8 = 15;   // 00001111 in binary\nlet d: u8 = 7;    // 00000111 in binary\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - in u8\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does simple command work in Hemlock?", "output": "```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Write a Hemlock program that test handling multiple different signals.", "output": "```hemlock\n// Test handling multiple different signals\nlet usr1_count = 0;\nlet usr2_count = 0;\n\nfn handler1(sig) {\n    usr1_count = usr1_count + 1;\n}\n\nfn handler2(sig) {\n    usr2_count = usr2_count + 1;\n}\n\n// Register different handlers for different signals\nsignal(SIGUSR1, handler1);\nsignal(SIGUSR2, handler2);\n\n// Raise signals\nraise(SIGUSR1);\nraise(SIGUSR2);\nraise(SIGUSR1);\n\n// Check counts\nassert(usr1_count == 2);\nassert(usr2_count == 1);\n\nprint(\"PASS: multiple_signals\");\n```", "category": "tests/signals", "source": "tests/signals/multiple_signals.hml"}
{"instruction": "How does url_encode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { url_encode } from \"@stdlib/encoding\";\n\n// Safe characters pass through unchanged\nlet safe = url_encode(\"ABCxyz123-_.~\");\nprint(safe);  // \"ABCxyz123-_.~\"\n\n// Space becomes +\nlet space = url_encode(\"Hello World\");\nprint(space);  // \"Hello+World\"\n\n// Special characters become %XX\nlet special = url_encode(\"hello@example.com\");\nprint(special);  // \"hello%40example.com\"\n\n// Query string encoding\nlet query = url_encode(\"key=value&foo=bar\");\nprint(query);  // \"key%3Dvalue%26foo%3Dbar\"\n\n// Unicode (UTF-8 bytes are percent-encoded)\nlet unicode = url_encode(\"Hello ‰∏ñÁïå\");\nprint(unicode);  // \"Hello+%E4%B8%96%E7%95%8C\"\n\n// Emoji\nlet emoji = url_encode(\"Hello üöÄ\");\nprint(emoji);  // \"Hello+%F0%9F%9A%80\"\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "Show an example of example: word counter in Hemlock.", "output": "```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"The quick brown fox\";\nlet count = count_words(sentence);  // 4\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Write Hemlock code that tests the typeof operator.", "output": "```hemlock\n// Test: typeof() returns \"object\" for anonymous objects\nlet obj = { x: 10, y: 20 };\nprint(typeof(obj));\n```", "category": "tests/objects", "source": "tests/objects/typeof_object.hml"}
{"instruction": "Write a Hemlock program that tests return in try.", "output": "```hemlock\n// Test: Return in try block - finally still executes\nfn test() {\n    try {\n        print(\"try\");\n        return 42;\n    } finally {\n        print(\"finally\");\n    }\n}\n\nlet result = test();\nprint(result);\n```", "category": "tests/exceptions", "source": "tests/exceptions/return_in_try.hml"}
{"instruction": "Implement a Hemlock program that test signal handler that throws exception Expected: Testing behavior.", "output": "```hemlock\n// Test signal handler that throws exception\n// Expected: Testing behavior\n\nlet handler_called = false;\n\nfn throwing_handler(sig) {\n    handler_called = true;\n    throw \"error in handler\";\n}\n\nsignal(SIGUSR1, throwing_handler);\n\ntry {\n    raise(SIGUSR1);\n    print(\"Handler completed\");\n} catch (e) {\n    print(\"Caught exception from handler: \" + e);\n}\n\nassert(handler_called == true, \"handler should have been called\");\n\nprint(\"PASS\");\n```", "category": "tests/signals", "source": "tests/signals/edge_handler_throws.hml"}
{"instruction": "Show an example of example in Hemlock.", "output": "```hemlock\nimport { Stack } from \"@stdlib/collections\";\n\nlet s = Stack();\n\n// Push items\ns.push(10);\ns.push(20);\ns.push(30);\n\n// Peek at top\nprint(s.peek());  // 30\n\n// Pop items (LIFO order)\nprint(s.pop());  // 30\nprint(s.pop());  // 20\nprint(s.pop());  // 10\n\n// Check if empty\nif (s.is_empty()) {\n    print(\"Stack is empty\");\n}\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How does map pattern work in Hemlock?", "output": "```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does file search work in Hemlock?", "output": "```hemlock\nimport { list_dir, is_dir, is_file } from \"@stdlib/fs\";\n\nfn find_files(dir: string, pattern: string): array {\n    let results = [];\n\n    try {\n        let entries = list_dir(dir);\n\n        let i = 0;\n        while (i < entries.length) {\n            let name = entries[i];\n            let full_path = dir + \"/\" + name;\n\n            if (is_file(full_path) && name.contains(pattern)) {\n                results.push(full_path);\n            }\n\n            if (is_dir(full_path)) {\n                let sub_results = find_files(full_path, pattern);\n                let j = 0;\n                while (j < sub_results.length) {\n                    results.push(sub_results[j]);\n                    j = j + 1;\n                }\n            }\n\n            i = i + 1;\n        }\n    } catch (e) {\n        print(\"Error searching directory: \" + e);\n    }\n\n    return results;\n}\n\n// Find all .txt files\nlet txt_files = find_files(\".\", \".txt\");\nprint(\"Found \" + typeof(txt_files.length) + \" text files\");\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does negative indices work in Hemlock?", "output": "Not supported* - Use positive indices only:\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // ERROR or undefined behavior\n\n// Use length for last element\nprint(arr[arr.length - 1]);  // 3\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does task spawning work in Hemlock?", "output": "Use spawn() to run async functions in parallel on separate OS threads:\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Spawn multiple tasks - these run in PARALLEL on different CPU cores!\nlet t1 = spawn(factorial, 5);  // Thread 1\nlet t2 = spawn(factorial, 6);  // Thread 2\nlet t3 = spawn(factorial, 7);  // Thread 3\n\n// All three are computing simultaneously right now!\n\n// Wait for results\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Show me Hemlock code that tests that multiple tasks can be spawned and joined.", "output": "```hemlock\n// Test: Multiple concurrent tasks with spawn/join\n// Tests that multiple tasks can be spawned and joined\n\nasync fn compute(id: i32, value: i32): i32 {\n    return id * 100 + value;\n}\n\n// Spawn multiple tasks\nlet t1 = spawn(compute, 1, 10);\nlet t2 = spawn(compute, 2, 20);\nlet t3 = spawn(compute, 3, 30);\n\n// Join all tasks\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n\n// Print results\nprint(r1);  // 110\nprint(r2);  // 220\nprint(r3);  // 330\n```", "category": "tests/async", "source": "tests/async/test_multiple_tasks.hml"}
{"instruction": "How does resolve work in Hemlock?", "output": "Resolves hostname to IPv4 address.\n\n```hemlock\nimport { resolve } from \"@stdlib/net\";\n\nlet ip = resolve(\"localhost\");      // \"127.0.0.1\"\nlet ip2 = resolve(\"example.com\");   // \"93.184.216.34\"\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does os_version() work in Hemlock?", "output": "Returns:* string - Version string (e.g., \"5.15.0-generic\", \"22.1.0\")\n\n```hemlock\nimport { os_version } from \"@stdlib/os\";\n\nlet version = os_version();\nprint(\"Kernel version: \" + version);  // e.g., \"5.15.0-generic\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does scope rules work in Hemlock?", "output": "```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // Can access: inner_var, outer_var, global\n    }\n\n    // Can access: outer_var, global\n    // Cannot access: inner_var\n}\n\n// Can access: global\n// Cannot access: outer_var, inner_var\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does functions work in Hemlock?", "output": "```hemlock\n// Named function\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// Anonymous function\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does comparison operators work in Hemlock?", "output": "```hemlock\nprint(a == b);  // false - Equal\nprint(a != b);  // true  - Not equal\nprint(a > b);   // true  - Greater than\nprint(a < b);   // false - Less than\nprint(a >= b);  // true  - Greater or equal\nprint(a <= b);  // false - Less or equal\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does udpsocket work in Hemlock?", "output": "port: i32 - Source port\n\n```hemlock\nlet packet = sock.recv_from(1024);\nprint(\"From \" + packet.address + \":\" + typeof(packet.port));\nprint(\"Data: \" + typeof(packet.data.length) + \" bytes\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All functions that can fail throw exceptions:\n\n```hemlock\ntry {\n    let result = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Execution failed: \" + e);\n}\n\ntry {\n    kill(99999, 15);  // Non-existent PID\n} catch (e) {\n    print(\"Could not signal process: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Create a Hemlock program that test optional chaining combined with null coalescing.", "output": "```hemlock\n// Test optional chaining combined with null coalescing\n\n// Optional chaining with null coalescing\nlet obj = null;\nlet name = obj?.name ?? \"Unknown\";\nprint(name);  // Unknown\n\n// Nested optional chaining with null coalescing\nlet user = { profile: null };\nlet email = user?.profile?.email ?? \"no-email@example.com\";\nprint(email);  // no-email@example.com\n\n// Array optional indexing with null coalescing\nlet arr = null;\nlet first = arr?.[0] ?? -1;\nprint(first);  // -1\n\n// Valid object with null coalescing\nlet person = { name: \"Alice\", age: 30 };\nlet person_name = person?.name ?? \"Unknown\";\nprint(person_name);  // Alice\n\n// Chaining multiple optional operations\nlet data = { users: [{ name: \"Bob\" }, { name: \"Charlie\" }] };\nlet first_user = data?.users?.[0]?.name ?? \"No user\";\nprint(first_user);  // Bob\n\n// Missing property with null coalescing\nlet config = { port: 8080 };\nlet host = config?.host ?? \"localhost\";\nlet port = config?.port ?? 3000;\nprint(host);  // localhost\nprint(port);  // 8080\n```", "category": "tests/optional_chaining", "source": "tests/optional_chaining/combined.hml"}
{"instruction": "Write Hemlock code that test @stdlib/json path access (get, set, has, delete).", "output": "```hemlock\n// Test @stdlib/json path access (get, set, has, delete)\n\nimport { get, set, has, delete } from \"@stdlib/json\";\n\n// Test get() with nested object\nlet doc = {\n    user: {\n        name: \"Alice\",\n        age: 30,\n        address: {\n            city: \"NYC\",\n            zip: 10001\n        }\n    },\n    items: [1, 2, 3, 4, 5]\n};\n\n// Test basic property access\nassert(get(doc, \"user.name\") == \"Alice\", \"get user.name\");\nassert(get(doc, \"user.age\") == 30, \"get user.age\");\n\n// Test deeply nested access\nassert(get(doc, \"user.address.city\") == \"NYC\", \"get user.address.city\");\nassert(get(doc, \"user.address.zip\") == 10001, \"get user.address.zip\");\n\n// Test array access\nassert(get(doc, \"items.0\") == 1, \"get items[0]\");\nassert(get(doc, \"items.1\") == 2, \"get items[1]\");\nassert(get(doc, \"items.4\") == 5, \"get items[4]\");\n\n// Test empty path (returns root)\nlet root = get(doc, \"\");\nassert(root.user.name == \"Alice\", \"get empty path returns root\");\n\n// Test missing path with default\nassert(get(doc, \"user.phone\", \"(none)\") == \"(none)\", \"get missing with default\");\nassert(get(doc, \"nonexistent.path\", 42) == 42, \"get nonexistent with default\");\n\n// Test missing path without default\nlet missing = get(doc, \"user.email\");\nassert(missing == null, \"get missing without default returns null\");\n\n// Test array out of bounds with default\nassert(get(doc, \"items.10\", -1) == -1, \"get array out of bounds with default\");\n\n// Test set() basic property\nset(doc, \"user.name\", \"Bob\");\nassert(doc.user.name == \"Bob\", \"set user.name\");\n\n// Test set() nested property\nset(doc, \"user.address.city\", \"LA\");\nassert(doc.user.address.city == \"LA\", \"set user.address.city\");\n\n// Test set() array element\nset(doc, \"items.0\", 99);\nassert(doc.items[0] == 99, \"set items[0]\");\n\nset(doc, \"items.2\", 88);\nassert(doc.items[2] == 88, \"set items[2]\");\n\n// Test has() for existing paths\nassert(has(doc, \"user.name\") == true, \"has user.name\");\nassert(has(doc, \"user.address.city\") == true, \"has user.address.city\");\nassert(has(doc, \"items.0\") == true, \"has items[0]\");\n\n// Test has() for missing paths\nassert(has(doc, \"user.phone\") == false, \"has missing user.phone\");\nassert(has(doc, \"nonexistent\") == false, \"has nonexistent path\");\nassert(has(doc, \"items.100\") == false, \"has array out of bounds\");\n\n// Test delete() (sets to null)\ndelete(doc, \"user.age\");\nassert(doc.user.age == null, \"delete sets to null\");\n\n// Test path with null intermediate\nlet null_test = { a: { b: { c: 10 } } };\nset(null_test, \"a.b.c\", null);\nassert(get(null_test, \"a.b.x\", \"default\") == \"default\", \"get with null intermediate\");\n\nprint(\"All path access tests passed!\");\n```", "category": "tests/stdlib_json", "source": "tests/stdlib_json/path_test.hml"}
{"instruction": "How does line breaks work in Hemlock?", "output": "Statements can span multiple lines:\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Write Hemlock code that test buffer operations.", "output": "```hemlock\n// Test buffer operations\n\n// Create buffer\nlet buf = buffer(10);\nprint(\"Created buffer\");\n\n// Check length\nprint(buf.length);\n\n// Set and get values\nbuf[0] = 65;\nbuf[1] = 66;\nbuf[2] = 67;\nprint(buf[0]);\nprint(buf[1]);\nprint(buf[2]);\n\n// Set values again\nbuf[3] = 72;  // 'H'\nbuf[4] = 105; // 'i'\nprint(buf[3]);\nprint(buf[4]);\n\n// Test alloc and free\nlet p = alloc(32);\nprint(\"Allocated p\");\nfree(p);\nprint(\"Freed p\");\n\n// Test realloc\nlet p2 = alloc(16);\nprint(\"Allocated 16 bytes\");\np2 = realloc(p2, 64);\nprint(\"Reallocated to 64 bytes\");\nfree(p2);\nprint(\"Freed reallocated p\");\n\n// Free buffer at the end\nfree(buf);\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/buffers.hml"}
{"instruction": "How does http client (simple get) work in Hemlock?", "output": "```hemlock\nimport { TcpStream } from \"@stdlib/net\";\n\nfn http_get(host: string, path: string) {\n    let stream = TcpStream(host, 80);\n    defer stream.close();\n\n    stream.set_timeout(10.0);  // 10 second timeout\n\n    let request = \"GET \" + path + \" HTTP/1.1\\r\\n\";\n    request = request + \"Host: \" + host + \"\\r\\n\";\n    request = request + \"Connection: close\\r\\n\\r\\n\";\n\n    stream.write(request);\n\n    let response = stream.read_all();\n    return response;\n}\n\nlet html = http_get(\"example.com\", \"/\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does dangling pointers work in Hemlock?", "output": "Allowed but undefined behavior:*\n\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // UNDEFINED: Reading freed memory\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does reverse(str) work in Hemlock?", "output": "Use case - palindrome checking:*\n\n```hemlock\nimport { reverse } from \"@stdlib/strings\";\n\nfn is_palindrome(s: string): bool {\n    let normalized = s.to_lower();\n    return normalized == reverse(normalized);\n}\n\nprint(is_palindrome(\"racecar\"));  // true\nprint(is_palindrome(\"Racecar\"));  // true\nprint(is_palindrome(\"hello\"));    // false\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does value comparison work in Hemlock?", "output": "find() and contains() use value equality:\n\n```hemlock\n// Primitives: compare by value\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// Strings: compare by value\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// Objects: compare by reference\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true (same reference)\narr2.contains(obj2);  // false (different reference)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does typed allocation work in Hemlock?", "output": "Hemlock provides typed allocation helpers for convenience:\n\n```hemlock\nlet arr = talloc(i32, 100);  // Allocate 100 i32 values (400 bytes)\nlet size = sizeof(i32);      // Returns 4 (bytes)\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Write Hemlock code that tests precedence.", "output": "```hemlock\nlet a = 2 + 3 * 4;\nlet b = (2 + 3) * 4;\nlet c = 10 - 2 * 3;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/precedence.hml"}
{"instruction": "How does string methods work in Hemlock?", "output": "```hemlock\nlet text = \"  Hello, World!  \";\n\n// Case conversion\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// Trimming\nprint(text.trim());      // \"Hello, World!\"\n\n// Substring extraction\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// Searching\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// Splitting\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// Replacement\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does replacement work in Hemlock?", "output": "replace_all(old, new)* - Replace all occurrences:\n\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does path types work in Hemlock?", "output": "Absolute Paths:*\n\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does type checking work in Hemlock?", "output": "```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // Type checking happens here\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\" (original is still anonymous)\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does ecdsa_verify(data: string, signature: buffer, keypair: ecdsakeypair): bool work in Hemlock?", "output": "Verify ECDSA signature with public key using SHA-256 digest.\n\n```hemlock\nimport { ecdsa_verify } from \"@stdlib/crypto\";\n\nlet valid = ecdsa_verify(data, signature, keypair);\n\nif (valid) {\n    print(\"‚úì Signature is valid\");\n} else {\n    print(\"‚úó Signature is invalid\");\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does json serialization work in Hemlock?", "output": "```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// Object to JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON to Object\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Writes data to the stream. Returns number of bytes written.\n\n```hemlock\nlet sent = stream.write(\"Hello, server!\");\nlet buf = buffer(10);\nlet sent2 = stream.write(buf);\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Show me Hemlock code that test defer with panic (uncatchable error) Expected: ERROR (panic should exit, but defer should run first).", "output": "```hemlock\n// Test defer with panic (uncatchable error)\n// Expected: ERROR (panic should exit, but defer should run first)\n\n// Note: This test will crash the program with panic\n// It's here to document behavior, but may need special handling\n\nlet cleanup_ran = false;\n\nfn test_panic_defer() {\n    defer print(\"Defer ran before panic\");\n    panic(\"test panic\");\n}\n\n// Commenting out the actual test since panic exits\n// test_panic_defer();\n\nprint(\"SKIP: Test would panic - defer runs before panic exit\");\n```", "category": "tests/defer", "source": "tests/defer/edge_defer_with_panic.hml"}
{"instruction": "Show me Hemlock code that variable declarations and assignments test.", "output": "```hemlock\n// Variable declarations and assignments test\n\n// Basic declaration\nlet x = 10;\nprint(x);\n\n// Multiple declarations\nlet a = 1;\nlet b = 2;\nlet c = 3;\nprint(a + b + c);\n\n// Typed declarations\nlet i: i32 = 42;\nlet f: f64 = 3.14;\nlet s: string = \"hello\";\nlet flag: bool = true;\n\nprint(i);\nprint(f);\nprint(s);\nprint(flag);\n\n// Reassignment\nlet y = 5;\ny = 10;\nprint(y);\n\n// Block scoping\nlet z = 1;\n{\n    let inner = 2;\n    print(inner);\n    print(z);  // can access outer z\n}\nprint(z);\n\n// Compound assignment simulation\nlet counter = 0;\ncounter = counter + 1;\ncounter = counter + 1;\ncounter = counter + 1;\nprint(counter);\n```", "category": "tests/parity", "source": "tests/parity/language/variables.hml"}
{"instruction": "How does join work in Hemlock?", "output": "Error Handling:*\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does future: project manifests work in Hemlock?", "output": "A future release may introduce optional project manifests for version constraints:\n\n```hemlock\n// Hypothetical project.hml\ndefine Project {\n    name: \"my-app\",\n    version: \"1.0.0\",\n    hemlock: \">=1.1.0\"\n}\n```", "category": "docs", "source": "docs/versioning.md"}
{"instruction": "Implement a Hemlock program that test FFI callbacks in compiled Hemlock This test verifies that callback(), callback_free(), and ptr helpers work.", "output": "```hemlock\n// Test FFI callbacks in compiled Hemlock\n// This test verifies that callback(), callback_free(), and ptr helpers work\n\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Comparison function for integers (ascending order)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) {\n        return -1;\n    }\n    if (va > vb) {\n        return 1;\n    }\n    return 0;\n}\n\n// Test qsort with callback\nfn test_qsort() {\n    print(\"Testing qsort with FFI callback (compiled)...\");\n\n    // Allocate array of 5 integers (4 bytes each)\n    let arr = alloc(20);  // 5 * 4 bytes\n\n    // Initialize array: [5, 2, 8, 1, 9]\n    ptr_write_i32(arr, 5);\n    ptr_write_i32(ptr_offset(arr, 1, 4), 2);\n    ptr_write_i32(ptr_offset(arr, 2, 4), 8);\n    ptr_write_i32(ptr_offset(arr, 3, 4), 1);\n    ptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n    // Create callback from comparison function\n    let cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\n\n    // Sort the array\n    qsort(arr, 5, 4, cmp);\n\n    // Verify sorted order: [1, 2, 5, 8, 9]\n    let sorted = true;\n    let i = 0;\n    while (i < 4) {\n        let current = ptr_deref_i32(ptr_offset(arr, i, 4));\n        let next = ptr_deref_i32(ptr_offset(arr, i + 1, 4));\n        if (current > next) {\n            sorted = false;\n        }\n        i = i + 1;\n    }\n\n    if (sorted) {\n        print(\"PASS: Array is sorted correctly\");\n    } else {\n        print(\"FAIL: Array is not sorted correctly\");\n        // Print the array for debugging\n        i = 0;\n        while (i < 5) {\n            let val = ptr_deref_i32(ptr_offset(arr, i, 4));\n            print(`  arr[${i}] = ${val}`);\n            i = i + 1;\n        }\n    }\n\n    // Clean up\n    callback_free(cmp);\n    free(arr);\n\n    return sorted;\n}\n\n// Run test\nlet result = test_qsort();\nif (result) {\n    print(\"All FFI callback tests passed!\");\n} else {\n    print(\"FFI callback tests FAILED\");\n}\n```", "category": "tests/compiler", "source": "tests/compiler/ffi_callback.hml"}
{"instruction": "Create a Hemlock program that test array slice() edge cases Expected: PASS.", "output": "```hemlock\n// Test array slice() edge cases\n// Expected: PASS\n\nlet arr = [1, 2, 3, 4, 5];\n\n// Slice with end beyond length\nlet s1 = arr.slice(0, 100);\nassert(s1.length == 5, \"slice beyond end should return all elements\");\n\n// Slice with start > end\nlet s2 = arr.slice(3, 1);\nassert(s2.length == 0, \"slice with start > end should return empty array\");\n\n// Slice with start == end\nlet s3 = arr.slice(2, 2);\nassert(s3.length == 0, \"slice with start == end should return empty array\");\n\n// Slice starting beyond length\nlet s4 = arr.slice(10, 20);\nassert(s4.length == 0, \"slice starting beyond length should return empty array\");\n\n// Slice entire array\nlet s5 = arr.slice(0, 5);\nassert(s5.length == 5, \"slice(0, length) should return full array\");\n\n// Slice with negative indices - test current behavior\ntry {\n    let s6 = arr.slice(-2, 5);\n    print(\"slice with negative start did not error\");\n} catch (e) {\n    print(\"slice with negative start threw error: \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/arrays", "source": "tests/arrays/edge_slice_bounds.hml"}
{"instruction": "How does basic assignment work in Hemlock?", "output": "```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does what to test work in Hemlock?", "output": "Example test coverage:*\n\n```hemlock\n// Feature: String.substr(start, length)\n\n// Happy path\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Edge cases\nprint(\"hello\".substr(0, 0));  // \"\" (empty)\nprint(\"hello\".substr(5, 0));  // \"\" (at end)\nprint(\"hello\".substr(2, 100)); // \"llo\" (past end)\n\n// Error cases\n// \"hello\".substr(-1, 5);  // Error: negative index\n// \"hello\".substr(0, -1);  // Error: negative length\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does switch value types work in Hemlock?", "output": "Switch works with any value type:\n\n```hemlock\n// Integers\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"one\"); break;\n}\n\n// Strings\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// Booleans\nswitch (flag) {\n    case true: print(\"on\"); break;\n    case false: print(\"off\"); break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does avoid logging sensitive data work in Hemlock?", "output": "```hemlock\n// Bad: Logs password\nlogger.info(\"User login\", { username: \"alice\", password: \"secret123\" });\n\n// Good: Omit sensitive data\nlogger.info(\"User login\", { username: \"alice\" });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does constants work in Hemlock?", "output": "Use const for immutable values:\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does lines(str) work in Hemlock?", "output": "Use case - processing multi-line input:*\n\n```hemlock\nimport { lines } from \"@stdlib/strings\";\n\nlet text = \"Alice\\nBob\\nCarol\\nDave\";\nlet names = lines(text);\n\nlet i = 0;\nwhile (i < names.length) {\n    print(\"User \" + typeof(i + 1) + \": \" + names[i]);\n    i = i + 1;\n}\n// Output:\n// User 1: Alice\n// User 2: Bob\n// User 3: Carol\n// User 4: Dave\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does predefined spinner styles work in Hemlock?", "output": "```hemlock\nimport { SPINNER_DOTS, SPINNER_LINE, SPINNER_ARROW } from \"@stdlib/terminal\";\n\n// Dots spinner (Unicode braille)\nlet s1 = Spinner(SPINNER_DOTS());\n\n// Classic line spinner\nlet s2 = Spinner(SPINNER_LINE());\n\n// Arrow spinner\nlet s3 = Spinner(SPINNER_ARROW());\n\n// Clock emoji spinner\nlet s4 = Spinner(SPINNER_CLOCK());\n\n// Bounce spinner\nlet s5 = Spinner(SPINNER_BOUNCE());\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Write a Hemlock program that type conversions test Uses Hemlock's built-in conversion mechanisms.", "output": "```hemlock\n// Type conversions test\n// Uses Hemlock's built-in conversion mechanisms\n\n// Implicit numeric conversion\nlet i: i32 = 42;\nlet f: f64 = i;  // i32 to f64\nprint(f);\n\n// String concatenation forces conversion\nlet num = 123;\nlet str = \"\" + num;  // number to string via concat\nprint(str);\nprint(typeof(str));\n\n// Arithmetic promotes types\nlet a: i32 = 5;\nlet b: f64 = 2.5;\nlet c = a + b;  // i32 promoted to f64\nprint(c);\nprint(typeof(c));\n\n// Array length\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);\n\n// String length\nlet text = \"hello\";\nprint(text.length);\n\n// Boolean in string context\nprint(\"value: \" + true);\nprint(\"value: \" + false);\n\n// Division always returns float\nlet x = 7 / 2;     // division always returns float (f64)\nprint(x);\n\nlet y = 7.0 / 2.0; // explicit float division (same result)\nprint(y);\n```", "category": "tests/parity", "source": "tests/parity/language/conversions.hml"}
{"instruction": "Show me Hemlock code that test string interpolation with expressions.", "output": "```hemlock\n// Test string interpolation with expressions\n\nlet x = 10;\nlet y = 20;\n\n// Arithmetic expressions\nprint(`Sum: ${x + y}`);\nprint(`Product: ${x * y}`);\nprint(`Division: ${y / x}`);\n\n// Method calls\nlet text = \"hemlock\";\nprint(`Uppercase: ${text.to_upper()}`);\n\n// Array access\nlet items = [1, 2, 3, 4, 5];\nprint(`First: ${items[0]}, Last: ${items[4]}`);\nprint(`Length: ${items.length}`);\n\n// Escape sequences\nprint(`Price: \\$100`);\nprint(`Use \\` for templates`);\n\n// Expected output:\n// Sum: 30\n// Product: 200\n// Division: 2\n// Uppercase: HEMLOCK\n// First: 1, Last: 5\n// Length: 5\n// Price: $100\n// Use ` for templates\n```", "category": "tests/interpolation", "source": "tests/interpolation/expressions.hml"}
{"instruction": "Implement a Hemlock program that tests getpid test.", "output": "```hemlock\n// Test: FFI getpid function (no parameters)\nimport \"libc.so.6\";\n\nextern fn getpid(): i32;\n\nlet pid = getpid();\nprint(pid);\n```", "category": "tests/ffi", "source": "tests/ffi/getpid_test.hml"}
{"instruction": "How does explicit type conversion work in Hemlock?", "output": "```hemlock\nlet ch: rune = 'üöÄ';\nlet s: string = ch;   // rune ‚Üí string (\"üöÄ\")\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does raise(signum) work in Hemlock?", "output": "```hemlock\nraise(SIGUSR1);  // Trigger SIGUSR1 handler\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Write a Hemlock program that functions stored in objects.", "output": "```hemlock\n// Functions stored in objects\nlet math = {\n    add: fn(a, b) {\n        return a + b;\n    },\n    multiply: fn(a, b) {\n        return a * b;\n    },\n};\n\nprint(math.add(5, 3));\nprint(math.multiply(4, 7));\n```", "category": "tests/objects", "source": "tests/objects/function_in_object.hml"}
{"instruction": "How does reading files work in Hemlock?", "output": "```hemlock\n// Read entire file\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// Read specific number of bytes\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // Read 100 bytes\nf2.close();\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does meeting scheduler work in Hemlock?", "output": "```hemlock\nimport { now, parse_iso } from \"@stdlib/datetime\";\n\n// Parse meeting times from ISO strings\nlet meeting1 = parse_iso(\"2025-03-20T14:30:00\");\nlet meeting2 = parse_iso(\"2025-03-20T16:00:00\");\n\n// Calculate duration\nlet duration_minutes = meeting2.diff_minutes(meeting1);\nprint(\"Meeting duration: \" + typeof(duration_minutes) + \" minutes\");\n\n// Check if meeting is in the future\nlet current = now();\nif (meeting1.is_after(current)) {\n    let days_until = meeting1.diff_days(current);\n    print(\"Meeting in \" + typeof(days_until) + \" days\");\n    print(\"Meeting time: \" + meeting1.format(\"%A, %B %d at %I:%M %p\"));\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does environment variable validator work in Hemlock?", "output": "```hemlock\nimport { getenv, exit } from \"@stdlib/env\";\n\ndefine EnvVar {\n    name: string,\n    required: bool,\n    default_value?: string,\n}\n\nfn validate_environment(vars: array): object {\n    let config = {};\n    let errors = [];\n\n    let i = 0;\n    while (i < vars.length) {\n        let var_def = vars[i];\n        let value = getenv(var_def.name);\n\n        if (value == null) {\n            if (var_def.required) {\n                errors.push(\"Required variable \" + var_def.name + \" not set\");\n            } else if (var_def.default_value != null) {\n                value = var_def.default_value;\n            }\n        }\n\n        // Store in config object (simplified)\n        print(var_def.name + \" = \" + (value == null ? \"(not set)\" : value));\n\n        i = i + 1;\n    }\n\n    if (errors.length > 0) {\n        let j = 0;\n        while (j < errors.length) {\n            print(\"Error: \" + errors[j]);\n            j = j + 1;\n        }\n        exit(1);\n    }\n\n    return config;\n}\n\n// Usage\nlet env_vars = [\n    { name: \"API_KEY\", required: true },\n    { name: \"PORT\", required: false, default_value: \"8080\" },\n    { name: \"DEBUG\", required: false }\n];\n\nlet config = validate_environment(env_vars);\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "Write Hemlock code that test type definitions and duck typing.", "output": "```hemlock\n// Test type definitions and duck typing\n\ndefine Person {\n    name: string,\n    age: i32\n}\n\n// Create object and assign to typed variable\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.name);\nprint(typed_p.age);\nprint(typeof(typed_p));\n\n// Extra fields are allowed\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\nprint(p2.name);\nprint(p2.city);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/type_definitions.hml"}
{"instruction": "How does empty objects work in Hemlock?", "output": "```hemlock\nlet obj = {};  // Empty object\n\n// Add fields later\nobj.name = \"Alice\";\nobj.age = 30;\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does compilation flags work in Hemlock?", "output": "Combining flags:*\n\n```hemlock\nimport { compile, REG_EXTENDED, REG_ICASE, REG_NEWLINE } from \"@stdlib/regex\";\n\n// Multiple flags using bitwise OR\nlet flags = REG_EXTENDED | REG_ICASE | REG_NEWLINE;\nlet pattern = compile(\"^hello\", flags);\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does ptr - raw pointer (dangerous) work in Hemlock?", "output": "```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation - allowed but dangerous\nfree(p);\nlet x = *p;       // Dangling pointer - undefined behavior\nfree(p);          // Double-free - will crash\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Show me Hemlock code that test enum with typed variable.", "output": "```hemlock\n// Test enum with typed variable\n\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet color: Color = Color.RED;\nprint(color);\n\ncolor = Color.BLUE;\nprint(color);\n```", "category": "tests/enums", "source": "tests/enums/typed_variable.hml"}
{"instruction": "Write Hemlock code that object with multiple fields of different types.", "output": "```hemlock\n// Object with multiple fields of different types\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    height: 1.75,\n    active: true,\n};\nprint(person);\n```", "category": "tests/objects", "source": "tests/objects/anonymous_multiple_fields.hml"}
{"instruction": "How does detach work in Hemlock?", "output": "```hemlock\ndetach(task: task): null\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Implement a Hemlock program that tests mutate.", "output": "```hemlock\nlet s = \"hello\";\ns[0] = 72;\nprint(s);\n```", "category": "tests/strings", "source": "tests/strings/mutate.hml"}
{"instruction": "What array methods are available in Hemlock?", "output": "Hemlock arrays have 18 methods:\n\n**Mutating:** push(val), pop(), shift(), unshift(val), insert(i, val), remove(i), clear(), reverse()\n**Access:** first(), last(), slice(start, end)\n**Search:** find(val), contains(val)\n**Transform:** join(sep), concat(arr), map(fn), filter(fn), reduce(fn, init)\n\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);              // [1, 2, 3, 4]\nlet doubled = arr.map(fn(x) { return x * 2; });  // [2, 4, 6, 8]\nlet sum = arr.reduce(fn(a, b) { return a + b; }, 0);  // 10\n```", "category": "concepts/arrays", "source": "CLAUDE.md"}
{"instruction": "How does channel type work in Hemlock?", "output": "```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Create a Hemlock program that test i64 type annotation and typeof.", "output": "```hemlock\n// Test i64 type annotation and typeof\nlet a: i64 = 2147483647;\nlet b: i64 = -2147483648;\nlet c: i64 = 0;\nlet d: i64 = 1000000;\nprint(a);\nprint(b);\nprint(c);\nprint(d);\nprint(typeof(a));\nprint(typeof(b));\nprint(typeof(c));\nprint(typeof(d));\n```", "category": "tests/primitives", "source": "tests/primitives/i64_valid.hml"}
{"instruction": "How does best practices for safe signal handling work in Hemlock?", "output": "4. Avoid Re-entrancy Issues*\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // Don't modify data while main code is using it\n        return;\n    }\n    // Safe to proceed\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Create a Hemlock program that tests f32 valid.", "output": "```hemlock\nlet a: f32 = 3.14;\nlet b: f32 = -2.5;\nlet c: f32 = 0.0;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/primitives", "source": "tests/primitives/f32_valid.hml"}
{"instruction": "How does do's work in Hemlock?", "output": "‚úÖ Add comments explaining tricky tests\n\n```hemlock\n// Test that closure captures outer variable by reference\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // Modify after closure creation\n    return f();  // Should return 20, not 10\n}\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does catching ctrl+c work in Hemlock?", "output": "```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Program continues running...\n// User presses Ctrl+C -> handle_interrupt() is called\n\nwhile (!interrupted) {\n    // Do work...\n}\n\nprint(\"Exiting due to interrupt\");\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does pattern: filter work in Hemlock?", "output": "```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does pattern: state object work in Hemlock?", "output": "```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does building arrays work in Hemlock?", "output": "```hemlock\nlet arr = [];\n\n// Build array with loop\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Show me Hemlock code that test string interpolation with template strings.", "output": "```hemlock\n// Test string interpolation with template strings\n\n// Basic variable interpolation\nlet name = \"Alice\";\nlet greeting = `Hello, ${name}!`;\nprint(greeting);\n\n// Multiple interpolations\nlet age = 30;\nlet msg = `${name} is ${age} years old.`;\nprint(msg);\n\n// Expression interpolation\nlet x = 10;\nlet y = 20;\nlet result = `Sum: ${x + y}, Product: ${x * y}`;\nprint(result);\n\n// Nested property access\nlet person = { name: \"Bob\", city: \"NYC\" };\nprint(`${person.name} lives in ${person.city}`);\n\n// Empty interpolation (edge case)\nlet empty = `start  end`;\nprint(empty);\n\n// Just a plain template string\nlet plain = `no interpolation here`;\nprint(plain);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/string_interpolation.hml"}
{"instruction": "Show me Hemlock code that this test ensures that expression results are properly released.", "output": "```hemlock\n// Test: Basic reference counting - expressions are released\n// This test ensures that expression results are properly released\n\n// Standalone expression statements should not leak\n\"hello\";\n[1, 2, 3];\n({ x: 10, y: 20 });  // Parentheses force object literal interpretation\n42 + 58;\n\n// Variable assignments should have correct ref_count\nlet s = \"world\";\nlet arr = [4, 5, 6];\nlet obj = { a: 1, b: 2 };\n\n// Reassignment should release old values\ns = \"new string\";\narr = [7, 8, 9];\nobj = { c: 3, d: 4 };\n\n// Nested expressions\nlet combined = \"prefix_\" + \"suffix\";\nlet computed = [1, 2].concat([3, 4]);\n\n// Print to verify execution completed\nprint(\"refcount_basic test passed\");\n```", "category": "tests/memory", "source": "tests/memory/refcount_basic.hml"}
{"instruction": "How does posix extended regular expression (ere) syntax work in Hemlock?", "output": "```hemlock\nimport { test } from \"@stdlib/regex\";\n\n// Email validation (simplified)\ntest(\"^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\\\.[a-z]+$\", \"user@example.com\");  // true\n\n// Phone number (US format)\ntest(\"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\", \"555-123-4567\");  // true\n\n// Hexadecimal color code\ntest(\"^#[0-9a-fA-F]{6}$\", \"#FF5733\");  // true\n\n// URL protocol\ntest(\"^(http|https)://\", \"https://example.com\");  // true\n\n// Whitespace\ntest(\"^[[:space:]]+$\", \"   \\t\\n\");  // true\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does import immutability work in Hemlock?", "output": "Imported bindings cannot be reassigned:\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // ERROR: cannot reassign imported binding\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does quick start work in Hemlock?", "output": "```hemlock\nimport { now, from_date, parse_iso } from \"@stdlib/datetime\";\n\n// Get current date/time\nlet current = now();\nprint(current.to_string());  // \"2025-01-16 12:30:45\"\n\n// Create from specific date\nlet birthday = from_date(1990, 5, 15, 14, 30, 0);\nprint(birthday.format(\"%B %d, %Y\"));  // \"May 15, 1990\"\n\n// Parse ISO date\nlet meeting = parse_iso(\"2025-03-20T14:30:00\");\nprint(meeting.to_string());  // \"2025-03-20 14:30:00\"\n\n// Date arithmetic\nlet next_week = current.add_days(7);\nprint(\"Next week: \" + next_week.to_date_string());\n\n// Comparison\nif (meeting.is_after(current)) {\n    print(\"Meeting is in the future\");\n}\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does mutual recursion work in Hemlock?", "output": "Functions can call each other:\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does testing success cases work in Hemlock?", "output": "Example: tests/strings/methods.hml*\n\n```hemlock\n// Test substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Expect: world\n\n// Test find\nlet pos = s.find(\"world\");\nprint(pos);  // Expect: 6\n\n// Test contains\nlet has = s.contains(\"lo\");\nprint(has);  // Expect: true\n\n// Test trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Expect: hello\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Implement a Hemlock program that test array first and last methods.", "output": "```hemlock\n// Test array first and last methods\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.first());\nprint(arr.last());\n\nlet single = [42];\nprint(single.first());\nprint(single.last());\n\nlet empty = [];\nprint(empty.first());\nprint(empty.last());\n```", "category": "tests/arrays", "source": "tests/arrays/first_last.hml"}
{"instruction": "How does appending to file work in Hemlock?", "output": "```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Event occurred\\n\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does append to file work in Hemlock?", "output": "```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Log entry 1\");\nappend_file(\"log.txt\", \"Log entry 2\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does bright colors (foreground) work in Hemlock?", "output": "```hemlock\nimport { BRIGHT_RED, BRIGHT_GREEN, BRIGHT_BLUE, GRAY } from \"@stdlib/terminal\";\n\nprint(BRIGHT_RED + \"Bright red\" + RESET);\nprint(GRAY + \"Gray text\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Implement a Hemlock program that test terminal information functions.", "output": "```hemlock\n// Test terminal information functions\nimport { size, supports_color } from \"@stdlib/terminal\";\n\nprint(\"=== Terminal Info Tests ===\");\nprint(\"\");\n\n// Test size() function\nprint(\"Testing size():\");\nlet dimensions = size();\nprint(\"Terminal size: \" + typeof(dimensions.rows) + \" rows x \" + typeof(dimensions.cols) + \" cols\");\n\nif (dimensions.rows > 0 && dimensions.cols > 0) {\n    print(\"‚úì size() returns valid dimensions\");\n} else {\n    print(\"‚úó size() returned invalid dimensions\");\n}\n\n// Verify size returns object with correct fields\nif (typeof(dimensions) == \"object\") {\n    print(\"‚úì size() returns object\");\n}\n\nprint(\"\");\n\n// Test supports_color() function\nprint(\"Testing supports_color():\");\nlet has_color = supports_color();\nprint(\"Color support: \" + typeof(has_color));\n\nif (typeof(has_color) == \"bool\") {\n    print(\"‚úì supports_color() returns boolean\");\n}\n\n// Most modern terminals support color\nif (has_color) {\n    print(\"‚úì Terminal supports ANSI colors\");\n} else {\n    print(\"‚ö† Terminal does not support ANSI colors\");\n}\n\nprint(\"\");\nprint(\"‚úì All terminal info tests completed\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/test_info.hml"}
{"instruction": "Write a Hemlock program that test functions.", "output": "```hemlock\n// Test functions\n\nfn add(a, b) {\n    return a + b;\n}\n\nprint(add(2, 3));\n\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\nprint(greet(\"World\"));\n\n// Recursion\nfn factorial(n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));\n\n// Higher-order function\nfn apply(f, x) {\n    return f(x);\n}\n\nfn twice(n) {\n    return n * 2;\n}\n\nprint(apply(twice, 5));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/functions.hml"}
{"instruction": "Create a Hemlock program that tests panic not catchable error.", "output": "```hemlock\n// Test: panic() is NOT catchable with try/catch\nprint(\"before try\");\ntry {\n    print(\"in try\");\n    panic(\"uncatchable\");\n    print(\"after panic in try\");  // Should never execute\n} catch (e) {\n    print(\"caught: \" + e);  // Should never execute\n}\nprint(\"after catch\");  // Should never execute\n```", "category": "tests/exceptions", "source": "tests/exceptions/panic_not_catchable_error.hml"}
{"instruction": "How does simple argument processing work in Hemlock?", "output": "Check for required argument:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Processing file: \" + filename);\n    // ... process file\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Implement a Hemlock program that test signal handling - simplified for parity.", "output": "```hemlock\n// Test signal handling - simplified for parity\n\nfn handle_signal(sig) {\n    print(\"signal received\");\n}\n\n// Register handler\nsignal(SIGUSR1, handle_signal);\n\n// Raise signal\nraise(SIGUSR1);\n\n// Reset to default\nsignal(SIGUSR1, null);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/signals.hml"}
{"instruction": "Create a Hemlock program that test type promotion: smaller types promote to u64.", "output": "```hemlock\n// Test type promotion: smaller types promote to u64\nlet small: u32 = 100;\nlet large: u64 = 5000;\nlet result = small + large;\nprint(result);\nprint(typeof(result));\n\n// Test that u64 is higher rank than u32\nlet a: u32 = 42;\nlet b: u64 = 58;\nlet c = a + b;\nprint(c);\nprint(typeof(c));\n```", "category": "tests/primitives", "source": "tests/primitives/u64_arithmetic.hml"}
{"instruction": "Show an example of example: character classification in Hemlock.", "output": "```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Write a Hemlock program that test env module process functions.", "output": "```hemlock\n// Test env module process functions\n\nimport * as env from \"@stdlib/env\";\n\n// Test get_pid\nlet pid = env.get_pid();\nassert(pid > 0, \"get_pid() should return positive process ID\");\nassert(typeof(pid) == \"i32\", \"get_pid() should return i32\");\n\n// Test that PID is consistent\nlet pid2 = env.get_pid();\nassert(pid == pid2, \"get_pid() should return same PID within same process\");\n\nprint(\"All process function tests passed!\");\n```", "category": "tests/stdlib_env", "source": "tests/stdlib_env/test_process.hml"}
{"instruction": "How does try/catch/finally work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n} finally {\n    // cleanup\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How do you queue usage in Hemlock?", "output": "```hemlock\nlet queue = [];\n\n// Enqueue\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dequeue\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does declare external function work in Hemlock?", "output": "```hemlock\nextern fn function_name(param: type): return_type;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does test organization work in Hemlock?", "output": "Descriptive suite names:*\n\n```hemlock\ndescribe(\"HashMap.set() method\", fn() { ... });\ndescribe(\"TcpListener connection handling\", fn() { ... });\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does exception propagation work in Hemlock?", "output": "Exceptions thrown in tasks are propagated when joined:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\n// Task that succeeds\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// Task that fails\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Write a Hemlock program that test @stdlib/strings manipulation functions.", "output": "```hemlock\n// Test @stdlib/strings manipulation functions\nimport { reverse, lines, words } from \"@stdlib/strings\";\n\nprint(\"Testing reverse...\");\n\n// Basic reverse\nprint(reverse(\"hello\") == \"olleh\");\nprint(reverse(\"abc\") == \"cba\");\nprint(reverse(\"12345\") == \"54321\");\n\n// Single character\nprint(reverse(\"a\") == \"a\");\n\n// Empty string\nprint(reverse(\"\") == \"\");\n\n// Palindrome\nprint(reverse(\"racecar\") == \"racecar\");\n\n// With spaces\nprint(reverse(\"hello world\") == \"dlrow olleh\");\n\n// Unicode / emojis\nprint(reverse(\"üöÄüåç\") == \"üåçüöÄ\");\nprint(reverse(\"HiüöÄ\") == \"üöÄiH\");\n\nprint(\"Testing lines...\");\n\n// Basic line splitting\nlet l1 = lines(\"hello\\nworld\");\nprint(l1.length == 2);\nprint(l1[0] == \"hello\");\nprint(l1[1] == \"world\");\n\n// Multiple lines\nlet l2 = lines(\"line1\\nline2\\nline3\");\nprint(l2.length == 3);\nprint(l2[0] == \"line1\");\nprint(l2[1] == \"line2\");\nprint(l2[2] == \"line3\");\n\n// Empty lines\nlet l3 = lines(\"a\\n\\nb\");\nprint(l3.length == 3);\nprint(l3[0] == \"a\");\nprint(l3[1] == \"\");\nprint(l3[2] == \"b\");\n\n// Single line (no newline)\nlet l4 = lines(\"hello\");\nprint(l4.length == 1);\nprint(l4[0] == \"hello\");\n\n// Empty string\nlet l5 = lines(\"\");\nprint(l5.length == 1);\nprint(l5[0] == \"\");\n\nprint(\"Testing words...\");\n\n// Basic word splitting\nlet w1 = words(\"hello world\");\nprint(w1.length == 2);\nprint(w1[0] == \"hello\");\nprint(w1[1] == \"world\");\n\n// Multiple words\nlet w2 = words(\"the quick brown fox\");\nprint(w2.length == 4);\nprint(w2[0] == \"the\");\nprint(w2[1] == \"quick\");\nprint(w2[2] == \"brown\");\nprint(w2[3] == \"fox\");\n\n// Extra spaces\nlet w3 = words(\"hello  world\");\nprint(w3.length == 2);\nprint(w3[0] == \"hello\");\nprint(w3[1] == \"world\");\n\n// Leading/trailing spaces\nlet w4 = words(\"  hello world  \");\nprint(w4.length == 2);\nprint(w4[0] == \"hello\");\nprint(w4[1] == \"world\");\n\n// Single word\nlet w5 = words(\"hello\");\nprint(w5.length == 1);\nprint(w5[0] == \"hello\");\n\n// Empty string\nlet w6 = words(\"\");\nprint(w6.length == 0);\n\n// Only spaces\nlet w7 = words(\"   \");\nprint(w7.length == 0);\n\nprint(\"All manipulation tests passed!\");\n```", "category": "tests/stdlib_strings", "source": "tests/stdlib_strings/test_manipulation.hml"}
{"instruction": "How does array type work in Hemlock?", "output": "```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];  // Mixed types allowed\nlet empty: array = [];\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show an example of example 2: multi-signal state machine in Hemlock.", "output": "```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"State: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"State: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"State: \" + state);\n    print(\"Requests: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // Do work\n        request_count = request_count + 1;\n    }\n\n    // Check every iteration...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Implement a Hemlock program that test filter() - keep elements that pass predicate.", "output": "```hemlock\n// Test filter() - keep elements that pass predicate\n\n// Basic filter - even numbers\nlet nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet evens = nums.filter(fn(x) {\n    return x % 2 == 0;\n});\nprint(evens[0]);  // 2\nprint(evens[1]);  // 4\nprint(evens[2]);  // 6\nprint(evens[3]);  // 8\nprint(evens[4]);  // 10\nprint(evens.length);  // 5\n\n// Filter - odd numbers\nlet odds = nums.filter(fn(x) {\n    return x % 2 == 1;\n});\nprint(odds[0]);  // 1\nprint(odds[1]);  // 3\nprint(odds[2]);  // 5\nprint(odds[3]);  // 7\nprint(odds.length);  // 5\n\n// Filter with empty array\nlet empty = [];\nlet empty_result = empty.filter(fn(x) {\n    return x > 5;\n});\nprint(empty_result.length);  // 0\n\n// Filter that keeps nothing\nlet none = [1, 2, 3].filter(fn(x) {\n    return x > 10;\n});\nprint(none.length);  // 0\n\n// Filter that keeps everything\nlet all = [1, 2, 3].filter(fn(x) {\n    return x > 0;\n});\nprint(all[0]);  // 1\nprint(all[1]);  // 2\nprint(all[2]);  // 3\nprint(all.length);  // 3\n\n// Filter preserves original array\nlet original = [1, 2, 3, 4, 5];\nlet filtered = original.filter(fn(x) {\n    return x > 3;\n});\nprint(original.length);  // 5 (unchanged)\nprint(filtered.length);  // 2\n\n// Filter with strings\nlet words = [\"apple\", \"banana\", \"cherry\", \"date\"];\nlet long_words = words.filter(fn(w) {\n    return w.length > 5;\n});\nprint(long_words[0]);  // banana\nprint(long_words[1]);  // cherry\nprint(long_words.length);  // 2\n\n// Filter with closure\nlet threshold = 5;\nlet above_threshold = [1, 3, 5, 7, 9].filter(fn(x) {\n    return x > threshold;\n});\nprint(above_threshold[0]);  // 7\nprint(above_threshold[1]);  // 9\nprint(above_threshold.length);  // 2\n\n// Truthy filter (non-bool return values)\nlet mixed = [1, 0, 2, null, 3];\nlet truthy = mixed.filter(fn(x) {\n    return x;  // Returns the value itself (truthy check)\n});\nprint(truthy[0]);  // 1\nprint(truthy[1]);  // 2\nprint(truthy[2]);  // 3\nprint(truthy.length);  // 3\n```", "category": "tests/arrays", "source": "tests/arrays/filter.hml"}
{"instruction": "How does atan2(y, x) work in Hemlock?", "output": "Returns:* f64 - Arc tangent in range [-œÄ, œÄ]\n\n```hemlock\nimport { atan2, PI } from \"@stdlib/math\";\n\nlet angle = atan2(1.0, 1.0);    // œÄ/4 (45 degrees)\nlet angle2 = atan2(1.0, -1.0);  // 3œÄ/4 (135 degrees)\nlet angle3 = atan2(-1.0, -1.0); // -3œÄ/4 (-135 degrees)\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Write Hemlock code that test unprefixed builtin aliases.", "output": "```hemlock\n// Test unprefixed builtin aliases\n\n// Math functions (using direct function call)\nprint(sin(0.0));\nprint(cos(0.0));\nprint(sqrt(4.0));\nprint(floor(3.7));\nprint(ceil(2.3));\nprint(round(2.5));\n\n// Test pow\nprint(pow(2.0, 3.0));\n\n// Test log functions\nprint(log(1.0));\nprint(log10(100.0));\nprint(log2(8.0));\n\n// Test atan2\nprint(atan2(1.0, 1.0));\n\n// Environment functions\nlet test_var = getenv(\"PATH\");\nif (test_var != null) {\n    print(\"PATH exists\");\n} else {\n    print(\"PATH not found\");\n}\n\n// get_pid should return a positive integer\nlet pid = get_pid();\nif (pid > 0) {\n    print(\"PID is positive\");\n}\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/unprefixed_builtins.hml"}
{"instruction": "How does api work in Hemlock?", "output": "```hemlock\nlet q = Queue();\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "Implement a Hemlock program that tests if true.", "output": "```hemlock\nif (true) {\n    print(\"yes\");\n} else {\n    print(\"no\");\n}\n```", "category": "tests/control", "source": "tests/control/if_true.hml"}
{"instruction": "How does platform-specific commands work in Hemlock?", "output": "```hemlock\nimport { platform } from \"@stdlib/os\";\nimport { exec } from \"@stdlib/process\";\n\nfn open_url(url: string): null {\n    let p = platform();\n    let cmd = \"\";\n\n    if (p == \"linux\") {\n        cmd = \"xdg-open \" + url;\n    } else if (p == \"macos\") {\n        cmd = \"open \" + url;\n    } else if (p == \"windows\") {\n        cmd = \"start \" + url;\n    } else {\n        print(\"Cannot open URL on unknown platform\");\n        return null;\n    }\n\n    let result = exec(cmd);\n    if (result.exit_code != 0) {\n        print(\"Failed to open URL: \" + result.output);\n    }\n\n    return null;\n}\n\nfn get_clipboard(): string {\n    let p = platform();\n\n    if (p == \"linux\") {\n        return exec(\"xclip -selection clipboard -o\").output;\n    } else if (p == \"macos\") {\n        return exec(\"pbpaste\").output;\n    }\n\n    return \"\";\n}\n\nfn set_clipboard(text: string): null {\n    let p = platform();\n\n    if (p == \"linux\") {\n        exec(\"echo -n '\" + text + \"' | xclip -selection clipboard\");\n    } else if (p == \"macos\") {\n        exec(\"echo -n '\" + text + \"' | pbcopy\");\n    }\n\n    return null;\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does recursive directory creation work in Hemlock?", "output": "```hemlock\nimport { exists, make_dir, is_dir } from \"@stdlib/fs\";\n\nfn make_dirs(path: string): bool {\n    if (exists(path)) {\n        return is_dir(path);\n    }\n\n    // Find the last slash\n    let parts = path.split(\"/\");\n    if (parts.length <= 1) {\n        try {\n            make_dir(path);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    // Create parent first\n    let parent_parts = parts.slice(0, parts.length - 1);\n    let parent = parent_parts.join(\"/\");\n\n    if (!make_dirs(parent)) {\n        return false;\n    }\n\n    // Then create this directory\n    try {\n        make_dir(path);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Usage\nif (make_dirs(\"/tmp/app/data/logs\")) {\n    print(\"Directory tree created\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does void type work in Hemlock?", "output": "```hemlock\nextern fn exit(code: i32): void;\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Create a Hemlock program that tests loop exception leak.", "output": "```hemlock\n// Test: Exception in for loop initializer should be caught\nprint(\"Test 1: Exception in for initializer\");\ntry {\n    fn bad_init() {\n        throw \"error in init\";\n    }\n    for (let i = bad_init(); i < 10; i = i + 1) {\n        print(\"Should not reach here\");\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for loop condition should be caught\nprint(\"\\nTest 2: Exception in for condition\");\ntry {\n    fn bad_condition() {\n        throw \"error in condition\";\n    }\n    for (let i = 0; bad_condition(); i = i + 1) {\n        print(\"Should not reach here\");\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for loop body should be caught\nprint(\"\\nTest 3: Exception in for body\");\ntry {\n    for (let i = 0; i < 5; i = i + 1) {\n        if (i == 2) {\n            throw \"error at i=2\";\n        }\n        print(\"i = \" + typeof(i));\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for loop increment should be caught\nprint(\"\\nTest 4: Exception in for increment\");\ntry {\n    fn bad_increment(x) {\n        if (x == 2) {\n            throw \"error in increment at i=2\";\n        }\n        return x + 1;\n    }\n    for (let i = 0; i < 5; i = bad_increment(i)) {\n        print(\"i = \" + typeof(i));\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for-in iterable evaluation\nprint(\"\\nTest 5: Exception in for-in iterable\");\ntry {\n    fn bad_iterable() {\n        throw \"error evaluating iterable\";\n    }\n    for (let val in bad_iterable()) {\n        print(\"Should not reach here\");\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\n// Test: Exception in for-in body\nprint(\"\\nTest 6: Exception in for-in body\");\ntry {\n    let arr = [1, 2, 3, 4, 5];\n    for (let val in arr) {\n        if (val == 3) {\n            throw \"error at val=3\";\n        }\n        print(\"val = \" + typeof(val));\n    }\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n\nprint(\"\\nAll tests completed\");\n```", "category": "tests/exceptions", "source": "tests/exceptions/loop_exception_leak.hml"}
{"instruction": "How does logger.log(level, message, data?) work in Hemlock?", "output": "```hemlock\nimport { DEBUG } from \"@stdlib/logging\";\n\nlet severity = DEBUG;\nlogger.log(severity, \"Custom level logging\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Write a Hemlock program that test tar archive creation (TarWriter) Note: TarReader has known issues with closure capture in Hemlock.", "output": "```hemlock\n// Test tar archive creation (TarWriter)\n// Note: TarReader has known issues with closure capture in Hemlock\nimport { TarWriter } from \"@stdlib/compression\";\n\n// Create a tar archive\nlet writer = TarWriter();\n\n// Add a directory\nwriter.add_directory(\"myproject\");\n\n// Add some files\nwriter.add_file(\"myproject/README.md\", \"# My Project\\n\\nThis is a test project.\");\nwriter.add_file(\"myproject/main.hml\", \"print(\\\"Hello, World!\\\");\");\nwriter.add_file(\"myproject/data.txt\", \"Some data content here.\");\n\n// Verify entry count\nprint(writer.count() == 4);  // true (1 dir + 3 files)\n\n// Build the archive\nlet tar_data = writer.build();\n\n// Verify output is valid tar (not empty)\nprint(tar_data.length > 0);  // true\n\n// Verify ustar magic bytes (offset 257-262)\nprint(tar_data[257] == 117);  // 'u'\nprint(tar_data[258] == 115);  // 's'\nprint(tar_data[259] == 116);  // 't'\nprint(tar_data[260] == 97);   // 'a'\nprint(tar_data[261] == 114);  // 'r'\n\nprint(\"Tar archive tests passed!\");\n```", "category": "tests/stdlib_compression", "source": "tests/stdlib_compression/tar_test.hml"}
{"instruction": "How does common errors work in Hemlock?", "output": "Reading from write-only file:*\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// Error: Cannot read from file 'output.txt' opened in write-only mode\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Create a Hemlock program that test that function parameters properly shadow global variables This is a regression test for a bug where parameters with the same name as global variables would incorrectly modify the global instead of creating a local binding.", "output": "```hemlock\n// Test that function parameters properly shadow global variables\n// This is a regression test for a bug where parameters with the same name\n// as global variables would incorrectly modify the global instead of\n// creating a local binding\n\nfn fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\n// Global variable named 'n' - same as parameter\nlet n = 10;\n\n// fib should work correctly without modifying global n\nprint(fib(n));  // Should print 55\n\n// Global n should be unchanged\nprint(n);  // Should still be 10\n\n// Also test with explicit different values (using smaller n to avoid timeout)\nlet x = 20;\nprint(fib(x));  // Should be 6765 (fib(20))\nprint(x);  // x should still be 20\n\n// Test that assignment inside function works with shadowed param\nfn modify_n(n) {\n    n = n + 1;\n    return n;\n}\n\nlet result = modify_n(5);\nprint(result);  // Should be 6\nprint(n);  // Global n should still be 10\n\nprint(\"PASS\");\n```", "category": "tests/functions", "source": "tests/functions/param_shadowing.hml"}
{"instruction": "Show an example of example: string validation in Hemlock.", "output": "```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does generate_iv(): buffer work in Hemlock?", "output": "Generate a secure 128-bit (16-byte) initialization vector (IV).\n\n```hemlock\nimport { generate_iv } from \"@stdlib/crypto\";\n\nlet iv = generate_iv();\nprint(iv.length);  // 16 bytes\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "Write a Hemlock program that array test.", "output": "```hemlock\n// Array test\nlet arr = [1, 2, 3, 4, 5];\narr.push(6);\nlet x = arr.pop();\nprint(\"Array length: \" + typeof(arr.length));\n```", "category": "tests/manual", "source": "tests/manual/valgrind_test_arrays.hml"}
{"instruction": "How does basic if/else work in Hemlock?", "output": "```hemlock\nif (x > 10) {\n    print(\"large\");\n} else {\n    print(\"small\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "contains(needle)* - Check if string contains substring:\n\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "1. Long-running services:*\n\n```hemlock\n// Bad\nlet r = exec(\"nginx\");  // Blocks forever\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does async_exists work in Hemlock?", "output": "```hemlock\nasync_exists(path: string): Future<bool>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\n// Import specific functions\nimport { compress, decompress, gzip, gunzip } from \"@stdlib/compression\";\nimport { TarWriter, TarReader } from \"@stdlib/compression\";\n\n// Import all\nimport * as compression from \"@stdlib/compression\";\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "Write Hemlock code that hash functions test.", "output": "```hemlock\n// Hash functions test\nimport { sha256, sha512, md5 } from \"@stdlib/hash\";\n\n// SHA256\nprint(sha256(\"hello\"));\nprint(sha256(\"\"));\nprint(sha256(\"The quick brown fox\"));\n\n// SHA512\nprint(sha512(\"hello\").slice(0, 32));  // First 32 chars to keep output manageable\n\n// MD5\nprint(md5(\"hello\"));\nprint(md5(\"\"));\n```", "category": "tests/parity", "source": "tests/parity/modules/stdlib_hash.hml"}
{"instruction": "How does panic vs throw work in Hemlock?", "output": "```hemlock\n// throw - Recoverable error (can be caught)\ntry {\n    throw \"recoverable error\";\n} catch (e) {\n    print(\"Caught: \" + e);  // ‚úÖ Caught successfully\n}\n\n// panic - Unrecoverable error (cannot be caught)\ntry {\n    panic(\"unrecoverable error\");  // ‚ùå Program exits immediately\n} catch (e) {\n    print(\"This never runs\");       // ‚ùå Never executes\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does async functions work in Hemlock?", "output": "```hemlock\nasync fn function_name(params): return_type {\n    // body\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does rate limiting work in Hemlock?", "output": "```hemlock\nimport { sleep } from \"@stdlib/time\";\n\nfn rate_limited_task(): null {\n    let i = 0;\n    while (i < 10) {\n        print(\"Processing item \" + typeof(i));\n        // Process item...\n\n        // Wait 100ms between items (max 10 items/second)\n        sleep(0.1);\n        i = i + 1;\n    }\n    return null;\n}\n\nrate_limited_task();\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does planned features work in Hemlock?", "output": "```hemlock\n// Future: Type annotations for FFI\n@ffi(\"libm.so\")\nfn sqrt(x: f64): f64;\n\nlet result = sqrt(16.0);  // Type-checked\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Provide a Hemlock example of makes HTTP requests.", "output": "```hemlock\n// HTTP Client Example\n// Demonstrates @stdlib/http (uses libwebsockets)\n\nimport * as http from \"@stdlib/http\";\n\nprint(\"=== Hemlock HTTP Client Examples ===\");\nprint(\"\");\n\n// Example 1: Simple GET request\nprint(\"1. Simple GET request to example.com\");\nprint(\"----------------------------------------\");\n\ntry {\n    let response = http.get(\"http://example.com\", []);\n\n    print(\"Status: \" + typeof(response.status_code));\n    print(\"Success: \" + typeof(http.is_success(response.status_code)));\n    print(\"Body length: \" + typeof(response.body.length) + \" bytes\");\n    print(\"\");\n\n    if (http.is_success(response.status_code)) {\n        print(\"‚úì GET request successful!\");\n    } else {\n        print(\"‚úó GET request failed\");\n    }\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\n\n// Example 2: Fetch (simpler API)\nprint(\"2. Fetch URL directly\");\nprint(\"----------------------------------------\");\n\ntry {\n    let html = http.fetch(\"http://example.com\");\n    print(\"Fetched \" + typeof(html.length) + \" bytes\");\n    print(\"First 100 chars:\");\n    print(html.substr(0, 100) + \"...\");\n    print(\"\");\n    print(\"‚úì Fetch successful!\");\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\n\n// Example 3: JSON API (httpbin.org)\nprint(\"3. POST JSON to API\");\nprint(\"----------------------------------------\");\n\ntry {\n    let user_data = {\n        name: \"Hemlock User\",\n        age: 42,\n        lang: \"hemlock\"\n    };\n\n    print(\"Sending JSON:\");\n    print(user_data.serialize());\n    print(\"\");\n\n    let post_response = http.post_json(\"http://httpbin.org/post\", user_data);\n\n    if (http.is_success(post_response.status_code)) {\n        print(\"‚úì POST successful!\");\n        print(\"Response body:\");\n        print(post_response.body.substr(0, 200) + \"...\");\n    } else {\n        print(\"‚úó POST failed: \" + typeof(post_response.status_code));\n    }\n} catch (e) {\n    print(\"ERROR: \" + e);\n}\n\nprint(\"\");\nprint(\"=== All Examples Complete ===\");\n```", "category": "examples", "source": "examples/http_client.hml"}
{"instruction": "How does safe execution pattern work in Hemlock?", "output": "```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warning: Command failed with code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Error executing command: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "char_at(index)* - Get Unicode codepoint at index (returns rune):\n\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h' (rune)\n\n// UTF-8 example\nlet emoji = \"üöÄ\";\nlet rocket = emoji.char_at(0);  // Returns rune U+1F680\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does memory management work in Hemlock?", "output": "Hemlock uses manual memory management:\n\n```hemlock\n// Safe buffer (recommended)\nlet buf = buffer(64);   // Allocate 64 bytes\nbuf[0] = 65;            // Set first byte to 'A'\nprint(buf[0]);          // 65\nfree(buf);              // Free memory\n\n// Raw pointer (advanced)\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // Fill with zeros\nfree(ptr);\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does environment variables work in Hemlock?", "output": "```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "May return less than size bytes\n\n```hemlock\nlet data = stream.read(1024);\nprint(\"Received \" + typeof(data.length) + \" bytes\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How do you call C functions from Hemlock using FFI?", "output": "Use ffi_open, ffi_bind, and ffi_close:\n\n```hemlock\n// Open shared library\nlet lib = ffi_open(\"libc.so.6\");\n\n// Bind function: name, arg types, return type\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\n\n// Call the function\nputs(\"Hello from C!\");\n\n// Clean up\nffi_close(lib);\n```\n\nFFI types: FFI_INT, FFI_DOUBLE, FFI_POINTER, FFI_STRING, FFI_VOID, etc.", "category": "concepts/ffi", "source": "CLAUDE.md"}
{"instruction": "How does asyncappendfile work in Hemlock?", "output": "```hemlock\nasync_append_file(path: string, content: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does when to use panic work in Hemlock?", "output": "```hemlock\n// Unreachable code\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"invalid state: \" + typeof(state));  // Should never happen\n    }\n}\n\n// Critical resource check\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json not found - cannot start\");\n    }\n    // ...\n}\n\n// Data structure invariant\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() called on empty stack\");\n    }\n    return stack.pop();\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does compress(data, level?) -> buffer work in Hemlock?", "output": "```hemlock\nimport { compress, decompress } from \"@stdlib/compression\";\n\nlet original = \"Hello, World! This is a test string to compress.\";\nlet compressed = compress(original);\nprint(\"Compressed size: \" + typeof(compressed.length));\n\nlet restored = decompress(compressed);\nprint(restored);  // \"Hello, World! This is a test string to compress.\"\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does parallel map work in Hemlock?", "output": "```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // Spawn workers\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // Send data\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // Collect results\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // Wait for workers\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does testing type system work in Hemlock?", "output": "Example: tests/conversions/promotion.hml*\n\n```hemlock\n// Test type promotion in binary operations\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Expect: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Expect: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Expect: i32\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Show me Hemlock code that this proves tasks actually run in parallel.", "output": "```hemlock\n// Test: True concurrency stress test\n// This proves tasks actually run in parallel\n\nasync fn slow_compute(id: i32, iterations: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < iterations) {\n        sum = sum + id;\n        i = i + 1;\n    }\n    return sum;\n}\n\nprint(\"Spawning 10 concurrent tasks...\");\n\nlet handles = [];\nlet i = 0;\nwhile (i < 10) {\n    handles.push(spawn(slow_compute, i, 1000000));\n    i = i + 1;\n}\n\nprint(\"All tasks spawned! Waiting for completion...\");\n\ni = 0;\nlet result = 0;\nwhile (i < handles.length) {\n    result = join(handles[i]);\n    print(\"Task \" + typeof(i) + \" result: \" + typeof(result));\n    i = i + 1;\n}\n\nprint(\"All tasks completed!\");\n```", "category": "tests/async", "source": "tests/async/test_concurrency_stress.hml"}
{"instruction": "How does append_file(path, content) work in Hemlock?", "output": "Throws:* Exception if file cannot be written\n\n```hemlock\nimport { append_file } from \"@stdlib/fs\";\n\ntry {\n    append_file(\"log.txt\", \"New log entry\\n\");\n    append_file(\"log.txt\", \"Another entry\\n\");\n    print(\"Log entries appended\");\n} catch (e) {\n    print(\"Error appending to file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Write a Hemlock program that test string builtin functions.", "output": "```hemlock\n// Test string builtin functions\n\n// Length - basic ASCII (emoji length differs between interpreter and compiler)\nprint(\"hello\".length);\nprint(\"\".length);\n\n// Character access\nprint(\"hello\".char_at(0));\nprint(\"hello\".char_at(4));\n\n// Byte access\nprint(\"hello\".byte_at(0));\nprint(\"hello\".byte_at(4));\n\n// Chars iteration\nlet chars = \"abc\".chars();\nprint(chars[0]);\nprint(chars[1]);\nprint(chars[2]);\nprint(chars.length);\n\n// Bytes\nlet bytes = \"Hi\".bytes();\nprint(bytes[0]);\nprint(bytes[1]);\nprint(bytes.length);\n\n// to_bytes\nlet b = \"AB\".to_bytes();\nprint(b[0]);\nprint(b[1]);\n\n// String concatenation\nlet a = \"Hello\";\nlet b2 = \" World\";\nprint(a + b2);\n\n// String with numbers\nlet num = 42;\nprint(\"Value: \" + num);\n\n// Template string\nlet name = \"Alice\";\nprint(`Hello ${name}!`);\n\n// Nested template\nlet x = 5;\nlet y = 3;\nprint(`${x} + ${y} = ${x + y}`);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/string_builtins.hml"}
{"instruction": "Show me Hemlock code that test += operator.", "output": "```hemlock\n// Test += operator\nlet x = 10;\nprint(x);\nx += 5;\nprint(x);\nx += 10;\nprint(x);\n\n// Test -= operator\nlet y = 100;\nprint(y);\ny -= 30;\nprint(y);\ny -= 20;\nprint(y);\n\n// Test *= operator\nlet z = 5;\nprint(z);\nz *= 3;\nprint(z);\nz *= 2;\nprint(z);\n\n// Test /= operator\nlet w = 100;\nprint(w);\nw /= 4;\nprint(w);\nw /= 5;\nprint(w);\n\n// Test with expressions\nlet a = 10;\na += 2 + 3;\nprint(a);\n\nlet b = 50;\nb -= 5 * 2;\nprint(b);\n\n// Test with different types\nlet f = 10.5;\nprint(f);\nf += 2.5;\nprint(f);\nf *= 2.0;\nprint(f);\n```", "category": "tests/variables", "source": "tests/variables/compound_assign.hml"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "Bitwise XOR (^)*\n\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does parallel_map work in Hemlock?", "output": "```hemlock\nimport { parallel_map } from \"@stdlib/async\";\n\nfn expensive_compute(n) {\n    // Simulate expensive operation\n    let result = 0;\n    let i = 0;\n    while (i < 1000000) {\n        result = result + n;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet data = [1, 2, 3, 4, 5, 6, 7, 8];\nlet results = parallel_map(data, expensive_compute, 4);\nprint(results);  // [1000000, 2000000, 3000000, ...]\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does boolean flags work in Hemlock?", "output": "```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Create a Hemlock program that test compound assignment on arrays.", "output": "```hemlock\n// Test compound assignment on arrays\nlet arr = [10, 20, 30, 40, 50];\nprint(arr[0]);\narr[0] += 5;\nprint(arr[0]);\n\nprint(arr[2]);\narr[2] *= 2;\nprint(arr[2]);\n\nprint(arr[4]);\narr[4] -= 10;\nprint(arr[4]);\n\n// Test compound assignment on nested arrays\nlet nested = [[1, 2], [3, 4], [5, 6]];\nprint(nested[1][0]);\nnested[1][0] += 10;\nprint(nested[1][0]);\n\n// Test compound assignment on objects\nlet obj = { x: 10, y: 20, z: 30 };\nprint(obj.x);\nobj.x += 5;\nprint(obj.x);\n\nprint(obj.y);\nobj.y *= 3;\nprint(obj.y);\n\nprint(obj.z);\nobj.z /= 2;\nprint(obj.z);\n\n// Test compound assignment on nested objects\nlet person = {\n    name: \"Alice\",\n    stats: { health: 100, mana: 50 }\n};\nprint(person.stats.health);\nperson.stats.health -= 25;\nprint(person.stats.health);\n\nprint(person.stats.mana);\nperson.stats.mana += 10;\nprint(person.stats.mana);\n\n// Test with variable indices\nlet i = 1;\nlet nums = [5, 10, 15];\nprint(nums[i]);\nnums[i] += 20;\nprint(nums[i]);\n\n// Test with expressions\nlet data = [100, 200, 300];\ndata[1 + 1] -= 50;\nprint(data[2]);\n\n// Test chained property access\nlet config = {\n    settings: {\n        volume: 75\n    }\n};\nprint(config.settings.volume);\nconfig.settings.volume += 25;\nprint(config.settings.volume);\n```", "category": "tests/variables", "source": "tests/variables/compound_assign_complex.hml"}
{"instruction": "How does pattern: error recovery work in Hemlock?", "output": "Provide fallback on error:\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division by zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Error: \" + e);\n        return null;  // Fallback value\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does arithmetic operators work in Hemlock?", "output": "```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - Addition\nprint(a - b);   // 7  - Subtraction\nprint(a * b);   // 30 - Multiplication\nprint(a / b);   // 3  - Division (integer)\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Write Hemlock code that basic string matching.", "output": "```hemlock\n// Test: Basic regex pattern matching\nimport { test, matches, find } from \"@stdlib/regex\";\n\n// Basic string matching\nprint(test(\"hello\", \"hello world\", null));         // true\nprint(test(\"hello\", \"goodbye world\", null));       // false\n\n// Anchors\nprint(test(\"^hello\", \"hello world\", null));        // true\nprint(test(\"^hello\", \"say hello\", null));          // false\nprint(test(\"world$\", \"hello world\", null));        // true\nprint(test(\"world$\", \"world hello\", null));        // false\n\n// Test aliases\nprint(matches(\"test\", \"testing\", null));           // true\nprint(find(\"error\", \"This is an error\", null));    // true\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/basic_test.hml"}
{"instruction": "How does type safety work in Hemlock?", "output": "```hemlock\n// Be explicit about types\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Write a Hemlock program that test read_file() and write_file() functions.", "output": "```hemlock\n// Test read_file() and write_file() functions\nimport { read_file, write_file, remove_file } from \"@stdlib/fs\";\n\nlet test_file = \"/tmp/test_read_write.txt\";\nlet content = \"Hello, World!\\nThis is a test.\";\n\n// Write to file\nwrite_file(test_file, content);\n\n// Read from file\nlet read_content = read_file(test_file);\n\n// Verify content matches\nassert(read_content == content, \"read_file() should return the same content as written\");\n\n// Clean up\nremove_file(test_file);\n\nprint(\"All read_file() and write_file() tests passed!\");\n```", "category": "tests/io", "source": "tests/io/read_write_file.hml"}
{"instruction": "How does pattern: multiple error types work in Hemlock?", "output": "Use error objects to distinguish error types:\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Data is null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Expected array\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array is empty\" };\n    }\n\n    // ... process\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"No data provided\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Wrong data type: \" + e.message);\n    } else {\n        print(\"Error: \" + e.message);\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does pitfall: self in non-method calls work in Hemlock?", "output": "```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// Works: Called as method\nprint(obj.method());  // 10\n\n// ERROR: Called as function\nlet f = obj.method;\nprint(f());  // ERROR: self is not defined\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does maybe add (under discussion) work in Hemlock?", "output": "3. Error types (Result<T, E>)*\n\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"division by zero\");\n    }\n    return Ok(a / b);\n}\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does ‚ùå don't add implicit behavior work in Hemlock?", "output": "```hemlock\n// BAD: Automatic semicolon insertion\nlet x = 5\nlet y = 10\n\n// BAD: Automatic memory management\nlet s = \"hello\"  // String auto-freed at end of scope? NO!\n\n// BAD: Implicit type conversions that lose precision\nlet x: i32 = 3.14  // Should truncate or error?\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does path: string work in Hemlock?", "output": "The file path used to open the file.\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Write Hemlock code that test @stdlib/strings with Unicode strings.", "output": "```hemlock\n// Test @stdlib/strings with Unicode strings\nimport { reverse, pad_left, pad_right, center } from \"@stdlib/strings\";\n\nprint(\"Testing Unicode support...\");\n\n// Reverse with emojis\nprint(reverse(\"Hello üåç\") == \"üåç olleH\");\nprint(reverse(\"üöÄüåüüí´\") == \"üí´üåüüöÄ\");\n\n// Reverse with CJK characters\nprint(reverse(\"‰Ω†Â•Ω\") == \"Â•Ω‰Ω†\");\nprint(reverse(\"„Åì„Çì„Å´„Å°„ÅØ\") == \"„ÅØ„Å°„Å´„Çì„Åì\");\n\n// Padding with Unicode\nlet s1 = pad_left(\"test\", 10, \"‚ñà\");\nprint(s1 == \"‚ñà‚ñà‚ñà‚ñà‚ñà‚ñàtest\");\nprint(s1.length == 10);\n\nlet s2 = pad_right(\"test\", 10, \"‚ñë\");\nprint(s2 == \"test‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë\");\nprint(s2.length == 10);\n\n// Centering with Unicode\nlet s3 = center(\"‰∏≠\", 5, \"‚îÄ\");\nprint(s3 == \"‚îÄ‚îÄ‰∏≠‚îÄ‚îÄ\");\nprint(s3.length == 5);\n\n// Mixed Unicode and ASCII\nlet s4 = reverse(\"HelloüöÄWorld\");\nprint(s4 == \"dlroWüöÄolleH\");\n\nprint(\"All Unicode tests passed!\");\n```", "category": "tests/stdlib_strings", "source": "tests/stdlib_strings/test_unicode.hml"}
{"instruction": "How does integer ‚Üî rune work in Hemlock?", "output": "Convert between integers and runes to work with codepoint values:\n\n```hemlock\n// Integer to rune (codepoint value)\nlet code: rune = 65;            // 'A' (ASCII 65)\nlet emoji_code: rune = 128640;  // U+1F680 (üöÄ)\n\n// Rune to integer (get codepoint value)\nlet r = 'Z';\nlet value: i32 = r;             // 90 (ASCII value)\n\nlet rocket = 'üöÄ';\nlet code: i32 = rocket;         // 128640 (U+1F680)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does .length work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"üöÄ\";\nprint(emoji.length);    // 1 (one codepoint)\n\nlet text = \"Hello üåç!\";\nprint(text.length);     // 8 (7 ASCII + 1 emoji)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does safe pattern work in Hemlock?", "output": "```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... process content ...\n} catch (e) {\n    print(\"Error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Write a Hemlock program that test terminal spinner.", "output": "```hemlock\n// Test terminal spinner\nimport {\n    Spinner, SPINNER_DOTS, SPINNER_LINE, SPINNER_ARROW,\n    SPINNER_BOUNCE, SPINNER_CLOCK\n} from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nprint(\"=== Terminal Spinner Tests ===\");\nprint(\"\");\n\n// Test basic spinner creation\nprint(\"Testing basic spinner:\");\nlet spinner1 = Spinner();\nlet i = 0;\nwhile (i < 8) {\n    spinner1.spin();\n    sleep(0.1);\n    i = i + 1;\n}\nspinner1.finish(\"‚úì Basic spinner works\");\n\nprint(\"\");\n\n// Test SPINNER_DOTS\nprint(\"Testing SPINNER_DOTS:\");\nlet dots = SPINNER_DOTS();\nif (dots.length == 10) {\n    print(\"‚úì SPINNER_DOTS has 10 frames\");\n}\nlet spinner2 = Spinner(dots);\ni = 0;\nwhile (i < 10) {\n    spinner2.spin();\n    sleep(0.05);\n    i = i + 1;\n}\nspinner2.finish(\"‚úì Dots spinner works\");\n\nprint(\"\");\n\n// Test SPINNER_LINE\nprint(\"Testing SPINNER_LINE:\");\nlet line = SPINNER_LINE();\nif (line.length == 4) {\n    print(\"‚úì SPINNER_LINE has 4 frames\");\n}\nlet spinner3 = Spinner(line);\ni = 0;\nwhile (i < 8) {\n    spinner3.spin();\n    sleep(0.1);\n    i = i + 1;\n}\nspinner3.finish(\"‚úì Line spinner works\");\n\nprint(\"\");\n\n// Test SPINNER_ARROW\nprint(\"Testing SPINNER_ARROW:\");\nlet arrow = SPINNER_ARROW();\nif (arrow.length == 8) {\n    print(\"‚úì SPINNER_ARROW has 8 frames\");\n}\nlet spinner4 = Spinner(arrow);\ni = 0;\nwhile (i < 8) {\n    spinner4.spin();\n    sleep(0.1);\n    i = i + 1;\n}\nspinner4.finish(\"‚úì Arrow spinner works\");\n\nprint(\"\");\n\n// Test SPINNER_BOUNCE\nprint(\"Testing SPINNER_BOUNCE:\");\nlet bounce = SPINNER_BOUNCE();\nif (bounce.length == 4) {\n    print(\"‚úì SPINNER_BOUNCE has 4 frames\");\n}\nlet spinner5 = Spinner(bounce);\ni = 0;\nwhile (i < 8) {\n    spinner5.spin();\n    sleep(0.1);\n    i = i + 1;\n}\nspinner5.finish(\"‚úì Bounce spinner works\");\n\nprint(\"\");\n\n// Test SPINNER_CLOCK\nprint(\"Testing SPINNER_CLOCK:\");\nlet clock = SPINNER_CLOCK();\nif (clock.length == 12) {\n    print(\"‚úì SPINNER_CLOCK has 12 frames\");\n}\nlet spinner6 = Spinner(clock);\ni = 0;\nwhile (i < 12) {\n    spinner6.spin();\n    sleep(0.05);\n    i = i + 1;\n}\nspinner6.finish(\"‚úì Clock spinner works\");\n\nprint(\"\");\nprint(\"‚úì All spinner tests completed\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/test_spinner.hml"}
{"instruction": "How does raise work in Hemlock?", "output": "```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "Show me Hemlock code that test non-cryptographic hash functions.", "output": "```hemlock\n// Test non-cryptographic hash functions\n\nimport { djb2, fnv1a, murmur3 } from \"@stdlib/hash\";\n\n// ========== DJB2 TESTS ==========\n\n// Test basic djb2 hash\nlet h1 = djb2(\"hello\");\nassert(typeof(h1) == \"u32\", \"djb2 should return u32\");\n\n// Test empty string\nlet h2 = djb2(\"\");\nassert(typeof(h2) == \"u32\", \"djb2 should handle empty string\");\nlet expected_djb2: u32 = 5381;\nassert(h2 == expected_djb2, \"djb2 of empty string should be 5381 (initial value)\");\n\n// Test deterministic (same input = same output)\nlet h3a = djb2(\"test\");\nlet h3b = djb2(\"test\");\nassert(h3a == h3b, \"djb2 should be deterministic\");\n\n// Test different inputs produce different hashes (usually)\nlet h4a = djb2(\"hello\");\nlet h4b = djb2(\"world\");\nassert(h4a != h4b, \"djb2 should produce different hashes for different inputs\");\n\n// Test UTF-8 strings\nlet h5 = djb2(\"Hello üåç\");\nassert(typeof(h5) == \"u32\", \"djb2 should handle UTF-8\");\n\n// Test longer strings\nlet h6 = djb2(\"The quick brown fox jumps over the lazy dog\");\nassert(typeof(h6) == \"u32\", \"djb2 should handle long strings\");\n\n// ========== FNV-1a TESTS ==========\n\n// Test basic fnv1a hash\nlet f1 = fnv1a(\"hello\");\nassert(typeof(f1) == \"u32\", \"fnv1a should return u32\");\n\n// Test empty string\nlet f2 = fnv1a(\"\");\nassert(typeof(f2) == \"u32\", \"fnv1a should handle empty string\");\nlet FNV_OFFSET_BASIS: u32 = 2166136261;\nassert(f2 == FNV_OFFSET_BASIS, \"fnv1a of empty string should be FNV offset basis\");\n\n// Test deterministic\nlet f3a = fnv1a(\"test\");\nlet f3b = fnv1a(\"test\");\nassert(f3a == f3b, \"fnv1a should be deterministic\");\n\n// Test different inputs\nlet f4a = fnv1a(\"hello\");\nlet f4b = fnv1a(\"world\");\nassert(f4a != f4b, \"fnv1a should produce different hashes for different inputs\");\n\n// Test UTF-8 strings\nlet f5 = fnv1a(\"Hello üöÄ\");\nassert(typeof(f5) == \"u32\", \"fnv1a should handle UTF-8\");\n\n// Test that djb2 and fnv1a produce different results\nlet d = djb2(\"collision test\");\nlet f = fnv1a(\"collision test\");\nassert(d != f, \"djb2 and fnv1a should produce different hashes\");\n\n// ========== MURMUR3 TESTS ==========\n\n// Test basic murmur3 hash (default seed = 0)\nlet m1 = murmur3(\"hello\");\nassert(typeof(m1) == \"u32\", \"murmur3 should return u32\");\n\n// Test with explicit seed\nlet m2a = murmur3(\"test\", 0);\nlet m2b = murmur3(\"test\", 42);\nassert(m2a != m2b, \"murmur3 should produce different hashes with different seeds\");\n\n// Test deterministic with same seed\nlet m3a = murmur3(\"data\", 123);\nlet m3b = murmur3(\"data\", 123);\nassert(m3a == m3b, \"murmur3 should be deterministic with same seed\");\n\n// Test empty string\nlet m4 = murmur3(\"\");\nassert(typeof(m4) == \"u32\", \"murmur3 should handle empty string\");\n\n// Test different inputs\nlet m5a = murmur3(\"hello\");\nlet m5b = murmur3(\"world\");\nassert(m5a != m5b, \"murmur3 should produce different hashes for different inputs\");\n\n// Test UTF-8 strings\nlet m6 = murmur3(\"Hello ‰∏ñÁïå\");\nassert(typeof(m6) == \"u32\", \"murmur3 should handle UTF-8\");\n\n// Test longer strings (multiple 4-byte chunks)\nlet m7 = murmur3(\"The quick brown fox jumps over the lazy dog\");\nassert(typeof(m7) == \"u32\", \"murmur3 should handle long strings\");\n\n// Test strings of various lengths (to test remainder processing)\nlet m8a = murmur3(\"a\");      // 1 byte\nlet m8b = murmur3(\"ab\");     // 2 bytes\nlet m8c = murmur3(\"abc\");    // 3 bytes\nlet m8d = murmur3(\"abcd\");   // 4 bytes (exactly one chunk)\nlet m8e = murmur3(\"abcde\");  // 5 bytes (one chunk + 1 byte)\nassert(m8a != m8b, \"murmur3 should handle 1-byte strings\");\nassert(m8b != m8c, \"murmur3 should handle 2-byte strings\");\nassert(m8c != m8d, \"murmur3 should handle 3-byte strings\");\nassert(m8d != m8e, \"murmur3 should handle 5-byte strings\");\n\n// Test that all three algorithms produce different results\nlet input = \"hash comparison test\";\nlet djb2_hash = djb2(input);\nlet fnv1a_hash = fnv1a(input);\nlet murmur3_hash = murmur3(input);\nassert(djb2_hash != fnv1a_hash, \"djb2 and fnv1a should differ\");\nassert(djb2_hash != murmur3_hash, \"djb2 and murmur3 should differ\");\nassert(fnv1a_hash != murmur3_hash, \"fnv1a and murmur3 should differ\");\n\nprint(\"All non-crypto hash tests passed!\");\n```", "category": "tests/stdlib_hash", "source": "tests/stdlib_hash/test_non_crypto.hml"}
{"instruction": "Write a Hemlock program that test @stdlib/strings character type checking functions.", "output": "```hemlock\n// Test @stdlib/strings character type checking functions\nimport { is_alpha, is_digit, is_alnum, is_whitespace } from \"@stdlib/strings\";\n\nprint(\"Testing is_alpha...\");\n\n// Alphabetic strings\nprint(is_alpha(\"hello\") == true);\nprint(is_alpha(\"HELLO\") == true);\nprint(is_alpha(\"HelloWorld\") == true);\nprint(is_alpha(\"abc\") == true);\nprint(is_alpha(\"XYZ\") == true);\n\n// Non-alphabetic\nprint(is_alpha(\"hello123\") == false);\nprint(is_alpha(\"hello world\") == false);  // Space\nprint(is_alpha(\"hello!\") == false);\nprint(is_alpha(\"123\") == false);\nprint(is_alpha(\"\") == false);  // Empty string\n\nprint(\"Testing is_digit...\");\n\n// Digit strings\nprint(is_digit(\"123\") == true);\nprint(is_digit(\"0\") == true);\nprint(is_digit(\"999\") == true);\nprint(is_digit(\"42\") == true);\n\n// Non-digit\nprint(is_digit(\"123a\") == false);\nprint(is_digit(\"12.3\") == false);\nprint(is_digit(\"1 2 3\") == false);\nprint(is_digit(\"hello\") == false);\nprint(is_digit(\"\") == false);\n\nprint(\"Testing is_alnum...\");\n\n// Alphanumeric strings\nprint(is_alnum(\"hello123\") == true);\nprint(is_alnum(\"ABC123\") == true);\nprint(is_alnum(\"test\") == true);\nprint(is_alnum(\"123\") == true);\nprint(is_alnum(\"a1b2c3\") == true);\n\n// Non-alphanumeric\nprint(is_alnum(\"hello world\") == false);  // Space\nprint(is_alnum(\"test!\") == false);\nprint(is_alnum(\"a-b\") == false);\nprint(is_alnum(\"\") == false);\n\nprint(\"Testing is_whitespace...\");\n\n// Whitespace strings\nprint(is_whitespace(\" \") == true);\nprint(is_whitespace(\"   \") == true);\nprint(is_whitespace(\"\\t\") == true);\nprint(is_whitespace(\"\\n\") == true);\nprint(is_whitespace(\"\\r\") == true);\nprint(is_whitespace(\" \\t\\n\\r \") == true);\n\n// Non-whitespace\nprint(is_whitespace(\"hello\") == false);\nprint(is_whitespace(\" a \") == false);\nprint(is_whitespace(\"\") == false);\n\nprint(\"All character type tests passed!\");\n```", "category": "tests/stdlib_strings", "source": "tests/stdlib_strings/test_char_type.hml"}
{"instruction": "How does import statements work in Hemlock?", "output": "```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does type promotion work in Hemlock?", "output": "When mixing types, Hemlock promotes to the larger/more precise type:\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result is f64 (10.0 + 3.5 = 13.5)\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does printing work in Hemlock?", "output": "How runes are displayed depends on the codepoint:\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (quoted, printable ASCII)\n\nlet emoji = 'üöÄ';\nprint(emoji);                   // U+1F680 (Unicode notation for non-ASCII)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (non-printable as hex)\n\nlet space = ' ';\nprint(space);                   // ' ' (printable)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Show me Hemlock code that tests index read.", "output": "```hemlock\nlet b = buffer(10);\nb[0] = 65;\nb[1] = 66;\nb[2] = 67;\nprint(b[0]);\nprint(b[1]);\nprint(b[2]);\nfree(b);\n```", "category": "tests/buffers", "source": "tests/buffers/index_read.hml"}
{"instruction": "How does configure from environment work in Hemlock?", "output": "```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet log_level = INFO;\nlet env_level = getenv(\"LOG_LEVEL\");\nif (env_level == \"DEBUG\") {\n    log_level = DEBUG;\n}\n\nlet logger = Logger({ level: log_level });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does float literal inference work in Hemlock?", "output": "```hemlock\nlet x = 3.14;        // f64 (default)\nlet y: f32 = 3.14;   // f32 (explicit)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does testing error cases work in Hemlock?", "output": "Example: tests/primitives/range_error.hml*\n\n```hemlock\n// This should fail with a type error\nlet x: u8 = 256;  // Out of range for u8\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Implement a Hemlock program that should not cause stack overflow when freed.", "output": "```hemlock\n// Test: Mutual references - two objects point to each other\n// Should not cause stack overflow when freed\n\nlet obj1 = { name: \"obj1\" };\nlet obj2 = { name: \"obj2\" };\n\nobj1.other = obj2;\nobj2.other = obj1;\n\n// Free obj1 - this will recursively free obj2 as well (without stack overflow!)\n// Note: Don't free obj2 separately as it's already freed via obj1\nfree(obj1);\n\nprint(\"PASS: Mutual references handled correctly\");\n```", "category": "tests/circular_refs", "source": "tests/circular_refs/test_mutual_reference.hml"}
{"instruction": "How does check if process exists work in Hemlock?", "output": "```hemlock\nfn process_exists(pid: i32) {\n    try {\n        kill(pid, 0);  // Signal 0 doesn't actually send a signal\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\nif (process_exists(1234)) {\n    print(\"Process 1234 is running\");\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does pointer arithmetic work in Hemlock?", "output": "Allowed but dangerous:*\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation boundary\n*q = 42;          // UNDEFINED: Out of bounds write\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does object type work in Hemlock?", "output": "```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Add field dynamically\nperson.email = \"alice@example.com\";\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "Read and write mode:*\n\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // Existing file, can read/write\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Write a Hemlock program that tests panic message error.", "output": "```hemlock\n// Test: panic() with custom message\nprint(\"before panic\");\npanic(\"something went wrong\");\nprint(\"after panic\");  // Should never execute\n```", "category": "tests/exceptions", "source": "tests/exceptions/panic_message_error.hml"}
{"instruction": "Implement a Hemlock program that test array indexing (write).", "output": "```hemlock\n// Test array indexing (write)\nlet arr = [1, 2, 3, 4, 5];\narr[2] = 99;\nprint(arr);\n```", "category": "tests/arrays", "source": "tests/arrays/index_write.hml"}
{"instruction": "How does test organization work in Hemlock?", "output": "Group related tests:*\n\n```hemlock\ndescribe(\"String methods\", fn() {\n    describe(\"substr()\", fn() {\n        test(\"extracts substring\", fn() { ... });\n        test(\"handles out of bounds\", fn() { ... });\n    });\n\n    describe(\"split()\", fn() {\n        test(\"splits on delimiter\", fn() { ... });\n        test(\"returns single element for no matches\", fn() { ... });\n    });\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does regex object work in Hemlock?", "output": "```hemlock\nlet pattern = compile(\"test\");\npattern.test(\"testing\");\npattern.free();  // Required!\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does argument validation work in Hemlock?", "output": "```hemlock\nfn validate_file(filename: string): bool {\n    // Check if file exists (example)\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Error: No filename provided\");\n} else if (!validate_file(args[1])) {\n    print(\"Error: Invalid file: \" + args[1]);\n} else {\n    print(\"Processing: \" + args[1]);\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does when you need free() vs when it's automatic work in Hemlock?", "output": "Raw pointers* - alloc() has no refcounting:\n\n```hemlock\nlet p = alloc(64);\n   // ... use p ...\n   free(p);  // Always required - will leak otherwise\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does safety tools provided work in Hemlock?", "output": "4. Runtime type checking:*\n\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // Safe to use as integer\n}\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Write Hemlock code that tests slice.", "output": "```hemlock\nlet s = \"hello world\";\nlet sub1 = s.slice(0, 5);\nprint(sub1);\n\nlet sub2 = s.slice(6, 11);\nprint(sub2);\n\nlet sub3 = s.slice(0, 0);\nprint(sub3);\n```", "category": "tests/strings", "source": "tests/strings/slice.hml"}
{"instruction": "How does pattern: input validation work in Hemlock?", "output": "```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write a Hemlock program that tests basic.", "output": "```hemlock\nlet b = buffer(100);\nprint(b);\nfree(b);\n```", "category": "tests/buffers", "source": "tests/buffers/basic.hml"}
{"instruction": "How does logger.error(message, data?) work in Hemlock?", "output": "```hemlock\nlogger.error(\"Database error\", { code: 500, message: \"Connection timeout\" });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does multiple arguments work in Hemlock?", "output": "```hemlock\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Input: \" + input_file);\n    print(\"Output: \" + output_file);\n\n    // Process files...\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does pitfall: recursion depth work in Hemlock?", "output": "```hemlock\n// Deep recursion may cause stack overflow\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // May crash with stack overflow\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does before_each(fn) work in Hemlock?", "output": "Run setup code before each test in the suite.\n\n```hemlock\ndescribe(\"Database tests\", fn() {\n    let db = null;\n\n    before_each(fn() {\n        db = create_db();\n        db.connect();\n    });\n\n    after_each(fn() {\n        db.close();\n    });\n\n    test(\"can insert record\", fn() {\n        db.insert(\"users\", { name: \"Alice\" });\n        expect(db.count(\"users\")).to_equal(1);\n    });\n\n    test(\"can query records\", fn() {\n        db.insert(\"users\", { name: \"Bob\" });\n        let users = db.query(\"users\");\n        expect(users.length).to_equal(1);\n    });\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does color_bg(text, fg, bg) work in Hemlock?", "output": "Returns:* string - Colorized text with reset\n\n```hemlock\nimport { color_bg, WHITE, RED, BG_RED, BG_GREEN } from \"@stdlib/terminal\";\n\nprint(color_bg(\" ERROR \", WHITE, BG_RED));\nprint(color_bg(\" OK \", WHITE, BG_GREEN));\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Write Hemlock code that test channel operations.", "output": "```hemlock\n// Test channel operations\n\n// Basic channel creation\nlet ch = channel(5);\nprint(typeof(ch));\n\n// Send and receive\nch.send(42);\nch.send(\"hello\");\nch.send(true);\n\nprint(ch.recv());\nprint(ch.recv());\nprint(ch.recv());\n\n// Channel with capacity\nlet bounded = channel(2);\nbounded.send(1);\nbounded.send(2);\nprint(bounded.recv());\nbounded.send(3);\nprint(bounded.recv());\nprint(bounded.recv());\n\n// Channel close\nlet closeable = channel(3);\ncloseable.send(10);\ncloseable.send(20);\ncloseable.close();\nprint(closeable.recv());\nprint(closeable.recv());\n\n// Try recv on closed empty channel\nlet result = closeable.recv();\nprint(result == null ? \"null received\" : result);\n\n// Channel with async\nasync fn producer(ch, count) {\n    for (let i = 0; i < count; i = i + 1) {\n        ch.send(i);\n    }\n    ch.close();\n}\n\nasync fn consumer(ch) {\n    let sum = 0;\n    let val = ch.recv();\n    while (val != null) {\n        sum = sum + val;\n        val = ch.recv();\n    }\n    return sum;\n}\n\nlet commCh = channel(10);\nlet prod = spawn(producer, commCh, 5);\nlet cons = spawn(consumer, commCh);\n\nawait prod;\nlet total = await cons;\nprint(total);\n\n// Multiple values\nlet multi = channel(10);\nfor (let i = 1; i <= 5; i = i + 1) {\n    multi.send(i * 10);\n}\n\nfor (let i = 0; i < 5; i = i + 1) {\n    print(multi.recv());\n}\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/channels.hml"}
{"instruction": "How does basic pattern work in Hemlock?", "output": "Always close files explicitly:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does buffertohex(buf: buffer): string work in Hemlock?", "output": "Convert buffer to hexadecimal string representation.\n\n```hemlock\nimport { buffer_to_hex } from \"@stdlib/crypto\";\n\nlet bytes = random_bytes(16);\nlet hex = buffer_to_hex(bytes);\nprint(hex);  // \"3a7f2c9e4d1b8f6a...\"\nprint(hex.length);  // 32 (2 hex chars per byte)\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does tcplistener work in Hemlock?", "output": "Throws exception on bind failure\n\n```hemlock\nlet listener = TcpListener(\"127.0.0.1\", 8080);\nlet listener2 = TcpListener(\"0.0.0.0\", 9000);  // Listen on all interfaces\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Create a Hemlock program that test that signal handler receives the signal number.", "output": "```hemlock\n// Test that signal handler receives the signal number\nlet received_sig = 0;\n\nfn handler(sig) {\n    received_sig = sig;\n}\n\n// Register handler for SIGUSR2\nsignal(SIGUSR2, handler);\n\n// Raise the signal\nraise(SIGUSR2);\n\n// Check that handler received the correct signal number\nassert(received_sig == SIGUSR2);\n\nprint(\"PASS: handler_argument\");\n```", "category": "tests/signals", "source": "tests/signals/handler_argument.hml"}
{"instruction": "Implement a Hemlock program that test buffer operations.", "output": "```hemlock\n// Test buffer operations\n\n// Create buffer\nlet buf = buffer(10);\nprint(buf.length);\n\n// Set and get values\nbuf[0] = 65;\nbuf[1] = 66;\nbuf[2] = 67;\nprint(buf[0]);\nprint(buf[1]);\nprint(buf[2]);\n\n// Modify\nbuf[0] = 100;\nprint(buf[0]);\n\n// alloc and free\nlet raw = alloc(10);\nfree(raw);\nfree(buf);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/buffers.hml"}
{"instruction": "How does string literals work in Hemlock?", "output": "```hemlock\n// Basic strings\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// With escape sequences\nlet s3 = \"Line 1\\nLine 2\\ttabbed\";\nlet s4 = \"Quote: \\\"Hello\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Unicode characters\nlet s6 = \"üöÄ Emoji\";\nlet s7 = \"‰∏≠ÊñáÂ≠óÁ¨¶\";\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does stack operations work in Hemlock?", "output": "pop()* - Remove and return last element:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // Returns 5, arr is now [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Show me Hemlock code that test math module constants.", "output": "```hemlock\n// Test math module constants\n\nimport * as math from \"@stdlib/math\";\n\n// Test PI\nassert(math.PI > 3.14 && math.PI < 3.15, \"PI should be approximately 3.14159\");\n\n// Test E\nassert(math.E > 2.71 && math.E < 2.72, \"E should be approximately 2.71828\");\n\n// Test TAU\nassert(math.TAU > 6.28 && math.TAU < 6.29, \"TAU should be approximately 6.28318\");\n\n// Test INF\nassert(math.INF > 0, \"INF should be positive\");\nassert(math.INF == math.INF, \"INF should equal itself\");\n\nprint(\"All math constant tests passed!\");\n```", "category": "tests/stdlib_math", "source": "tests/stdlib_math/test_math_constants.hml"}
{"instruction": "How does murmur3(input: string, seed?: 0): i32 work in Hemlock?", "output": "MurmurHash3 (32-bit) - excellent distribution, widely used in production systems.\n\n```hemlock\nlet h = murmur3(\"hello world\");\nprint(h);  // -862545276\n\n// With custom seed\nlet h2 = murmur3(\"hello world\", 42);\nprint(h2);  // Different hash due to different seed\n\n// Seed changes output\nassert(murmur3(\"test\", 0) != murmur3(\"test\", 1));\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does add diagnostic prints work in Hemlock?", "output": "```hemlock\nfn debug_handler(sig) {\n    print(\"Handler called for signal: \" + typeof(sig));\n    print(\"Stack: (not yet available)\");\n\n    // Your handler logic...\n}\n\nsignal(SIGINT, debug_handler);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does iteration work in Hemlock?", "output": "```hemlock\nlet items = [\"apple\", \"banana\", \"cherry\"];\n\n// For-in loop\nfor (let item in items) {\n    print(item);\n}\n\n// Manual iteration\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does writing characters work in Hemlock?", "output": "Strings are mutable - you can modify individual characters:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // Now \"Hello\"\ns[4] = '!';            // Now \"Hell!\"\n\n// With Unicode\nlet msg = \"Go!\";\nmsg[0] = 'üöÄ';         // Now \"üöÄo!\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Show me Hemlock code that basic object type definition.", "output": "```hemlock\n// Basic object type definition\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// Just test that parsing works - type checking not fully implemented yet\nprint(42);\n```", "category": "tests/objects", "source": "tests/objects/define_basic.hml"}
{"instruction": "How does sizeof work in Hemlock?", "output": "```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// Calculate array allocation size\nlet count = 100;\nlet total = sizeof(i32) * count; // 400 bytes\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does pattern: map (transform) work in Hemlock?", "output": "```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Show an example of lifecycle example in Hemlock.", "output": "```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. Create task\nlet t = spawn(work, 21);  // State: Running\n\n// Task executes on separate thread...\n\n// 2. Join task\nlet result = join(t);     // State: Completed ‚Üí Joined\nprint(result);            // 42\n\n// Task resources cleaned up after join\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does trunc(x) work in Hemlock?", "output": "Returns:* f64 - Truncated value\n\n```hemlock\nimport { trunc } from \"@stdlib/math\";\n\nlet result = trunc(3.7);   // 3.0\nlet result2 = trunc(-2.9); // -2.0\nlet result3 = trunc(5.0);  // 5.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Write a Hemlock program that basic anonymous object creation.", "output": "```hemlock\n// Basic anonymous object creation\nlet obj = { x: 10, y: 20 };\nprint(obj);\n```", "category": "tests/objects", "source": "tests/objects/anonymous_basic.hml"}
{"instruction": "How does fall-through behavior work in Hemlock?", "output": "Cases without break fall through to the next case (C-style):\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C or below\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport {\n    describe, test, expect,\n    before_each, after_each, run\n} from \"@stdlib/testing\";\nimport { exit } from \"@stdlib/env\";\n\n// Helper function to test\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\ndescribe(\"Factorial function\", fn() {\n    test(\"base case n=0\", fn() {\n        expect(factorial(0)).to_equal(1);\n    });\n\n    test(\"base case n=1\", fn() {\n        expect(factorial(1)).to_equal(1);\n    });\n\n    test(\"small values\", fn() {\n        expect(factorial(5)).to_equal(120);\n        expect(factorial(6)).to_equal(720);\n    });\n\n    test(\"returns positive numbers\", fn() {\n        expect(factorial(3)).to_be_greater_than(0);\n    });\n});\n\ndescribe(\"Array operations\", fn() {\n    let arr = null;\n\n    before_each(fn() {\n        arr = [1, 2, 3];\n    });\n\n    test(\"push adds element\", fn() {\n        arr.push(4);\n        expect(arr).to_equal([1, 2, 3, 4]);\n    });\n\n    test(\"pop removes element\", fn() {\n        let last = arr.pop();\n        expect(last).to_equal(3);\n        expect(arr.length).to_equal(2);\n    });\n\n    test(\"contains checks membership\", fn() {\n        expect(arr).to_contain(2);\n        expect(arr).not_to_contain(10);\n    });\n});\n\ndescribe(\"Error handling\", fn() {\n    test(\"division by zero throws\", fn() {\n        fn divide_by_zero() {\n            if (true) {\n                throw \"division by zero\";\n            }\n            return null;\n        }\n\n        expect(divide_by_zero).to_throw(\"division by zero\");\n    });\n\n    test(\"safe operations don't throw\", fn() {\n        expect(fn() {\n            let x = 10 + 5;\n            return x;\n        }).not_to_throw();\n    });\n});\n\n// Run all tests\nlet results = run();\n\n// Exit with appropriate code\nif (!results.success) {\n    exit(1);\n}\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "Reading an existing file:*\n\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// or simply:\nlet f = open(\"config.json\");  // \"r\" is default\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { compile, test, matches, REG_EXTENDED, REG_ICASE } from \"@stdlib/regex\";\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Create a Hemlock program that should succeed without errors.", "output": "```hemlock\n// Test: Basic TCP socket creation and configuration\n// Should succeed without errors\n\nlet sock = socket_create(AF_INET, SOCK_STREAM, 0);\n\n// Test socket properties\nprint(\"Socket created with fd: \" + typeof(sock.fd));\nprint(\"Socket closed: \" + typeof(sock.closed));\n\n// Test setting socket options\nsock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);\nprint(\"SO_REUSEADDR set\");\n\n// Close the socket\nsock.close();\nprint(\"Socket closed\");\nprint(\"Socket closed property: \" + typeof(sock.closed));\n\nprint(\"Basic TCP socket test passed\");\n```", "category": "tests/networking", "source": "tests/networking/tcp_socket_basic.hml"}
{"instruction": "How does debugging failed tests work in Hemlock?", "output": "Or add temporary print statements:\n\n```hemlock\ntest(\"complex calculation\", fn() {\n    let x = calculate_something();\n    print(\"x = \" + typeof(x));  // Debug output\n    expect(x).to_equal(expected);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does working directory changes work in Hemlock?", "output": "```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show an example of example 2: bitwise operators in Hemlock.", "output": "```hemlock\nlet result1 = 12 | 10 & 8;\n// Evaluated as: 12 | (10 & 8) = 12 | 8 = 12\n// & has higher precedence than |\n\nlet result2 = 8 | 1 << 2;\n// Evaluated as: 8 | (1 << 2) = 8 | 4 = 12\n// Shift has higher precedence than bitwise OR\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);\n// Evaluated as: 1 | 4 = 5\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does core allocation work in Hemlock?", "output": "alloc(bytes) - Allocate raw memory*\n\n```hemlock\nlet p = alloc(1024);  // Allocate 1KB, returns ptr\n// ... use memory\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Implement a Hemlock program that test array pop method.", "output": "```hemlock\n// Test array pop method\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();\nprint(last);\nprint(arr);\nprint(arr.length);\n```", "category": "tests/arrays", "source": "tests/arrays/pop.hml"}
{"instruction": "How does working with string indexing work in Hemlock?", "output": "String indexing returns runes, not bytes:\n\n```hemlock\nlet s = \"HelloüöÄ\";\nlet h = s[0];                   // 'H' (rune)\nlet rocket = s[5];              // 'üöÄ' (rune)\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// Convert to string if needed\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"üöÄ\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does udpsocket work in Hemlock?", "output": "Sends datagram to destaddr:destport. Returns number of bytes sent.\n\n```hemlock\nlet sent = sock.send_to(\"192.168.1.100\", 9000, \"Hello UDP!\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does temporary file creation work in Hemlock?", "output": "```hemlock\nimport { write_file, remove_file, exists } from \"@stdlib/fs\";\nimport { get_pid } from \"@stdlib/env\";\nimport { now } from \"@stdlib/time\";\n\nfn create_temp_file(prefix: string): string {\n    let pid = get_pid();\n    let timestamp = now();\n    let temp_path = \"/tmp/\" + prefix + \".\" + typeof(pid) + \".\" + typeof(timestamp);\n\n    let counter = 0;\n    let final_path = temp_path;\n\n    while (exists(final_path)) {\n        counter = counter + 1;\n        final_path = temp_path + \".\" + typeof(counter);\n    }\n\n    try {\n        write_file(final_path, \"\");\n        return final_path;\n    } catch (e) {\n        print(\"Error creating temp file: \" + e);\n        return \"\";\n    }\n}\n\nfn cleanup_temp_file(path: string): null {\n    if (exists(path)) {\n        try {\n            remove_file(path);\n        } catch (e) {\n            print(\"Error removing temp file: \" + e);\n        }\n    }\n    return null;\n}\n\n// Usage\nlet temp = create_temp_file(\"myapp\");\nprint(\"Temp file: \" + temp);\n// ... use temp file ...\ncleanup_temp_file(temp);\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does signal work in Hemlock?", "output": "```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "Write a Hemlock program that accessing nested object fields.", "output": "```hemlock\n// Accessing nested object fields\nlet person = {\n    name: \"Alice\",\n    address: {\n        city: \"NYC\",\n        zip: 10001,\n    },\n};\n\nprint(person.name);\nprint(person.address.city);\nprint(person.address.zip);\n```", "category": "tests/objects", "source": "tests/objects/nested_access.hml"}
{"instruction": "How does copy_file(src, dest) work in Hemlock?", "output": "Throws:* Exception if source doesn't exist or copy fails\n\n```hemlock\nimport { copy_file } from \"@stdlib/fs\";\n\ntry {\n    copy_file(\"original.txt\", \"backup.txt\");\n    print(\"File copied\");\n} catch (e) {\n    print(\"Error copying file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Implement a Hemlock program that test memory builtins.", "output": "```hemlock\n// Test memory builtins\n\n// alloc and free\nlet p = alloc(64);\nprint(p != null);\nfree(p);\n\n// buffer\nlet buf = buffer(32);\nprint(buf.length);\n\nbuf[0] = 65;\nbuf[1] = 66;\nprint(buf[0]);\nprint(buf[1]);\n\nfree(buf);\n\n// memset\nlet p2 = alloc(16);\nmemset(p2, 0, 16);\nprint(\"memset ok\");\nfree(p2);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/memory.hml"}
{"instruction": "Write Hemlock code that test defer statement - LIFO order execution.", "output": "```hemlock\n// Test defer statement - LIFO order execution\n\nfn test_single_defer() {\n    defer print(\"cleanup\");\n    print(\"work\");\n    return null;\n}\n\nfn test_multiple_defers() {\n    defer print(\"first\");\n    defer print(\"second\");\n    defer print(\"third\");\n    print(\"start\");\n    return null;\n}\n\nfn test_early_return() {\n    defer print(\"always runs\");\n    print(\"before return\");\n    return 42;\n}\n\n// Run tests\ntest_single_defer();\nprint(\"---\");\ntest_multiple_defers();\nprint(\"---\");\nlet result = test_early_return();\nprint(result);\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/defer.hml"}
{"instruction": "How does write_file(path, content) work in Hemlock?", "output": "Throws:* Exception if file cannot be written\n\n```hemlock\nimport { write_file } from \"@stdlib/fs\";\n\ntry {\n    write_file(\"output.txt\", \"Hello, World!\");\n    print(\"File written successfully\");\n} catch (e) {\n    print(\"Error writing file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Show an example of example 6: multiple loggers in Hemlock.", "output": "```hemlock\nimport { Logger, DEBUG, ERROR } from \"@stdlib/logging\";\n\n// Application logger (stdout, all levels)\nlet app_logger = Logger({ level: DEBUG });\n\n// Error logger (file, errors only)\nlet error_logger = Logger({\n    output: \"errors.log\",\n    level: ERROR\n});\ndefer error_logger.close();\n\nfn process() {\n    app_logger.debug(\"Starting process\");\n\n    try {\n        // ... work ...\n        app_logger.info(\"Process completed\");\n    } catch (e) {\n        app_logger.error(\"Process failed\");\n        error_logger.error(\"Critical error\", {\n            error: e,\n            timestamp: __now()\n        });\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Write a Hemlock program that tests i8 valid.", "output": "```hemlock\nlet a: i8 = 127;\nlet b: i8 = -128;\nlet c: i8 = 0;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/primitives", "source": "tests/primitives/i8_valid.hml"}
{"instruction": "Implement a Hemlock program that math utilities that use helper.", "output": "```hemlock\n// Math utilities that use helper\nimport { add, multiply } from \"./helper.hml\";\n\nexport fn square(x) {\n    return multiply(x, x);\n}\n\nexport fn sum_of_squares(a, b) {\n    return add(square(a), square(b));\n}\n```", "category": "tests/parity", "source": "tests/parity/modules/math_utils.hml"}
{"instruction": "How does configuration reload on signal work in Hemlock?", "output": "```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Reloading configuration...\");\n    config = load_config();\n    print(\"Configuration reloaded\");\n}\n\nsignal(SIGHUP, reload_config);  // Reload on SIGHUP\n\n// Send SIGHUP to process to reload config\n// From shell: kill -HUP <pid>\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does periodic task execution work in Hemlock?", "output": "```hemlock\nimport { now, sleep } from \"@stdlib/time\";\n\nfn run_periodic(task: function, interval_seconds: i32, duration_seconds: i32): null {\n    let start_time = now();\n    let next_run = start_time;\n\n    while (now() - start_time < duration_seconds) {\n        if (now() >= next_run) {\n            task();\n            next_run = next_run + interval_seconds;\n        }\n        sleep(0.1);  // Check every 100ms\n    }\n\n    return null;\n}\n\n// Run task every 5 seconds for 30 seconds\nrun_periodic(fn() {\n    print(\"Task executed at \" + typeof(now()));\n}, 5, 30);\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does no async i/o integration work in Hemlock?", "output": "File/network operations still block the thread:\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // Blocks the thread\n    f.close();\n    return content;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Write a Hemlock program that test directory navigation: cwd(), chdir(), absolute_path().", "output": "```hemlock\n// Test directory navigation: cwd(), chdir(), absolute_path()\nimport { cwd, make_dir, chdir, absolute_path, remove_dir } from \"@stdlib/fs\";\n\nlet original_dir = cwd();\nassert(typeof(original_dir) == \"string\", \"cwd() should return a string\");\nprint(\"Current directory: \" + original_dir);\n\n// Create test directory\nlet test_dir = \"/tmp/test_nav_dir\";\nmake_dir(test_dir);\n\n// Test chdir()\nchdir(test_dir);\nlet new_dir = cwd();\nassert(new_dir == test_dir, \"cwd() should return new directory after chdir()\");\n\n// Change back to original directory\nchdir(original_dir);\nlet back_dir = cwd();\nassert(back_dir == original_dir, \"Should be back to original directory\");\n\n// Test absolute_path()\nlet abs = absolute_path(\".\");\nassert(typeof(abs) == \"string\", \"absolute_path() should return a string\");\nassert(abs == original_dir, \"absolute_path('.') should return current directory\");\n\n// Clean up\nremove_dir(test_dir);\n\nprint(\"All directory navigation tests passed!\");\n```", "category": "tests/io", "source": "tests/io/directory_navigation.hml"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does exec work in Hemlock?", "output": "```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// Check exit status\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found:\", r.output);\n} else {\n    print(\"Pattern not found\");\n}\n\n// Process multi-line output\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "Show me Hemlock code that tests panic basic error.", "output": "```hemlock\n// Test: panic() with no arguments\nprint(\"before panic\");\npanic();\nprint(\"after panic\");  // Should never execute\n```", "category": "tests/exceptions", "source": "tests/exceptions/panic_basic_error.hml"}
{"instruction": "How does is_file(path) work in Hemlock?", "output": "Returns:* bool - True if path is a file, false otherwise\n\n```hemlock\nimport { is_file, is_dir } from \"@stdlib/fs\";\n\nif (is_file(\"data.txt\")) {\n    print(\"Path is a file\");\n}\n\nif (is_dir(\"/tmp\")) {\n    print(\"Path is a directory\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does logger(config?) work in Hemlock?", "output": "```hemlock\nimport { Logger, DEBUG } from \"@stdlib/logging\";\n\n// Basic logger (stdout, INFO level)\nlet logger1 = Logger();\n\n// Custom configuration\nlet logger2 = Logger({\n    output: \"/var/log/app.log\",\n    level: DEBUG,\n    format: \"[{level}] {message}\",\n    include_timestamp: false\n});\n\n// Don't forget to close file loggers!\ndefer logger2.close();\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Implement a Hemlock program that test nested switch statements.", "output": "```hemlock\n// Test nested switch statements\n\nlet x = 1;\nlet y = 2;\n\nswitch (x) {\n    case 1:\n        print(\"x is 1\");\n        switch (y) {\n            case 1:\n                print(\"y is 1\");\n                break;\n            case 2:\n                print(\"y is 2\");\n                break;\n        }\n        break;\n    case 2:\n        print(\"x is 2\");\n        break;\n}\n\n// Expected: x is 1, y is 2\n```", "category": "tests/switch", "source": "tests/switch/nested.hml"}
{"instruction": "Write Hemlock code that this test covers various scenarios for accessing properties on objects stored in arrays, including indexed and chained access.", "output": "```hemlock\n// Test: Arrays of objects - comprehensive access patterns\n// This test covers various scenarios for accessing properties on\n// objects stored in arrays, including indexed and chained access.\n\n// Basic array of objects\nlet sections = [\n    { dir: \"foo\", name: \"Foo\" },\n    { dir: \"bar\", name: \"Bar\" }\n];\n\n// Direct indexed access\nassert(sections[0].dir == \"foo\", \"direct access sections[0].dir\");\nassert(sections[0].name == \"Foo\", \"direct access sections[0].name\");\nassert(sections[1].dir == \"bar\", \"direct access sections[1].dir\");\nassert(sections[1].name == \"Bar\", \"direct access sections[1].name\");\n\n// Loop with index variable\nlet dirs = [];\nfor (let i = 0; i < sections.length; i = i + 1) {\n    dirs.push(sections[i].dir);\n}\nassert(dirs[0] == \"foo\", \"loop access dirs[0]\");\nassert(dirs[1] == \"bar\", \"loop access dirs[1]\");\n\n// For-in loop\nlet names = [];\nfor (let section in sections) {\n    names.push(section.name);\n}\nassert(names[0] == \"Foo\", \"for-in access names[0]\");\nassert(names[1] == \"Bar\", \"for-in access names[1]\");\n\n// For-in with index\nlet indexed_dirs = [];\nfor (let idx, section in sections) {\n    indexed_dirs.push(section.dir);\n    assert(idx >= 0, \"for-in index is valid\");\n}\nassert(indexed_dirs.length == 2, \"for-in with index processed all elements\");\n\n// Typed array: array\nlet typed_sections: array = [\n    { dir: \"typed1\", name: \"Typed1\" },\n    { dir: \"typed2\", name: \"Typed2\" }\n];\nassert(typed_sections[0].dir == \"typed1\", \"typed array access\");\n\n// Typed array: array<object>\nlet object_sections: array<object> = [\n    { dir: \"obj1\", name: \"Obj1\" },\n    { dir: \"obj2\", name: \"Obj2\" }\n];\nassert(object_sections[1].name == \"Obj2\", \"array<object> access\");\n\n// Nested object with array of objects\nlet data = {\n    items: [\n        { dir: \"nested1\", name: \"Nested1\" },\n        { dir: \"nested2\", name: \"Nested2\" }\n    ]\n};\nassert(data.items[0].dir == \"nested1\", \"nested object.items[0].dir\");\nassert(data.items[1].name == \"Nested2\", \"nested object.items[1].name\");\n\n// Deep nesting\nlet deep = {\n    level1: {\n        level2: {\n            items: [\n                { dir: \"deep1\", name: \"Deep1\" },\n                { dir: \"deep2\", name: \"Deep2\" }\n            ]\n        }\n    }\n};\nassert(deep.level1.level2.items[0].dir == \"deep1\", \"deep nested access\");\n\n// Function returning array of objects\nfn get_items() {\n    return [\n        { dir: \"func1\", name: \"Func1\" },\n        { dir: \"func2\", name: \"Func2\" }\n    ];\n}\nlet items = get_items();\nassert(items[0].dir == \"func1\", \"function return array access\");\n\n// Chained access from function return\nassert(get_items()[1].name == \"Func2\", \"direct chained function access\");\n\n// Function with array parameter\nfn process_items(arr) {\n    let result = [];\n    for (let i = 0; i < arr.length; i = i + 1) {\n        result.push(arr[i].dir);\n    }\n    return result;\n}\nlet processed = process_items(sections);\nassert(processed[0] == \"foo\", \"function with array param\");\n\n// Function with typed array parameter\nfn process_typed_items(arr: array) {\n    return arr[0].dir;\n}\nassert(process_typed_items(sections) == \"foo\", \"typed array param\");\n\n// Array element assigned to variable\nfor (let i = 0; i < sections.length; i = i + 1) {\n    let item = sections[i];\n    assert(item.dir != null, \"element to variable works\");\n}\n\n// User-defined type with array of objects\ndefine Section {\n    dir: string,\n    name: string\n}\n\nlet custom_sections: array<Section> = [\n    { dir: \"custom1\", name: \"Custom1\" },\n    { dir: \"custom2\", name: \"Custom2\" }\n];\nassert(custom_sections[0].dir == \"custom1\", \"custom type array access\");\n\n// Modify object in array\nsections[0].dir = \"modified\";\nassert(sections[0].dir == \"modified\", \"modify object in array\");\n\n// Async context\nasync fn async_process(items) {\n    return items[0].name;\n}\nlet task = spawn(async_process, sections);\nlet async_result = await task;\nassert(async_result == \"Foo\", \"async array of objects access\");\n\nprint(\"All array-of-objects tests passed!\");\n```", "category": "tests/arrays", "source": "tests/arrays/array_of_objects.hml"}
{"instruction": "How does extraction operations work in Hemlock?", "output": "last()* - Get last element (without removing):\n\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3 (without removing)\nprint(arr);                  // [1, 2, 3] (unchanged)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does is_linux() work in Hemlock?", "output": "Returns:* bool - true if on Linux, false otherwise\n\n```hemlock\nimport { is_linux } from \"@stdlib/os\";\n\nif (is_linux()) {\n    print(\"Linux-specific code here\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Show an example of example: array deduplication in Hemlock.", "output": "```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does nested arrays work in Hemlock?", "output": "```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does file size work in Hemlock?", "output": "```hemlock\nfn file_size(path: string): i32 {\n    let f = open(path, \"r\");\n    try {\n        // Seek to end\n        let end = f.seek(999999999);  // Large number\n        f.seek(0);  // Reset\n        return end;\n    } finally {\n        f.close();\n    }\n}\n\nlet size = file_size(\"data.txt\");\nprint(\"File size: \" + typeof(size) + \" bytes\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does validate arguments work in Hemlock?", "output": "```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Error: Missing required argument\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Error: Empty argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // exit or show usage\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does spawn/join work in Hemlock?", "output": "```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does memory leaks work in Hemlock?", "output": "Easy to create, hard to debug:*\n\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // Forgot to free!\n    return;  // Memory leaked\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Write Hemlock code that test for-in loop with array (value only).", "output": "```hemlock\n// Test for-in loop with array (value only)\nlet arr = [10, 20, 30, 40];\nfor (let val in arr) {\n    print(val);\n}\n```", "category": "tests/loops", "source": "tests/loops/for_in_array.hml"}
{"instruction": "How does safe practices work in Hemlock?", "output": "1. Never use unsanitized user input:*\n\n```hemlock\n// Bad\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // DANGEROUS\n\n// Good - validate first\nfn is_safe_filename(name: string): bool {\n    // Only allow alphanumeric, dash, underscore, dot\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Invalid filename\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does arrays in structured data work in Hemlock?", "output": "```hemlock\nlogger.warn(\"Multiple validation errors\", {\n    field: \"email\",\n    errors: [\"Invalid format\", \"Domain not allowed\", \"Too long\"]\n});\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does rsafreekeys(keypair: rsakeypair): null work in Hemlock?", "output": "Free RSA key pair memory. Always call when done with keys.\n\n```hemlock\nrsa_free_keys(keypair);\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does getppid(): i32 work in Hemlock?", "output": "Get the parent process ID.\n\n```hemlock\nlet ppid = getppid();\nprint(\"Parent PID: \" + typeof(ppid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Implement a Hemlock program that tests split.", "output": "```hemlock\nlet s = \"a,b,c\";\nlet parts = s.split(\",\");\nprint(parts[0]);\nprint(parts[1]);\nprint(parts[2]);\nprint(typeof(parts.length));\n\nlet s2 = \"hello world foo\";\nlet parts2 = s2.split(\" \");\nprint(parts2[0]);\nprint(parts2[1]);\nprint(parts2[2]);\n```", "category": "tests/strings", "source": "tests/strings/split.hml"}
{"instruction": "Create a Hemlock program that tests UDP datagram sending and receiving.", "output": "```hemlock\n// Test: UdpSocket basic functionality\n// Tests UDP datagram sending and receiving\n\nimport { UdpSocket } from \"@stdlib/net\";\n\nasync fn udp_server(port: i32) {\n    let sock = UdpSocket(\"127.0.0.1\", port);\n    sock.set_timeout(5.0);  // 5 second timeout\n    defer sock.close();\n\n    print(\"UDP server bound to 127.0.0.1:\" + typeof(port));\n\n    // Receive datagram\n    let packet = sock.recv_from(1024);\n    print(\"Server received \" + typeof(packet.data.length) + \" bytes from \" + packet.address + \":\" + typeof(packet.port));\n\n    // Small delay before echoing to ensure client is ready\n    __sleep(0.2);\n\n    // Echo back to sender\n    try {\n        let sent = sock.send_to(packet.address, packet.port, packet.data);\n        print(\"Server sent \" + typeof(sent) + \" bytes\");\n    } catch (e) {\n        print(\"Server send error: \" + e);\n    }\n\n    return null;\n}\n\nasync fn udp_client(port: i32) {\n    // Give server time to start and bind\n    __sleep(0.5);\n\n    let sock = UdpSocket(\"0.0.0.0\", 0);  // Bind to any port\n    sock.set_timeout(5.0);  // 5 second timeout\n    defer sock.close();\n\n    print(\"UDP client ready\");\n\n    // Send datagram\n    let message = \"Hello UDP!\";\n    let sent = sock.send_to(\"127.0.0.1\", port, message);\n    print(\"Client sent \" + typeof(sent) + \" bytes\");\n\n    // Receive echo\n    try {\n        let packet = sock.recv_from(1024);\n        print(\"Client received \" + typeof(packet.data.length) + \" bytes\");\n    } catch (e) {\n        print(\"Client recv error: \" + e);\n    }\n\n    return null;\n}\n\nlet test_port = 29999;\n\n// Spawn server and client\nlet server_task = spawn(udp_server, test_port);\nlet client_task = spawn(udp_client, test_port);\n\n// Wait for completion\njoin(server_task);\njoin(client_task);\n\nprint(\"UdpSocket test passed!\");\n```", "category": "tests/stdlib_net", "source": "tests/stdlib_net/udp_socket_basic.hml"}
{"instruction": "Write Hemlock code that tests sizeof.", "output": "```hemlock\nprint(sizeof(u8));\nprint(sizeof(i8));\nprint(sizeof(u16));\nprint(sizeof(i16));\nprint(sizeof(u32));\nprint(sizeof(i32));\nprint(sizeof(f32));\nprint(sizeof(f64));\nprint(sizeof(ptr));\n```", "category": "tests/memory", "source": "tests/memory/sizeof.hml"}
{"instruction": "How does when to use type annotations work in Hemlock?", "output": "Enforcing constraints (e.g., range checks)\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // Implementation\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does pitfall: mutation vs. new array work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\n\n// Mutates original\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// Returns new array\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1] (unchanged)\nprint(sub);  // [3, 2]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does finally block work in Hemlock?", "output": "Finally with control flow:*\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // ‚úÖ Breaks after finally runs\n        }\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does when you need free() vs when it's automatic work in Hemlock?", "output": "Early cleanup* - free before scope ends to release memory sooner:\n\n```hemlock\nfn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... done with big ...\n       free(big);  // Free now, don't wait for function to return\n       // ... more work that doesn't need big ...\n   }\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does basic pattern work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Create a Hemlock program that tests define duck typing extra fields.", "output": "```hemlock\n// Test: Duck typing allows extra fields\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p = { name: \"Alice\", age: 30, city: \"NYC\", active: true };\nlet typed_p: Person = p;\n\nprint(typed_p.name);\nprint(typed_p.age);\nprint(typed_p.city);  // Extra fields are preserved\nprint(typed_p.active);\n```", "category": "tests/objects", "source": "tests/objects/define_duck_typing_extra_fields.hml"}
{"instruction": "How does type promotion rules work in Hemlock?", "output": "```hemlock\n// Size promotion\nu8 + i32    ‚Üí i32    // Larger size wins\ni32 + i64   ‚Üí i64    // Larger size wins\nu32 + u64   ‚Üí u64    // Larger size wins\n\n// Float promotion\ni32 + f32   ‚Üí f32    // Float always wins\ni64 + f64   ‚Üí f64    // Float always wins\ni8 + f64    ‚Üí f64    // Float + largest wins\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does parallel_map work in Hemlock?", "output": "```hemlock\nparallel_map(arr: array, map_fn: fn, num_workers?: i32): array\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "Write a Hemlock program that comprehensive demo of @stdlib/terminal features.", "output": "```hemlock\n// Comprehensive demo of @stdlib/terminal features\nimport {\n    RED, GREEN, BLUE, YELLOW, CYAN, MAGENTA,\n    BRIGHT_GREEN, BRIGHT_BLUE, BRIGHT_YELLOW,\n    BG_RED, BG_GREEN, BG_BLUE, WHITE, BLACK,\n    BOLD, UNDERLINE, ITALIC, DIM, RESET,\n    color, color_bg, rgb, bg_rgb,\n    clear, size, supports_color,\n    ProgressBar, Spinner, SPINNER_DOTS, SPINNER_ARROW,\n    print_color, print_styled\n} from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nprint(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\");\nprint(\"‚ïë   Hemlock Terminal Module Demo           ‚ïë\");\nprint(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\");\nprint(\"\");\n\n// Check terminal capabilities\nprint(\"Terminal Information:\");\nlet term = size();\nprint(\"  Size: \" + typeof(term.rows) + \" rows √ó \" + typeof(term.cols) + \" cols\");\nprint(\"  Color support: \" + typeof(supports_color()));\nprint(\"\");\n\n// Color demonstrations\nprint(\"‚ïê‚ïê‚ïê Basic Colors ‚ïê‚ïê‚ïê\");\nprint_color(\"  ‚óè Red\", RED);\nprint_color(\"  ‚óè Green\", GREEN);\nprint_color(\"  ‚óè Blue\", BLUE);\nprint_color(\"  ‚óè Yellow\", YELLOW);\nprint_color(\"  ‚óè Cyan\", CYAN);\nprint_color(\"  ‚óè Magenta\", MAGENTA);\nprint(\"\");\n\n// Bright colors\nprint(\"‚ïê‚ïê‚ïê Bright Colors ‚ïê‚ïê‚ïê\");\nprint(BRIGHT_GREEN + \"  ‚óè Bright Green\" + RESET);\nprint(BRIGHT_BLUE + \"  ‚óè Bright Blue\" + RESET);\nprint(BRIGHT_YELLOW + \"  ‚óè Bright Yellow\" + RESET);\nprint(\"\");\n\n// Background colors\nprint(\"‚ïê‚ïê‚ïê Background Colors ‚ïê‚ïê‚ïê\");\nprint(color_bg(\" ERROR \", WHITE, BG_RED) + \" \" +\n      color_bg(\" SUCCESS \", WHITE, BG_GREEN) + \" \" +\n      color_bg(\" INFO \", WHITE, BG_BLUE));\nprint(\"\");\n\n// Text styles\nprint(\"‚ïê‚ïê‚ïê Text Styles ‚ïê‚ïê‚ïê\");\nprint_styled(\"  ‚óè Bold text\", BOLD);\nprint_styled(\"  ‚óè Underlined text\", UNDERLINE);\nprint_styled(\"  ‚óè Italic text\", ITALIC);\nprint(DIM + \"  ‚óè Dim text\" + RESET);\nprint(\"\");\n\n// RGB colors (24-bit)\nprint(\"‚ïê‚ïê‚ïê RGB True Color (24-bit) ‚ïê‚ïê‚ïê\");\nprint(rgb(255, 100, 50) + \"  ‚óè Custom orange (255, 100, 50)\" + RESET);\nprint(rgb(75, 0, 130) + \"  ‚óè Indigo (75, 0, 130)\" + RESET);\nprint(rgb(255, 20, 147) + \"  ‚óè Deep pink (255, 20, 147)\" + RESET);\nprint(rgb(255, 255, 255) + bg_rgb(138, 43, 226) + \" White on purple \" + RESET);\nprint(\"\");\n\n// Styled logger demo\nprint(\"‚ïê‚ïê‚ïê Styled Logger ‚ïê‚ïê‚ïê\");\nprint(RED + BOLD + \"[ERROR]\" + RESET + \" Connection failed to database\");\nprint(YELLOW + BOLD + \"[WARN]\" + RESET + \" Low disk space detected\");\nprint(BLUE + BOLD + \"[INFO]\" + RESET + \" Starting background service\");\nprint(GREEN + BOLD + \"[OK]\" + RESET + \" Operation completed successfully\");\nprint(\"\");\n\n// Progress bar demo\nprint(\"‚ïê‚ïê‚ïê Progress Bar ‚ïê‚ïê‚ïê\");\nlet bar = ProgressBar(50, 40);\nlet i = 0;\nwhile (i <= 50) {\n    bar.update(i);\n    sleep(0.03);\n    i = i + 1;\n}\nbar.finish();\nprint(\"\");\n\n// Spinner demo - Dots\nprint(\"‚ïê‚ïê‚ïê Spinners ‚ïê‚ïê‚ïê\");\nprint(\"Dots spinner:\");\nlet spinner1 = Spinner(SPINNER_DOTS());\ni = 0;\nwhile (i < 20) {\n    spinner1.spin();\n    sleep(0.1);\n    i = i + 1;\n}\nspinner1.finish(\"  ‚úì Loading complete\");\n\n// Spinner demo - Arrow\nprint(\"Arrow spinner:\");\nlet spinner2 = Spinner(SPINNER_ARROW());\ni = 0;\nwhile (i < 16) {\n    spinner2.spin();\n    sleep(0.08);\n    i = i + 1;\n}\nspinner2.finish(\"  ‚úì Processing complete\");\n\nprint(\"\");\n\n// Color gradient effect\nprint(\"‚ïê‚ïê‚ïê Color Gradient ‚ïê‚ïê‚ïê\");\nlet colors = [\n    rgb(255, 0, 0),\n    rgb(255, 127, 0),\n    rgb(255, 255, 0),\n    rgb(0, 255, 0),\n    rgb(0, 0, 255),\n    rgb(75, 0, 130),\n    rgb(148, 0, 211)\n];\nlet labels = [\"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Indigo\", \"Violet\"];\ni = 0;\nwhile (i < colors.length) {\n    print(colors[i] + \"  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \" + labels[i] + RESET);\n    i = i + 1;\n}\nprint(\"\");\n\n// Status indicators\nprint(\"‚ïê‚ïê‚ïê Status Indicators ‚ïê‚ïê‚ïê\");\nprint(GREEN + \"‚óè\" + RESET + \" Service A: Running\");\nprint(YELLOW + \"‚óè\" + RESET + \" Service B: Warning\");\nprint(RED + \"‚óè\" + RESET + \" Service C: Stopped\");\nprint(BLUE + \"‚óè\" + RESET + \" Service D: Starting\");\nprint(\"\");\n\n// Table with colors\nprint(\"‚ïê‚ïê‚ïê Colored Table ‚ïê‚ïê‚ïê\");\nprint(BOLD + \"Name\" + RESET + \"          \" + BOLD + \"Status\" + RESET + \"        \" + BOLD + \"Load\" + RESET);\nprint(\"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\");\nprint(\"web-01        \" + GREEN + \"‚óè Online\" + RESET + \"      \" + GREEN + \"12%\" + RESET);\nprint(\"web-02        \" + GREEN + \"‚óè Online\" + RESET + \"      \" + YELLOW + \"67%\" + RESET);\nprint(\"db-01         \" + YELLOW + \"‚óè Warning\" + RESET + \"     \" + RED + \"89%\" + RESET);\nprint(\"cache-01      \" + RED + \"‚óè Offline\" + RESET + \"     \" + DIM + \"0%\" + RESET);\nprint(\"\");\n\nprint(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\");\nprint(\"‚ïë   Demo Complete!                          ‚ïë\");\nprint(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/demo.hml"}
{"instruction": "How does handling clients work in Hemlock?", "output": "```hemlock\nasync fn handle_client(conn) {\n    defer conn.close();\n\n    while (true) {\n        let msg = conn.recv(30000);  // 30s timeout\n\n        if (msg == null || msg.type == \"close\") {\n            break;\n        }\n\n        if (msg.type == \"text\") {\n            // Echo back\n            conn.send_text(\"Echo: \" + msg.data);\n        }\n    }\n\n    print(\"Client disconnected\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does read file in chunks work in Hemlock?", "output": "```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // Read 1KB at a time\n        if (chunk.length == 0) {\n            break;  // EOF\n        }\n\n        // Process chunk\n        print(\"Processing\", chunk.length, \"bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does process identification work in Hemlock?", "output": "```hemlock\nimport { get_pid } from \"@stdlib/env\";\nimport { write_file } from \"@stdlib/fs\";\n\nfn create_pid_file(app_name: string): null {\n    let pid = get_pid();\n    let pid_file = \"/var/run/\" + app_name + \".pid\";\n\n    write_file(pid_file, typeof(pid));\n    print(\"PID file created: \" + pid_file);\n\n    return null;\n}\n\nfn remove_pid_file(app_name: string): null {\n    let pid_file = \"/var/run/\" + app_name + \".pid\";\n    // Remove file (using fs module)\n    return null;\n}\n\n// Usage in daemon/service\ncreate_pid_file(\"myapp\");\n// ... run application ...\n// remove_pid_file(\"myapp\");  // On shutdown\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "Show an example of example: qsort in Hemlock.", "output": "```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Comparison function for integers (ascending order)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// Allocate array of 5 integers\nlet arr = alloc(20);  // 5 * 4 bytes\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// Create callback and sort\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// Array is now sorted: [1, 2, 5, 8, 9]\n\n// Clean up\ncallback_free(cmp);\nfree(arr);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does chdir(path) work in Hemlock?", "output": "Throws:* Exception if directory doesn't exist or cannot be accessed\n\n```hemlock\nimport { chdir, cwd } from \"@stdlib/fs\";\n\ntry {\n    print(\"Before: \" + cwd());\n\n    chdir(\"/tmp\");\n    print(\"After: \" + cwd());\n\n    // Change back\n    chdir(\"..\");\n} catch (e) {\n    print(\"Error changing directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does signature work in Hemlock?", "output": "```hemlock\nexec(command: string): object\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does objects work in Hemlock?", "output": "JavaScript-style objects:\n\n```hemlock\n// Object literal\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // Modify field\n\n// Methods with 'self'\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "Write a Hemlock program that test allocating zero bytes Expected: ERROR (alloc requires positive size) Note: This is a fatal error, not catchable by try-catch.", "output": "```hemlock\n// Test allocating zero bytes\n// Expected: ERROR (alloc requires positive size)\n// Note: This is a fatal error, not catchable by try-catch\n\nlet p = alloc(0);\nprint(\"ERROR: alloc(0) should have failed\");\n```", "category": "tests/memory", "source": "tests/memory/edge_alloc_zero_error.hml"}
{"instruction": "How does email validation work in Hemlock?", "output": "```hemlock\nimport { compile, REG_EXTENDED } from \"@stdlib/regex\";\n\nfn is_valid_email(email: string): bool {\n    // Simplified email regex\n    let pattern = compile(\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\");\n    let valid = pattern.test(email);\n    pattern.free();\n    return valid;\n}\n\nprint(is_valid_email(\"user@example.com\"));     // true\nprint(is_valid_email(\"invalid.email\"));        // false\nprint(is_valid_email(\"test@domain.co.uk\"));    // true\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does optimization tips work in Hemlock?", "output": "```hemlock\n// Bad - repeated checking in loop\nlet i = 0;\nwhile (i < items.length) {\n    if (is_digit(items[i])) {  // O(m) check per iteration\n        // ...\n    }\n    i = i + 1;\n}\n\n// Better - check once, cache result if needed\nlet i = 0;\nwhile (i < items.length) {\n    let item = items[i];\n    let is_num = is_digit(item);  // Cache result\n    if (is_num) {\n        // Use is_num multiple times\n    }\n    i = i + 1;\n}\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Implement a Hemlock program that test that default case can appear anywhere in switch body.", "output": "```hemlock\n// Test that default case can appear anywhere in switch body\n\nlet x = 99;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    default:\n        print(\"default case in middle\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n    case 4:\n        print(\"four\");\n        break;\n}\n\n// Test with matching case after default\nlet y = 3;\n\nswitch (y) {\n    case 1:\n        print(\"one\");\n        break;\n    default:\n        print(\"should not print - case 3 should match\");\n        break;\n    case 3:\n        print(\"three matched\");\n        break;\n}\n\n// Expected output:\n// default case in middle\n// three matched\n```", "category": "tests/switch", "source": "tests/switch/default_in_middle.hml"}
{"instruction": "Implement a Hemlock program that tests that exceptions thrown in tasks are re-thrown on join.", "output": "```hemlock\n// Test: Exception propagation through join\n// Tests that exceptions thrown in tasks are re-thrown on join\n\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\n// Test successful task\nlet t1 = spawn(risky_operation, 0);\nlet r1 = join(t1);\nprint(\"Success: \" + typeof(r1));\n\n// Test failing task\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let r2 = join(t2);\n    print(\"Should not reach here\");\n} catch (e) {\n    print(\"Caught exception: \" + e);\n}\n\nprint(\"Exception handling works!\");\n```", "category": "tests/async", "source": "tests/async/test_exception_propagation.hml"}
{"instruction": "How does shell injection risk work in Hemlock?", "output": "Vulnerable code:*\n\n```hemlock\n// DANGEROUS - DO NOT DO THIS\nlet filename = args[1];  // User input\nlet r = exec(\"cat \" + filename);  // Shell injection!\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Write a Hemlock program that this tests that async fn syntax is parsed and executed correctly.", "output": "```hemlock\n// Test: Basic async function declaration and call\n// This tests that async fn syntax is parsed and executed correctly\n\nasync fn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet result = greet(\"World\");\nprint(result);\n```", "category": "tests/async", "source": "tests/async/basic_async_fn.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as fs from \"@stdlib/fs\";\nlet files = fs.list_dir(\".\");\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does sqrt(x) work in Hemlock?", "output": "Returns:* f64 - Square root of x\n\n```hemlock\nimport { sqrt } from \"@stdlib/math\";\n\nlet result = sqrt(16.0);  // 4.0\nlet result2 = sqrt(2.0);  // 1.414213...\nlet result3 = sqrt(0.0);  // 0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does graceful shutdown pattern work in Hemlock?", "output": "Common pattern for cleanup on termination:\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Main loop\nwhile (!should_exit) {\n    // Do work...\n    // Check should_exit flag periodically\n}\n\nprint(\"Cleanup complete\");\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does basic arithmetic work in Hemlock?", "output": "```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3 (integer division)\nprint(a == b);  // false\nprint(a > b);   // true\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does shutdownasyncfs work in Hemlock?", "output": "```hemlock\nshutdown_async_fs(): null\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does braces are required work in Hemlock?", "output": "```hemlock\n// ‚ùå ERROR: Missing braces\nif (x > 0)\n    print(\"positive\");\n\n// ‚úÖ CORRECT\nif (x > 0) {\n    print(\"positive\");\n}\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "Write Hemlock code that server echoes back what client sends.", "output": "```hemlock\n// Test: TCP echo server with async client\n// Server echoes back what client sends\n\nasync fn echo_server(port: i32) {\n    let server = socket_create(AF_INET, SOCK_STREAM, 0);\n    defer server.close();\n\n    server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);\n    server.bind(\"127.0.0.1\", port);\n    server.listen(1);\n\n    print(\"Server listening on port \" + typeof(port));\n\n    let client = server.accept();\n    defer client.close();\n\n    print(\"Client connected from \" + client.address + \":\" + typeof(client.port));\n\n    // Receive data\n    let data = client.recv(1024);\n    print(\"Server received: \" + typeof(data.length) + \" bytes\");\n\n    // Echo back\n    let sent = client.send(data);\n    print(\"Server sent: \" + typeof(sent) + \" bytes\");\n\n    return null;\n}\n\nasync fn echo_client(port: i32) {\n    // Give server time to start\n    __sleep(0.1);\n\n    let sock = socket_create(AF_INET, SOCK_STREAM, 0);\n    defer sock.close();\n\n    sock.connect(\"127.0.0.1\", port);\n    print(\"Client connected to port \" + typeof(port));\n\n    // Send message\n    let message = \"Hello, server!\";\n    let sent = sock.send(message);\n    print(\"Client sent: \" + typeof(sent) + \" bytes\");\n\n    // Receive echo\n    let received = sock.recv(1024);\n    print(\"Client received: \" + typeof(received.length) + \" bytes\");\n\n    return null;\n}\n\nlet port = 9999;\n\n// Spawn server and client\nlet server_task = spawn(echo_server, port);\nlet client_task = spawn(echo_client, port);\n\n// Wait for both to complete\njoin(server_task);\njoin(client_task);\n\nprint(\"TCP echo test passed\");\n```", "category": "tests/networking", "source": "tests/networking/tcp_echo_server.hml"}
{"instruction": "How does pattern: callback functions work in Hemlock?", "output": "```hemlock\nfn process_async(data, callback) {\n    // ... do processing\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does unsafe is a feature, not a bug work in Hemlock?", "output": "Type system prevents accidents but allows footguns when needed\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation - allowed but dangerous\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Create a Hemlock program that test freeing null pointer Expected: PASS (free(null) should be safe no-op).", "output": "```hemlock\n// Test freeing null pointer\n// Expected: PASS (free(null) should be safe no-op)\n\nfree(null);\nprint(\"PASS: free(null) did not crash\");\n```", "category": "tests/memory", "source": "tests/memory/edge_free_null.hml"}
{"instruction": "Write a Hemlock program that test basic datetime functionality.", "output": "```hemlock\n// Test basic datetime functionality\nimport { DateTime, now, from_date, localtime, gmtime, mktime, strftime } from \"@stdlib/datetime\";\n\n// Test 1: Create DateTime from current time\nlet dt = now();\nprint(\"Test 1: now() created DateTime\");\nprint(typeof(dt.year));\nprint(typeof(dt.month));\nprint(typeof(dt.day));\n\n// Test 2: Create DateTime from specific date\nlet dt2 = from_date(2025, 1, 15, 14, 30, 45);\nprint(\"Test 2: from_date() created DateTime for 2025-01-15 14:30:45\");\nprint(dt2.year);\nprint(dt2.month);\nprint(dt2.day);\nprint(dt2.hour);\nprint(dt2.minute);\nprint(dt2.second);\n\n// Test 3: Format date/time\nlet formatted = dt2.format(\"%Y-%m-%d %H:%M:%S\");\nprint(\"Test 3: format() -> \" + formatted);\n\n// Test 4: to_string method\nlet str = dt2.to_string();\nprint(\"Test 4: to_string() -> \" + str);\n\n// Test 5: to_date_string method\nlet date_str = dt2.to_date_string();\nprint(\"Test 5: to_date_string() -> \" + date_str);\n\n// Test 6: to_time_string method\nlet time_str = dt2.to_time_string();\nprint(\"Test 6: to_time_string() -> \" + time_str);\n\n// Test 7: Low-level localtime builtin\nlet components = localtime(1737037845);  // 2025-01-16 12:30:45 (approx)\nprint(\"Test 7: localtime() components:\");\nprint(\"  year: \" + typeof(components.year));\nprint(\"  month: \" + typeof(components.month));\nprint(\"  day: \" + typeof(components.day));\n\n// Test 8: Low-level gmtime builtin\nlet utc_components = gmtime(1737037845);\nprint(\"Test 8: gmtime() components:\");\nprint(\"  year: \" + typeof(utc_components.year));\nprint(\"  hour: \" + typeof(utc_components.hour));\n\n// Test 9: Low-level mktime builtin\nlet ts = mktime({ year: 2025, month: 1, day: 15, hour: 0, minute: 0, second: 0 });\nprint(\"Test 9: mktime() -> \" + typeof(ts));\n\n// Test 10: Low-level strftime builtin\nlet formatted2 = strftime(\"%Y/%m/%d\", { year: 2025, month: 12, day: 25, hour: 0, minute: 0, second: 0, weekday: 0, yearday: 1 });\nprint(\"Test 10: strftime() -> \" + formatted2);\n\nprint(\"All basic tests passed!\");\n```", "category": "tests/stdlib_datetime", "source": "tests/stdlib_datetime/test_basic.hml"}
{"instruction": "Write a Hemlock program that test prefix increment.", "output": "```hemlock\n// Test prefix increment\nlet x = 10;\nprint(x);\nprint(++x);\nprint(x);\n\n// Test prefix decrement\nlet y = 20;\nprint(y);\nprint(--y);\nprint(y);\n\n// Test postfix increment\nlet a = 5;\nprint(a);\nprint(a++);\nprint(a);\n\n// Test postfix decrement\nlet b = 15;\nprint(b);\nprint(b--);\nprint(b);\n\n// Test prefix vs postfix difference\nlet i = 0;\nlet j = ++i;  // i becomes 1, j = 1\nprint(i);\nprint(j);\n\nlet k = 0;\nlet m = k++;  // m = 0, then k becomes 1\nprint(k);\nprint(m);\n\n// Test on arrays\nlet arr = [10, 20, 30];\nprint(arr[0]);\narr[0]++;\nprint(arr[0]);\n++arr[1];\nprint(arr[1]);\nprint(arr[2]--);\nprint(arr[2]);\n\n// Test on objects\nlet obj = { count: 100, value: 50 };\nprint(obj.count);\nobj.count++;\nprint(obj.count);\n++obj.value;\nprint(obj.value);\nprint(obj.count--);\nprint(obj.count);\n\n// Test with floats\nlet f = 3.5;\nprint(f);\nf++;\nprint(f);\n--f;\nprint(f);\n```", "category": "tests/variables", "source": "tests/variables/increment_decrement.hml"}
{"instruction": "How does pad_left(str, width, fill?) work in Hemlock?", "output": "Padding length is calculated in codepoints (emoji = 1 character)\n\n```hemlock\nimport { pad_left } from \"@stdlib/strings\";\n\nlet s1 = pad_left(\"42\", 5);\nprint(s1);  // \"   42\"\n\nlet s2 = pad_left(\"42\", 5, \"0\");\nprint(s2);  // \"00042\"\n\nlet s3 = pad_left(\"test\", 10, \"*\");\nprint(s3);  // \"******test\"\n\n// Unicode fill character\nlet s4 = pad_left(\"Hi\", 5, \"üöÄ\");\nprint(s4);  // \"üöÄüöÄüöÄHi\"\nprint(s4.length);  // 5 (codepoints)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Write a Hemlock program that tests define optional without default.", "output": "```hemlock\n// Test: Optional fields without defaults get null\ndefine Person {\n    name: string,\n    age: i32,\n    nickname?: string,\n}\n\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.name);\nprint(typed_p.age);\nprint(typed_p.nickname);  // Should be null\n```", "category": "tests/objects", "source": "tests/objects/define_optional_without_default.hml"}
{"instruction": "Provide a Hemlock example of prints the number 42.", "output": "```hemlock\nlet message = 42;\nprint(message);\n```", "category": "examples", "source": "examples/42.hml"}
{"instruction": "Show me Hemlock code that test chaining map, filter, and reduce.", "output": "```hemlock\n// Test chaining map, filter, and reduce\n\n// Example 1: Double numbers, filter evens, sum them\nlet result1 = [1, 2, 3, 4, 5]\n    .map(fn(x) { return x * 2; })\n    .filter(fn(x) { return x % 4 == 0; })\n    .reduce(fn(acc, x) { return acc + x; }, 0);\nprint(result1);  // 12 (4 + 8)\n\n// Example 2: Filter > 2, square them, find product\nlet result2 = [1, 2, 3, 4, 5]\n    .filter(fn(x) { return x > 2; })\n    .map(fn(x) { return x * x; })\n    .reduce(fn(acc, x) { return acc * x; }, 1);\nprint(result2);  // 3600 (9 * 16 * 25)\n\n// Example 3: String processing pipeline\nlet words = [\"hello\", \"world\", \"test\", \"code\"];\nlet result3 = words\n    .filter(fn(w) { return w.length > 4; })\n    .map(fn(w) { return w.to_upper(); })\n    .reduce(fn(acc, w) { return acc + \" \" + w; }, \"\");\nprint(result3.trim());  // HELLO WORLD\n\n// Example 4: Count even numbers after doubling\nlet count = [1, 2, 3, 4, 5, 6]\n    .map(fn(x) { return x * 2; })\n    .filter(fn(x) { return x % 4 == 0; })\n    .reduce(fn(acc, x) { return acc + 1; }, 0);\nprint(count);  // 3 (4, 8, 12)\n\n// Example 5: Complex pipeline\nlet nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet result5 = nums\n    .filter(fn(x) { return x % 2 == 1; })  // Odds: 1,3,5,7,9\n    .map(fn(x) { return x + 1; })          // Add 1: 2,4,6,8,10\n    .filter(fn(x) { return x > 5; })       // Keep > 5: 6,8,10\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // Sum: 24\nprint(result5);  // 24\n\n// Example 6: Array building with reduce\nlet doubled_evens = [1, 2, 3, 4, 5, 6]\n    .filter(fn(x) { return x % 2 == 0; })\n    .map(fn(x) { return x * 2; })\n    .reduce(fn(acc, x) {\n        acc.push(x);\n        return acc;\n    }, []);\nprint(doubled_evens[0]);  // 4\nprint(doubled_evens[1]);  // 8\nprint(doubled_evens[2]);  // 12\nprint(doubled_evens.length);  // 3\n\nprint(\"All chaining tests passed\");\n```", "category": "tests/arrays", "source": "tests/arrays/map_filter_reduce_chaining.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as math from \"@stdlib/math\";\nlet result = math.sqrt(16);\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Show me Hemlock code that tests empty args.", "output": "```hemlock\n// Test: Verify script name is in args[0] even with no extra arguments\nif (args.length >= 1) {\n    print(\"Script name: \" + args[0]);\n} else {\n    print(\"ERROR: args should always have at least the script name\");\n}\n```", "category": "tests/args", "source": "tests/args/empty_args.hml"}
{"instruction": "How does best practices for safe signal handling work in Hemlock?", "output": "2. Minimize Shared State*\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // Only modify this one variable\n    interrupt_count = interrupt_count + 1;\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does object literals work in Hemlock?", "output": "```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// Add/modify fields\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does clamp(value, minval, maxval) work in Hemlock?", "output": "Returns:* f64 - Clamped value\n\n```hemlock\nimport { clamp } from \"@stdlib/math\";\n\nlet result = clamp(5.0, 0.0, 10.0);   // 5.0\nlet result2 = clamp(-3.0, 0.0, 10.0); // 0.0 (clamped to min)\nlet result3 = clamp(15.0, 0.0, 10.0); // 10.0 (clamped to max)\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Create a Hemlock program that test enum as function parameters.", "output": "```hemlock\n// Test enum as function parameters\n\nenum Status {\n    OK,\n    ERROR,\n    PENDING\n}\n\nfn process(s: Status): string {\n    if (s == Status.OK) {\n        return \"Success\";\n    }\n    if (s == Status.ERROR) {\n        return \"Failed\";\n    }\n    return \"Waiting\";\n}\n\nprint(process(Status.OK));\nprint(process(Status.ERROR));\nprint(process(Status.PENDING));\n```", "category": "tests/enums", "source": "tests/enums/function_params.hml"}
{"instruction": "Show me Hemlock code that boolean logic test Tests: &&, ||, !, truthiness.", "output": "```hemlock\n// Boolean logic test\n// Tests: &&, ||, !, truthiness\n\n// Basic logic\nprint(true && true);    // true\nprint(true && false);   // false\nprint(false && true);   // false\nprint(false && false);  // false\n\nprint(true || true);    // true\nprint(true || false);   // true\nprint(false || true);   // true\nprint(false || false);  // false\n\nprint(!true);           // false\nprint(!false);          // true\nprint(!!true);          // true\n\n// Compound expressions\nprint((true && false) || true);   // true\nprint(true && (false || true));   // true\nprint(!(true && false));          // true\n\n// Short-circuit evaluation\nfn side_effect() {\n    print(\"called\");\n    return true;\n}\n\n// Should not call side_effect\nlet a = false && side_effect();\nprint(a);  // false\n\n// Should call side_effect\nlet b = true && side_effect();\nprint(b);  // true (after \"called\")\n```", "category": "tests/parity", "source": "tests/parity/language/booleans.hml"}
{"instruction": "How does function return type annotations work in Hemlock?", "output": "```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does print_color(text, code) work in Hemlock?", "output": "```hemlock\nimport { print_color, RED, GREEN, BLUE } from \"@stdlib/terminal\";\n\nprint_color(\"Error message\", RED);\nprint_color(\"Success!\", GREEN);\nprint_color(\"Information\", BLUE);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does range checking work in Hemlock?", "output": "Invalid Assignments (Runtime Error):*\n\n```hemlock\nlet x: u8 = 256;             // ERROR: out of range\nlet y: i8 = 128;             // ERROR: max is 127\nlet z: u64 = -1;             // ERROR: u64 cannot be negative\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does module caching work in Hemlock?", "output": "Modules are loaded once and cached. Multiple imports of the same module return the same instance:\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // Same instance!\nprint(count);  // Still 1 (shared state)\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "Write Hemlock code that tests i32 valid.", "output": "```hemlock\nlet a: i32 = 2147483647;\nlet b: i32 = -2147483648;\nlet c: i32 = 0;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/primitives", "source": "tests/primitives/i32_valid.hml"}
{"instruction": "How does dot notation work in Hemlock?", "output": "```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// Read field\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// Modify field\nperson.age = 31;\nprint(person.age);           // 31\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does relational work in Hemlock?", "output": "Type promotion applies:*\n\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true (i32 promoted to i64)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does when not to use panic work in Hemlock?", "output": "Expected error conditions\n\n```hemlock\n// BAD: Panic for expected errors\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"division by zero\");  // ‚ùå Too harsh\n    }\n    return a / b;\n}\n\n// GOOD: Throw for expected errors\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";  // ‚úÖ Recoverable\n    }\n    return a / b;\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Create a Hemlock program that expect: 12 Expect: 6 Expect: 12 Expect: 1 Expect: 1.", "output": "```hemlock\n// Test: Bitwise operator precedence\n// Expect: 12\n// Expect: 6\n// Expect: 12\n// Expect: 1\n// Expect: 1\n\n// & has higher precedence than |\n// 12 | 10 & 8 = 12 | (10 & 8) = 12 | 8 = 12\nlet result1 = 12 | 10 & 8;\nprint(result1);\n\n// & has higher precedence than ^\n// 2 ^ 4 & 6 = 2 ^ (4 & 6) = 2 ^ 4 = 6\nlet result2 = 2 ^ 4 & 6;\nprint(result2);\n\n// Shift has higher precedence than bitwise\n// 8 | 1 << 2 = 8 | (1 << 2) = 8 | 4 = 12\nlet result3 = 8 | 1 << 2;\nprint(result3);\n\n// Parentheses override precedence\n// (5 & 3) = 1\nlet result4 = (5 & 3);\nprint(result4);\n\n// Multiple operators\n// 0 ^ 1 & 1 = 0 ^ (1 & 1) = 0 ^ 1 = 1\nlet result5 = 0 ^ 1 & 1;\nprint(result5);\n```", "category": "tests/bitwise", "source": "tests/bitwise/precedence.hml"}
{"instruction": "How do you using try/catch in Hemlock?", "output": "```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does buffer work in Hemlock?", "output": "```hemlock\nbuffer(size: i32): buffer\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does planned features work in Hemlock?", "output": "1. Struct Support*\n\n```hemlock\n// Future: Pass/return C structs\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nlet p = Point { x: 1.0, y: 2.0 };\nc_function_with_struct(p);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does system libraries work in Hemlock?", "output": "Memory allocation:*\n\n```hemlock\n// Call malloc/free from libc\nlet ptr = malloc(1024);\nfree(ptr);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does asynclistdir work in Hemlock?", "output": "```hemlock\nimport { async_list_dir } from \"@stdlib/async_fs\";\n\nlet future = async_list_dir(\"./src\");\nlet files = future.get();\nfor (file in files) {\n    print(file);\n}\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does total_memory() work in Hemlock?", "output": "Resource monitoring\n\n```hemlock\nimport { total_memory, format_bytes } from \"@stdlib/os\";\n\nlet total = total_memory();\nprint(\"Total memory: \" + format_bytes(total));  // e.g., \"16 GB\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Create a Hemlock program that test type coercion and promotion rules.", "output": "```hemlock\n// Test type coercion and promotion rules\n\n// Integer promotion\nlet i8val: i8 = 10;\nlet i16val: i16 = 1000;\nlet i32val: i32 = 100000;\nlet i64val: i64 = 10000000000;\n\n// i8 + i16 -> i16\nprint(typeof(i8val + i16val));\n\n// i16 + i32 -> i32\nprint(typeof(i16val + i32val));\n\n// i32 + i64 -> i64\nprint(typeof(i32val + i64val));\n\n// Integer + float -> float\nlet f32val: f32 = 3.14;\nlet f64val: f64 = 2.71828;\n\n// i32 + f32 -> f32\nprint(typeof(i32val + f32val));\n\n// i32 + f64 -> f64\nprint(typeof(i32val + f64val));\n\n// f32 + f64 -> f64\nprint(typeof(f32val + f64val));\n\n// Explicit conversions\nlet big: i64 = 9999999999;\nprint(big);\n\n// String concatenation with number\nlet num = 42;\nlet str = \"The answer is: \";\nprint(str + num);\n\n// Comparison type handling\nprint(10 == 10.0);\nprint(10 < 10.5);\n\n// Unsigned types\nlet u8val: u8 = 255;\nlet u16val: u16 = 65535;\nlet u32val: u32 = 4294967295;\n\nprint(u8val);\nprint(u16val);\nprint(u32val);\n\n// Mixed signed/unsigned\nprint(typeof(i32val + u32val));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/type_coercion.hml"}
{"instruction": "How does implicit type promotion work in Hemlock?", "output": "```hemlock\nu8 + i32  ‚Üí i32\ni32 + i64 ‚Üí i64\nu32 + u64 ‚Üí u64\ni32 + f32 ‚Üí f32\ni64 + f64 ‚Üí f64\ni8 + f64  ‚Üí f64\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Implement a Hemlock program that test string_concat_many function for optimized string building.", "output": "```hemlock\n// Test string_concat_many function for optimized string building\n\n// Test basic concatenation\nlet parts = [\"Hello\", \", \", \"World\", \"!\"];\nlet result = string_concat_many(parts);\nassert(result == \"Hello, World!\", \"Basic concat failed\");\nprint(result);\n\n// Test empty array\nlet empty = [];\nlet empty_result = string_concat_many(empty);\nassert(empty_result == \"\", \"Empty array should produce empty string\");\nprint(\"Empty: '\" + empty_result + \"'\");\n\n// Test single element\nlet single = [\"only\"];\nlet single_result = string_concat_many(single);\nassert(single_result == \"only\", \"Single element failed\");\nprint(single_result);\n\n// Test with empty strings in array\nlet with_empty = [\"a\", \"\", \"b\", \"\", \"c\"];\nlet with_empty_result = string_concat_many(with_empty);\nassert(with_empty_result == \"abc\", \"Empty strings in array failed\");\nprint(with_empty_result);\n\n// Test building a longer string\nlet words = [\"The\", \" \", \"quick\", \" \", \"brown\", \" \", \"fox\"];\nlet sentence = string_concat_many(words);\nassert(sentence == \"The quick brown fox\", \"Sentence building failed\");\nprint(sentence);\n\n// Test with Unicode characters\nlet unicode_parts = [\"Hello \", \"‰∏ñÁïå\", \" \", \"üåç\"];\nlet unicode_result = string_concat_many(unicode_parts);\nprint(unicode_result);\n\n// Test building a path\nlet path_parts = [\"/home\", \"/\", \"user\", \"/\", \"hemlock\"];\nlet path = string_concat_many(path_parts);\nassert(path == \"/home/user/hemlock\", \"Path building failed\");\nprint(path);\n\nprint(\"All string_concat_many tests passed!\");\n```", "category": "tests/strings", "source": "tests/strings/string_concat_many.hml"}
{"instruction": "How does relational work in Hemlock?", "output": "```hemlock\nif (x < 10) { }     // Less than\nif (x > 10) { }     // Greater than\nif (x <= 10) { }    // Less than or equal\nif (x >= 10) { }    // Greater than or equal\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does difference methods work in Hemlock?", "output": "Get the difference in hours.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 1, 10, 0, 0);\nlet dt2 = from_date(2025, 1, 1, 16, 0, 0);\n\nlet diff = dt2.diff_hours(dt1);\nprint(diff);  // 6\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does system requirements check work in Hemlock?", "output": "```hemlock\nimport * as os from \"@stdlib/os\";\n\nfn check_requirements(): bool {\n    let errors = [];\n\n    // Check platform\n    if (!os.is_linux() && !os.is_macos()) {\n        errors.push(\"This application requires Linux or macOS\");\n    }\n\n    // Check CPU cores\n    let cores = os.cpu_count();\n    if (cores < 2) {\n        errors.push(\"At least 2 CPU cores required, found \" + typeof(cores));\n    }\n\n    // Check memory (require at least 2 GB)\n    let min_memory: i64 = 2147483648;  // 2 GB in bytes\n    let total = os.total_memory();\n    if (total < min_memory) {\n        errors.push(\"At least 2 GB RAM required, found \" + os.format_bytes(total));\n    }\n\n    // Report results\n    if (errors.length > 0) {\n        print(\"System requirements not met:\");\n        let i = 0;\n        while (i < errors.length) {\n            print(\"  - \" + errors[i]);\n            i = i + 1;\n        }\n        return false;\n    }\n\n    print(\"System requirements satisfied\");\n    return true;\n}\n\ncheck_requirements();\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "bytes()* - Convert to array of bytes (u8 values):\n\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111] (array of u8)\n\n// UTF-8 example\nlet emoji = \"üöÄ\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Show an example of example 4: timeout pattern in Hemlock.", "output": "```hemlock\nlet operation_complete = false;\nlet timed_out = false;\n\nfn timeout_handler(sig) {\n    timed_out = true;\n}\n\nsignal(SIGALRM, timeout_handler);\n\n// Start long operation\nasync fn long_operation() {\n    // ... work\n    operation_complete = true;\n}\n\nlet task = spawn(long_operation);\n\n// Wait with timeout (manual check)\nlet elapsed = 0;\nwhile (!operation_complete && elapsed < 1000) {\n    // Sleep or check\n    elapsed = elapsed + 1;\n}\n\nif (!operation_complete) {\n    print(\"Operation timed out\");\n    detach(task);  // Give up waiting\n} else {\n    join(task);\n    print(\"Operation completed\");\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Show an example of example 4: using parentheses in Hemlock.", "output": "```hemlock\n// Without parentheses\nlet a = 2 + 3 * 4;        // 14\n\n// With parentheses\nlet b = (2 + 3) * 4;      // 20\n\n// Complex expression\nlet c = (a + b) * (a - b);\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Create a Hemlock program that tests index.", "output": "```hemlock\nlet s = \"hello\";\nprint(s[0]);\nprint(s[4]);\n```", "category": "tests/strings", "source": "tests/strings/index.hml"}
{"instruction": "Implement a Hemlock program that test command-line arguments array exists and is accessible.", "output": "```hemlock\n// Test command-line arguments array exists and is accessible\n\n// Test args is an array with length property\nprint(typeof(args));\n\n// Test we can access args.length (will be 0 if no args passed)\nprint(args.length >= 0);\n\n// Test args array methods work\nlet pushed = args.length;\nprint(pushed >= 0);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/args.hml"}
{"instruction": "Write Hemlock code that tests talloc.", "output": "```hemlock\nlet numbers = talloc(i32, 10);\nprint(numbers);\nfree(numbers);\n\nlet bytes = talloc(u8, 256);\nprint(bytes);\nfree(bytes);\n\nlet floats = talloc(f64, 5);\nprint(floats);\nfree(floats);\n```", "category": "tests/memory", "source": "tests/memory/talloc.hml"}
{"instruction": "How does ptr - raw pointer (dangerous) work in Hemlock?", "output": "Raw pointers are just addresses with minimal safety guarantees:\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // You must remember to free\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Throws exception on connection failure\n\n```hemlock\nlet stream = TcpStream(\"example.com\", 80);\nlet stream2 = TcpStream(\"192.168.1.1\", 9000);\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does workarounds work in Hemlock?", "output": "For concurrent requests:*\n\n```hemlock\nimport { get } from \"@stdlib/http\";\n\nasync fn fetch_url(url: string): object {\n    return get(url, null);\n}\n\n// Fetch multiple URLs in parallel\nlet task1 = spawn(fetch_url, \"https://api.example.com/data1\");\nlet task2 = spawn(fetch_url, \"https://api.example.com/data2\");\nlet task3 = spawn(fetch_url, \"https://api.example.com/data3\");\n\nlet result1 = await task1;\nlet result2 = await task2;\nlet result3 = await task3;\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "3. Commands producing huge output:*\n\n```hemlock\n// Bad - loads entire output into memory\nlet r = exec(\"cat 10GB_file.log\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does pattern: object builder work in Hemlock?", "output": "```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // Enable chaining\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does pattern: resource management with try/finally work in Hemlock?", "output": "Ensure cleanup even on errors:\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... risky operations\n    process(data);\n} finally {\n    free(data);  // Always freed, even on error\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does platform() work in Hemlock?", "output": "Feature availability checks\n\n```hemlock\nimport { platform } from \"@stdlib/os\";\n\nlet p = platform();\nprint(\"Running on: \" + p);  // e.g., \"linux\"\n\nif (p == \"linux\") {\n    print(\"Using Linux-specific features\");\n} else if (p == \"macos\") {\n    print(\"Using macOS-specific features\");\n} else if (p == \"windows\") {\n    print(\"Using Windows-specific features\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does receiving messages work in Hemlock?", "output": "Receive with timeout:*\n\n```hemlock\nlet msg = ws.recv(5000);  // 5 second timeout\nif (msg == null) {\n    print(\"Timeout or connection closed\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does command-line arguments work in Hemlock?", "output": "Access program arguments via the args array:\n\n```hemlock\n// script.hml\nprint(\"Script: \" + args[0]);\nprint(\"Arguments: \" + typeof(args.length - 1));\n\nlet i = 1;\nwhile (i < args.length) {\n    print(\"  arg \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as strings from \"@stdlib/strings\";\nlet result = strings.reverse(\"hello\");\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does issecureurl work in Hemlock?", "output": "Check if URL uses secure WebSocket:\n\n```hemlock\nimport { is_secure_url } from \"@stdlib/websocket\";\n\nif (is_secure_url(\"wss://example.com\")) {\n    print(\"Secure connection\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does is_digit(str) work in Hemlock?", "output": "Returns:* bool - True if all characters are digits\n\n```hemlock\nimport { is_digit } from \"@stdlib/strings\";\n\nprint(is_digit(\"123\"));      // true\nprint(is_digit(\"0\"));        // true\nprint(is_digit(\"999\"));      // true\n\nprint(is_digit(\"123a\"));     // false\nprint(is_digit(\"12.3\"));     // false (decimal point)\nprint(is_digit(\"1 2 3\"));    // false (spaces)\nprint(is_digit(\"\"));         // false (empty)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Write a Hemlock program that this tests that FFI functions are properly freed when scopes exit.", "output": "```hemlock\n// Test: FFI function cleanup\n// This tests that FFI functions are properly freed when scopes exit\nimport \"libc.so.6\";\n\n// Global FFI function (should be cleaned up at program exit)\nextern fn strlen(s: string): i32;\n\n// Test FFI function in nested scope\n{\n    extern fn getpid(): i32;\n    let pid = getpid();\n    print(\"PID in scope:\");\n    print(pid);\n    // getpid FFI function should be freed when scope exits\n}\n\n// Test FFI function used and then scope exits\nlet result = 0;\n{\n    extern fn abs(n: i32): i32;\n    result = abs(-42);\n    // abs FFI function should be freed when scope exits\n}\n\nprint(\"Result:\");\nprint(result);\n\n// Use global strlen\nlet len = strlen(\"test\");\nprint(\"Length:\");\nprint(len);\n```", "category": "tests/ffi", "source": "tests/ffi/function_cleanup.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { RED, GREEN, BOLD, clear, color } from \"@stdlib/terminal\";\n\n// Colored text\nprint(RED + \"Error: Something went wrong\" + RESET);\nprint(color(\"Success!\", GREEN));\n\n// Styled text\nprint(BOLD + \"Important message\" + RESET);\n\n// Clear screen\nclear();\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does test organization work in Hemlock?", "output": "Clear test names:*\n\n```hemlock\ntest(\"returns null when key not found\", fn() { ... });\ntest(\"throws error on invalid input\", fn() { ... });\ntest(\"handles empty array correctly\", fn() { ... });\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does type annotations (optional) work in Hemlock?", "output": "```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hello\";\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does alloc work in Hemlock?", "output": "```hemlock\nlet p = alloc(1024);        // Allocate 1KB\nmemset(p, 0, 1024);         // Initialize to zero\nfree(p);                    // Free when done\n\n// Allocate for structure\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Implement a Hemlock program that test signal handling.", "output": "```hemlock\n// Test signal handling\n\n// Test signal constants exist\nprint(\"Testing signal constants:\");\nprint(SIGINT);\nprint(SIGTERM);\nprint(SIGUSR1);\nprint(SIGUSR2);\n\n// Test registering a signal handler (no closures - signal handlers are C callbacks)\nfn my_handler(signum) {\n    print(\"Handler called with signal:\");\n    print(signum);\n}\n\n// Register handler for SIGUSR1\nsignal(SIGUSR1, my_handler);\n\n// Raise SIGUSR1 multiple times\nprint(\"Raising SIGUSR1:\");\nraise(SIGUSR1);\nraise(SIGUSR1);\n\n// Test resetting handler to default\nsignal(SIGUSR1, null);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/signals.hml"}
{"instruction": "Show an example of example in Hemlock.", "output": "```hemlock\nimport { Queue } from \"@stdlib/collections\";\n\nlet q = Queue();\n\n// Enqueue items\nq.enqueue(\"first\");\nq.enqueue(\"second\");\nq.enqueue(\"third\");\n\n// Peek at front\nprint(q.peek());  // \"first\"\n\n// Dequeue items (FIFO order)\nprint(q.dequeue());  // \"first\"\nprint(q.dequeue());  // \"second\"\nprint(q.dequeue());  // \"third\"\n\n// Check if empty\nif (q.is_empty()) {\n    print(\"Queue is empty\");\n}\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "Write Hemlock code that alternation.", "output": "```hemlock\n// Test: Grouping and alternation\nimport { test } from \"@stdlib/regex\";\n\n// Alternation\nprint(test(\"^(cat|dog)$\", \"cat\", null));          // true\nprint(test(\"^(cat|dog)$\", \"dog\", null));          // true\nprint(test(\"^(cat|dog)$\", \"bird\", null));         // false\n\n// Grouping with quantifiers\nprint(test(\"^(ab)+$\", \"ab\", null));               // true\nprint(test(\"^(ab)+$\", \"abab\", null));             // true\nprint(test(\"^(ab)+$\", \"aba\", null));              // false\n\n// Complex alternation\nprint(test(\"^(http|https)://\", \"http://example.com\", null));   // true\nprint(test(\"^(http|https)://\", \"https://example.com\", null));  // true\nprint(test(\"^(http|https)://\", \"ftp://example.com\", null));    // false\n\n// Nested groups\nprint(test(\"^((ab|cd)+)$\", \"abcdab\", null));      // true\nprint(test(\"^((ab|cd)+)$\", \"abef\", null));        // false\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/grouping.hml"}
{"instruction": "How does test with raise() work in Hemlock?", "output": "```hemlock\nfn test_handler(sig) {\n    print(\"Test signal received: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// Test by manually raising\nraise(SIGUSR1);\nprint(\"Handler should have been called\");\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does .byte_length work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 byte per ASCII char)\n\nlet emoji = \"üöÄ\";\nprint(emoji.byte_length); // 4 (emoji is 4 UTF-8 bytes)\n\nlet text = \"Hello üåç!\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 for emoji)\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does command chaining work in Hemlock?", "output": "```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does creating a connection work in Hemlock?", "output": "```hemlock\nimport { WebSocket } from \"@stdlib/websocket\";\n\nlet ws = WebSocket(\"ws://echo.websocket.org\");\ndefer ws.close();\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does run(options?) work in Hemlock?", "output": "Execute all registered tests and print results.\n\n```hemlock\n// Basic usage\nlet results = run();\n\n// With options\nlet results = run({\n    verbose: true,    // Print errors inline\n    no_color: false   // Disable colored output\n});\n\n// Check if all tests passed\nif (!results.success) {\n    import { exit } from \"@stdlib/env\";\n    exit(1);\n}\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Show me Hemlock code that test resetting signal handler to default.", "output": "```hemlock\n// Test resetting signal handler to default\nlet count = 0;\n\nfn handler(sig) {\n    count = count + 1;\n}\n\n// Register handler\nsignal(SIGUSR1, handler);\n\n// Raise signal - should call handler\nraise(SIGUSR1);\nassert(count == 1);\n\n// Reset to default handler (null)\nsignal(SIGUSR1, null);\n\n// Raise signal again - handler should NOT be called\n// (Note: default handler for SIGUSR1 is to terminate, but since we reset it,\n//  the process will get the default behavior which we can't easily test here.\n//  So we'll just verify the signal() call works with null.)\n\nprint(\"PASS: reset_handler\");\n```", "category": "tests/signals", "source": "tests/signals/reset_handler.hml"}
{"instruction": "How does good use cases work in Hemlock?", "output": "3. Checking system state:*\n\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Disk usage:\\n\" + r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Write Hemlock code that tests conditional statements.", "output": "```hemlock\nlet x = 3;\nif (x > 5) {\n    print(1);\n} else {\n    print(2);\n}\n```", "category": "tests/control", "source": "tests/control/if_else.hml"}
{"instruction": "Write a Hemlock program that tests args ops.", "output": "```hemlock\n// Test: Perform operations with arguments\nif (args.length >= 3) {\n    let a = args[1];\n    let b = args[2];\n    print(\"First arg: \" + a);\n    print(\"Second arg: \" + b);\n    print(\"Combined: \" + a + \" \" + b);\n}\n```", "category": "tests/args", "source": "tests/args/args_ops.hml"}
{"instruction": "How does true parallelism work in Hemlock?", "output": "```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Sequential execution\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// Parallel execution\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// parallel_time should be ~50% of sequential_time on multi-core systems\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does string comparison work in Hemlock?", "output": "Strings are compared lexicographically:\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does floating-point types work in Hemlock?", "output": "```hemlock\nlet f: f32 = 3.14159;        // 32-bit float\nlet d: f64 = 2.718281828;    // 64-bit float (default)\nlet n: number = 1.618;       // Alias for f64\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does finally block work in Hemlock?", "output": "```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    // Always runs\n    if (file != null) {\n        file.close();\n    }\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Write Hemlock code that modifications in the spawned task should NOT affect the parent's copy.", "output": "```hemlock\n// Test: Arguments passed to spawn are deep-copied for thread isolation\n// Modifications in the spawned task should NOT affect the parent's copy\n\nasync fn modify_array(arr: array): array {\n    // Modify the array in the task\n    arr.push(999);\n    arr[0] = -1;\n    return arr;\n}\n\nasync fn modify_object(obj: object): object {\n    // Modify the object in the task\n    obj.modified = true;\n    obj.value = 42;\n    return obj;\n}\n\n// Test 1: Array isolation\nlet original_arr = [1, 2, 3];\nlet t1 = spawn(modify_array, original_arr);\nlet modified_arr = join(t1);\n\n// Original should be unchanged\nprint(original_arr.length);  // Should be 3\nprint(original_arr[0]);      // Should be 1\n\n// Modified should have changes\nprint(modified_arr.length);  // Should be 4\nprint(modified_arr[0]);      // Should be -1\n\n// Test 2: Object isolation\nlet original_obj = { value: 10, name: \"test\" };\nlet t2 = spawn(modify_object, original_obj);\nlet modified_obj = join(t2);\n\n// Original should be unchanged\nprint(original_obj.value);  // Should be 10\n\n// Modified should have changes\nprint(modified_obj.value);  // Should be 42\nprint(modified_obj.modified);  // Should be true\n\n// Test 3: Nested object isolation\nasync fn modify_nested(data: object): object {\n    data.inner.count = 100;\n    return data;\n}\n\nlet nested = { inner: { count: 0 } };\nlet t3 = spawn(modify_nested, nested);\nlet modified_nested = join(t3);\n\n// Original nested data should be unchanged\nprint(nested.inner.count);  // Should be 0\n\n// Modified should have changes\nprint(modified_nested.inner.count);  // Should be 100\n\nprint(\"All isolation tests passed!\");\n```", "category": "tests/async", "source": "tests/async/test_argument_isolation.hml"}
{"instruction": "How does runes (unicode codepoints) work in Hemlock?", "output": "```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = 'üöÄ';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Rune + String concatenation\nlet msg = '>' + \" Important\";\nprint(msg);  // \"> Important\"\n\n// Convert between rune and integer\nlet code: i32 = ch;     // 65 (ASCII code)\nlet r: rune = 128640;   // U+1F680 (üöÄ)\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does pointer types work in Hemlock?", "output": "```hemlock\nlet buf: buffer = buffer(64);\n// Bounds-checked, tracks length and capacity\nfree(buf);\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does other type inference work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Implement a Hemlock program that using 'array' without '<type>' should allow any element types.", "output": "```hemlock\n// Test: Explicit untyped array annotation with mixed types\n// Using 'array' without '<type>' should allow any element types\n\nlet arr: array = [\"yo\", 3.14, 42, true, null];\n\nprint(\"Length: \" + typeof(arr.length));  // 5\nprint(\"First: \" + arr[0]);               // \"yo\"\nprint(\"Second: \" + typeof(arr[1]));      // 3.14\nprint(\"Third: \" + typeof(arr[2]));       // 42\nprint(\"Fourth: \" + typeof(arr[3]));      // true\nprint(\"Fifth: \" + typeof(arr[4]));       // null\n\n// Should allow any type to be pushed\narr.push(\"another string\");\narr.push(999);\narr.push(false);\n\nprint(\"After push, length: \" + typeof(arr.length));  // 8\nprint(\"Sixth: \" + arr[5]);    // \"another string\"\nprint(\"Seventh: \" + typeof(arr[6]));  // 999\nprint(\"Eighth: \" + typeof(arr[7]));   // false\n\nprint(\"SUCCESS\");\n```", "category": "tests/typed_arrays", "source": "tests/typed_arrays/untyped_explicit.hml"}
{"instruction": "Show an example of example: building strings from runes in Hemlock.", "output": "```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('‚≠ê', 5);  // \"‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does parsewsurl work in Hemlock?", "output": "Parse WebSocket URL into components:\n\n```hemlock\nimport { parse_ws_url } from \"@stdlib/websocket\";\n\nlet parts = parse_ws_url(\"wss://example.com:8080/socket\");\n// {\n//     secure: true,\n//     host: \"example.com\",\n//     port: 8080,\n//     path: \"/socket\"\n// }\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does dynamic growth pattern work in Hemlock?", "output": "```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// ... use memory ...\n\n// Need more space - check for failure\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // Original pointer still valid, clean up\n    free(p);\n    panic(\"realloc failed\");\n}\np = new_p;\nsize = 200;\n\n// ... use expanded memory ...\n\nfree(p);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Create a Hemlock program that tests trim.", "output": "```hemlock\nlet s1 = \"  hello  \";\nprint(s1.trim());\n\nlet s2 = \"\\t\\nhello\\r\\n\";\nprint(s2.trim());\n\nlet s3 = \"no spaces\";\nprint(s3.trim());\n\nlet s4 = \"   \";\nprint(s4.trim());\n```", "category": "tests/strings", "source": "tests/strings/trim.hml"}
{"instruction": "How does lines(str) work in Hemlock?", "output": "Returns array with one element (the string itself) if no newlines\n\n```hemlock\nimport { lines } from \"@stdlib/strings\";\n\n// Basic line splitting\nlet l1 = lines(\"hello\\nworld\");\nprint(l1.length);   // 2\nprint(l1[0]);       // \"hello\"\nprint(l1[1]);       // \"world\"\n\n// Multiple lines\nlet l2 = lines(\"line1\\nline2\\nline3\");\nprint(l2.length);   // 3\n\n// Empty lines are preserved\nlet l3 = lines(\"a\\n\\nb\");\nprint(l3.length);   // 3\nprint(l3[1]);       // \"\" (empty line)\n\n// Single line (no newline)\nlet l4 = lines(\"hello\");\nprint(l4.length);   // 1\nprint(l4[0]);       // \"hello\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Implement a Hemlock program that test type mismatch when inserting into typed array.", "output": "```hemlock\n// Test type mismatch when inserting into typed array\n\nlet arr: array<string> = [\"hello\", \"world\"];\narr.insert(1, 123);  // Should error: type mismatch\n```", "category": "tests/typed_arrays", "source": "tests/typed_arrays/type_mismatch_insert_error.hml"}
{"instruction": "How does list_dir(path) work in Hemlock?", "output": "Throws:* Exception if directory doesn't exist or cannot be read\n\n```hemlock\nimport { list_dir } from \"@stdlib/fs\";\n\ntry {\n    let entries = list_dir(\".\");\n    print(\"Files in current directory:\");\n\n    let i = 0;\n    while (i < entries.length) {\n        print(\"  \" + entries[i]);\n        i = i + 1;\n    }\n} catch (e) {\n    print(\"Error listing directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does data transformation work in Hemlock?", "output": "```hemlock\nimport { parse, stringify, clone } from \"@stdlib/json\";\n\nlet input = parse(input_json);\n\n// Clone to avoid mutating original\nlet output = clone(input);\n\n// Transform data\nset(output, \"metadata.processed\", true);\nset(output, \"metadata.timestamp\", time());\n\n// Output as JSON\nlet result_json = stringify(output);\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "Create a Hemlock program that test comparison operations.", "output": "```hemlock\n// Test comparison operations\nlet a = 10;\nlet b = 5;\nlet c = 10;\n\nprint(a > b);\nprint(a < b);\nprint(a >= c);\nprint(a <= c);\nprint(a == c);\nprint(a != b);\n\n// Boolean comparisons\nprint(true == true);\nprint(true != false);\nprint(false == false);\n```", "category": "tests/compiler", "source": "tests/compiler/comparisons.hml"}
{"instruction": "How does boolean type work in Hemlock?", "output": "```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does function composition work in Hemlock?", "output": "```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Write Hemlock code that test primitive types and basic operations.", "output": "```hemlock\n// Test primitive types and basic operations\n\n// Integers\nlet a = 42;\nprint(a);\n\n// Floats\nlet b = 3.14;\nprint(b);\n\n// Booleans\nprint(true);\nprint(false);\n\n// Null\nprint(null);\n\n// Strings\nlet s = \"hello\";\nprint(s);\n\n// Arithmetic\nprint(10 + 5);\nprint(10 - 5);\nprint(10 * 5);\nprint(10 / 5);\nprint(10 % 3);\n\n// Comparisons\nprint(5 == 5);\nprint(5 != 3);\nprint(5 < 10);\nprint(5 > 3);\nprint(5 <= 5);\nprint(5 >= 5);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/primitives.hml"}
{"instruction": "Implement a Hemlock program that test while loop with break on first iteration Expected: PASS.", "output": "```hemlock\n// Test while loop with break on first iteration\n// Expected: PASS\n\nlet count = 0;\nwhile (true) {\n    count = count + 1;\n    break;\n}\n\nassert(count == 1, \"while with first iteration break should execute once\");\n\nprint(\"PASS\");\n```", "category": "tests/control", "source": "tests/control/edge_while_first_break.hml"}
{"instruction": "How does indentation work in Hemlock?", "output": "Hemlock doesn't enforce specific indentation, but 4 spaces is recommended:\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indented\");\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does return without value work in Hemlock?", "output": "return; without a value returns null:\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // Returns null\n    }\n    return value * 2;\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does string literals work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet escaped = \"line1\\nline2\\ttabbed\";\nlet quote = \"She said \\\"hello\\\"\";\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Implement a Hemlock program that deeply nested objects.", "output": "```hemlock\n// Deeply nested objects\nlet data = {\n    level1: {\n        level2: {\n            level3: {\n                value: 42,\n            },\n        },\n    },\n};\n\nprint(data.level1.level2.level3.value);\n```", "category": "tests/objects", "source": "tests/objects/nested_deep.hml"}
{"instruction": "Write a Hemlock example that demonstrates implements a countdown loop.", "output": "```hemlock\nlet n = 10;\nwhile (n > 0) {\n    print(n);\n    n = n - 1;\n}\nprint(n);\n```", "category": "examples", "source": "examples/countdown.hml"}
{"instruction": "How does unicode support work in Hemlock?", "output": "All functions are Unicode-aware and work with UTF-8 encoded strings:\n\n```hemlock\nimport { reverse, pad_left, pad_right, center } from \"@stdlib/strings\";\n\n// Reverse with emojis\nprint(reverse(\"Hello üåç\"));      // \"üåç olleH\"\nprint(reverse(\"üöÄüåüüí´\"));        // \"üí´üåüüöÄ\"\n\n// Reverse with CJK characters\nprint(reverse(\"‰Ω†Â•Ω\"));          // \"Â•Ω‰Ω†\"\nprint(reverse(\"„Åì„Çì„Å´„Å°„ÅØ\"));    // \"„ÅØ„Å°„Å´„Çì„Åì\"\n\n// Padding with Unicode\nlet s1 = pad_left(\"test\", 10, \"‚ñà\");\nprint(s1);  // \"‚ñà‚ñà‚ñà‚ñà‚ñà‚ñàtest\"\n\nlet s2 = pad_right(\"test\", 10, \"‚ñë\");\nprint(s2);  // \"test‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë\"\n\n// Centering with Unicode\nlet s3 = center(\"‰∏≠\", 5, \"‚îÄ\");\nprint(s3);  // \"‚îÄ‚îÄ‰∏≠‚îÄ‚îÄ\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does safe practices work in Hemlock?", "output": "4. Avoid exec() for file operations:*\n\n```hemlock\n// Bad - use exec for file operations\nlet r = exec(\"cat file.txt\");\n\n// Good - use Hemlock's file API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Implement a Hemlock program that tests basic shebang.", "output": "```hemlock\n#!/usr/bin/env hemlock\nlet x = 42;\nprint(x);\n```", "category": "tests/shebang", "source": "tests/shebang/basic_shebang.hml"}
{"instruction": "Create a Hemlock program that tests serialize nested.", "output": "```hemlock\n// Test: Nested object serialization\nlet inner = { a: 1, b: 2 };\nlet outer = { x: inner, y: 3 };\nprint(outer.serialize());\n```", "category": "tests/objects", "source": "tests/objects/serialize_nested.hml"}
{"instruction": "How does talloc work in Hemlock?", "output": "```hemlock\nlet arr = talloc(i32, 100);      // Array of 100 i32s (400 bytes)\nlet floats = talloc(f64, 50);    // Array of 50 f64s (400 bytes)\nlet bytes = talloc(u8, 1024);    // Array of 1024 bytes\n\n// Always check for allocation failure\nif (arr == null) {\n    panic(\"allocation failed\");\n}\n\n// Use the allocated memory\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Write Hemlock code that test channel timeout methods.", "output": "```hemlock\n// Test channel timeout methods\nprint(\"=== Channel Timeout Tests ===\");\n\n// Test recv_timeout - should return null on timeout\nlet ch = channel(1);\n\n// Channel is empty, recv_timeout should return null after 100ms\nlet result = ch.recv_timeout(100);\nprint(\"recv_timeout on empty channel:\");\nprint(result == null);\n\n// Now send a value and receive it with timeout\nch.send(42);\nlet val = ch.recv_timeout(100);\nprint(\"recv with value:\");\nprint(val);\n\nch.close();\n\n// Test send_timeout - should return false on timeout when channel is full\nlet ch2 = channel(1);\n\n// Fill the channel\nch2.send(\"first\");\n\n// Channel is full, send_timeout should return false after 100ms\nlet success = ch2.send_timeout(\"second\", 100);\nprint(\"send_timeout on full channel:\");\nprint(success);\n\n// Drain the channel and try again\nlet first = ch2.recv();\nprint(\"drained:\");\nprint(first);\n\nlet success2 = ch2.send_timeout(\"second\", 100);\nprint(\"send after drain:\");\nprint(success2);\n\nlet second = ch2.recv();\nprint(\"received:\");\nprint(second);\n\nch2.close();\nprint(\"=== Done ===\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/channel_timeout.hml"}
{"instruction": "How does floor division (div / divi) work in Hemlock?", "output": "For other rounding operations that return integers:\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// These can be used directly as array indices\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20 (index 1)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "Left Shift (<<)*\n\n```hemlock\nprint(a << 2);  // 48 (110000) - shift left by 2\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does sleep(seconds) work in Hemlock?", "output": "Animation timing\n\n```hemlock\nimport { sleep } from \"@stdlib/time\";\n\n// Sleep for 1 second\nsleep(1.0);\n\n// Sleep for half a second (500ms)\nsleep(0.5);\n\n// Sleep for 100 milliseconds\nsleep(0.1);\n\n// Sleep for 10 milliseconds\nsleep(0.01);\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "Show an example of bitwise examples in Hemlock.", "output": "Type preservation:*\n\n```hemlock\n// Bitwise operations preserve the type of operands\nlet x: u8 = 255;\nlet result = ~x;  // result is u8 with value 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 is i32 with value 400\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does split & trim work in Hemlock?", "output": "split(delimiter)* - Split into array of strings:\n\n```hemlock\nlet csv = \"apple,banana,cherry\";\nlet parts = csv.split(\",\");     // [\"apple\", \"banana\", \"cherry\"]\n\nlet words = \"one two three\".split(\" \");  // [\"one\", \"two\", \"three\"]\n\n// Empty delimiter splits by character\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does boolean literals work in Hemlock?", "output": "```hemlock\nlet t = true;\nlet f = false;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does is_macos() work in Hemlock?", "output": "Returns:* bool - true if on macOS, false otherwise\n\n```hemlock\nimport { is_macos } from \"@stdlib/os\";\n\nif (is_macos()) {\n    print(\"macOS-specific code here\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does pattern: partial application work in Hemlock?", "output": "```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does typed allocation work in Hemlock?", "output": "talloc(type, count)* allocates count elements of type:\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 bytes for 10 i32 values\nlet floats = talloc(f64, 5);  // 40 bytes for 5 f64 values\nfree(ints);\nfree(floats);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does signal counter work in Hemlock?", "output": "Track number of signals received:\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Received \" + typeof(signal_count) + \" signals\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// Later...\nprint(\"Total signals: \" + typeof(signal_count));\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Show an example of example: custom error types in Hemlock.", "output": "```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a must be a number\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b must be a number\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Cannot divide by zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does close files in reverse order of opening work in Hemlock?", "output": "```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... use files\n} finally {\n    // Close in reverse order\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Write Hemlock code that simple function test.", "output": "```hemlock\n// Simple function test\nfn square(x) {\n    return x * x;\n}\n\nprint(square(5));\n```", "category": "tests/manual", "source": "tests/manual/valgrind_test_simple_fn.hml"}
{"instruction": "How does nested objects work in Hemlock?", "output": "```hemlock\nlogger.error(\"API request failed\", {\n    endpoint: \"/api/users\",\n    status: 500,\n    error: {\n        code: \"TIMEOUT\",\n        message: \"Request timed out after 30s\",\n        retry_count: 3\n    }\n});\n\n// Output includes nested JSON\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does .length work in Hemlock?", "output": "```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Implement a Hemlock program that tests int to float.", "output": "```hemlock\nlet x: i32 = 5;\nlet y: f64 = 3.14;\nlet z = x + y;\nprint(z);\n```", "category": "tests/conversions", "source": "tests/conversions/int_to_float.hml"}
{"instruction": "Implement a Hemlock program that assigning to existing field.", "output": "```hemlock\n// Assigning to existing field\nlet obj = { x: 10, y: 20 };\nprint(obj.x);\nobj.x = 99;\nprint(obj.x);\n```", "category": "tests/objects", "source": "tests/objects/field_assign_existing.hml"}
{"instruction": "How does type checking work in Hemlock?", "output": "```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // Promotes to f64, returns f64\nadd(\"a\", \"b\");     // Runtime error: type mismatch\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show me Hemlock code that test channel operations on closed channel Expected: PASS (testing expected behavior).", "output": "```hemlock\n// Test channel operations on closed channel\n// Expected: PASS (testing expected behavior)\n\nlet ch = channel(5);\n\n// Send some values\nch.send(1);\nch.send(2);\nch.send(3);\n\n// Close the channel\nch.close();\n\n// Try to send on closed channel - should error\ntry {\n    ch.send(4);\n    print(\"ERROR: send on closed channel should fail\");\n} catch (e) {\n    print(\"Caught send on closed: \" + e);\n}\n\n// Receive from closed channel with data should work\nlet v1 = ch.recv();\nprint(\"Received from closed channel with data: \" + typeof(v1));\n\nlet v2 = ch.recv();\nprint(\"Received: \" + typeof(v2));\n\nlet v3 = ch.recv();\nprint(\"Received: \" + typeof(v3));\n\n// Receive from closed, empty channel should return null\nlet v4 = ch.recv();\nif (v4 == null) {\n    print(\"Received null from closed empty channel\");\n} else {\n    print(\"Received: \" + typeof(v4));\n}\n\n// Close already closed channel - test behavior\ntry {\n    ch.close();\n    print(\"Closing already closed channel did not error\");\n} catch (e) {\n    print(\"Caught close on closed: \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/async", "source": "tests/async/edge_channel_closed.hml"}
{"instruction": "Implement a Hemlock program that collections test.", "output": "```hemlock\n// Collections test\nimport { HashMap, Set, Stack, Queue } from \"@stdlib/collections\";\n\n// HashMap\nlet map = HashMap();\nmap.set(\"a\", 1);\nmap.set(\"b\", 2);\nmap.set(\"c\", 3);\nprint(map.get(\"a\"));\nprint(map.get(\"b\"));\nprint(map.has(\"c\"));\nprint(map.has(\"d\"));\nprint(map.size);\n\n// Set\nlet s = Set();\ns.add(1);\ns.add(2);\ns.add(3);\ns.add(2);  // duplicate\nprint(s.has(1));\nprint(s.has(4));\nprint(s.size);\n\n// Stack\nlet stack = Stack();\nstack.push(10);\nstack.push(20);\nstack.push(30);\nprint(stack.pop());\nprint(stack.pop());\nprint(stack.size);\n\n// Queue\nlet q = Queue();\nq.enqueue(100);\nq.enqueue(200);\nq.enqueue(300);\nprint(q.dequeue());\nprint(q.dequeue());\nprint(q.size);\n```", "category": "tests/parity", "source": "tests/parity/modules/stdlib_collections.hml"}
{"instruction": "Create a Hemlock program that tests i16 valid.", "output": "```hemlock\nlet a: i16 = -32768;\nlet b: i16 = 32767;\nlet c: i16 = 100;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/primitives", "source": "tests/primitives/i16_valid.hml"}
{"instruction": "How does memory functions work in Hemlock?", "output": "```hemlock\n// Reallocate\nlet p = alloc(64);\np = realloc(p, 128);  // Resize to 128 bytes\nfree(p);\n\n// Typed allocation (future)\n// let arr = talloc(i32, 100);  // Array of 100 i32s\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Implement a Hemlock program that factorial recursion.", "output": "```hemlock\n// Factorial recursion\nfn factorial(n) {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));\n```", "category": "tests/functions", "source": "tests/functions/factorial.hml"}
{"instruction": "How does file_stat(path) work in Hemlock?", "output": "is_dir: bool - True if directory\n\n```hemlock\nimport { file_stat } from \"@stdlib/fs\";\n\ntry {\n    let info = file_stat(\"data.txt\");\n\n    print(\"Size: \" + typeof(info.size) + \" bytes\");\n    print(\"Modified: \" + typeof(info.mtime));\n    print(\"Is file: \" + typeof(info.is_file));\n    print(\"Is directory: \" + typeof(info.is_dir));\n} catch (e) {\n    print(\"Error getting file info: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "```hemlock\nimport { get, is_success, is_client_error } from \"@stdlib/http\";\n\ntry {\n    let response = get(\"https://httpbin.org/status/404\", null);\n\n    if (is_success(response.status_code)) {\n        print(\"Success: \" + response.body);\n    } else if (is_client_error(response.status_code)) {\n        print(\"Client error: HTTP \" + typeof(response.status_code));\n    } else {\n        print(\"Error: HTTP \" + typeof(response.status_code));\n    }\n} catch (e) {\n    print(\"Request failed: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does raising signals manually work in Hemlock?", "output": "Send signals to your own process:\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// Trigger handler manually\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does script name included work in Hemlock?", "output": "args[0] always contains the script path/name:\n\n```hemlock\nprint(\"Running: \" + args[0]);\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Create a Hemlock program that test basic modulo operator with i32.", "output": "```hemlock\n// Test basic modulo operator with i32\nlet a = 10 % 3;\nprint(a);  // 1\n\nlet b = 15 % 4;\nprint(b);  // 3\n\nlet c = 20 % 5;\nprint(c);  // 0\n\nlet d = 7 % 2;\nprint(d);  // 1\n\nlet e = 100 % 7;\nprint(e);  // 2\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_basic.hml"}
{"instruction": "How does no select() for multiplexing work in Hemlock?", "output": "Workaround:* Use separate tasks per channel:\n\n```hemlock\nasync fn monitor_ch1(ch1, result_ch) {\n    let val = ch1.recv();\n    result_ch.send({ channel: 1, value: val });\n}\n\n// Similar for ch2, ch3...\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does tarreader(data) -> object work in Hemlock?", "output": "```hemlock\nimport { TarReader, TAR_TYPE_FILE, TAR_TYPE_DIRECTORY } from \"@stdlib/compression\";\n\n// Read tar file\nlet f = open(\"archive.tar\", \"r\");\nlet content = f.read();\nf.close();\n\n// Convert to buffer\nlet bytes = content.bytes();\nlet buf = buffer(bytes.length);\nlet i = 0;\nwhile (i < bytes.length) {\n    buf[i] = bytes[i];\n    i = i + 1;\n}\n\n// Parse archive\nlet reader = TarReader(buf);\n\n// List contents\nprint(\"Files in archive:\");\nlet names = reader.list();\ni = 0;\nwhile (i < names.length) {\n    print(\"  \" + names[i]);\n    i = i + 1;\n}\n\n// Get specific file\nlet readme = reader.get(\"myproject/README.md\");\nif (readme != null) {\n    print(\"README content:\");\n    print(readme.content);\n}\n\n// Iterate all entries\nlet entries = reader.entries();\ni = 0;\nwhile (i < entries.length) {\n    let entry = entries[i];\n    if (entry.type == TAR_TYPE_FILE) {\n        print(\"File: \" + entry.name + \" (\" + typeof(entry.size) + \" bytes)\");\n    } else if (entry.type == TAR_TYPE_DIRECTORY) {\n        print(\"Dir: \" + entry.name);\n    }\n    i = i + 1;\n}\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "Write a Hemlock program that test Base64 encoding and decoding.", "output": "```hemlock\n// Test Base64 encoding and decoding\n\nimport { base64_encode, base64_decode } from \"@stdlib/encoding\";\n\n// Test 1: Empty string\nlet encoded1 = base64_encode(\"\");\nif (encoded1 != \"\") {\n    throw \"Empty string should encode to empty string\";\n}\nlet decoded1 = base64_decode(\"\");\nif (decoded1 != \"\") {\n    throw \"Empty string should decode to empty string\";\n}\nprint(\"‚úì Test 1: Empty string\");\n\n// Test 2: Single character\nlet encoded2 = base64_encode(\"A\");\nif (encoded2 != \"QQ==\") {\n    throw \"Failed to encode 'A', got: \" + encoded2;\n}\nlet decoded2 = base64_decode(\"QQ==\");\nif (decoded2 != \"A\") {\n    throw \"Failed to decode 'QQ==', got: \" + decoded2;\n}\nprint(\"‚úì Test 2: Single character\");\n\n// Test 3: Two characters\nlet encoded3 = base64_encode(\"AB\");\nif (encoded3 != \"QUI=\") {\n    throw \"Failed to encode 'AB', got: \" + encoded3;\n}\nlet decoded3 = base64_decode(\"QUI=\");\nif (decoded3 != \"AB\") {\n    throw \"Failed to decode 'QUI=', got: \" + decoded3;\n}\nprint(\"‚úì Test 3: Two characters\");\n\n// Test 4: Three characters (no padding)\nlet encoded4 = base64_encode(\"ABC\");\nif (encoded4 != \"QUJD\") {\n    throw \"Failed to encode 'ABC', got: \" + encoded4;\n}\nlet decoded4 = base64_decode(\"QUJD\");\nif (decoded4 != \"ABC\") {\n    throw \"Failed to decode 'QUJD', got: \" + decoded4;\n}\nprint(\"‚úì Test 4: Three characters\");\n\n// Test 5: Standard test vector \"Hello, World!\"\nlet encoded5 = base64_encode(\"Hello, World!\");\nif (encoded5 != \"SGVsbG8sIFdvcmxkIQ==\") {\n    throw \"Failed to encode 'Hello, World!', got: \" + encoded5;\n}\nlet decoded5 = base64_decode(\"SGVsbG8sIFdvcmxkIQ==\");\nif (decoded5 != \"Hello, World!\") {\n    throw \"Failed to decode 'SGVsbG8sIFdvcmxkIQ==', got: \" + decoded5;\n}\nprint(\"‚úì Test 5: Hello, World!\");\n\n// Test 6: Longer text\nlet text6 = \"The quick brown fox jumps over the lazy dog\";\nlet encoded6 = base64_encode(text6);\nlet decoded6 = base64_decode(encoded6);\nif (decoded6 != text6) {\n    throw \"Failed round-trip for longer text\";\n}\nprint(\"‚úì Test 6: Longer text round-trip\");\n\n// Test 7: ASCII printable and control characters (bytes 1-127)\n// Note: byte 0 (null) cannot be stored in strings due to C string termination\n// Note: bytes 128-255 alone are not valid UTF-8 and cause multi-byte expansion\nlet binary7 = \"\";\nlet i = 1;\nwhile (i < 128) {\n    let byte_char: rune = i;\n    binary7 = binary7 + byte_char;\n    i = i + 1;\n}\nlet encoded7 = base64_encode(binary7);\nlet decoded7 = base64_decode(encoded7);\nif (decoded7.length != binary7.length) {\n    throw \"Binary data length mismatch: original=\" + binary7.length + \" decoded=\" + decoded7.length;\n}\nprint(\"‚úì Test 7: ASCII characters (bytes 1-127)\");\n\n// Test 8: Special characters\nlet text8 = \"Hello\\nWorld\\t!\\r\\n\";\nlet encoded8 = base64_encode(text8);\nlet decoded8 = base64_decode(encoded8);\nif (decoded8 != text8) {\n    throw \"Failed round-trip for special characters\";\n}\nprint(\"‚úì Test 8: Special characters\");\n\n// Test 9: Numbers and symbols\nlet text9 = \"0123456789!@#$%^&*()\";\nlet encoded9 = base64_encode(text9);\nlet decoded9 = base64_decode(encoded9);\nif (decoded9 != text9) {\n    throw \"Failed round-trip for numbers and symbols\";\n}\nprint(\"‚úì Test 9: Numbers and symbols\");\n\n// Test 10: Unicode (UTF-8)\n// Note: Due to byte-by-byte string reconstruction in decode, multi-byte UTF-8\n// characters don't round-trip correctly. This is a known limitation.\n// For now, we just verify encode/decode doesn't crash\nlet text10 = \"Hello ‰∏ñÁïå üöÄ\";\nlet encoded10 = base64_encode(text10);\nlet decoded10 = base64_decode(encoded10);\n// Skip exact comparison due to UTF-8 reconstruction limitation\nprint(\"‚úì Test 10: Unicode (UTF-8) - encoding works (decode has known limitation)\");\n\n// Test 11: Multiple padding scenarios\nlet test11a = base64_encode(\"a\");\nlet test11b = base64_encode(\"ab\");\nlet test11c = base64_encode(\"abc\");\nlet test11d = base64_encode(\"abcd\");\nif (base64_decode(test11a) != \"a\") { throw \"Failed 1-byte padding\"; }\nif (base64_decode(test11b) != \"ab\") { throw \"Failed 2-byte padding\"; }\nif (base64_decode(test11c) != \"abc\") { throw \"Failed 3-byte padding\"; }\nif (base64_decode(test11d) != \"abcd\") { throw \"Failed 4-byte padding\"; }\nprint(\"‚úì Test 11: Multiple padding scenarios\");\n\nprint(\"\\n‚úÖ All Base64 tests passed!\");\n```", "category": "tests/stdlib_encoding", "source": "tests/stdlib_encoding/test_base64.hml"}
{"instruction": "Create a Hemlock program that test switch with boolean values.", "output": "```hemlock\n// Test switch with boolean values\n\nfn check_condition(flag: bool) {\n    switch (flag) {\n        case true:\n            print(\"condition is true\");\n            break;\n        case false:\n            print(\"condition is false\");\n            break;\n    }\n}\n\ncheck_condition(true);\ncheck_condition(false);\n\n// Test boolean expressions\nlet x = 10;\nswitch (x > 5) {\n    case true:\n        print(\"x is greater than 5\");\n        break;\n    case false:\n        print(\"x is not greater than 5\");\n        break;\n}\n\n// Expected output:\n// condition is true\n// condition is false\n// x is greater than 5\n```", "category": "tests/switch", "source": "tests/switch/boolean.hml"}
{"instruction": "How does basic type definition work in Hemlock?", "output": "Define object shapes with define:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Create object and assign to typed variable\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Duck typing validates structure\n\nprint(typeof(typed_p));  // \"Person\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Implement a Hemlock program that tests the print function.", "output": "```hemlock\n// Test: Print all command line arguments\nlet i = 0;\nwhile (i < args.length) {\n    print(args[i]);\n    i = i + 1;\n}\n```", "category": "tests/args", "source": "tests/args/print_args.hml"}
{"instruction": "Write Hemlock code that test terminal color constants and functions.", "output": "```hemlock\n// Test terminal color constants and functions\nimport {\n    RED, GREEN, BLUE, YELLOW, CYAN, MAGENTA, WHITE, BLACK,\n    BRIGHT_RED, BRIGHT_GREEN, BRIGHT_BLUE, GRAY,\n    BG_RED, BG_GREEN, BG_BLUE, BG_YELLOW,\n    RESET, color, color_bg, rgb, bg_rgb, color_256, bg_color_256\n} from \"@stdlib/terminal\";\n\nprint(\"=== Terminal Color Tests ===\");\nprint(\"\");\n\n// Test basic colors\nprint(\"Basic Colors:\");\nprint(RED + \"Red text\" + RESET);\nprint(GREEN + \"Green text\" + RESET);\nprint(BLUE + \"Blue text\" + RESET);\nprint(YELLOW + \"Yellow text\" + RESET);\nprint(CYAN + \"Cyan text\" + RESET);\nprint(MAGENTA + \"Magenta text\" + RESET);\nprint(WHITE + \"White text\" + RESET);\n\nprint(\"\");\n\n// Test bright colors\nprint(\"Bright Colors:\");\nprint(BRIGHT_RED + \"Bright red\" + RESET);\nprint(BRIGHT_GREEN + \"Bright green\" + RESET);\nprint(BRIGHT_BLUE + \"Bright blue\" + RESET);\nprint(GRAY + \"Gray text\" + RESET);\n\nprint(\"\");\n\n// Test background colors\nprint(\"Background Colors:\");\nprint(WHITE + BG_RED + \" White on red \" + RESET);\nprint(WHITE + BG_GREEN + \" White on green \" + RESET);\nprint(WHITE + BG_BLUE + \" White on blue \" + RESET);\nprint(BLACK + BG_YELLOW + \" Black on yellow \" + RESET);\n\nprint(\"\");\n\n// Test color() function\nprint(\"color() function:\");\nprint(color(\"Error message\", RED));\nprint(color(\"Success message\", GREEN));\nprint(color(\"Info message\", BLUE));\n\nprint(\"\");\n\n// Test color_bg() function\nprint(\"color_bg() function:\");\nprint(color_bg(\" ERROR \", WHITE, BG_RED));\nprint(color_bg(\" SUCCESS \", WHITE, BG_GREEN));\nprint(color_bg(\" INFO \", WHITE, BG_BLUE));\n\nprint(\"\");\n\n// Test RGB colors (24-bit)\nprint(\"RGB Colors (24-bit true color):\");\nprint(rgb(255, 100, 50) + \"Custom orange\" + RESET);\nprint(rgb(75, 0, 130) + \"Indigo\" + RESET);\nprint(rgb(255, 20, 147) + \"Deep pink\" + RESET);\n\nprint(\"\");\n\n// Test RGB background\nprint(\"RGB Background:\");\nprint(rgb(255, 255, 255) + bg_rgb(255, 0, 0) + \" White on red \" + RESET);\nprint(rgb(0, 0, 0) + bg_rgb(0, 255, 0) + \" Black on green \" + RESET);\n\nprint(\"\");\n\n// Test 256-color palette\nprint(\"256-Color Palette:\");\nprint(color_256(196) + \"Color 196 (bright red)\" + RESET);\nprint(color_256(21) + \"Color 21 (deep blue)\" + RESET);\nprint(color_256(226) + \"Color 226 (yellow)\" + RESET);\nprint(bg_color_256(240) + \"Background color 240\" + RESET);\n\nprint(\"\");\nprint(\"‚úì All color tests completed\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/test_colors.hml"}
{"instruction": "Create a Hemlock program that test math module rounding functions.", "output": "```hemlock\n// Test math module rounding functions\n\nimport * as math from \"@stdlib/math\";\n\n// Test floor\nassert(math.floor(3.7) == 3.0, \"floor(3.7) should be 3\");\nassert(math.floor(3.2) == 3.0, \"floor(3.2) should be 3\");\nassert(math.floor(-2.3) == -3.0, \"floor(-2.3) should be -3\");\nassert(math.floor(5.0) == 5.0, \"floor(5.0) should be 5\");\n\n// Test ceil\nassert(math.ceil(3.2) == 4.0, \"ceil(3.2) should be 4\");\nassert(math.ceil(3.7) == 4.0, \"ceil(3.7) should be 4\");\nassert(math.ceil(-2.3) == -2.0, \"ceil(-2.3) should be -2\");\nassert(math.ceil(5.0) == 5.0, \"ceil(5.0) should be 5\");\n\n// Test round\nassert(math.round(3.2) == 3.0, \"round(3.2) should be 3\");\nassert(math.round(3.7) == 4.0, \"round(3.7) should be 4\");\nassert(math.round(3.5) == 4.0, \"round(3.5) should be 4\");\nassert(math.round(-2.3) == -2.0, \"round(-2.3) should be -2\");\nassert(math.round(-2.7) == -3.0, \"round(-2.7) should be -3\");\nassert(math.round(5.0) == 5.0, \"round(5.0) should be 5\");\n\n// Test trunc\nassert(math.trunc(3.7) == 3.0, \"trunc(3.7) should be 3\");\nassert(math.trunc(3.2) == 3.0, \"trunc(3.2) should be 3\");\nassert(math.trunc(-2.7) == -2.0, \"trunc(-2.7) should be -2\");\nassert(math.trunc(-2.2) == -2.0, \"trunc(-2.2) should be -2\");\nassert(math.trunc(5.0) == 5.0, \"trunc(5.0) should be 5\");\n\nprint(\"All rounding function tests passed!\");\n```", "category": "tests/stdlib_math", "source": "tests/stdlib_math/test_rounding.hml"}
{"instruction": "How does is_whitespace(str) work in Hemlock?", "output": "Carriage return (U+000D)\n\n```hemlock\nimport { is_whitespace } from \"@stdlib/strings\";\n\nprint(is_whitespace(\" \"));       // true\nprint(is_whitespace(\"   \"));     // true\nprint(is_whitespace(\"\\t\"));      // true\nprint(is_whitespace(\"\\n\"));      // true\nprint(is_whitespace(\"\\r\"));      // true\nprint(is_whitespace(\" \\t\\n\"));   // true\n\nprint(is_whitespace(\"hello\"));   // false\nprint(is_whitespace(\" a \"));     // false\nprint(is_whitespace(\"\"));        // false (empty)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does ‚ùå discouraged contributions work in Hemlock?", "output": "2. RAII/destructors*\n\n```hemlock\n// BAD: This would be rejected\nlet f = open(\"file.txt\");\n// File automatically closed at end of scope\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does memory management work in Hemlock?", "output": "```hemlock\n// Remember to free allocated memory\nlet ptr = c_malloc(1024);\n// ... use ptr\nc_free(ptr);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does float literals work in Hemlock?", "output": "```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;  // Not yet supported\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does hello world work in Hemlock?", "output": "Let's start with the traditional first program:\n\n```hemlock\nprint(\"Hello, World!\");\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How do you pitfall: using panic for expected errors in Hemlock?", "output": "```hemlock\n// BAD: Panic for expected error\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Config file not found\");  // ‚ùå Too harsh\n    }\n    return read_file(path);\n}\n\n// GOOD: Throw for expected error\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Config file not found: \" + path;  // ‚úÖ Recoverable\n    }\n    return read_file(path);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    print(\"Done\");\n}\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All functions throw exceptions for invalid input:\n\n```hemlock\nimport { pad_left, is_alpha, reverse } from \"@stdlib/strings\";\n\n// Invalid fill character length\ntry {\n    pad_left(\"test\", 10, \"ab\");  // Must be single character\n} catch (e) {\n    print(\"Error: \" + e);  // \"pad_left() fill must be single character\"\n}\n\n// Invalid type\ntry {\n    is_alpha(123);  // Must be string\n} catch (e) {\n    print(\"Error: \" + e);  // \"is_alpha() requires string argument\"\n}\n\n// Invalid type\ntry {\n    reverse(null);\n} catch (e) {\n    print(\"Error: \" + e);  // \"reverse() requires string argument\"\n}\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "Write a Hemlock program that spawns and joins many tasks to verify no memory leaks.", "output": "```hemlock\n// Test: Memory leak detection with many spawn/join cycles\n// Spawns and joins many tasks to verify no memory leaks\n\nasync fn simple_task(id: i32): i32 {\n    return id * 2;\n}\n\n// Run multiple batches of tasks\nlet num_batches = 50;\nlet tasks_per_batch = 20;\nlet batch = 0;\nlet total_sum = 0;\n\nwhile (batch < num_batches) {\n    let tasks = [];\n    let i = 0;\n\n    // Spawn batch of tasks\n    while (i < tasks_per_batch) {\n        tasks.push(spawn(simple_task, batch * tasks_per_batch + i));\n        i = i + 1;\n    }\n\n    // Join all tasks in this batch\n    i = 0;\n    while (i < tasks.length) {\n        let result = join(tasks[i]);\n        total_sum = total_sum + result;\n        i = i + 1;\n    }\n\n    batch = batch + 1;\n}\n\nprint(\"Batches:\");\nprint(num_batches);\nprint(\"Tasks per batch:\");\nprint(tasks_per_batch);\nprint(\"Total tasks:\");\nprint(num_batches * tasks_per_batch);\nprint(\"Total sum:\");\nprint(total_sum);\n```", "category": "tests/async", "source": "tests/async/stress_memory_leak.hml"}
{"instruction": "How does unary bitwise work in Hemlock?", "output": "```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (two's complement)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Show me Hemlock code that tests append.", "output": "```hemlock\n// Test: Append to file\nlet f1 = open(\"tests/temp/test_append.txt\", \"w\");\nf1.write(\"First line\\n\");\nf1.close();\n\nlet f2 = open(\"tests/temp/test_append.txt\", \"a\");\nf2.write(\"Second line\\n\");\nf2.close();\n\nlet f3 = open(\"tests/temp/test_append.txt\", \"a\");\nf3.write(\"Third line\\n\");\nf3.close();\n\nlet f4 = open(\"tests/temp/test_append.txt\", \"r\");\nlet content = f4.read();\nf4.close();\nprint(content);\n```", "category": "tests/io", "source": "tests/io/append.hml"}
{"instruction": "How does try/catch work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Write Hemlock code that string operations test.", "output": "```hemlock\n// String operations test\nlet s = \"hello\";\nlet s2 = s.to_upper();\nlet s3 = s2 + \" world\";\nlet parts = s3.split(\" \");\nprint(parts[0]);\n```", "category": "tests/manual", "source": "tests/manual/valgrind_test_strings.hml"}
{"instruction": "How does no stderr capture work in Hemlock?", "output": "Workaround - redirect stderr to stdout:*\n\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// Now error messages are in r.output\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Create a Hemlock program that tests assertions.", "output": "```hemlock\n// Test: Assert with different numeric types\nlet x: i32 = 10;\nassert(x);\nprint(\"i32 assertion passed\");\n\nlet y: u8 = 0;\ntry {\n    assert(y);\n} catch (e) {\n    print(\"u8 zero caught: \" + e);\n}\n\nlet z: f64 = 3.14;\nassert(z);\nprint(\"f64 assertion passed\");\n\nlet w: f32 = 0.0;\ntry {\n    assert(w);\n} catch (e) {\n    print(\"f32 zero caught: \" + e);\n}\n\n// Test: Assert with objects (always truthy)\nlet obj = { x: 10, y: 20 };\nassert(obj);\nprint(\"object assertion passed\");\n\n// Test: Assert with arrays (always truthy)\nlet arr = [1, 2, 3];\nassert(arr);\nprint(\"array assertion passed\");\n\n// Test: Assert with functions (always truthy)\nlet func = fn() { return 42; };\nassert(func);\nprint(\"function assertion passed\");\n\n// Test: Assert in functions\nfn check_positive(n) {\n    assert(n > 0, \"number must be positive\");\n    return n * 2;\n}\n\nprint(check_positive(5));\n\ntry {\n    check_positive(-1);\n} catch (e) {\n    print(\"Caught in function: \" + e);\n}\n\n// Test: Assert with comparison expressions\nlet a = 10;\nlet b = 20;\nassert(b > a);\nprint(\"comparison assertion passed\");\n\ntry {\n    assert(a > b);\n} catch (e) {\n    print(\"comparison failed: \" + e);\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/assert_types.hml"}
{"instruction": "How does integer literal inference work in Hemlock?", "output": "Hemlock infers integer types based on value range:\n\n```hemlock\nlet a = 42;              // i32 (fits in 32-bit)\nlet b = 5000000000;      // i64 (> i32 max)\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8 (explicit annotation)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does performance tips work in Hemlock?", "output": "Reuse compiled patterns:* If testing the same pattern multiple times, compile once and reuse:\n\n```hemlock\n// Good: Compile once\n   let pattern = compile(\"test\");\n   pattern.test(text1);\n   pattern.test(text2);\n   pattern.free();\n\n   // Bad: Compile every time\n   test(\"test\", text1);\n   test(\"test\", text2);\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Write a Hemlock program that create basic logger.", "output": "```hemlock\n// Test: Basic logging to stdout\nimport { Logger, DEBUG, INFO, WARN, ERROR } from \"@stdlib/logging\";\n\n// Create basic logger\nlet logger = Logger();\n\n// Test all log levels\nlogger.debug(\"This is a debug message\");\nlogger.info(\"This is an info message\");\nlogger.warn(\"This is a warning message\");\nlogger.error(\"This is an error message\");\n\n// Test with different message types\nlogger.info(42);\nlogger.info(3.14);\nlogger.info(true);\nlogger.info(false);\nlogger.info(null);\n\n// Test with arrays\nlogger.info([1, 2, 3]);\nlogger.info([\"a\", \"b\", \"c\"]);\n\nprint(\"PASS: Basic logging test completed\");\n```", "category": "tests/stdlib_logging", "source": "tests/stdlib_logging/basic.hml"}
{"instruction": "Show me Hemlock code that tests char at.", "output": "```hemlock\nlet s = \"hello\";\nprint(s.char_at(0));\nprint(s.char_at(4));\nprint(s[0]);\nprint(s[4]);\n```", "category": "tests/strings", "source": "tests/strings/char_at.hml"}
{"instruction": "Show me Hemlock code that tests panic nonstring error.", "output": "```hemlock\n// Test: panic() with non-string value (integer)\nprint(\"before panic\");\npanic(42);\nprint(\"after panic\");  // Should never execute\n```", "category": "tests/exceptions", "source": "tests/exceptions/panic_nonstring_error.hml"}
{"instruction": "How does supports_color() work in Hemlock?", "output": "Returns:* bool - True if colors are supported\n\n```hemlock\nimport { supports_color, RED, RESET } from \"@stdlib/terminal\";\n\nif (supports_color()) {\n    print(RED + \"Colored output!\" + RESET);\n} else {\n    print(\"No color support\");\n}\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does log(x) work in Hemlock?", "output": "Returns:* f64 - ln(x)\n\n```hemlock\nimport { log, E } from \"@stdlib/math\";\n\nlet result = log(1.0);  // 0.0\nlet result2 = log(E);   // 1.0\nlet result3 = log(10.0); // 2.302585...\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does array transformation work in Hemlock?", "output": "```hemlock\n// Filter (manual)\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// Map (manual)\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Create a Hemlock program that tests u8 to i32.", "output": "```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;\nprint(c);\n```", "category": "tests/conversions", "source": "tests/conversions/u8_to_i32.hml"}
{"instruction": "How does syntax work in Hemlock?", "output": "Try/catch/finally:*\n\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error\n} finally {\n    // cleanup code\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Create a Hemlock program that test time builtins.", "output": "```hemlock\n// Test time builtins\n\n// now() returns a timestamp\nlet t = now();\nprint(t > 0);\n\n// time_ms() returns milliseconds\nlet ms = time_ms();\nprint(ms > 0);\n\n// clock() returns CPU time\nlet c = clock();\nprint(c >= 0.0);\n\n// Test sleep with tiny duration (0.001 seconds = 1ms)\nlet before = time_ms();\nsleep(0.001);\nlet after = time_ms();\n// After should be >= before (sleep may wake up early)\nprint(after >= before);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/time_builtins.hml"}
{"instruction": "How does typeof work in Hemlock?", "output": "```hemlock\ntypeof(value: any): string\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does chained conversions work in Hemlock?", "output": "Type conversions can be chained:\n\n```hemlock\n// i32 ‚Üí rune ‚Üí string\nlet code: i32 = 128512;         // Grinning face codepoint\nlet r: rune = code;             // üòÄ\nlet s: string = r;              // \"üòÄ\"\n\n// All in one expression\nlet emoji: string = 128640;     // Implicit i32 ‚Üí rune ‚Üí string (üöÄ)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Create a Hemlock program that test terminal screen control.", "output": "```hemlock\n// Test terminal screen control\nimport {\n    CLEAR_SCREEN, CLEAR_TO_END, CLEAR_LINE, CLEAR_LINE_TO_END,\n    scroll_up, scroll_down, clear\n} from \"@stdlib/terminal\";\n\n// ESC character for testing\nlet ESC: rune = 27;\nlet ESC_STR: string = ESC;\n\nprint(\"=== Terminal Screen Tests ===\");\nprint(\"\");\n\n// Test clear constants\nprint(\"Testing clear constants:\");\nif (CLEAR_SCREEN.contains(ESC_STR + \"[2J\")) {\n    print(\"‚úì CLEAR_SCREEN correct\");\n}\nif (CLEAR_TO_END.contains(ESC_STR + \"[0J\")) {\n    print(\"‚úì CLEAR_TO_END correct\");\n}\nif (CLEAR_LINE.contains(ESC_STR + \"[2K\")) {\n    print(\"‚úì CLEAR_LINE correct\");\n}\nif (CLEAR_LINE_TO_END.contains(ESC_STR + \"[0K\")) {\n    print(\"‚úì CLEAR_LINE_TO_END correct\");\n}\n\nprint(\"\");\n\n// Test scroll functions\nprint(\"Testing scroll functions:\");\nlet up = scroll_up(3);\nlet down = scroll_down(2);\n\nif (up.contains(ESC_STR + \"[3S\")) {\n    print(\"‚úì scroll_up(3) correct\");\n}\nif (down.contains(ESC_STR + \"[2T\")) {\n    print(\"‚úì scroll_down(2) correct\");\n}\n\nprint(\"\");\n\n// Test clear() function\nprint(\"Testing clear() function:\");\nprint(\"(Would clear screen if not in test mode)\");\nprint(\"‚úì clear() function exists\");\n\nprint(\"\");\nprint(\"‚úì All screen tests completed\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/test_screen.hml"}
{"instruction": "How does receiving messages work in Hemlock?", "output": "Blocking receive:*\n\n```hemlock\nlet msg = ws.recv(-1);  // Block forever\nif (msg != null && msg.type == \"text\") {\n    print(\"Received: \" + msg.data);\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Write Hemlock code that methods with different return types.", "output": "```hemlock\n// Methods with different return types\nlet obj = {\n    num: 42,\n    str: \"hello\",\n    getNum: fn() {\n        return self.num;\n    },\n    getStr: fn() {\n        return self.str;\n    },\n    getBool: fn() {\n        return true;\n    },\n};\n\nprint(obj.getNum());\nprint(obj.getStr());\nprint(obj.getBool());\n```", "category": "tests/objects", "source": "tests/objects/method_return_values.hml"}
{"instruction": "How does export statements work in Hemlock?", "output": "```hemlock\n// Re-export from another module\nexport { add, subtract } from \"./math.hml\";\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\n// Import specific functions\nimport { random_bytes, aes_encrypt, aes_decrypt } from \"@stdlib/crypto\";\nimport { rsa_generate_key, rsa_sign, rsa_verify } from \"@stdlib/crypto\";\nimport { ecdsa_generate_key, ecdsa_sign, ecdsa_verify } from \"@stdlib/crypto\";\n\n// Or import all as namespace\nimport * as crypto from \"@stdlib/crypto\";\nlet key = crypto.generate_aes_key();\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does read entire file work in Hemlock?", "output": "```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does writing to read-only file work in Hemlock?", "output": "```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Implement a Hemlock program that tests memcpy.", "output": "```hemlock\nlet source = alloc(4);\nlet dest = alloc(4);\nmemset(source, 72, 4);\nmemcpy(dest, source, 4);\nprint(dest);\nfree(source);\nfree(dest);\n```", "category": "tests/pointers", "source": "tests/pointers/memcpy.hml"}
{"instruction": "How does signal(signum, handler_fn) work in Hemlock?", "output": "```hemlock\nfn my_handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does why message-passing? work in Hemlock?", "output": "This follows Hemlock's \"explicit over implicit\" philosophy:\n\n```hemlock\n// BAD: Shared mutable state (would cause data races)\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // Race!\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // Race!\n\n// GOOD: Message-passing via channels\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - no race condition\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does panic work in Hemlock?", "output": "```hemlock\npanic(message);\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does safety tools provided work in Hemlock?", "output": "1. Safe buffer type:*\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bounds checked\nprint(b.length);        // 64\nfree(b);                // still manual\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Write a Hemlock program that test assert builtin.", "output": "```hemlock\n// Test assert builtin\n\nassert(true);\nassert(1 == 1);\nassert(5 > 3);\nassert(\"hello\" == \"hello\");\n\nlet x = 10;\nassert(x == 10);\n\nprint(\"all assertions passed\");\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/assert.hml"}
{"instruction": "Show an example of example 2: log analyzer in Hemlock.", "output": "```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyzing log: \" + logfile);\n\n    // Count total lines\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Total lines: \" + r1.output.trim());\n\n    // Count errors\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errors: \" + errors);\n    } else {\n        print(\"Errors: 0\");\n    }\n\n    // Count warnings\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnings: \" + warnings);\n    } else {\n        print(\"Warnings: 0\");\n    }\n\n    // Recent errors\n    print(\"\\nRecent errors:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Write a Hemlock program that tests to bytes.", "output": "```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(typeof(buf));\nprint(typeof(buf.length));\nprint(buf[0]);\nprint(buf[4]);\n```", "category": "tests/strings", "source": "tests/strings/to_bytes.hml"}
{"instruction": "Implement a Hemlock program that nOTE: ECDSA verification has known FFI issues with OpenSSL in this environment. This test verifies key generation and signing work correctly.", "output": "```hemlock\n// Test: @stdlib/crypto - ECDSA signatures\n// NOTE: ECDSA verification has known FFI issues with OpenSSL in this environment.\n// This test verifies key generation and signing work correctly.\n\nimport { ecdsa_generate_key, ecdsa_sign, ecdsa_verify, ecdsa_free_keys } from \"@stdlib/crypto\";\n\nprint(\"Testing ECDSA signatures...\");\n\n// Test 1: Generate ECDSA key pair\nprint(\"Generating ECDSA P-256 key pair...\");\nlet keypair = null;\nlet keygen_works = false;\n\ntry {\n    keypair = ecdsa_generate_key();\n    keygen_works = true;\n    print(\"‚úì ECDSA key generation\");\n} catch (e) {\n    print(\"‚ö† ECDSA key generation not available: \" + e);\n}\n\nif (!keygen_works) {\n    print(\"ECDSA tests skipped (key generation not available).\");\n} else {\n    defer ecdsa_free_keys(keypair);\n\n    if (typeof(keypair) != \"ECDSAKeyPair\") {\n        throw \"Expected ECDSAKeyPair type, got \" + typeof(keypair);\n    }\n\n    // Check if keys are valid (non-null)\n    if (keypair.private_key == null || keypair.public_key == null) {\n        print(\"‚ö† ECDSA keys are null\");\n        print(\"ECDSA tests skipped (null keys).\");\n    } else {\n        // Test 2: Sign a message\n        let message = \"This is a test message\";\n        let signature = ecdsa_sign(message, keypair);\n\n        if (typeof(signature) != \"buffer\") {\n            throw \"Expected buffer signature, got \" + typeof(signature);\n        }\n\n        // ECDSA P-256 signature should be ~70-72 bytes (DER-encoded)\n        if (signature.length < 60 || signature.length > 80) {\n            throw \"Unexpected signature length: \" + signature.length;\n        }\n        print(\"‚úì ECDSA signing (signature: \" + signature.length + \" bytes)\");\n\n        // Test 3: Verify signature (may fail due to FFI issues)\n        let valid = ecdsa_verify(message, signature, keypair);\n\n        if (valid != true) {\n            print(\"‚ö† Signature verification returned false (known FFI limitation)\");\n            print(\"ECDSA signing works, verification has issues.\");\n        } else {\n            print(\"‚úì ECDSA signature verification\");\n\n            // Only run additional tests if verification works\n            // Test 4: Different messages produce different signatures\n            let message2 = \"This is a different message\";\n            let signature2 = ecdsa_sign(message2, keypair);\n\n            let same = true;\n            let i = 0;\n            let min_len = signature.length;\n            if (signature2.length < min_len) {\n                min_len = signature2.length;\n            }\n\n            while (i < min_len) {\n                if (signature[i] != signature2[i]) {\n                    same = false;\n                }\n                i = i + 1;\n            }\n\n            if (same) {\n                throw \"Different messages should produce different signatures\";\n            }\n            print(\"‚úì Different messages produce different signatures\");\n\n            print(\"All ECDSA tests passed!\");\n        }\n    }\n}\n```", "category": "tests/stdlib_crypto", "source": "tests/stdlib_crypto/test_ecdsa.hml"}
{"instruction": "Write a Hemlock program that tests recv_timeout() and send_timeout().", "output": "```hemlock\n// Test: channel timed operations\n// Tests recv_timeout() and send_timeout()\n\n// Test recv_timeout with data available\nasync fn test_recv_timeout_data() {\n    let ch = channel(10);\n    ch.send(42);\n\n    let result = ch.recv_timeout(100);\n    assert(result == 42);\n\n    ch.close();\n    return \"ok\";\n}\n\nlet r1 = join(spawn(test_recv_timeout_data));\nassert(r1 == \"ok\");\nprint(\"PASS: recv_timeout with data available\");\n\n// Test recv_timeout that times out\nasync fn test_recv_timeout_empty() {\n    let ch = channel(10);\n    // Don't send anything\n\n    let start = __time_ms();\n    let result = ch.recv_timeout(50);\n    let elapsed = __time_ms() - start;\n\n    // Should timeout (return null)\n    let timed_out = (result == null);\n    // Should have waited approximately 50ms\n    let waited = (elapsed >= 40);\n\n    ch.close();\n    return { timed_out: timed_out, waited: waited };\n}\n\nlet r2 = join(spawn(test_recv_timeout_empty));\nassert(r2.timed_out == true);\nassert(r2.waited == true);\nprint(\"PASS: recv_timeout times out on empty channel\");\n\n// Test recv_timeout with delayed producer\nasync fn test_recv_timeout_delayed() {\n    let ch = channel(10);\n\n    // Spawn producer that sends after delay\n    let producer = spawn(async fn(ch) {\n        __sleep(0.02);\n        ch.send(\"message\");\n        return null;\n    }, ch);\n\n    // recv_timeout should wait and receive\n    let result = ch.recv_timeout(1000);\n    assert(result == \"message\");\n\n    join(producer);\n    ch.close();\n    return \"ok\";\n}\n\nlet r3 = join(spawn(test_recv_timeout_delayed));\nassert(r3 == \"ok\");\nprint(\"PASS: recv_timeout waits for delayed producer\");\n\n// Test send_timeout with space available\nasync fn test_send_timeout_space() {\n    let ch = channel(10);\n\n    let success = ch.send_timeout(42, 100);\n    assert(success == true);\n\n    let val = ch.recv();\n    assert(val == 42);\n\n    ch.close();\n    return \"ok\";\n}\n\nlet r4 = join(spawn(test_send_timeout_space));\nassert(r4 == \"ok\");\nprint(\"PASS: send_timeout with space available\");\n\n// Test send_timeout that times out on full channel\nasync fn test_send_timeout_full() {\n    let ch = channel(1);  // Capacity of 1\n    ch.send(1);  // Fill it up\n\n    let start = __time_ms();\n    let success = ch.send_timeout(2, 50);  // Should timeout\n    let elapsed = __time_ms() - start;\n\n    // Should timeout (return false)\n    let timed_out = (success == false);\n    // Should have waited approximately 50ms\n    let waited = (elapsed >= 40);\n\n    ch.close();\n    return { timed_out: timed_out, waited: waited };\n}\n\nlet r5 = join(spawn(test_send_timeout_full));\nassert(r5.timed_out == true);\nassert(r5.waited == true);\nprint(\"PASS: send_timeout times out on full channel\");\n\n// Test send_timeout with delayed consumer\nasync fn test_send_timeout_delayed_consumer() {\n    let ch = channel(1);\n    ch.send(1);  // Fill it up\n\n    // Spawn consumer that receives after delay\n    let consumer = spawn(async fn(ch) {\n        __sleep(0.02);\n        let val = ch.recv();\n        return val;\n    }, ch);\n\n    // send_timeout should wait and succeed\n    let success = ch.send_timeout(2, 1000);\n    assert(success == true);\n\n    join(consumer);\n    let val = ch.recv();\n    assert(val == 2);\n\n    ch.close();\n    return \"ok\";\n}\n\nlet r6 = join(spawn(test_send_timeout_delayed_consumer));\nassert(r6 == \"ok\");\nprint(\"PASS: send_timeout waits for delayed consumer\");\n\n// Test recv_timeout on closed channel\nasync fn test_recv_timeout_closed() {\n    let ch = channel(10);\n    ch.close();\n\n    let result = ch.recv_timeout(100);\n    assert(result == null);\n\n    return \"ok\";\n}\n\nlet r7 = join(spawn(test_recv_timeout_closed));\nassert(r7 == \"ok\");\nprint(\"PASS: recv_timeout on closed channel returns null\");\n\nprint(\"All channel timeout tests passed!\");\n```", "category": "tests/async_io", "source": "tests/async_io/channel_timeout.hml"}
{"instruction": "How does max(a, b) work in Hemlock?", "output": "Returns:* f64 - Maximum of a and b\n\n```hemlock\nimport { max } from \"@stdlib/math\";\n\nlet result = max(5.0, 10.0);  // 10.0\nlet result2 = max(-3.0, 2.0); // 2.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does comparison operators work in Hemlock?", "output": "```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// String comparison\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexicographic)\n\n// Mixed types\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (promoted to i32)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Implement a Hemlock program that test 1: INFO level (should filter DEBUG).", "output": "```hemlock\n// Test: Log level filtering\nimport { Logger, DEBUG, INFO, WARN, ERROR } from \"@stdlib/logging\";\n\n// Test 1: INFO level (should filter DEBUG)\nprint(\"=== Test 1: INFO level ===\");\nlet logger1 = Logger({ level: INFO });\nlogger1.debug(\"Should NOT appear\");\nlogger1.info(\"Should appear - INFO\");\nlogger1.warn(\"Should appear - WARN\");\nlogger1.error(\"Should appear - ERROR\");\n\n// Test 2: WARN level (should filter DEBUG and INFO)\nprint(\"\\n=== Test 2: WARN level ===\");\nlet logger2 = Logger({ level: WARN });\nlogger2.debug(\"Should NOT appear\");\nlogger2.info(\"Should NOT appear\");\nlogger2.warn(\"Should appear - WARN\");\nlogger2.error(\"Should appear - ERROR\");\n\n// Test 3: ERROR level (should only show ERROR)\nprint(\"\\n=== Test 3: ERROR level ===\");\nlet logger3 = Logger({ level: ERROR });\nlogger3.debug(\"Should NOT appear\");\nlogger3.info(\"Should NOT appear\");\nlogger3.warn(\"Should NOT appear\");\nlogger3.error(\"Should appear - ERROR\");\n\n// Test 4: DEBUG level (should show all)\nprint(\"\\n=== Test 4: DEBUG level ===\");\nlet logger4 = Logger({ level: DEBUG });\nlogger4.debug(\"Should appear - DEBUG\");\nlogger4.info(\"Should appear - INFO\");\nlogger4.warn(\"Should appear - WARN\");\nlogger4.error(\"Should appear - ERROR\");\n\n// Test 5: Dynamic level change\nprint(\"\\n=== Test 5: Dynamic level change ===\");\nlet logger5 = Logger({ level: ERROR });\nlogger5.info(\"Should NOT appear (level=ERROR)\");\nlogger5.error(\"Should appear (level=ERROR)\");\n\nlogger5.set_level(INFO);\nlogger5.info(\"Should appear (level=INFO)\");\nlogger5.debug(\"Should NOT appear (level=INFO)\");\n\nlogger5.set_level(DEBUG);\nlogger5.debug(\"Should appear (level=DEBUG)\");\n\nprint(\"\\nPASS: Log level filtering test completed\");\n```", "category": "tests/stdlib_logging", "source": "tests/stdlib_logging/log_levels.hml"}
{"instruction": "Write Hemlock code that tests operators.", "output": "```hemlock\nlet a = true && false;\nlet b = true || false;\nlet c = !false;\nlet d = !true;\nprint(a);\nprint(b);\nprint(c);\nprint(d);\n```", "category": "tests/bools", "source": "tests/bools/operators.hml"}
{"instruction": "Implement a Hemlock program that object test.", "output": "```hemlock\n// Object test\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);\nperson.email = \"alice@example.com\";\n```", "category": "tests/manual", "source": "tests/manual/valgrind_test_objects.hml"}
{"instruction": "How does while loops work in Hemlock?", "output": "Condition-based iteration:\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Implement a Hemlock program that test basic signal handling.", "output": "```hemlock\n// Test basic signal handling\nlet caught = false;\n\nfn handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n    caught = true;\n}\n\n// Register handler for SIGUSR1\nsignal(SIGUSR1, handler);\n\n// Raise the signal\nraise(SIGUSR1);\n\n// Check that handler was called\nassert(caught);\nprint(\"PASS: basic_signal\");\n```", "category": "tests/signals", "source": "tests/signals/basic_signal.hml"}
{"instruction": "How does async_rename work in Hemlock?", "output": "```hemlock\nimport { async_rename } from \"@stdlib/async_fs\";\n\nlet future = async_rename(\"old_name.txt\", \"new_name.txt\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Give me Hemlock code that shows tests range error2.", "output": "```hemlock\nlet x: u8 = -1;\n```", "category": "examples", "source": "examples/range_error2.hml"}
{"instruction": "How does switch statements work in Hemlock?", "output": "```hemlock\nswitch (expression) {\n    case value1:\n        // body\n        break;\n    case value2:\n        // body\n        break;\n    default:\n        // default body\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show me Hemlock code that test char_at and byte_at with out of bounds indices Expected: ERROR.", "output": "```hemlock\n// Test char_at and byte_at with out of bounds indices\n// Expected: ERROR\n\nlet s = \"hello\";\n\n// Test char_at out of bounds\ntry {\n    let ch = s.char_at(10);\n    print(\"ERROR: char_at should have thrown on out of bounds\");\n} catch (e) {\n    print(\"Caught char_at out of bounds: \" + e);\n}\n\n// Test byte_at out of bounds\ntry {\n    let b = s.byte_at(10);\n    print(\"ERROR: byte_at should have thrown on out of bounds\");\n} catch (e) {\n    print(\"Caught byte_at out of bounds: \" + e);\n}\n\n// Test char_at negative index\ntry {\n    let ch = s.char_at(-1);\n    print(\"ERROR: char_at should have thrown on negative index\");\n} catch (e) {\n    print(\"Caught char_at negative index: \" + e);\n}\n\n// Test byte_at negative index\ntry {\n    let b = s.byte_at(-1);\n    print(\"ERROR: byte_at should have thrown on negative index\");\n} catch (e) {\n    print(\"Caught byte_at negative index: \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/strings", "source": "tests/strings/edge_char_byte_at_bounds.hml"}
{"instruction": "Implement a Hemlock program that test chained imports (module imports from another module).", "output": "```hemlock\n// Test chained imports (module imports from another module)\nimport { square, sum_of_squares } from \"./math_utils.hml\";\n\nprint(square(5));\nprint(sum_of_squares(3, 4));\n```", "category": "tests/parity", "source": "tests/parity/modules/chained_import.hml"}
{"instruction": "How does sha512(input: string): string work in Hemlock?", "output": "SHA-512 hash (512-bit / 64-byte output). More secure variant of SHA-2 family.\n\n```hemlock\nlet hash = sha512(\"hello\");\nprint(hash);\n// Returns 128-character hex string\n\nassert(hash.length == 128, \"SHA-512 produces 128 hex characters\");\n\n// Empty string\nlet empty_hash = sha512(\"\");\nprint(empty_hash);\n// \"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\n//  47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does basic allocation pattern work in Hemlock?", "output": "```hemlock\n// Allocate\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// Use\nmemset(p, 0, 1024);\n\n// Free\nfree(p);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "What control flow statements does Hemlock have?", "output": "Hemlock has standard control flow with mandatory braces:\n\n```hemlock\n// Conditionals\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n\n// While loop\nwhile (condition) {\n    break;     // exit loop\n    continue;  // next iteration\n}\n\n// For loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// For-in loop\nfor (item in array) {\n    print(item);\n}\n\n// Switch\nswitch (x) {\n    case 1: print(\"one\"); break;\n    case 2: print(\"two\"); break;\n    default: print(\"other\"); break;\n}\n```", "category": "concepts/control-flow", "source": "CLAUDE.md"}
{"instruction": "How does ‚ùå don't hide complexity work in Hemlock?", "output": "```hemlock\n// BAD: Magic behind-the-scenes optimization\nlet arr = [1, 2, 3]  // Is this stack or heap? User should know!\n\n// BAD: Automatic reference counting\nlet p = create_thing()  // Does this increment a refcount? NO!\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Write a Hemlock program that tests relational.", "output": "```hemlock\nlet a = 5 < 10;\nlet b = 10 < 5;\nlet c = 5 <= 5;\nlet d = 5 > 3;\nlet e = 3 > 5;\nlet f = 5 >= 5;\nprint(a);\nprint(b);\nprint(c);\nprint(d);\nprint(e);\nprint(f);\n```", "category": "tests/comparisons", "source": "tests/comparisons/relational.hml"}
{"instruction": "How does command injection work in Hemlock?", "output": "The exec() function executes commands via the shell, which can be dangerous with untrusted input:\n\n```hemlock\n// ‚ùå UNSAFE - vulnerable to command injection\nlet user_input = \"file.txt; rm -rf /\";\nlet result = exec(\"cat \" + user_input);\n\n// ‚úÖ SAFE - validate/sanitize input\nfn safe_exec(filename: string) {\n    // Validate filename contains only safe characters\n    let i = 0;\n    while (i < filename.length) {\n        let ch = filename[i];\n        if (!(ch >= 'a' && ch <= 'z') &&\n            !(ch >= 'A' && ch <= 'Z') &&\n            !(ch >= '0' && ch <= '9') &&\n            ch != '.' && ch != '_' && ch != '-') {\n            throw \"Invalid filename\";\n        }\n        i = i + 1;\n    }\n    return exec(\"cat \" + filename);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does pitfall: missing break in switch work in Hemlock?", "output": "```hemlock\n// Unintentional fall-through\nswitch (x) {\n    case 1:\n        print(\"one\");\n        // Missing break - falls through!\n    case 2:\n        print(\"two\");  // Executes for both 1 and 2\n        break;\n}\n\n// Fix: Add break\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // Now correct\n    case 2:\n        print(\"two\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does color_256(n) work in Hemlock?", "output": "Returns:* string - 256-color code\n\n```hemlock\nimport { color_256, RESET } from \"@stdlib/terminal\";\n\n// 0-15: Standard colors\n// 16-231: 6x6x6 color cube\n// 232-255: Grayscale\n\nprint(color_256(196) + \"Bright red\" + RESET);\nprint(color_256(21) + \"Deep blue\" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does for loops work in Hemlock?", "output": "For-in (arrays):*\n\n```hemlock\nfor (let item in array) {\n    // body\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "Using a freed regex throws an exception:\n\n```hemlock\nlet pattern = compile(\"test\");\npattern.free();\n\ntry {\n    pattern.test(\"testing\");  // Error!\n} catch (e) {\n    print(e);  // \"Regex has been freed\"\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does pitfall: string byte indexing work in Hemlock?", "output": "```hemlock\n// DON'T: Assume byte indexing\nlet s = \"üöÄ\";\nlet byte = s.byte_at(0);    // 240 (first UTF-8 byte, not complete char)\n\n// DO: Use codepoint indexing\nlet s = \"üöÄ\";\nlet rune = s[0];            // 'üöÄ' (complete character)\nlet rune2 = s.char_at(0);   // 'üöÄ' (explicit method)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does random_bytes(size: i32): buffer work in Hemlock?", "output": "Generate cryptographically secure random bytes using OpenSSL's RAND_bytes.\n\n```hemlock\nimport { random_bytes } from \"@stdlib/crypto\";\n\n// Generate random bytes\nlet random = random_bytes(32);\nprint(random.length);  // 32\n\n// Generate secret token\nlet token = random_bytes(16);\nprint(buffer_to_hex(token));  // \"3a7f2c9e...\" (32 hex chars)\n\n// Generate nonce\nlet nonce = random_bytes(12);\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How do you define objects in Hemlock?", "output": "Hemlock supports object literals and defined types:\n\n```hemlock\n// Anonymous object\nlet point = { x: 10, y: 20 };\nprint(point.x);  // 10\n\n// Defined type with defaults\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true  // optional with default\n}\n\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(p.active);  // true (default)\n\n// Serialization\nlet json = p.serialize();\nlet restored = json.deserialize();\n```", "category": "concepts/objects", "source": "CLAUDE.md"}
{"instruction": "Show me Hemlock code that test switch with default case.", "output": "```hemlock\n// Test switch with default case\n\nlet x = 99;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    default:\n        print(\"other\");\n        break;\n}\n\n// Test that default works when no case matches\n// Expected: other\n```", "category": "tests/switch", "source": "tests/switch/default.hml"}
{"instruction": "How does copyfilesparallel work in Hemlock?", "output": "```hemlock\nimport { copy_files_parallel } from \"@stdlib/async_fs\";\n\nlet copies = [\n    { src: \"file1.txt\", dst: \"backup/file1.txt\" },\n    { src: \"file2.txt\", dst: \"backup/file2.txt\" },\n    { src: \"file3.txt\", dst: \"backup/file3.txt\" }\n];\n\ncopy_files_parallel(copies);\nprint(\"All files copied\");\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Create a Hemlock program that fibonacci recursion.", "output": "```hemlock\n// Fibonacci recursion\nfn fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\nprint(fib(10));\n```", "category": "tests/functions", "source": "tests/functions/fibonacci.hml"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "4. Buffer Overflow (ptr)*\n\n```hemlock\n// BAD: Buffer overflow with ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // CRASH: writing past allocation\n\n// GOOD: Use buffer for bounds checking\nlet buf = buffer(10);\n// buf[100] = 65;  // ERROR: bounds check fails\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Show me Hemlock code that modifying nested object fields.", "output": "```hemlock\n// Modifying nested object fields\nlet obj = {\n    outer: 1,\n    nested: {\n        inner: 2,\n    },\n};\n\nprint(obj.outer);\nprint(obj.nested.inner);\n\nobj.outer = 10;\nobj.nested.inner = 20;\n\nprint(obj.outer);\nprint(obj.nested.inner);\n```", "category": "tests/objects", "source": "tests/objects/nested_modify.hml"}
{"instruction": "How does spawn work in Hemlock?", "output": "```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn single task\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// Spawn multiple tasks (run in parallel!)\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// All three are running simultaneously\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does absolute_path(path) work in Hemlock?", "output": "Throws:* Exception if path doesn't exist or cannot be resolved\n\n```hemlock\nimport { absolute_path } from \"@stdlib/fs\";\n\ntry {\n    let abs = absolute_path(\"../data/file.txt\");\n    print(\"Absolute path: \" + abs);\n\n    // Resolve current directory\n    let here = absolute_path(\".\");\n    print(\"Current directory (absolute): \" + here);\n} catch (e) {\n    print(\"Error resolving path: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "to_bytes()* - Convert to buffer for low-level access:\n\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // Returns buffer with UTF-8 bytes\nprint(buf.length);              // 5\nfree(buf);                      // Remember to free\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Show me Hemlock code that demonstrates that spawn+await allows parallelism while direct call doesn't.", "output": "```hemlock\n// Test: await with parallel tasks\n// Demonstrates that spawn+await allows parallelism while direct call doesn't\n\nasync fn cpu_task(id: i32, iterations: i32): i32 {\n    print(\"Task \" + typeof(id) + \" started\");\n    let sum = 0;\n    let i = 0;\n    while (i < iterations) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    print(\"Task \" + typeof(id) + \" finished\");\n    return sum;\n}\n\n// Test 1: Spawn multiple tasks, then await them (parallel execution)\nprint(\"Test 1: Parallel execution with spawn+await\");\nlet t1 = spawn(cpu_task, 1, 10000);\nlet t2 = spawn(cpu_task, 2, 10000);\nlet t3 = spawn(cpu_task, 3, 10000);\n\n// All three tasks are running in parallel NOW\n\nlet r1 = await t1;\nlet r2 = await t2;\nlet r3 = await t3;\n\nprint(\"Results: \" + typeof(r1) + \", \" + typeof(r2) + \", \" + typeof(r3));\n\n// Test 2: await on spawn expression (still parallel if we spawn multiple)\nprint(\"Test 2: await spawn expression\");\nlet task4 = spawn(cpu_task, 4, 5000);\nlet task5 = spawn(cpu_task, 5, 5000);\n\n// Can await in any order\nlet r5 = await task5;\nlet r4 = await task4;\n\nprint(\"Results: \" + typeof(r4) + \", \" + typeof(r5));\n\nprint(\"All tests passed!\");\n```", "category": "tests/async", "source": "tests/async/await_parallel.hml"}
{"instruction": "How does wait(): object work in Hemlock?", "output": "status (i32) - Exit status of the child\n\n```hemlock\nlet result = wait();\nprint(\"Child \" + typeof(result.pid) + \" exited with status: \" + typeof(result.status));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does signal work in Hemlock?", "output": "Handler Signature:*\n\n```hemlock\nfn handler(signum: i32) {\n    // signum contains the signal number\n}\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does field deletion work in Hemlock?", "output": "Note:* Field deletion is not currently supported. Set to null instead:\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// Cannot delete fields (not supported)\n// obj.x = undefined;  // No 'undefined' in Hemlock\n\n// Workaround: Set to null\nobj.x = null;\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does type annotations work in Hemlock?", "output": "Optional type annotations on parameters:\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // Runtime type check promotes to f64\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does use appropriate channel capacity work in Hemlock?", "output": "Large capacity (100+): For high-throughput scenarios\n\n```hemlock\nlet signal_ch = channel(1);      // Coordination\nlet work_ch = channel(50);       // Work queue\nlet buffer_ch = channel(1000);   // High throughput\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does commands with pipes work in Hemlock?", "output": "```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Implement a Hemlock program that simplified email regex.", "output": "```hemlock\n// Test: Email validation example\nimport { compile } from \"@stdlib/regex\";\n\nfn is_valid_email(email: string): bool {\n    // Simplified email regex\n    let pattern = compile(\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\", null);\n    let valid = pattern.test(email);\n    pattern.free();\n    return valid;\n}\n\n// Valid emails\nprint(is_valid_email(\"user@example.com\"));         // true\nprint(is_valid_email(\"test.user@domain.org\"));     // true\nprint(is_valid_email(\"admin+tag@site.co.uk\"));     // true\n\n// Invalid emails\nprint(is_valid_email(\"invalid.email\"));            // false\nprint(is_valid_email(\"@domain.com\"));              // false\nprint(is_valid_email(\"user@\"));                    // false\nprint(is_valid_email(\"user@domain\"));              // false\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/email_validation.hml"}
{"instruction": "Write Hemlock code that defer with exception - defers should execute even when exception is thrown.", "output": "```hemlock\n// Defer with exception - defers should execute even when exception is thrown\nfn test_exception() {\n    defer print(\"cleanup 1\");\n    defer print(\"cleanup 2\");\n    print(\"before throw\");\n    throw \"error!\";\n    print(\"after throw (should not print)\");\n}\n\ntry {\n    test_exception();\n} catch (e) {\n    print(\"Caught: \" + e);\n}\n```", "category": "tests/defer", "source": "tests/defer/defer_with_exception.hml"}
{"instruction": "How does concatenation work in Hemlock?", "output": "Multiple Concatenations:*\n\n```hemlock\nlet msg = \"Hi \" + 'üëã' + \" World \" + 'üåç';  // \"Hi üëã World üåç\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does menu system work in Hemlock?", "output": "```hemlock\nimport { clear, print_at, color, GREEN, YELLOW, RESET } from \"@stdlib/terminal\";\n\nfn show_menu(options: array, selected: i32): null {\n    clear();\n\n    print(\"=== Menu ===\");\n    print(\"\");\n\n    let i = 0;\n    while (i < options.length) {\n        if (i == selected) {\n            print(GREEN + \"> \" + options[i] + RESET);\n        } else {\n            print(\"  \" + options[i]);\n        }\n        i = i + 1;\n    }\n\n    return null;\n}\n\nlet menu_items = [\"Start\", \"Settings\", \"About\", \"Exit\"];\nshow_menu(menu_items, 1);  // Highlight \"Settings\"\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does panic work in Hemlock?", "output": "```hemlock\npanic(message?: any): never\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does is_windows() work in Hemlock?", "output": "Returns:* bool - true if on Windows, false otherwise\n\n```hemlock\nimport { is_windows } from \"@stdlib/os\";\n\nif (is_windows()) {\n    print(\"Windows-specific code here\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Write a Hemlock program that test const in nested scopes.", "output": "```hemlock\n// Test const in nested scopes\nconst x = 10;\nprint(x);\n\n{\n    const y = 20;\n    print(y);\n    print(x);\n}\n\n// Expected output:\n// 10\n// 20\n// 10\n```", "category": "tests/const", "source": "tests/const/const_in_scope.hml"}
{"instruction": "Show an example of example: array statistics in Hemlock.", "output": "```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does insertion and removal work in Hemlock?", "output": "insert(index, value)* - Insert element at index:\n\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // Insert 3 at index 2: [1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // Insert at beginning: [0, 1, 2, 3, 4, 5]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does resetting to default behavior work in Hemlock?", "output": "Pass null as the handler to reset to default behavior:\n\n```hemlock\n// Register custom handler\nsignal(SIGINT, my_handler);\n\n// Later, reset to default (terminate on SIGINT)\nsignal(SIGINT, null);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does environment-based feature flags work in Hemlock?", "output": "```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nfn is_enabled(feature_name: string): bool {\n    let env_var = \"ENABLE_\" + feature_name.to_upper();\n    let value = getenv(env_var);\n\n    if (value == null) {\n        return false;\n    }\n\n    // Check for truthy values\n    return value == \"1\" || value == \"true\" || value == \"yes\";\n}\n\nif (is_enabled(\"NEW_UI\")) {\n    print(\"Using new UI\");\n} else {\n    print(\"Using legacy UI\");\n}\n\nif (is_enabled(\"BETA_FEATURES\")) {\n    print(\"Beta features enabled\");\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "Write Hemlock code that test rune creation with invalid codepoints Expected: ERROR.", "output": "```hemlock\n// Test rune creation with invalid codepoints\n// Expected: ERROR\n\n// Negative rune value - this should be caught\ntry {\n    let r: rune = -1;\n    print(\"ERROR: Should reject negative codepoint\");\n} catch (e) {\n    print(\"PASS: Caught negative codepoint: \" + e);\n}\n```", "category": "tests/primitives", "source": "tests/primitives/edge_rune_invalid.hml"}
{"instruction": "How does join work in Hemlock?", "output": "```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // Blocks until task completes\nprint(result);         // 3628800\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate with rune (now \"Hello\")\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Show me Hemlock code that create and use compiled regex.", "output": "```hemlock\n// Test: Compiled regex objects\nimport { compile } from \"@stdlib/regex\";\n\n// Create and use compiled regex\nlet pattern = compile(\"^[0-9]+$\", null);\n\nprint(pattern.test(\"12345\"));        // true\nprint(pattern.test(\"abc123\"));       // false\nprint(pattern.test(\"123\"));          // true\n\n// Test methods\nprint(pattern.matches(\"999\"));       // true\nprint(pattern.find(\"42\"));           // true\n\n// Check pattern property\nprint(pattern.pattern);              // ^[0-9]+$\n\n// Free the regex\npattern.free();\n\nprint(\"Compiled regex test passed\");\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/compile_test.hml"}
{"instruction": "How does tcplistener work in Hemlock?", "output": "Blocks until a client connects, returns TcpStream for the connection.\n\n```hemlock\nlet stream = listener.accept();\ndefer stream.close();\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Write a Hemlock program that test bitwise shifts by 0 Expected: PASS.", "output": "```hemlock\n// Test bitwise shifts by 0\n// Expected: PASS\n\nlet x = 42;\n\nlet left = x << 0;\nassert(left == 42, \"shift left by 0 should return original value\");\n\nlet right = x >> 0;\nassert(right == 42, \"shift right by 0 should return original value\");\n\nprint(\"PASS\");\n```", "category": "tests/bitwise", "source": "tests/bitwise/edge_shift_zero.hml"}
{"instruction": "Write Hemlock code that test array extension with out-of-bounds write.", "output": "```hemlock\n// Test array extension with out-of-bounds write\nlet arr = [1, 2, 3];\narr[5] = 99;\nprint(arr);\nprint(arr.length);\n```", "category": "tests/arrays", "source": "tests/arrays/extend.hml"}
{"instruction": "How does value arguments work in Hemlock?", "output": "```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // Would need to parse string to int\n        }\n    }\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How do you using pipes in Hemlock?", "output": "Complex pipelines:*\n\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does pitfall: memory leaks work in Hemlock?", "output": "```hemlock\n// Arrays must be manually freed\nfn create_large_array() {\n    let arr = [];\n    let i = 0;\n    while (i < 1000000) {\n        arr.push(i);\n        i = i + 1;\n    }\n    // Should call: free(arr);\n}\n\ncreate_large_array();  // Leaks memory without free()\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does udp socket work in Hemlock?", "output": "```hemlock\nimport { UdpSocket } from \"@stdlib/net\";\n\nlet sock = UdpSocket(\"0.0.0.0\", 5000);\ndefer sock.close();\n\n// Receive datagram\nlet packet = sock.recv_from(1024);\nprint(\"Received from \" + packet.address + \":\" + typeof(packet.port));\n\n// Send reply\nsock.send_to(packet.address, packet.port, \"Reply\");\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "What string methods are available in Hemlock?", "output": "Hemlock strings have 19 methods:\n\n**Slicing:** substr(start, len), slice(start, end)\n**Search:** find(needle), contains(str)\n**Transform:** split(delim), trim(), to_upper(), to_lower()\n**Check:** starts_with(prefix), ends_with(suffix)\n**Replace:** replace(old, new), replace_all(old, new)\n**Other:** repeat(n), char_at(i), byte_at(i), chars(), bytes(), to_bytes(), deserialize()\n\n```hemlock\nlet s = \"hello world\";\nprint(s.length);           // 11\nprint(s.substr(0, 5));     // \"hello\"\nprint(s.split(\" \")[0]);   // \"hello\"\nprint(s.to_upper());       // \"HELLO WORLD\"\n```", "category": "concepts/strings", "source": "CLAUDE.md"}
{"instruction": "How does bitwise operators work in Hemlock?", "output": "```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - Bitwise AND\nprint(a | b);   // 14 - Bitwise OR\nprint(a ^ b);   // 6  - Bitwise XOR\nprint(a << 2);  // 48 - Left shift\nprint(a >> 1);  // 6  - Right shift\nprint(~a);      // -13 - Bitwise NOT\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does no stderr capture work in Hemlock?", "output": "Only stdout is captured, stderr goes to terminal:\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output is empty\n// Error message appears on terminal, not captured\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Write a Hemlock program that test finally block with return statement Expected: PASS (finally return should override try return).", "output": "```hemlock\n// Test finally block with return statement\n// Expected: PASS (finally return should override try return)\n\nfn test_finally_return(): i32 {\n    try {\n        return 1;\n    } finally {\n        return 2;\n    }\n}\n\nlet result = test_finally_return();\nassert(result == 2, \"finally return should override try return\");\n\nprint(\"PASS\");\n```", "category": "tests/exceptions", "source": "tests/exceptions/edge_finally_with_return.hml"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet text = \"HiüöÄ!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // 'üöÄ' (one codepoint)\nprint(text[3]);         // '!'\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Show me Hemlock code that test exception handling.", "output": "```hemlock\n// Test exception handling\n\n// Basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(e);\n}\n\n// Try without throw\ntry {\n    print(\"no error\");\n} catch (e) {\n    print(\"should not reach\");\n}\n\n// Finally always runs\ntry {\n    print(\"try block\");\n} finally {\n    print(\"finally block\");\n}\n\n// Catch and finally\ntry {\n    throw \"oops\";\n} catch (e) {\n    print(\"caught\");\n} finally {\n    print(\"cleanup\");\n}\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/exceptions.hml"}
{"instruction": "How does debugging failed tests work in Hemlock?", "output": "Use verbose mode to see errors inline:\n\n```hemlock\nrun({ verbose: true });\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does integer types work in Hemlock?", "output": "Signed integers:*\n\n```hemlock\nlet tiny: i8 = 127;              // 8-bit  (-128 to 127)\nlet small: i16 = 32767;          // 16-bit (-32768 to 32767)\nlet normal: i32 = 2147483647;    // 32-bit (default)\nlet large: i64 = 9223372036854775807;  // 64-bit\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does type errors work in Hemlock?", "output": "Some operations are not allowed between incompatible types:\n\n```hemlock\n// ERROR: Cannot use bitwise operators on floats\nlet x = 3.14 & 2.71;\n\n// ERROR: Cannot use bitwise operators on strings\nlet y = \"hello\" & \"world\";\n\n// OK: Type promotion for arithmetic\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promoted)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does path separators work in Hemlock?", "output": "Windows: \\ (backslash) or / (also supported)\n\n```hemlock\n// Cross-platform path construction\nlet path = \"dir\" + \"/\" + \"file.txt\";  // Works on both Unix and Windows\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does optional fields work in Hemlock?", "output": "Fields can be optional with default values:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Optional with default value\n    nickname?: string,   // Optional, defaults to null\n}\n\n// Object with only required fields\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (default applied)\nprint(typed_p.nickname);  // null (no default)\n\n// Can override optional fields\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (overridden)\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does export statements work in Hemlock?", "output": "```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "How does free work in Hemlock?", "output": "```hemlock\n// Free raw pointer\nlet p = alloc(1024);\nfree(p);\n\n// Free buffer\nlet buf = buffer(256);\nfree(buf);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does command substitution work in Hemlock?", "output": "```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // Current date\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\nimport { parse, stringify, pretty } from \"@stdlib/json\";\nimport * as json from \"@stdlib/json\";\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does ecdsafreekeys(keypair: ecdsakeypair): null work in Hemlock?", "output": "Free ECDSA key pair memory. Always call when done with keys.\n\n```hemlock\necdsa_free_keys(keypair);\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does planned features work in Hemlock?", "output": "3. Function Pointer Callbacks* ‚úÖ (Implemented!)\n\n```hemlock\n// Pass Hemlock functions to C as callbacks\nfn my_compare(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    return va - vb;\n}\n\n// Create a C-callable function pointer\nlet cmp = callback(my_compare, [\"ptr\", \"ptr\"], \"i32\");\n\n// Use with qsort or any C function expecting a callback\nqsort(arr, count, elem_size, cmp);\n\n// Clean up when done\ncallback_free(cmp);\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does memory management work in Hemlock?", "output": "Memory leak example:*\n\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // New allocation\n    // s2 never freed - memory leak\n}\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Show me Hemlock code that test break and continue in loops.", "output": "```hemlock\n// Test break and continue in loops\n\n// Basic break in while\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\nprint(\"after while break\");\n\n// Basic continue in while\ni = 0;\nwhile (i < 5) {\n    i = i + 1;\n    if (i == 3) {\n        continue;\n    }\n    print(i);\n}\nprint(\"after while continue\");\n\n// Break in for loop\nfor (let j = 0; j < 10; j = j + 1) {\n    if (j == 4) {\n        break;\n    }\n    print(j);\n}\nprint(\"after for break\");\n\n// Continue in for loop\nfor (let k = 0; k < 5; k = k + 1) {\n    if (k == 2) {\n        continue;\n    }\n    print(k);\n}\nprint(\"after for continue\");\n\n// Break in for-in loop\nlet arr = [10, 20, 30, 40, 50];\nfor (let item in arr) {\n    if (item == 30) {\n        break;\n    }\n    print(item);\n}\nprint(\"after for-in break\");\n\n// Continue in for-in loop\nfor (let item in arr) {\n    if (item == 30) {\n        continue;\n    }\n    print(item);\n}\nprint(\"after for-in continue\");\n\n// Nested loop break (breaks inner only)\nfor (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (y == 1) {\n            break;\n        }\n        print(x * 10 + y);\n    }\n}\nprint(\"after nested break\");\n\n// Break in switch (distinct from loop break)\nlet val = 2;\nswitch (val) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\nprint(\"after switch\");\n\n// Break in loop with switch inside\nfor (let m = 0; m < 3; m = m + 1) {\n    switch (m) {\n        case 0:\n            print(\"case 0\");\n            break;\n        case 1:\n            print(\"case 1\");\n            break;\n        default:\n            print(\"default\");\n            break;\n    }\n    print(m);\n}\nprint(\"after loop with switch\");\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/break_continue.hml"}
{"instruction": "How does basic timing work in Hemlock?", "output": "```hemlock\nimport { time_ms } from \"@stdlib/time\";\n\nfn measure(task_name: string, fn: function): null {\n    let start = time_ms();\n    fn();\n    let elapsed = time_ms() - start;\n    print(task_name + \" took \" + typeof(elapsed) + \"ms\");\n    return null;\n}\n\nmeasure(\"Heavy computation\", fn() {\n    let sum = 0;\n    let i = 0;\n    while (i < 1000000) {\n        sum = sum + i;\n        i = i + 1;\n    }\n});\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does difference methods work in Hemlock?", "output": "Get the difference in minutes.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 1, 12, 0, 0);\nlet dt2 = from_date(2025, 1, 1, 12, 30, 0);\n\nlet diff = dt2.diff_minutes(dt1);\nprint(diff);  // 30\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does udp echo server work in Hemlock?", "output": "```hemlock\nimport { UdpSocket } from \"@stdlib/net\";\n\nlet sock = UdpSocket(\"0.0.0.0\", 5000);\ndefer sock.close();\n\nprint(\"UDP echo server listening on port 5000\");\n\nwhile (true) {\n    let packet = sock.recv_from(1024);\n    print(\"Echo from \" + packet.address + \":\" + typeof(packet.port));\n    sock.send_to(packet.address, packet.port, packet.data);\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does gzipfile(inputpath, output_path, level?) -> null work in Hemlock?", "output": "```hemlock\nimport { gzip_file, gunzip_file } from \"@stdlib/compression\";\n\n// Compress file\ngzip_file(\"data.txt\", \"data.txt.gz\");\n\n// Decompress file\ngunzip_file(\"data.txt.gz\", \"data_restored.txt\");\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "Implement a Hemlock program that object type with dynamic (untyped) fields.", "output": "```hemlock\n// Object type with dynamic (untyped) fields\ndefine Flexible {\n    id: i32,\n    data,\n    metadata,\n}\n\n// Just test that parsing works\nprint(42);\n```", "category": "tests/objects", "source": "tests/objects/define_dynamic.hml"}
{"instruction": "Show an example of example: basic error handling in Hemlock.", "output": "```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Error: \" + e);  // Prints: Error: division by zero\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does hex_decode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { hex_decode } from \"@stdlib/encoding\";\n\n// Basic decoding\nlet decoded1 = hex_decode(\"48656c6c6f\");\nprint(decoded1);  // \"Hello\"\n\n// Case-insensitive\nlet decoded2 = hex_decode(\"48656C6C6F\");\nprint(decoded2);  // \"Hello\" (uppercase works too)\n\nlet decoded3 = hex_decode(\"48656C6c6f\");\nprint(decoded3);  // \"Hello\" (mixed case works)\n\n// Whitespace is automatically removed\nlet decoded4 = hex_decode(\"48 65 6c 6c 6f\");\nprint(decoded4);  // \"Hello\"\n\n// Round-trip\nlet original = \"The quick brown fox\";\nlet encoded = hex_encode(original);\nlet decoded5 = hex_decode(encoded);\nprint(decoded5 == original);  // true\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does named functions work in Hemlock?", "output": "```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does typeof work in Hemlock?", "output": "```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// Typed objects\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// Other types\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does asyncremovefile work in Hemlock?", "output": "```hemlock\nimport { async_remove_file } from \"@stdlib/async_fs\";\n\nlet future = async_remove_file(\"temp.txt\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does pattern: constructor function work in Hemlock?", "output": "```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does integer types work in Hemlock?", "output": "Unsigned integers:*\n\n```hemlock\nlet byte: u8 = 255;              // 8-bit  (0 to 255)\nlet word: u16 = 65535;           // 16-bit (0 to 65535)\nlet dword: u32 = 4294967295;     // 32-bit (0 to 4294967295)\nlet qword: u64 = 18446744073709551615;  // 64-bit\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show me Hemlock code that test bitwise operators.", "output": "```hemlock\n// Test bitwise operators\n\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\n// Bitwise AND\nprint(a & b);  // 8 (1000)\n\n// Bitwise OR\nprint(a | b);  // 14 (1110)\n\n// Bitwise XOR\nprint(a ^ b);  // 6 (0110)\n\n// Left shift\nprint(a << 2);  // 48 (110000)\n\n// Right shift\nprint(a >> 1);  // 6 (110)\n\n// Bitwise NOT\nprint(~0);  // -1\n\n// Compound expressions\nprint((5 & 3) | (2 << 1));  // 5\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/bitwise.hml"}
{"instruction": "Show an example of example: prime checker in Hemlock.", "output": "```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does switch with default work in Hemlock?", "output": "```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown color\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does pattern: allocate, use, free work in Hemlock?", "output": "The basic pattern for memory management:\n\n```hemlock\n// 1. Allocate\nlet data = alloc(1024);\n\n// 2. Use\nmemset(data, 0, 1024);\n// ... do work\n\n// 3. Free\nfree(data);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does queue operations work in Hemlock?", "output": "unshift(value)* - Add element to beginning:\n\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does pitfall: assignment in condition work in Hemlock?", "output": "```hemlock\n// This is NOT allowed (no assignment in conditions)\nif (x = 10) { }  // ERROR: Syntax error\n\n// Use comparison instead\nif (x == 10) { }  // OK\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write a Hemlock program that basic math module.", "output": "```hemlock\n// Basic math module\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport fn subtract(a, b) {\n    return a - b;\n}\n\nexport const PI = 3.14159;\n```", "category": "tests/modules", "source": "tests/modules/math.hml"}
{"instruction": "How does memory operations work in Hemlock?", "output": "memcpy(dest, src, size) - Copy memory*\n\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // Copy 50 bytes from src to dst\nfree(src);\nfree(dst);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does pitfall: memory leaks work in Hemlock?", "output": "```hemlock\n// Objects must be manually freed\nfn create_objects() {\n    let obj = { data: alloc(1000) };\n    // obj never freed - memory leak\n    // Should call: free(obj);\n}\n\ncreate_objects();  // Leaks memory\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Create a Hemlock program that tests exception handling.", "output": "```hemlock\n// Test: Try/catch/finally all together\ntry {\n    print(\"try\");\n    throw \"error\";\n} catch (e) {\n    print(\"catch: \" + e);\n} finally {\n    print(\"finally\");\n}\nprint(\"after\");\n```", "category": "tests/exceptions", "source": "tests/exceptions/try_catch_finally.hml"}
{"instruction": "How does putting it all together work in Hemlock?", "output": "Let's build a simple word counter program:\n\n```hemlock\n// wordcount.hml - Count words in a file\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // Split by whitespace and count\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Error reading file: \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// Main program\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(\"Word count: \" + typeof(words));\n    }\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does path traversal work in Hemlock?", "output": "‚ö†Ô∏è WARNING:* Validate user-provided paths to prevent directory traversal attacks:\n\n```hemlock\nimport { absolute_path } from \"@stdlib/fs\";\n\nfn is_safe_path(user_path: string, base_dir: string): bool {\n    try {\n        let abs_base = absolute_path(base_dir);\n        let abs_user = absolute_path(base_dir + \"/\" + user_path);\n\n        // Check if user path is within base directory\n        return abs_user.starts_with(abs_base);\n    } catch (e) {\n        return false;\n    }\n}\n\n// Validate before using\nlet user_input = \"../../etc/passwd\";  // Malicious\nif (is_safe_path(user_input, \"/var/www/uploads\")) {\n    // Safe to use\n} else {\n    print(\"Invalid path detected\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does exit code patterns work in Hemlock?", "output": "Different exit codes indicate different conditions:\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does pitfall: type confusion work in Hemlock?", "output": "```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// ERROR: Missing required field 'y'\nlet p: Point = obj;\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does function scope work in Hemlock?", "output": "Functions create their own scope:\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // Can read outer scope\n}\n\nfoo();\n// print(local);  // ERROR: 'local' not defined here\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does capture stderr when needed work in Hemlock?", "output": "```hemlock\n// Redirect stderr to stdout\nlet r = exec(\"command 2>&1\");\n// Now r.output contains both stdout and stderr\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Create a Hemlock program that test string indexing and operations with out-of-bounds access Expected: ERROR (should test that appropriate errors are thrown).", "output": "```hemlock\n// Test string indexing and operations with out-of-bounds access\n// Expected: ERROR (should test that appropriate errors are thrown)\n\nlet s = \"hello\";\n\n// Test out of bounds indexing - this should throw an error\ntry {\n    let ch = s[10];\n    print(\"ERROR: Should have thrown on out of bounds index\");\n} catch (e) {\n    print(\"PASS: Caught out of bounds error: \" + e);\n}\n```", "category": "tests/strings", "source": "tests/strings/edge_out_of_bounds.hml"}
{"instruction": "How does file i/o work in Hemlock?", "output": "```hemlock\n// Write to file\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// Read from file\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does read binary file work in Hemlock?", "output": "```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Read\", binary.length, \"bytes\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does pad_right(str, width, fill?) work in Hemlock?", "output": "Returns:* string - Padded string\n\n```hemlock\nimport { pad_right } from \"@stdlib/strings\";\n\nlet s1 = pad_right(\"42\", 5);\nprint(s1);  // \"42   \"\n\nlet s2 = pad_right(\"42\", 5, \"0\");\nprint(s2);  // \"42000\"\n\n// Unicode fill\nlet s3 = pad_right(\"test\", 10, \"‚îÄ\");\nprint(s3);  // \"test‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does throwing objects work in Hemlock?", "output": "```hemlock\ntry {\n    throw { code: 404, message: \"Not found\" };\n} catch (e) {\n    print(\"Error \" + typeof(e.code) + \": \" + e.message);\n}\n// Output: Error 404: Not found\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Create a Hemlock program that test array join method.", "output": "```hemlock\n// Test array join method\nlet arr = [\"a\", \"b\", \"c\"];\nprint(arr.join(\",\"));\nprint(arr.join(\" \"));\nprint(arr.join(\"\"));\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers.join(\", \"));\n\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));\n\nlet empty = [];\nprint(empty.join(\",\"));\n```", "category": "tests/arrays", "source": "tests/arrays/join.hml"}
{"instruction": "How does typeof(value) work in Hemlock?", "output": "```hemlock\ntypeof(value: any): string\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Create a Hemlock program that tests define optional with default.", "output": "```hemlock\n// Test: Optional fields with defaults are added automatically\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.name);\nprint(typed_p.age);\nprint(typed_p.active);  // Should be true (default value)\n```", "category": "tests/objects", "source": "tests/objects/define_optional_with_default.hml"}
{"instruction": "Write a Hemlock program that test basic optional parameters with defaults.", "output": "```hemlock\n// Test basic optional parameters with defaults\n\n// Simple optional parameter with default value\nfn greet(name: string, greeting?: \"Hello\") {\n    print(greeting + \" \" + name);\n}\n\ngreet(\"Alice\");              // Should print: Hello Alice\ngreet(\"Bob\", \"Hi\");          // Should print: Hi Bob\ngreet(\"Charlie\", \"Hey\");     // Should print: Hey Charlie\n\n// Optional numeric parameter\nfn add(a: i32, b?: 10) {\n    return a + b;\n}\n\nprint(add(5));        // 15\nprint(add(5, 20));    // 25\nprint(add(0, 0));     // 0\n\n// Multiple optional parameters\nfn format_name(first: string, middle?: \"\", last?: \"Doe\") {\n    if (middle == \"\") {\n        return first + \" \" + last;\n    }\n    return first + \" \" + middle + \" \" + last;\n}\n\nprint(format_name(\"John\"));                    // John Doe\nprint(format_name(\"John\", \"Q\"));               // John Q Doe\nprint(format_name(\"John\", \"Quincy\", \"Adams\")); // John Quincy Adams\n\n// Optional parameter with type annotation\nfn multiply(x: i32, factor?: 2): i32 {\n    return x * factor;\n}\n\nprint(multiply(5));      // 10\nprint(multiply(5, 3));   // 15\n\n// Optional parameter with boolean default\nfn log_message(msg: string, verbose?: false) {\n    if (verbose) {\n        print(\"[VERBOSE] \" + msg);\n    } else {\n        print(msg);\n    }\n}\n\nlog_message(\"Test\");        // Test\nlog_message(\"Test\", true);  // [VERBOSE] Test\nlog_message(\"Test\", false); // Test\n```", "category": "tests/functions", "source": "tests/functions/optional_params_basic.hml"}
{"instruction": "How does sizeof work in Hemlock?", "output": "```hemlock\nsizeof(type): i32\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Write a Hemlock program that method accessing multiple fields via self.", "output": "```hemlock\n// Method accessing multiple fields via self\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    describe: fn() {\n        print(self.name);\n        print(self.age);\n    },\n};\n\nperson.describe();\n```", "category": "tests/objects", "source": "tests/objects/method_self_access.hml"}
{"instruction": "Write Hemlock code that tests define optional override.", "output": "```hemlock\n// Test: Optional fields can be overridden\ndefine Person {\n    name: string,\n    age: i32,\n    active?: false,\n}\n\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;\n\nprint(typed_p.name);\nprint(typed_p.age);\nprint(typed_p.active);  // Should be true (overridden, not default)\n```", "category": "tests/objects", "source": "tests/objects/define_optional_override.hml"}
{"instruction": "How does when exec() throws exceptions work in Hemlock?", "output": "The exec() function throws an exception if the command cannot be executed:\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does object literals work in Hemlock?", "output": "```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does stdlib imports work in Hemlock?", "output": "The bundler automatically resolves @stdlib/ imports:\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```", "category": "docs", "source": "docs/advanced/bundling-packaging.md"}
{"instruction": "How does method storage work in Hemlock?", "output": "Methods are just functions stored in fields:\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method is a function stored in obj.method\nprint(typeof(obj.method));  // \"function\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does logical and (&&) work in Hemlock?", "output": "Both conditions must be true:\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"single digit positive\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does ssl/tls support work in Hemlock?", "output": "Secure WebSocket (wss://) is fully supported:\n\n```hemlock\n// Connects with SSL/TLS\nlet ws = WebSocket(\"wss://secure.example.com/api\");\ndefer ws.close();\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does method chaining work in Hemlock?", "output": "```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "What floating-point types does Hemlock support?", "output": "Hemlock supports two floating-point types:\n\n- `f32` - 32-bit single precision\n- `f64` - 64-bit double precision\n\nType alias: `number` (f64)\n\n```hemlock\nlet pi = 3.14;        // f64 by default\nlet f: f32 = 3.14;    // explicit f32\n```", "category": "concepts/types", "source": "CLAUDE.md"}
{"instruction": "Show an example of example: dynamic string builder in Hemlock.", "output": "```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // Caller must free\n}\n\nlet msg = build_message(5);\n// ... use msg\nfree(msg);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { read_file, write_file, exists } from \"@stdlib/fs\";\n\nif (exists(\"config.json\")) {\n    let content = read_file(\"config.json\");\n    print(content);\n} else {\n    write_file(\"config.json\", \"{}\");\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "How does testing concurrency work in Hemlock?", "output": "Example: tests/async/basic.hml*\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn tasks\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Join and print results\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Expect: 45\nprint(r2);  // Expect: 190\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Create a Hemlock program that test terminal utility functions.", "output": "```hemlock\n// Test terminal utility functions\nimport {\n    color, print_color, print_styled,\n    RED, GREEN, BLUE, BOLD, UNDERLINE, RESET\n} from \"@stdlib/terminal\";\n\n// ESC character for testing\nlet ESC: rune = 27;\nlet ESC_STR: string = ESC;\n\nprint(\"=== Terminal Utility Tests ===\");\nprint(\"\");\n\n// Test color() function\nprint(\"Testing color() function:\");\nlet colored = color(\"Test\", RED);\nif (colored.contains(ESC_STR + \"[31m\") && colored.contains(ESC_STR + \"[0m\")) {\n    print(\"‚úì color() wraps text with color and reset\");\n}\nprint(colored);\n\nprint(\"\");\n\n// Test print_color() function\nprint(\"Testing print_color() function:\");\nprint_color(\"Red text\", RED);\nprint_color(\"Green text\", GREEN);\nprint_color(\"Blue text\", BLUE);\nprint(\"‚úì print_color() works\");\n\nprint(\"\");\n\n// Test print_styled() function\nprint(\"Testing print_styled() function:\");\nprint_styled(\"Bold text\", BOLD);\nprint_styled(\"Underlined text\", UNDERLINE);\nprint(\"‚úì print_styled() works\");\n\nprint(\"\");\n\n// Test combining color and style\nprint(\"Testing combined color and style:\");\nprint(BOLD + RED + \"Bold red text\" + RESET);\nprint(UNDERLINE + GREEN + \"Underlined green text\" + RESET);\nprint(\"‚úì Color and style combination works\");\n\nprint(\"\");\nprint(\"‚úì All utility tests completed\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/test_utilities.hml"}
{"instruction": "How does udpsocket work in Hemlock?", "output": "Bind to port 0 to let OS assign a random port\n\n```hemlock\nlet sock = UdpSocket(\"0.0.0.0\", 5000);  // Server\nlet sock2 = UdpSocket(\"0.0.0.0\", 0);    // Client (any port)\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does rune literals work in Hemlock?", "output": "```hemlock\nlet ch = 'A';\nlet emoji = 'üöÄ';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does memory operations work in Hemlock?", "output": "realloc(ptr, size) - Resize allocation*\n\n```hemlock\nlet p = alloc(100);\n// ... use 100 bytes\np = realloc(p, 200);   // Resize to 200 bytes\n// ... use 200 bytes\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Implement a Hemlock program that helper module for testing imports.", "output": "```hemlock\n// Helper module for testing imports\nexport let greeting = \"Hello\";\n\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport fn multiply(a, b) {\n    return a * b;\n}\n\nexport const PI = 3.14159;\n```", "category": "tests/parity", "source": "tests/parity/modules/helper.hml"}
{"instruction": "How does maybe add (under discussion) work in Hemlock?", "output": "2. Pattern matching*\n\n```hemlock\nmatch (value) {\n    case i32: print(\"integer\");\n    case string: print(\"text\");\n    case _: print(\"other\");\n}\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does getuid(): i32 work in Hemlock?", "output": "Get the real user ID of the current process.\n\n```hemlock\nlet uid = getuid();\nprint(\"User ID: \" + typeof(uid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does buffer - safe wrapper (recommended) work in Hemlock?", "output": "```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100 (current size)\nprint(buf.capacity);    // 100 (allocated capacity)\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does always close file loggers work in Hemlock?", "output": "Use defer to ensure cleanup:\n\n```hemlock\nlet logger = Logger({ output: \"app.log\" });\ndefer logger.close();\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Show me Hemlock code that tests the resolve() helper function.", "output": "```hemlock\n// Test: DNS resolution with stdlib/net wrapper\n// Tests the resolve() helper function\n\nimport { resolve } from \"@stdlib/net\";\n\nlet ip = resolve(\"localhost\");\nprint(\"localhost resolves to: \" + ip);\n\nif (ip != \"127.0.0.1\") {\n    print(\"ERROR: localhost should resolve to 127.0.0.1\");\n} else {\n    print(\"DNS resolve test passed!\");\n}\n```", "category": "tests/stdlib_net", "source": "tests/stdlib_net/dns_resolve.hml"}
{"instruction": "How does difference methods work in Hemlock?", "output": "Get the difference in days.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 1, 0, 0, 0);\nlet dt2 = from_date(2025, 1, 11, 0, 0, 0);\n\nlet diff = dt2.diff_days(dt1);\nprint(diff);  // 10\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does log line filtering work in Hemlock?", "output": "```hemlock\nimport { compile, REG_ICASE } from \"@stdlib/regex\";\n\nfn filter_logs(lines: array<string>, pattern: string): array<string> {\n    let regex = compile(pattern, REG_ICASE);\n    let filtered: array<string> = [];\n\n    let i = 0;\n    while (i < lines.length) {\n        if (regex.test(lines[i])) {\n            filtered.push(lines[i]);\n        }\n        i = i + 1;\n    }\n\n    regex.free();\n    return filtered;\n}\n\nlet logs = [\n    \"INFO: Starting application\",\n    \"ERROR: Connection failed\",\n    \"INFO: Processing data\",\n    \"ERROR: Invalid input\",\n];\n\nlet errors = filter_logs(logs, \"error\");\n// Returns: [\"ERROR: Connection failed\", \"ERROR: Invalid input\"]\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does method call detection work in Hemlock?", "output": "```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// Called as method - self is bound\nprint(obj.method());  // 10\n\n// Called as function - self is null (error)\nlet f = obj.method;\nprint(f());  // ERROR: self is not defined\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does async_exists work in Hemlock?", "output": "```hemlock\nimport { async_exists } from \"@stdlib/async_fs\";\n\nlet future = async_exists(\"config.json\");\nif (future.get()) {\n    print(\"Config file exists\");\n}\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Implement a Hemlock program that test switch on null value Expected: PASS.", "output": "```hemlock\n// Test switch on null value\n// Expected: PASS\n\nlet x = null;\nlet matched = false;\n\nswitch (x) {\n    case null:\n        matched = true;\n        break;\n    default:\n        print(\"ERROR: Should match null case\");\n        break;\n}\n\nassert(matched == true, \"should match null case\");\n\nprint(\"PASS\");\n```", "category": "tests/switch", "source": "tests/switch/edge_switch_null.hml"}
{"instruction": "Show me Hemlock code that test array indexing with negative index Tests that negative indices throw catchable exceptions.", "output": "```hemlock\n// Test array indexing with negative index\n// Tests that negative indices throw catchable exceptions\n\nlet arr = [1, 2, 3];\n\n// Test negative indexing\ntry {\n    let val = arr[-1];\n    print(\"ERROR: Should have thrown on negative index\");\n} catch (e) {\n    print(\"PASS: Caught negative index: \" + e);\n}\n```", "category": "tests/arrays", "source": "tests/arrays/edge_index_below_zero.hml"}
{"instruction": "Create a Hemlock program that test invalid binary literal - should fail to parse.", "output": "```hemlock\n// Test invalid binary literal - should fail to parse\nlet x = 0b;\nprint(x);\n```", "category": "tests/primitives", "source": "tests/primitives/binary_invalid.hml"}
{"instruction": "Write Hemlock code that tests open write.", "output": "```hemlock\n// Test: Open file and write\nlet f = open(\"tests/temp/test_write.txt\", \"w\");\nlet bytes1 = f.write(\"Hello, \");\nprint(\"Wrote bytes:\");\nprint(bytes1);\nlet bytes2 = f.write(\"Hemlock!\");\nprint(bytes2);\nf.close();\n\nlet f2 = open(\"tests/temp/test_write.txt\", \"r\");\nlet content = f2.read();\nf2.close();\nprint(content);\n```", "category": "tests/io", "source": "tests/io/open_write.hml"}
{"instruction": "How does runtime type checking work in Hemlock?", "output": "Type annotations are checked at runtime, not compile-time:\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // Runtime error: type mismatch\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hello\");     // Runtime error: type mismatch\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Create a Hemlock program that test typed arrays.", "output": "```hemlock\n// Test typed arrays\n\n// Typed array of i32\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nprint(nums[0]);\nprint(nums.length);\n\n// Typed array of string\nlet names: array<string> = [\"Alice\", \"Bob\", \"Charlie\"];\nprint(names[0]);\nprint(names.length);\n\n// Untyped array (explicit)\nlet mixed: array = [1, \"hello\", true];\nprint(mixed[0]);\nprint(mixed[1]);\nprint(mixed[2]);\nprint(mixed.length);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/typed_arrays.hml"}
{"instruction": "Show an example of examples in Hemlock.", "output": "```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "Create a Hemlock program that test writing zero bytes Expected: PASS.", "output": "```hemlock\n// Test writing zero bytes\n// Expected: PASS\n\nlet f = open(\"/tmp/test_write_zero.txt\", \"w\");\nlet written = f.write(\"\");\nassert(written == 0, \"write('') should return 0\");\n\nf.close();\n\n// Verify file is empty\nlet f2 = open(\"/tmp/test_write_zero.txt\", \"r\");\nlet content = f2.read();\nassert(content == \"\", \"file should be empty\");\nf2.close();\n\nprint(\"PASS\");\n```", "category": "tests/io", "source": "tests/io/edge_write_zero_bytes.hml"}
{"instruction": "How does process control work in Hemlock?", "output": "```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as time from \"@stdlib/time\";\nlet timestamp = time.now();\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "Implement a Hemlock program that test namespace imports.", "output": "```hemlock\n// Test namespace imports\nimport * as math from \"./helper.hml\";\n\n// Use namespace to access exports\nprint(math.add(5, 3));\nprint(math.multiply(6, 7));\nprint(math.PI);\nprint(math.greeting);\n```", "category": "tests/parity", "source": "tests/parity/modules/namespace_import.hml"}
{"instruction": "Write Hemlock code that test float special values (NaN, Infinity) IEEE 754 compliant behavior for float division by zero.", "output": "```hemlock\n// Test float special values (NaN, Infinity)\n// IEEE 754 compliant behavior for float division by zero\n\n// Test Infinity\nlet pos_inf = 1.0 / 0.0;\nlet neg_inf = -1.0 / 0.0;\n\n// Test NaN\nlet nan_val = 0.0 / 0.0;\n\n// Verify Infinity behavior\nprint(pos_inf > 1000000000.0);  // true - Infinity is greater than any finite number\nprint(neg_inf < -1000000000.0); // true - -Infinity is less than any finite number\nprint(pos_inf == pos_inf);      // true - Infinity equals itself\n\n// Verify NaN behavior (NaN is not equal to anything, including itself)\nprint(nan_val == nan_val);      // false - NaN != NaN (IEEE 754)\nprint(nan_val != nan_val);      // true - NaN is not equal to itself\n\n// Test using built-in special values\nprint(__INF > 0.0);             // true\nprint(__NAN == __NAN);          // false\n\nprint(\"PASSED\");\n```", "category": "tests/primitives", "source": "tests/primitives/edge_float_special.hml"}
{"instruction": "How does signal-based state machine work in Hemlock?", "output": "```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // Advance state\nsignal(SIGUSR2, prev_state);  // Go back\n\n// Control state machine:\n// kill -USR1 <pid>  # Next state\n// kill -USR2 <pid>  # Previous state\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does no timeout work in Hemlock?", "output": "Commands can run indefinitely:\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// Blocks for 1000 seconds\n// No way to timeout or cancel\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Implement a Hemlock program that tests alloc free.", "output": "```hemlock\nlet p = alloc(100);\nprint(p);\nfree(p);\n```", "category": "tests/pointers", "source": "tests/pointers/alloc_free.hml"}
{"instruction": "How does getenv(name) work in Hemlock?", "output": "Checking feature flags\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\n// Get common environment variables\nlet home = getenv(\"HOME\");\nlet path = getenv(\"PATH\");\nlet user = getenv(\"USER\");\n\nif (home != null) {\n    print(\"Home directory: \" + home);\n} else {\n    print(\"HOME not set\");\n}\n\n// Check if variable exists\nlet debug = getenv(\"DEBUG\");\nif (debug != null) {\n    print(\"Debug mode enabled\");\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "Create a Hemlock program that test array concat method.", "output": "```hemlock\n// Test array concat method\nlet arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\nlet combined = arr1.concat(arr2);\nprint(combined);\nprint(typeof(combined.length));\n\nlet arr3 = [\"a\", \"b\"];\nlet arr4 = [\"c\", \"d\"];\nlet combined2 = arr3.concat(arr4);\nprint(combined2);\n```", "category": "tests/arrays", "source": "tests/arrays/concat.hml"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Show me Hemlock code that basic function call.", "output": "```hemlock\n// Basic function call\nfn add(a, b) {\n    return a + b;\n}\n\nprint(add(5, 3));\n```", "category": "tests/functions", "source": "tests/functions/basic.hml"}
{"instruction": "How does preserve cursor position work in Hemlock?", "output": "```hemlock\nimport { SAVE_CURSOR, RESTORE_CURSOR } from \"@stdlib/terminal\";\n\nexec(\"printf '\" + SAVE_CURSOR + \"'\");\n\n// ... print status at specific location ...\n\nexec(\"printf '\" + RESTORE_CURSOR + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Write Hemlock code that test string utility builtins.", "output": "```hemlock\n// Test string utility builtins\n\n// Test to_string\nprint(to_string(42) == \"42\");\nprint(to_string(3.14) == \"3.14\");\nprint(to_string(true) == \"true\");\nprint(to_string(false) == \"false\");\nprint(to_string(null) == \"null\");\nprint(to_string(\"hello\") == \"hello\");\n\n// Test string_byte_length\nprint(string_byte_length(\"hello\") == 5);\nprint(string_byte_length(\"\") == 0);\n\n// strerror() returns the last errno message\n// Just test it returns a string\nlet err = strerror();\nprint(typeof(err) == \"string\");\n\n// Test string_to_cstr and cstr_to_string roundtrip\nlet original = \"Hello, World!\";\nlet cstr = string_to_cstr(original);\nprint(cstr != null);\nlet restored = cstr_to_string(cstr);\nprint(restored == original);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/string_utils.hml"}
{"instruction": "Write a Hemlock program that tests equality.", "output": "```hemlock\nlet a = 5 == 5;\nlet b = 5 == 6;\nlet c = 5 != 6;\nlet d = 5 != 5;\nprint(a);\nprint(b);\nprint(c);\nprint(d);\n```", "category": "tests/comparisons", "source": "tests/comparisons/equality.hml"}
{"instruction": "How does planned features work in Hemlock?", "output": "2. Array/Buffer Handling*\n\n```hemlock\n// Future: Better array passing\nlet arr = [1, 2, 3, 4, 5];\nprocess_array(arr);  // Pass to C function\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Write Hemlock code that test finally block that throws exception Expected: PASS (finally exception should override try exception).", "output": "```hemlock\n// Test finally block that throws exception\n// Expected: PASS (finally exception should override try exception)\n\ntry {\n    try {\n        throw \"first error\";\n    } finally {\n        throw \"second error\";\n    }\n} catch (e) {\n    assert(e == \"second error\", \"finally exception should override try exception\");\n    print(\"PASS: Caught exception from finally\");\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/edge_finally_with_throw.hml"}
{"instruction": "How does multi-producer, multi-consumer work in Hemlock?", "output": "Channels can be safely shared between multiple producers and consumers:\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// Multiple producers\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// Multiple consumers\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// Wait for all\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does aes_decrypt(ciphertext: buffer, key: buffer, iv: buffer): string work in Hemlock?", "output": "Decrypt ciphertext using AES-256-CBC, removing PKCS#7 padding.\n\n```hemlock\nimport { aes_decrypt } from \"@stdlib/crypto\";\n\n// Decrypt using same key and IV as encryption\nlet decrypted = aes_decrypt(ciphertext, key, iv);\nprint(decrypted);  // \"Secret message!\"\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "Create a Hemlock program that test file path.", "output": "```hemlock\n// Test: File logging\nimport { Logger, INFO } from \"@stdlib/logging\";\nimport { exists, read_file, remove_file } from \"@stdlib/fs\";\n\n// Test file path\nlet log_file = \"/tmp/hemlock_test_log.txt\";\n\n// Clean up any existing test file\nif (exists(log_file)) {\n    remove_file(log_file);\n}\n\n// Create logger with file output\nlet logger = Logger({\n    output: log_file,\n    level: INFO\n});\n\n// Write some log messages\nlogger.info(\"First log message\");\nlogger.info(\"Second log message\");\nlogger.warn(\"Warning message\");\nlogger.error(\"Error message\");\n\n// Close the logger\nlogger.close();\n\n// Verify file was created\nif (!exists(log_file)) {\n    print(\"FAIL: Log file was not created\");\n} else {\n    print(\"PASS: Log file created\");\n\n    // Read and verify contents\n    let content = read_file(log_file);\n\n    if (content.contains(\"First log message\")) {\n        print(\"PASS: First message logged\");\n    } else {\n        print(\"FAIL: First message not found\");\n    }\n\n    if (content.contains(\"Second log message\")) {\n        print(\"PASS: Second message logged\");\n    } else {\n        print(\"FAIL: Second message not found\");\n    }\n\n    if (content.contains(\"Warning message\")) {\n        print(\"PASS: Warning logged\");\n    } else {\n        print(\"FAIL: Warning not found\");\n    }\n\n    if (content.contains(\"Error message\")) {\n        print(\"PASS: Error logged\");\n    } else {\n        print(\"FAIL: Error not found\");\n    }\n\n    if (content.contains(\"[INFO]\")) {\n        print(\"PASS: INFO level marker found\");\n    } else {\n        print(\"FAIL: INFO level marker not found\");\n    }\n\n    if (content.contains(\"[WARN]\")) {\n        print(\"PASS: WARN level marker found\");\n    } else {\n        print(\"FAIL: WARN level marker not found\");\n    }\n\n    if (content.contains(\"[ERROR]\")) {\n        print(\"PASS: ERROR level marker found\");\n    } else {\n        print(\"FAIL: ERROR level marker not found\");\n    }\n\n    // Clean up\n    remove_file(log_file);\n    print(\"PASS: Cleanup completed\");\n}\n\nprint(\"\\nPASS: File logging test completed\");\n```", "category": "tests/stdlib_logging", "source": "tests/stdlib_logging/file_logging.hml"}
{"instruction": "How does opening files work in Hemlock?", "output": "Use open(path, mode?) to open a file:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // Read mode (default)\nlet f2 = open(\"output.txt\", \"w\");  // Write mode (truncate)\nlet f3 = open(\"log.txt\", \"a\");     // Append mode\nlet f4 = open(\"data.bin\", \"r+\");   // Read/write mode\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Implement a Hemlock program that test WebSocket client with local echo server Requires: libwebsockets-dev installed, make stdlib Run with: ./hemlock tests/stdlib_websocket/test_websocket_echo.hml.", "output": "```hemlock\n// Test WebSocket client with local echo server\n// Requires: libwebsockets-dev installed, make stdlib\n// Run with: ./hemlock tests/stdlib_websocket/test_websocket_echo.hml\n\nimport { WebSocket, WebSocketServer } from \"@stdlib/websocket\";\nimport { sleep } from \"@stdlib/time\";\n\nprint(\"Testing WebSocket client with local echo server...\");\nprint(\"Requires: libwebsockets-dev\");\nprint(\"\");\n\nlet tests_passed = 0;\nlet tests_failed = 0;\n\n// Echo server that reflects messages back to client\nasync fn echo_server(server, num_messages: i32) {\n    print(\"  Echo server: Waiting for client connection...\");\n    let conn = server.accept(10000);\n\n    if (conn == null) {\n        print(\"  Echo server: Accept timeout\");\n        return;\n    }\n\n    defer conn.close();\n    print(\"  Echo server: Client connected\");\n\n    let count = 0;\n    while (count < num_messages) {\n        let msg = conn.recv(5000);\n        if (msg == null) {\n            print(\"  Echo server: Receive timeout\");\n            return;\n        }\n\n        // Echo the message back\n        if (msg.type == \"text\") {\n            conn.send_text(msg.data);\n        } else {\n            conn.send_binary(msg.data, msg.length);\n        }\n\n        count = count + 1;\n    }\n\n    print(\"  Echo server: Echoed \" + count + \" messages\");\n}\n\n// Test 1: Connect to local echo server\nprint(\"Test 1: Connect to local echo server\");\ntry {\n    let server = WebSocketServer(\"127.0.0.1\", 9002);\n    defer server.close();\n\n    // Start echo server in background (will echo 5 messages total)\n    let server_task = spawn(echo_server, server, 5);\n\n    // Give server time to start listening\n    sleep(0.5);\n\n    // Client connects\n    print(\"  Client: Connecting to ws://127.0.0.1:9002...\");\n    let ws = WebSocket(\"ws://127.0.0.1:9002\");\n    defer ws.close();\n\n    assert(ws != null, \"WebSocket should be created\");\n    assert(ws.url == \"ws://127.0.0.1:9002\", \"URL should be stored\");\n    assert(ws.closed == false, \"Should not be closed initially\");\n    print(\"  Client: Connected\");\n\n    print(\"‚úì Connected to local echo server\");\n    tests_passed = tests_passed + 1;\n\n    // Test 2: Send and receive text message\n    print(\"\");\n    print(\"Test 2: Send and receive text message\");\n\n    let test_msg = \"Hello WebSocket!\";\n    let send_ok = ws.send_text(test_msg);\n    assert(send_ok == true, \"send_text should return true\");\n\n    print(\"  Sent: \" + test_msg);\n\n    // Receive echo (5 second timeout)\n    let msg = ws.recv(5000);\n\n    assert(msg != null, \"Should receive message\");\n    assert(msg.type == \"text\", \"Message should be text type\");\n    assert(msg.data == test_msg, \"Echo should match sent message\");\n\n    print(\"  Received: \" + msg.data);\n    print(\"‚úì Echo test passed\");\n    tests_passed = tests_passed + 1;\n\n    // Test 3: Multiple messages\n    print(\"\");\n    print(\"Test 3: Send multiple messages\");\n\n    let count = 0;\n    while (count < 3) {\n        let msg_text = \"Message \" + (count + 1);\n        ws.send_text(msg_text);\n\n        let response = ws.recv(5000);\n        assert(response != null, \"Should receive response\");\n        assert(response.data == msg_text, \"Echo should match\");\n\n        print(\"  \" + msg_text + \" ‚Üí \" + response.data);\n        count = count + 1;\n    }\n\n    print(\"‚úì Multiple messages test passed\");\n    tests_passed = tests_passed + 1;\n\n    // Test 4: Connection close\n    print(\"\");\n    print(\"Test 4: Close connection\");\n\n    ws.close();\n    assert(ws.closed == true, \"Should be marked as closed\");\n\n    print(\"‚úì Connection closed successfully\");\n    tests_passed = tests_passed + 1;\n\n    // Wait for echo server to complete\n    join(server_task);\n\n} catch (e) {\n    print(\"‚úó WebSocket test failed: \" + e);\n    tests_failed = tests_failed + 1;\n}\n\nprint(\"\");\nprint(\"========================================\");\nprint(\"WebSocket Echo Tests Summary:\");\nprint(\"  Passed: \" + tests_passed);\nprint(\"  Failed: \" + tests_failed);\nprint(\"========================================\");\n\nif (tests_failed > 0) {\n    print(\"\");\n    print(\"Some tests failed. Common issues:\");\n    print(\"  - lws_wrapper.so not compiled (run: make stdlib)\");\n    print(\"  - libwebsockets not installed\");\n    print(\"  - Port 9002 already in use\");\n}\n\nprint(\"\");\nassert(tests_failed == 0, \"All WebSocket echo tests should pass\");\n```", "category": "tests/stdlib_websocket", "source": "tests/stdlib_websocket/test_websocket_echo.hml"}
{"instruction": "How does basic structured logging work in Hemlock?", "output": "```hemlock\nimport { Logger, INFO } from \"@stdlib/logging\";\n\nlet logger = Logger();\n\n// Log with structured data\nlogger.info(\"User login\", {\n    user_id: 12345,\n    username: \"alice\",\n    ip_address: \"192.168.1.100\",\n    timestamp: 1638360000\n});\n\n// Output: 1638360123 [INFO] User login {\"user_id\":12345,\"username\":\"alice\",\"ip_address\":\"192.168.1.100\",\"timestamp\":1638360000}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does basic syntax work in Hemlock?", "output": "```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Create a Hemlock program that test switch with expression.", "output": "```hemlock\n// Test switch with expression\n\nlet a = 5;\nlet b = 3;\n\nswitch (a + b) {\n    case 5:\n        print(\"five\");\n        break;\n    case 8:\n        print(\"eight\");\n        break;\n    case 10:\n        print(\"ten\");\n        break;\n}\n\n// Expected: eight\n```", "category": "tests/switch", "source": "tests/switch/expression.hml"}
{"instruction": "Write a Hemlock program that test enum with explicit values.", "output": "```hemlock\n// Test enum with explicit values\n\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);\nprint(Status.ERROR);\nprint(Status.PENDING);\n```", "category": "tests/enums", "source": "tests/enums/explicit_values.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { pad_left, pad_right, center } from \"@stdlib/strings\";\nimport { is_alpha, is_digit, is_alnum, is_whitespace } from \"@stdlib/strings\";\nimport { reverse, lines, words } from \"@stdlib/strings\";\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { now, time_ms, sleep, clock } from \"@stdlib/time\";\n\nlet start = time_ms();\n// ... do work ...\nlet elapsed = time_ms() - start;\nprint(\"Elapsed: \" + typeof(elapsed) + \"ms\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "Show an example of complete rsa example in Hemlock.", "output": "```hemlock\nimport {\n    rsa_generate_key,\n    rsa_sign,\n    rsa_verify,\n    rsa_free_keys,\n    buffer_to_hex\n} from \"@stdlib/crypto\";\n\n// Generate key pair (slow operation)\nprint(\"Generating RSA-2048 key pair...\");\nlet keypair = rsa_generate_key();\ndefer rsa_free_keys(keypair);\n\n// Sign a message\nlet message = \"Authenticate this message\";\nlet signature = rsa_sign(message, keypair);\n\nprint(\"Message: \" + message);\nprint(\"Signature (\" + typeof(signature.length) + \" bytes): \" + buffer_to_hex(signature).substr(0, 64) + \"...\");\n\n// Verify signature\nlet valid = rsa_verify(message, signature, keypair);\nprint(\"Signature valid: \" + typeof(valid));  // true\n\n// Tamper with message\nlet tampered = \"Authenticate this messag3\";  // Changed last character\nlet still_valid = rsa_verify(tampered, signature, keypair);\nprint(\"Tampered message valid: \" + typeof(still_valid));  // false\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "Show me Hemlock code that test input validation and error handling in encoding module.", "output": "```hemlock\n// Test input validation and error handling in encoding module\n\nimport { base64_encode, base64_decode, hex_encode, hex_decode, url_encode, url_decode } from \"@stdlib/encoding\";\n\nlet error_count = 0;\n\n// Test 1: Invalid Base64 - wrong length\ntry {\n    base64_decode(\"ABC\");  // Not multiple of 4\n    throw \"Should have thrown error for invalid Base64 length\";\n} catch (e) {\n    if (!e.contains(\"multiple of 4\")) {\n        throw \"Wrong error message for Base64 length: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 1: Base64 invalid length error\");\n\n// Test 2: Invalid Base64 - invalid characters\ntry {\n    base64_decode(\"A@C!\");  // Invalid characters\n    throw \"Should have thrown error for invalid Base64 characters\";\n} catch (e) {\n    if (!e.contains(\"invalid character\")) {\n        throw \"Wrong error message for Base64 characters: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 2: Base64 invalid character error\");\n\n// Test 3: Invalid Base64 - unexpected padding\ntry {\n    base64_decode(\"=ABC\");  // Padding at start\n    throw \"Should have thrown error for unexpected padding\";\n} catch (e) {\n    if (!e.contains(\"padding\")) {\n        throw \"Wrong error message for Base64 padding: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 3: Base64 unexpected padding error\");\n\n// Test 4: Invalid hex - odd length\ntry {\n    hex_decode(\"ABC\");  // Odd length\n    throw \"Should have thrown error for odd hex length\";\n} catch (e) {\n    if (!e.contains(\"must be even\")) {\n        throw \"Wrong error message for hex length: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 4: Hex invalid length error\");\n\n// Test 5: Invalid hex - invalid characters\ntry {\n    hex_decode(\"XYZW\");  // Invalid hex characters (even length to test character validation)\n    throw \"Should have thrown error for invalid hex characters\";\n} catch (e) {\n    if (!e.contains(\"invalid character\")) {\n        throw \"Wrong error message for hex characters: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 5: Hex invalid character error\");\n\n// Test 6: Invalid URL encoding - incomplete percent sequence\ntry {\n    url_decode(\"Hello%2\");  // Incomplete %XX\n    throw \"Should have thrown error for incomplete percent sequence\";\n} catch (e) {\n    if (!e.contains(\"incomplete\")) {\n        throw \"Wrong error message for URL encoding: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 6: URL incomplete percent sequence error\");\n\n// Test 7: Invalid URL encoding - bad hex in percent\ntry {\n    url_decode(\"Hello%XY\");  // Invalid hex digits\n    throw \"Should have thrown error for invalid hex in percent sequence\";\n} catch (e) {\n    if (!e.contains(\"invalid hex\")) {\n        throw \"Wrong error message for URL hex digits: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 7: URL invalid hex digits error\");\n\n// Test 8: Type checking - base64_encode\ntry {\n    base64_encode(123);  // Not a string\n    throw \"Should have thrown error for non-string argument\";\n} catch (e) {\n    if (!e.contains(\"requires string\")) {\n        throw \"Wrong error message for type check: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 8: base64_encode type checking\");\n\n// Test 9: Type checking - hex_encode\ntry {\n    hex_encode(null);  // Not a string\n    throw \"Should have thrown error for non-string argument\";\n} catch (e) {\n    if (!e.contains(\"requires string\")) {\n        throw \"Wrong error message for type check: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 9: hex_encode type checking\");\n\n// Test 10: Type checking - url_encode\ntry {\n    url_encode(true);  // Not a string\n    throw \"Should have thrown error for non-string argument\";\n} catch (e) {\n    if (!e.contains(\"requires string\")) {\n        throw \"Wrong error message for type check: \" + e;\n    }\n    error_count = error_count + 1;\n}\nprint(\"‚úì Test 10: url_encode type checking\");\n\nprint(\"\\n‚úÖ All error handling tests passed! (\" + typeof(error_count) + \" errors correctly caught)\");\n```", "category": "tests/stdlib_encoding", "source": "tests/stdlib_encoding/test_validation.hml"}
{"instruction": "Write a Hemlock program that test break in loop.", "output": "```hemlock\n// Test break in loop\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n```", "category": "tests/loops", "source": "tests/loops/break.hml"}
{"instruction": "How does concatenation work in Hemlock?", "output": "```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '‚Ä¢' + \" Item\";        // \"‚Ä¢ Item\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "How does basic switch work in Hemlock?", "output": "```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Implement a Hemlock program that tests switch statements.", "output": "```hemlock\nlet x = 85;\nswitch (x) {\n    case 85:\n        print(\"matched\");\n        break;\n}\nprint(\"done\");\n```", "category": "tests/manual", "source": "tests/manual/test_switch.hml"}
{"instruction": "How does async function declaration work in Hemlock?", "output": "```hemlock\nasync fn function_name(params): return_type {\n    // function body\n}\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does basic get request work in Hemlock?", "output": "```hemlock\nimport { get } from \"@stdlib/http\";\n\nlet response = get(\"https://httpbin.org/get\", null);\nprint(\"Status: \" + typeof(response.status_code));\nprint(\"Body: \" + response.body);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does repetition work in Hemlock?", "output": "repeat(count)* - Repeat string n times:\n\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does seed(value) work in Hemlock?", "output": "```hemlock\nimport { seed, rand } from \"@stdlib/math\";\n\nseed(42);\nlet r1 = rand();  // Same sequence every time with seed 42\nlet r2 = rand();\n\nseed(42);         // Reset to same seed\nlet r3 = rand();  // r3 == r1\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does search & find work in Hemlock?", "output": "find(needle)* - Find first occurrence:\n\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6 (index of first occurrence)\nlet pos2 = s.find(\"foo\");       // -1 (not found)\nlet pos3 = s.find(\"l\");         // 2 (first 'l')\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Create a Hemlock program that test random builtins.", "output": "```hemlock\n// Test random builtins\n\n// Test rand returns value in [0, 1)\nseed(42);\nlet r1 = rand();\nprint(r1 >= 0.0);\nprint(r1 < 1.0);\n\n// Test seeding produces reproducible results\nseed(12345);\nlet r2 = rand();\nseed(12345);\nlet r3 = rand();\nprint(r2 == r3);\n\n// Test multiple calls to rand produce different values\nseed(100);\nlet a = rand();\nlet b = rand();\nprint(a != b);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/random_builtins.hml"}
{"instruction": "How does what reference counting handles work in Hemlock?", "output": "Containers are freed* - elements are released:\n\n```hemlock\nlet arr = [obj1, obj2];\n   free(arr);  // obj1 and obj2 get their ref_counts decremented\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does detach work in Hemlock?", "output": "```hemlock\nasync fn background_work() {\n    print(\"Working in background...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // Task continues running independently\n\n// Cannot join detached task\n// join(t);  // ERROR\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Implement a Hemlock program that test string comparison operators.", "output": "```hemlock\n// Test string comparison operators\nlet a = \"a\" < \"b\";\nlet b = \"b\" > \"a\";\nlet c = \"a\" <= \"a\";\nlet d = \"a\" <= \"b\";\nlet e = \"b\" >= \"b\";\nlet f = \"b\" >= \"a\";\nlet g = \"apple\" < \"banana\";\nlet h = \"app\" < \"apple\";\nlet i = \"hello\" == \"hello\";\nlet j = \"hello\" != \"world\";\nprint(a);\nprint(b);\nprint(c);\nprint(d);\nprint(e);\nprint(f);\nprint(g);\nprint(h);\nprint(i);\nprint(j);\n```", "category": "tests/comparisons", "source": "tests/comparisons/string_comparisons.hml"}
{"instruction": "How does execute and check success work in Hemlock?", "output": "```hemlock\nfn exec_success(command: string) {\n    let result = exec(command);\n    return result.exit_code == 0;\n}\n\nif (exec_success(\"test -f myfile.txt\")) {\n    print(\"File exists\");\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Create a Hemlock program that ternary operator with complex expressions.", "output": "```hemlock\n// Ternary operator with complex expressions\n\n// Test 1: Arithmetic in condition\nlet result1 = (5 + 3) > 7 ? 100 : 200;\nprint(typeof(result1));\n\n// Test 2: Arithmetic in branches\nlet a = 10;\nlet result2 = a > 5 ? a * 2 : a + 5;\nprint(typeof(result2));\n\n// Test 3: Logical operators in condition\nlet b = true;\nlet c = false;\nlet result3 = b && c ? \"both true\" : \"not both\";\nprint(result3);\n\nlet result4 = b || c ? \"at least one\" : \"none\";\nprint(result4);\n\n// Test 4: String concatenation in branches\nlet is_alice = true;\nlet name = \"Alice\";\nlet greeting = is_alice ? \"Hello, \" + name : \"Who are you?\";\nprint(greeting);\n\n// Test 5: Ternary in assignment\nlet x = 0;\nx = x == 0 ? 1 : 0;\nprint(typeof(x));\n\n// Test 6: Ternary with null\nlet val = null;\nlet is_null = true;\nlet result6 = is_null ? \"is null\" : \"not null\";\nprint(result6);\n\n// Test 7: Multiple ternaries in one statement (independent)\nlet p = 5;\nlet q = 10;\nlet sum = (p > 3 ? p : 0) + (q > 8 ? q : 0);\nprint(typeof(sum));\n```", "category": "tests/control", "source": "tests/control/ternary_expressions.hml"}
{"instruction": "How does pattern: try/finally work in Hemlock?", "output": "```hemlock\nlet pattern = compile(\"test\");\ntry {\n    let result = pattern.test(\"testing\");\n    // ... process result\n} finally {\n    pattern.free();  // Always freed, even on exception\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does difference methods work in Hemlock?", "output": "Get the difference in seconds.\n\n```hemlock\nlet dt1 = from_date(2025, 1, 1, 12, 0, 0);\nlet dt2 = from_date(2025, 1, 1, 12, 0, 45);\n\nlet diff = dt2.diff_seconds(dt1);\nprint(diff);  // 45\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "2. Use After Free*\n\n```hemlock\n// BAD: Use after free\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // CRASH: using freed memory\n\n// GOOD: Don't use after free\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// Don't touch p2 after this\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Write Hemlock code that test objects.", "output": "```hemlock\n// Test objects\n\nlet obj = { name: \"Alice\", age: 30 };\nprint(obj.name);\nprint(obj.age);\n\n// Modification\nobj.age = 31;\nprint(obj.age);\n\n// Add new field\nobj.city = \"NYC\";\nprint(obj.city);\n\n// Nested objects\nlet data = {\n    user: {\n        profile: {\n            email: \"test@example.com\"\n        }\n    }\n};\nprint(data.user.profile.email);\n\n// Object with method\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n        return self.count;\n    }\n};\n\nprint(counter.increment());\nprint(counter.increment());\nprint(counter.count);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/objects.hml"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport {\n    async_read_file,\n    async_write_file,\n    read_files_parallel,\n    shutdown_async_fs\n} from \"@stdlib/async_fs\";\n\n// Process multiple config files in parallel\nlet config_files = [\"app.json\", \"db.json\", \"cache.json\"];\nlet configs = read_files_parallel(config_files);\n\nprint(\"Loaded \" + configs.length + \" config files\");\n\n// Process configs and write results\nlet i = 0;\nlet futures = [];\nwhile (i < configs.length) {\n    let processed = \"Processed: \" + configs[i];\n    futures.push(async_write_file(\"output_\" + i + \".txt\", processed));\n    i = i + 1;\n}\n\n// Wait for all writes\ni = 0;\nwhile (i < futures.length) {\n    futures[i].get();\n    i = i + 1;\n}\n\nprint(\"All processing complete\");\n\n// Cleanup\nshutdown_async_fs();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does background colors work in Hemlock?", "output": "```hemlock\nimport { BG_RED, BG_GREEN, BG_BLUE, WHITE } from \"@stdlib/terminal\";\n\nprint(WHITE + BG_RED + \" Error \" + RESET);\nprint(WHITE + BG_GREEN + \" Success \" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "5. Dangling Pointers*\n\n```hemlock\n// BAD: Dangling pointer\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // CRASH: p2 is dangling\n\n// GOOD: Track ownership carefully\nlet p = alloc(100);\n// ... use p ...\nfree(p);\n// Don't keep other references to p\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does dynamic field addition work in Hemlock?", "output": "Add new fields at runtime:\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// Add new field\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does closures work in Hemlock?", "output": "Functions capture their environment:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Show an example of example: text processing in Hemlock.", "output": "```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // Normalize whitespace\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does e work in Hemlock?", "output": "The mathematical constant e (Euler's number) ‚âà 2.71828182845904523536\n\n```hemlock\nimport { E } from \"@stdlib/math\";\nlet growth = E * rate;\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does pattern: memoization work in Hemlock?", "output": "```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // Much faster with caching\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show me Hemlock code that simple ThreadPool test - minimal version.", "output": "```hemlock\n// Simple ThreadPool test - minimal version\nimport { ThreadPool } from \"@stdlib/async\";\n\nprint(\"Creating pool...\");\nlet pool = ThreadPool(2);\nprint(\"Pool created\");\n\nfn square(n) {\n    return n * n;\n}\n\nprint(\"Submitting task...\");\nlet future = pool.submit1(square, 5);\nprint(\"Task submitted, getting result...\");\n\nlet result = future.get();\nprint(\"Result: \" + result);\nassert(result == 25);\n\nprint(\"Shutting down...\");\npool.shutdown();\nprint(\"PASS: basic ThreadPool test\");\n```", "category": "tests/async_io", "source": "tests/async_io/thread_pool_simple.hml"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\n// C-style for loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// For-in loop (arrays)\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(\"Item: \" + typeof(item));\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does open work in Hemlock?", "output": "```hemlock\nopen(path: string, mode?: string): file\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Write a Hemlock program that test nested closures and complex capture scenarios.", "output": "```hemlock\n// Test nested closures and complex capture scenarios\n\n// Double nested closure\nfn outer(a) {\n    return fn(b) {\n        return fn(c) {\n            return a + b + c;\n        };\n    };\n}\n\nlet f1 = outer(1);\nlet f2 = f1(2);\nprint(f2(3));\n\n// Closure capturing loop variable\nfn makeCounters() {\n    let counters = [];\n    for (let i = 0; i < 3; i = i + 1) {\n        let val = i;\n        counters.push(fn() { return val; });\n    }\n    return counters;\n}\n\nlet ctrs = makeCounters();\nprint(ctrs[0]());\nprint(ctrs[1]());\nprint(ctrs[2]());\n\n// Closure with mutation\nfn makeCounter() {\n    let count = 0;\n    return {\n        inc: fn() { count = count + 1; return count; },\n        dec: fn() { count = count - 1; return count; },\n        get: fn() { return count; }\n    };\n}\n\nlet counter = makeCounter();\nprint(counter.get());\nprint(counter.inc());\nprint(counter.inc());\nprint(counter.dec());\nprint(counter.get());\n\n// Multiple closures sharing state\nfn makeShared() {\n    let shared = 0;\n    let adder = fn(n) { shared = shared + n; };\n    let getter = fn() { return shared; };\n    return { add: adder, get: getter };\n}\n\nlet s = makeShared();\ns.add(10);\ns.add(5);\nprint(s.get());\n\n// Closure capturing closure\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nlet double = fn(x) { return x * 2; };\nlet addOne = fn(x) { return x + 1; };\nlet composed = compose(double, addOne);\nprint(composed(5));\n\n// Recursive closure (via object)\nlet fib = {\n    calc: fn(n) {\n        if (n <= 1) { return n; }\n        return fib.calc(n - 1) + fib.calc(n - 2);\n    }\n};\nprint(fib.calc(10));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/nested_closures.hml"}
{"instruction": "How does clear() work in Hemlock?", "output": "```hemlock\nimport { clear } from \"@stdlib/terminal\";\n\nclear();  // Fresh screen\nprint(\"Starting new output...\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does type definitions work in Hemlock?", "output": "```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Give me Hemlock code that shows creates a WebSocket client.", "output": "```hemlock\n// WebSocket Client Example (libwebsockets version)\n// Demonstrates @stdlib/websocket (production FFI implementation)\n// Requires: libwebsockets-dev and compiled lws_wrapper.so (make stdlib)\n\nimport { WebSocket } from \"@stdlib/websocket\";\n\nprint(\"=== Hemlock WebSocket Client (libwebsockets) ===\");\nprint(\"\");\nprint(\"Requirements:\");\nprint(\"  1. Install: sudo apt-get install libwebsockets-dev\");\nprint(\"  2. Compile: make stdlib\");\nprint(\"\");\n\ntry {\n    print(\"Connecting to ws://echo.websocket.org...\");\n\n    let ws = WebSocket(\"ws://echo.websocket.org\");\n    defer ws.close();\n\n    print(\"‚úì Connected!\");\n    print(\"\");\n\n    // Send test message\n    print(\"Sending: 'Hello from Hemlock!'\");\n    let sent = ws.send_text(\"Hello from Hemlock!\");\n\n    if (sent) {\n        print(\"‚úì Message sent\");\n    } else {\n        print(\"‚úó Failed to send\");\n    }\n\n    // Wait for echo (5 second timeout)\n    print(\"Waiting for echo (5s timeout)...\");\n    let msg = ws.recv(5000);\n\n    if (msg != null) {\n        print(\"‚úì Received message!\");\n        print(\"  Type: \" + msg.type);\n        if (msg.type == \"text\") {\n            print(\"  Data: \" + msg.data);\n        }\n    } else {\n        print(\"‚úó No response (timeout or connection closed)\");\n    }\n\n    print(\"\");\n    print(\"Sending another message...\");\n    ws.send_text(\"Second message from Hemlock\");\n\n    let msg2 = ws.recv(5000);\n    if (msg2 != null && msg2.type == \"text\") {\n        print(\"‚úì Received: \" + msg2.data);\n    }\n\n    print(\"\");\n    print(\"Closing connection...\");\n\n} catch (e) {\n    print(\"\");\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"  - lws_wrapper.so not found: Run 'make stdlib'\");\n    print(\"  - libwebsockets not installed: Run 'sudo apt-get install libwebsockets-dev'\");\n    print(\"  - Network connectivity issues\");\n    print(\"  - echo.websocket.org is down\");\n}\n\nprint(\"\");\nprint(\"Done!\");\nprint(\"\");\nprint(\"Features of libwebsockets version:\");\nprint(\"  ‚úì SSL/TLS support (wss://\");\nprint(\"  ‚úì Production-ready performance\");\nprint(\"  ‚úì Proper protocol compliance\");\nprint(\"  ‚úì Large message support\");\nprint(\"  ‚úì Automatic ping/pong handling\");\n```", "category": "examples", "source": "examples/websocket_client_lws.hml"}
{"instruction": "Write Hemlock code that test for-in loops on empty containers Expected: PASS.", "output": "```hemlock\n// Test for-in loops on empty containers\n// Expected: PASS\n\nlet count = 0;\n\n// for-in on empty array\nlet arr = [];\nfor (let val in arr) {\n    count = count + 1;\n}\nassert(count == 0, \"for-in on empty array should not iterate\");\n\n// for-in on empty object\nlet obj = {};\nfor (let key in obj) {\n    count = count + 1;\n}\nassert(count == 0, \"for-in on empty object should not iterate\");\n\n// for-in on empty string (if supported)\nlet str = \"\";\nfor (let ch in str) {\n    count = count + 1;\n}\nassert(count == 0, \"for-in on empty string should not iterate\");\n\nprint(\"PASS\");\n```", "category": "tests/control", "source": "tests/control/edge_for_in_empty.hml"}
{"instruction": "Create a Hemlock program that basic FFI callback test This test verifies that callback() creates a valid function pointer and that callback_free() properly cleans up.", "output": "```hemlock\n// Basic FFI callback test\n// This test verifies that callback() creates a valid function pointer\n// and that callback_free() properly cleans up\n\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Simple comparison function\nfn compare(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    return va - vb;\n}\n\n// Test 1: Create and use a callback\nlet arr = alloc(12);  // 3 * 4 bytes\nptr_write_i32(arr, 3);\nptr_write_i32(ptr_offset(arr, 1, 4), 1);\nptr_write_i32(ptr_offset(arr, 2, 4), 2);\n\nlet cmp = callback(compare, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 3, 4, cmp);\n\n// Verify sorted: should be [1, 2, 3]\nlet first = ptr_deref_i32(arr);\nlet second = ptr_deref_i32(ptr_offset(arr, 1, 4));\nlet third = ptr_deref_i32(ptr_offset(arr, 2, 4));\n\nassert(first == 1, \"First element should be 1\");\nassert(second == 2, \"Second element should be 2\");\nassert(third == 3, \"Third element should be 3\");\n\n// Cleanup\ncallback_free(cmp);\nfree(arr);\n\nprint(\"PASS: basic_callback\");\n```", "category": "tests/ffi_callbacks", "source": "tests/ffi_callbacks/basic_callback.hml"}
{"instruction": "Write Hemlock code that test date/time arithmetic.", "output": "```hemlock\n// Test date/time arithmetic\nimport { from_date } from \"@stdlib/datetime\";\n\n// Create a base date: 2025-01-15 12:00:00\nlet dt = from_date(2025, 1, 15, 12, 0, 0);\nprint(\"Base date: \" + dt.to_string());\n\n// Test 1: Add days\nlet dt_plus_5_days = dt.add_days(5);\nprint(\"Test 1: add_days(5) -> \" + dt_plus_5_days.to_string());\nprint(\"  Expected: 2025-01-20 12:00:00\");\n\n// Test 2: Add hours\nlet dt_plus_6_hours = dt.add_hours(6);\nprint(\"Test 2: add_hours(6) -> \" + dt_plus_6_hours.to_string());\nprint(\"  Expected: 2025-01-15 18:00:00\");\n\n// Test 3: Add minutes\nlet dt_plus_45_min = dt.add_minutes(45);\nprint(\"Test 3: add_minutes(45) -> \" + dt_plus_45_min.to_string());\nprint(\"  Expected: 2025-01-15 12:45:00\");\n\n// Test 4: Add seconds\nlet dt_plus_30_sec = dt.add_seconds(30);\nprint(\"Test 4: add_seconds(30) -> \" + dt_plus_30_sec.to_string());\nprint(\"  Expected: 2025-01-15 12:00:30\");\n\n// Test 5: Subtract days (negative)\nlet dt_minus_2_days = dt.add_days(-2);\nprint(\"Test 5: add_days(-2) -> \" + dt_minus_2_days.to_string());\nprint(\"  Expected: 2025-01-13 12:00:00\");\n\n// Test 6: Difference in days\nlet dt1 = from_date(2025, 1, 1, 0, 0, 0);\nlet dt2 = from_date(2025, 1, 11, 0, 0, 0);\nlet diff_days = dt2.diff_days(dt1);\nprint(\"Test 6: diff_days between Jan 1 and Jan 11 -> \" + typeof(diff_days));\nprint(\"  Expected: 10\");\n\n// Test 7: Difference in hours\nlet dt3 = from_date(2025, 1, 1, 10, 0, 0);\nlet dt4 = from_date(2025, 1, 1, 16, 0, 0);\nlet diff_hours = dt4.diff_hours(dt3);\nprint(\"Test 7: diff_hours between 10:00 and 16:00 -> \" + typeof(diff_hours));\nprint(\"  Expected: 6\");\n\n// Test 8: Difference in minutes\nlet dt5 = from_date(2025, 1, 1, 12, 0, 0);\nlet dt6 = from_date(2025, 1, 1, 12, 30, 0);\nlet diff_minutes = dt6.diff_minutes(dt5);\nprint(\"Test 8: diff_minutes between 12:00 and 12:30 -> \" + typeof(diff_minutes));\nprint(\"  Expected: 30\");\n\nprint(\"All arithmetic tests passed!\");\n```", "category": "tests/stdlib_datetime", "source": "tests/stdlib_datetime/test_arithmetic.hml"}
{"instruction": "Implement a Hemlock program that test math builtins.", "output": "```hemlock\n// Test math builtins\n\n// Floor, ceil, round\nprint(floor(3.7));\nprint(ceil(3.2));\nprint(round(3.5));\n\n// Integer-returning versions\nprint(floori(3.7));\nprint(ceili(3.2));\nprint(roundi(3.5));\nprint(trunci(3.9));\nprint(typeof(floori(3.7)));\n\n// Negative numbers\nprint(floori(-3.7));\nprint(ceili(-3.2));\nprint(roundi(-3.5));\n\n// Square root\nprint(sqrt(16.0));\nprint(sqrt(25.0));\n\n// Power\nprint(pow(2.0, 3.0));\nprint(pow(3.0, 2.0));\n\n// Trigonometry\nlet sin_val = sin(0.0);\nlet cos_val = cos(0.0);\nprint(sin_val == 0);\nprint(cos_val == 1);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/math.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { platform, hostname, cpu_count } from \"@stdlib/os\";\n\nprint(\"Platform: \" + platform());\nprint(\"Hostname: \" + hostname());\nprint(\"CPU cores: \" + typeof(cpu_count()));\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does one-shot pattern matching work in Hemlock?", "output": "```hemlock\nimport { test } from \"@stdlib/regex\";\n\n// Test if string matches pattern\nif (test(\"^hello\", \"hello world\")) {\n    print(\"Match found!\");\n}\n\n// Case-insensitive matching\nimport { REG_ICASE } from \"@stdlib/regex\";\nif (test(\"HELLO\", \"hello world\", REG_ICASE)) {\n    print(\"Case-insensitive match!\");\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does basic throw work in Hemlock?", "output": "Throw any value as an exception:\n\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\nthrow [\"error\", \"details\"];\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Write a Hemlock program that test file checksum functions.", "output": "```hemlock\n// Test file checksum functions\n\nimport { file_checksum, file_sha256, file_sha512, file_md5, file_djb2, file_fnv1a, file_murmur3 } from \"@stdlib/hash\";\nimport { sha256, sha512, md5, djb2, fnv1a, murmur3 } from \"@stdlib/hash\";\n\n// Create test files with known content\nlet test_file1 = \"/tmp/hash_test1.txt\";\nlet test_file2 = \"/tmp/hash_test2.txt\";\nlet test_empty = \"/tmp/hash_empty.txt\";\n\nlet f1 = open(test_file1, \"w\");\nf1.write(\"hello world\");\nf1.close();\n\nlet f2 = open(test_file2, \"w\");\nf2.write(\"The quick brown fox jumps over the lazy dog\");\nf2.close();\n\nlet f3 = open(test_empty, \"w\");\nf3.close();\n\n// ========== GENERIC file_checksum() TESTS ==========\n\n// Test with SHA-256\nlet checksum1 = file_checksum(test_file1, sha256);\nassert(typeof(checksum1) == \"string\", \"file_checksum should return string for sha256\");\nassert(checksum1.length == 64, \"file_checksum with sha256 should return 64-char hex\");\n\n// Test with MD5\nlet checksum2 = file_checksum(test_file1, md5);\nassert(typeof(checksum2) == \"string\", \"file_checksum should return string for md5\");\nassert(checksum2.length == 32, \"file_checksum with md5 should return 32-char hex\");\n\n// Test with non-crypto hash (returns string representation of integer)\nlet checksum3 = file_checksum(test_file1, djb2);\nassert(typeof(checksum3) == \"string\", \"file_checksum should return string for djb2\");\n\n// ========== CONVENIENCE FUNCTION TESTS ==========\n\n// Test file_sha256\nlet hash1 = file_sha256(test_file1);\nlet direct1 = sha256(\"hello world\");\nassert(hash1 == direct1, \"file_sha256 should match direct sha256 of content\");\n\n// Test file_sha512\nlet hash2 = file_sha512(test_file1);\nlet direct2 = sha512(\"hello world\");\nassert(hash2 == direct2, \"file_sha512 should match direct sha512 of content\");\n\n// Test file_md5\nlet hash3 = file_md5(test_file1);\nlet direct3 = md5(\"hello world\");\nassert(hash3 == direct3, \"file_md5 should match direct md5 of content\");\n\n// Test file_djb2\nlet hash4 = file_djb2(test_file1);\nlet direct4 = djb2(\"hello world\");\nassert(hash4 == \"\" + direct4, \"file_djb2 should match direct djb2 of content\");\n\n// Test file_fnv1a\nlet hash5 = file_fnv1a(test_file1);\nlet direct5 = fnv1a(\"hello world\");\nassert(hash5 == \"\" + direct5, \"file_fnv1a should match direct fnv1a of content\");\n\n// Test file_murmur3\nlet hash6 = file_murmur3(test_file1);\nlet direct6 = murmur3(\"hello world\");\nassert(hash6 == \"\" + direct6, \"file_murmur3 should match direct murmur3 of content\");\n\n// ========== DIFFERENT FILE CONTENT TESTS ==========\n\n// Test that different files produce different checksums\nlet hash_f1 = file_sha256(test_file1);\nlet hash_f2 = file_sha256(test_file2);\nassert(hash_f1 != hash_f2, \"Different files should have different checksums\");\n\n// Test known SHA-256 of pangram\nlet pangram_hash = file_sha256(test_file2);\nassert(pangram_hash == \"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\",\n       \"SHA-256 of pangram file should match known value\");\n\n// ========== EMPTY FILE TESTS ==========\n\n// Test empty file checksums\nlet empty_sha256 = file_sha256(test_empty);\nassert(empty_sha256 == \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n       \"SHA-256 of empty file should match known value\");\n\nlet empty_md5 = file_md5(test_empty);\nassert(empty_md5 == \"d41d8cd98f00b204e9800998ecf8427e\",\n       \"MD5 of empty file should match known value\");\n\n// ========== CLEANUP ==========\n\n// Remove test files\nlet exec_result1 = exec(\"rm -f \" + test_file1);\nlet exec_result2 = exec(\"rm -f \" + test_file2);\nlet exec_result3 = exec(\"rm -f \" + test_empty);\n\nprint(\"All file checksum tests passed!\");\n```", "category": "tests/stdlib_hash", "source": "tests/stdlib_hash/test_file_checksum.hml"}
{"instruction": "How does default logger instance work in Hemlock?", "output": "```hemlock\nimport { default_logger } from \"@stdlib/logging\";\n\ndefault_logger.info(\"Quick log message\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does reverse(str) work in Hemlock?", "output": "O(n) time complexity where n = string length\n\n```hemlock\nimport { reverse } from \"@stdlib/strings\";\n\nprint(reverse(\"hello\"));       // \"olleh\"\nprint(reverse(\"abc\"));         // \"cba\"\nprint(reverse(\"12345\"));       // \"54321\"\n\n// Single character\nprint(reverse(\"a\"));           // \"a\"\n\n// Empty string\nprint(reverse(\"\"));            // \"\"\n\n// Palindrome\nprint(reverse(\"racecar\"));     // \"racecar\"\n\n// With spaces\nprint(reverse(\"hello world\")); // \"dlrow olleh\"\n\n// Unicode / emojis\nprint(reverse(\"üöÄüåç\"));        // \"üåçüöÄ\"\nprint(reverse(\"HiüöÄ\"));        // \"üöÄiH\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does explicit type conversion work in Hemlock?", "output": "```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8 ‚Üí rune ('A')\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does no select() for multiplexing work in Hemlock?", "output": "Cannot wait on multiple channels simultaneously (planned):\n\n```hemlock\n// NOT YET SUPPORTED:\n// let (value, ch_id) = select(ch1, ch2, ch3);\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does use shell features wisely work in Hemlock?", "output": "```hemlock\n// Use pipes for efficiency\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// Use command substitution\nlet r = exec(\"echo Current user: $(whoami)\");\n\n// Use conditional execution\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show me Hemlock code that test empty input handling.", "output": "```hemlock\n// Test empty input handling\nimport { compress, decompress, gzip, gunzip } from \"@stdlib/compression\";\n\n// Test empty string compression\nlet empty = \"\";\nlet compressed = compress(empty);\n// Empty string zlib compression produces a small output (not zero)\nprint(compressed.length >= 0);  // true\n\n// Test round-trip with empty string - decompress returns empty string\nlet decompressed = decompress(compressed);\nprint(decompressed == \"\");  // true\n\n// Test gzip with empty input (produces valid gzip header/trailer)\nlet gzip_empty = gzip(empty);\nprint(gzip_empty.length > 0);  // true (gzip has header even for empty)\nprint(gzip_empty[0] == 31);    // true (gzip magic byte 1)\nprint(gzip_empty[1] == 139);   // true (gzip magic byte 2)\n\nlet gunzip_result = gunzip(gzip_empty);\nprint(gunzip_result == \"\");  // true\n\nprint(\"Empty input tests passed!\");\n```", "category": "tests/stdlib_compression", "source": "tests/stdlib_compression/empty_input_test.hml"}
{"instruction": "How does pattern: validation work in Hemlock?", "output": "Use exceptions for validation:\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Name is required\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Invalid age\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Invalid email\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invalid\" });\n} catch (e) {\n    print(\"Validation failed: \" + e);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does realloc work in Hemlock?", "output": "```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does log rotation work in Hemlock?", "output": "```hemlock\nimport { file_stat, rename, remove_file, exists } from \"@stdlib/fs\";\n\nfn rotate_log(log_path: string, max_size: i64): null {\n    if (!exists(log_path)) {\n        return null;\n    }\n\n    try {\n        let info = file_stat(log_path);\n\n        if (info.size >= max_size) {\n            // Rotate: log.txt -> log.txt.1 -> log.txt.2 -> ...\n            let i = 4;\n            while (i > 0) {\n                let old_name = log_path + \".\" + typeof(i);\n                let new_name = log_path + \".\" + typeof(i + 1);\n\n                if (exists(old_name)) {\n                    if (i == 4) {\n                        remove_file(old_name);  // Delete oldest\n                    } else {\n                        rename(old_name, new_name);\n                    }\n                }\n\n                i = i - 1;\n            }\n\n            rename(log_path, log_path + \".1\");\n            print(\"Log rotated\");\n        }\n    } catch (e) {\n        print(\"Error rotating log: \" + e);\n    }\n\n    return null;\n}\n\n// Check before each write\nrotate_log(\"app.log\", 10485760);  // 10 MB\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Show an example of example: csv parser in Hemlock.", "output": "```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"apple, banana , cherry\";\nlet fields = parse_csv_line(csv);  // [\"apple\", \"banana\", \"cherry\"]\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does asyncfilestat work in Hemlock?", "output": "```hemlock\nimport { async_file_stat } from \"@stdlib/async_fs\";\n\nlet future = async_file_stat(\"data.txt\");\nlet stat = future.get();\nprint(\"Size: \" + stat.size);\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does hardware access work in Hemlock?", "output": "Interface with hardware libraries:\n\n```hemlock\n// GPIO control on embedded systems\n// USB device communication\n// Serial port access\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Write Hemlock code that test array unshift method.", "output": "```hemlock\n// Test array unshift method\nlet arr = [2, 3, 4];\narr.unshift(1);\nprint(arr);\n\narr.unshift(0);\nprint(arr);\nprint(typeof(arr.length));\n```", "category": "tests/arrays", "source": "tests/arrays/unshift.hml"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "chars()* - Convert to array of runes (codepoints):\n\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (array of runes)\n\n// UTF-8 example\nlet text = \"HiüöÄ\";\nlet chars2 = text.chars();      // ['H', 'i', 'üöÄ']\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does separate concerns with multiple loggers work in Hemlock?", "output": "```hemlock\nlet app_logger = Logger({ output: \"app.log\" });\nlet access_logger = Logger({ output: \"access.log\" });\nlet error_logger = Logger({ output: \"error.log\", level: ERROR });\n\ndefer app_logger.close();\ndefer access_logger.close();\ndefer error_logger.close();\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Write Hemlock code that object contains array, array contains object.", "output": "```hemlock\n// Test: Object and array circular reference\n// Object contains array, array contains object\n\nlet obj = { name: \"test\" };\nlet arr = [1, 2, 3];\n\nobj.items = arr;\narr.push(obj);\n\n// Free obj - this recursively frees the array without stack overflow!\nfree(obj);\n\nprint(\"PASS: Object-array cycle handled correctly\");\n```", "category": "tests/circular_refs", "source": "tests/circular_refs/test_object_array_cycle.hml"}
{"instruction": "How does if statements work in Hemlock?", "output": "```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does future: direct ffi work in Hemlock?", "output": "FFI declarations to libcurl are included in the module for future implementation:\n\n```hemlock\n// Already declared (not yet fully implemented)\nextern fn curl_easy_init(): ptr;\nextern fn curl_easy_setopt(handle: ptr, option: i32, parameter: ptr): i32;\nextern fn curl_easy_perform(handle: ptr): i32;\n// ...\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does low-level builtins work in Hemlock?", "output": "Convert Unix timestamp to UTC time components.\n\n```hemlock\nimport { gmtime } from \"@stdlib/datetime\";\n\nlet utc_components = gmtime(1737037845);\nprint(\"UTC hour: \" + typeof(utc_components.hour));\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does nested if statements work in Hemlock?", "output": "```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"single digit positive\");\n    } else {\n        print(\"multi-digit positive\");\n    }\n} else {\n    print(\"non-positive\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does user-defined signals work in Hemlock?", "output": "```hemlock\n// Use for custom communication\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does input validation work in Hemlock?", "output": "Always validate environment variable contents:\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nfn get_port(): i32 {\n    let port_str = getenv(\"PORT\");\n\n    if (port_str == null) {\n        return 8080;  // Default\n    }\n\n    // Validate: should be numeric, in valid range\n    let port: i32 = port_str;  // Type conversion (simplified)\n\n    if (port < 1 || port > 65535) {\n        print(\"Error: Invalid port \" + typeof(port));\n        return 8080;  // Fall back to default\n    }\n\n    return port;\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does use structured concurrency work in Hemlock?", "output": "Spawn tasks and join them in the same scope:\n\n```hemlock\nfn process_data(data) {\n    // Spawn tasks\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // Always join before returning\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does for-in loops work in Hemlock?", "output": "Iterate over array elements:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // Prints each element\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does exit(code?: i32) work in Hemlock?", "output": "Terminate the current process with an optional exit code (default: 0).\n\n```hemlock\n// Exit with success\nexit();\n\n// Exit with error code\nif (error_occurred) {\n    exit(1);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Show me Hemlock code that test date/time formatting.", "output": "```hemlock\n// Test date/time formatting\nimport { from_date } from \"@stdlib/datetime\";\n\nlet dt = from_date(2025, 3, 15, 14, 30, 45);\n\n// Test various strftime format strings\nprint(\"Test datetime: March 15, 2025, 14:30:45\");\n\n// Test 1: %Y - 4-digit year\nprint(\"Test 1: %Y -> \" + dt.format(\"%Y\"));\n\n// Test 2: %m - Month number\nprint(\"Test 2: %m -> \" + dt.format(\"%m\"));\n\n// Test 3: %d - Day\nprint(\"Test 3: %d -> \" + dt.format(\"%d\"));\n\n// Test 4: %H - Hour (24h)\nprint(\"Test 4: %H -> \" + dt.format(\"%H\"));\n\n// Test 5: %M - Minute\nprint(\"Test 5: %M -> \" + dt.format(\"%M\"));\n\n// Test 6: %S - Second\nprint(\"Test 6: %S -> \" + dt.format(\"%S\"));\n\n// Test 7: Combined format\nprint(\"Test 7: %Y-%m-%d %H:%M:%S -> \" + dt.format(\"%Y-%m-%d %H:%M:%S\"));\n\n// Test 8: ISO format\nprint(\"Test 8: to_iso_string() -> \" + dt.to_iso_string());\n\n// Test 9: Weekday name\nprint(\"Test 9: weekday_name() -> \" + dt.weekday_name());\n\n// Test 10: Month name\nprint(\"Test 10: month_name() -> \" + dt.month_name());\n\n// Test 11: Custom format\nprint(\"Test 11: %B %d, %Y -> \" + dt.format(\"%B %d, %Y\"));\n\n// Test 12: Another custom format\nprint(\"Test 12: %d/%m/%Y -> \" + dt.format(\"%d/%m/%Y\"));\n\nprint(\"All formatting tests passed!\");\n```", "category": "tests/stdlib_datetime", "source": "tests/stdlib_datetime/test_formatting.hml"}
{"instruction": "Show me Hemlock code that accessing non-existent field should error.", "output": "```hemlock\n// Accessing non-existent field should error\nlet obj = { x: 10 };\nprint(obj.y);\n```", "category": "tests/objects", "source": "tests/objects/field_access_error.hml"}
{"instruction": "How does current implementation: exec() wrapper work in Hemlock?", "output": "This module wraps the curl CLI tool via Hemlock's exec() builtin:\n\n```hemlock\n// Simplified internal implementation\nlet cmd = \"curl -s -w '\\\\n%{http_code}' -L -X POST\";\ncmd = cmd + \" -H 'Content-Type: application/json'\";\ncmd = cmd + \" -d '\" + body + \"'\";\ncmd = cmd + \" '\" + url + \"'\";\n\nlet result = exec(cmd);\n// Parse result.output to extract body and status code\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does creating a thread pool work in Hemlock?", "output": "```hemlock\nlet pool = ThreadPool(num_workers: i32);\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does write binary file work in Hemlock?", "output": "```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does interrupt & termination work in Hemlock?", "output": "```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // kill command\nsignal(SIGHUP, handle_hangup);      // Terminal closes\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does logical operators work in Hemlock?", "output": "```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - AND\nprint(x || y);  // true  - OR\nprint(!x);      // false - NOT\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Write Hemlock code that test @stdlib/strings error handling.", "output": "```hemlock\n// Test @stdlib/strings error handling\nimport { pad_left, pad_right, center, is_alpha, reverse } from \"@stdlib/strings\";\n\nprint(\"Testing error cases...\");\n\n// Test pad_left with invalid fill length\ntry {\n    pad_left(\"test\", 10, \"ab\");  // Fill must be single character\n    print(false);  // Should not reach here\n} catch (e) {\n    print(true);  // Expected error\n}\n\n// Test pad_right with invalid fill length\ntry {\n    pad_right(\"test\", 10, \"\");  // Fill must be single character\n    print(false);\n} catch (e) {\n    print(true);\n}\n\n// Test center with invalid fill\ntry {\n    center(\"test\", 10, \"abc\");\n    print(false);\n} catch (e) {\n    print(true);\n}\n\n// Test is_alpha with non-string\ntry {\n    is_alpha(123);\n    print(false);\n} catch (e) {\n    print(true);\n}\n\n// Test reverse with non-string\ntry {\n    reverse(null);\n    print(false);\n} catch (e) {\n    print(true);\n}\n\nprint(\"All error tests passed!\");\n```", "category": "tests/stdlib_strings", "source": "tests/stdlib_strings/test_exception_handling.hml"}
{"instruction": "Write Hemlock code that tests that exceptions from awaited tasks are properly propagated.", "output": "```hemlock\n// Test: await with exception propagation\n// Tests that exceptions from awaited tasks are properly propagated\n\nasync fn task_that_throws(should_throw: i32): i32 {\n    if (should_throw == 1) {\n        throw \"Task error!\";\n    }\n    return 42;\n}\n\n// Test 1: Exception propagation through await\nprint(\"Test 1: Exception propagation through await\");\ntry {\n    let task = spawn(task_that_throws, 1);\n    let result = await task;\n    print(\"ERROR: Should not reach here\");\n} catch (e) {\n    print(\"Caught: \" + e);  // Should print \"Caught: Task error!\"\n}\n\n// Test 2: Successful task with await\nprint(\"Test 2: Successful task with await\");\nlet task2 = spawn(task_that_throws, 0);\nlet result2 = await task2;\nif (result2 == 42) {\n    print(\"Success: got 42\");\n} else {\n    print(\"ERROR: Wrong result\");\n}\n\nprint(\"All tests passed!\");\n```", "category": "tests/async", "source": "tests/async/await_exceptions.hml"}
{"instruction": "Implement a Hemlock program that test array insert method.", "output": "```hemlock\n// Test array insert method\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);\nprint(arr);\n\narr.insert(0, 0);\nprint(arr);\n\narr.insert(6, 6);\nprint(arr);\n```", "category": "tests/arrays", "source": "tests/arrays/insert.hml"}
{"instruction": "How does declare external function work in Hemlock?", "output": "```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does method chaining work in Hemlock?", "output": "```hemlock\n// Chain slice and join\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// Chain concat and slice\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Complex chaining\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does prefix/suffix checking work in Hemlock?", "output": "ends_with(suffix)* - Check if ends with suffix:\n\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How do you import modules in Hemlock?", "output": "Use `import` with the `@stdlib/` prefix for standard library:\n\n```hemlock\n// Import specific items\nimport { sin, cos, PI } from \"@stdlib/math\";\n\n// Import all as namespace\nimport * as math from \"@stdlib/math\";\nlet result = math.sqrt(16);\n\n// Import from local files\nimport { helper } from \"./utils.hml\";\n```\n\nStandard library modules: math, collections, fs, net, json, http, crypto, regex, time, datetime, encoding, hash, logging, terminal, testing, and more.", "category": "concepts/modules", "source": "CLAUDE.md"}
{"instruction": "Implement a Hemlock program that basic collections tests - demonstrating core functionality.", "output": "```hemlock\n// Basic collections tests - demonstrating core functionality\n\nimport { HashMap, Queue, Stack, Set } from \"@stdlib/collections\";\n\nprint(\"=== Testing Queue ===\");\nlet q = Queue();\nq.enqueue(10);\nq.enqueue(20);\nq.enqueue(30);\nassert(q.size == 3, \"Queue size should be 3\");\nassert(q.dequeue() == 10, \"First dequeue should return 10\");\nassert(q.dequeue() == 20, \"Second dequeue should return 20\");\nassert(q.size == 1, \"Queue size should be 1\");\nprint(\"Queue tests passed!\");\n\nprint(\"=== Testing Stack ===\");\nlet s = Stack();\ns.push(10);\ns.push(20);\ns.push(30);\nassert(s.size == 3, \"Stack size should be 3\");\nassert(s.pop() == 30, \"First pop should return 30\");\nassert(s.pop() == 20, \"Second pop should return 20\");\nassert(s.size == 1, \"Stack size should be 1\");\nprint(\"Stack tests passed!\");\n\nprint(\"=== Testing Set ===\");\nlet set = Set();\nassert(set.add(10) == true, \"Adding 10 should return true\");\nassert(set.add(20) == true, \"Adding 20 should return true\");\nassert(set.add(10) == false, \"Adding duplicate 10 should return false\");\nassert(set.size == 2, \"Set size should be 2\");\nassert(set.has(10) == true, \"Set should have 10\");\nassert(set.has(30) == false, \"Set should not have 30\");\nprint(\"Set tests passed!\");\n\nprint(\"=== Testing HashMap (basic) ===\");\nlet map = HashMap();\nmap.set(\"name\", \"Alice\");\nmap.set(\"age\", 30);\nassert(map.size == 2, \"Map size should be 2\");\nassert(map.get(\"name\") == \"Alice\", \"Should get correct value for name\");\nassert(map.get(\"age\") == 30, \"Should get correct value for age\");\nassert(map.has(\"name\") == true, \"Map should have name key\");\nassert(map.has(\"missing\") == false, \"Map should not have missing key\");\nprint(\"HashMap tests passed!\");\n\nprint(\"\");\nprint(\"All basic collections tests passed!\");\n```", "category": "tests/stdlib_collections", "source": "tests/stdlib_collections/test_basic.hml"}
{"instruction": "Write Hemlock code that tests negation.", "output": "```hemlock\nlet a = -5;\nlet b = -(-10);\nlet c = -(3 + 2);\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/negation.hml"}
{"instruction": "Show me Hemlock code that test rune type conversions.", "output": "```hemlock\n// Test rune type conversions\n\n// Integer to rune\nlet code: rune = 65;\nprint(\"Integer to rune:\");\nprint(code);  // 'A'\n\nlet emoji_code: rune = 128640;  // U+1F680 (rocket)\nprint(emoji_code);\n\n// Rune to integer\nlet r = 'Z';\nlet int_val: i32 = r;\nprint(\"\\nRune to integer:\");\nprint(int_val);  // 90\n\nlet rocket = 'üöÄ';\nlet rocket_val: i32 = rocket;\nprint(rocket_val);  // 128640\n\n// Rune to string\nlet ch = 'H';\nlet str: string = ch;\nprint(\"\\nRune to string:\");\nprint(str);  // \"H\"\n\nlet heart: string = '‚ù§';\nprint(heart);  // \"‚ù§\"\n\n// u8 (char) to rune\nlet b: u8 = 72;\nlet byte_rune: rune = b;\nprint(\"\\nu8 to rune:\");\nprint(byte_rune);  // 'H'\n\n// Rune to u8 (will work for ASCII range)\nlet ascii_rune = 'A';\nlet ascii_byte: u8 = ascii_rune;\nprint(\"\\nRune to u8:\");\nprint(ascii_byte);  // 65\n\n// Multiple conversions\nlet x: i32 = 128512;\nlet r2: rune = x;\nlet s: string = r2;\nprint(\"\\nChained conversions (i32 -> rune -> string):\");\nprint(s);  // \"üòÄ\"\n\n// Range checking (should work)\nlet min_rune: rune = 0;\nlet max_rune: rune = 1114111;  // 0x10FFFF\nprint(\"\\nRange checking:\");\nprint(min_rune);\nprint(max_rune);\n\nprint(\"\\nRune type conversions working!\");\n```", "category": "tests/primitives", "source": "tests/primitives/rune_conversions.hml"}
{"instruction": "How does sha256(input: string): string work in Hemlock?", "output": "SHA-256 hash (256-bit / 32-byte output). Industry-standard secure hash.\n\n```hemlock\nlet hash = sha256(\"hello\");\nprint(hash);\n// \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"\n\nassert(hash.length == 64, \"SHA-256 produces 64 hex characters\");\n\n// Empty string\nlet empty_hash = sha256(\"\");\nprint(empty_hash);\n// \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\n// UTF-8 support\nlet emoji_hash = sha256(\"Hello üåç\");\nprint(emoji_hash);  // Works with any UTF-8 string\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does explicit type conversion work in Hemlock?", "output": "Integer ‚Üî Rune:*\n\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32 ‚Üí rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune ‚Üí i32 (90)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does integer literal inference work in Hemlock?", "output": "```hemlock\nlet small = 42;                    // i32 (fits in i32)\nlet large = 5000000000;            // i64 (> i32 max)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (type annotation overrides)\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Create a Hemlock program that test switch fall-through behavior Cases should fall through to subsequent cases unless break is used.", "output": "```hemlock\n// Test switch fall-through behavior\n// Cases should fall through to subsequent cases unless break is used\n\nfn test_fallthrough(x) {\n    let result = \"\";\n    switch (x) {\n        case 1:\n            result = result + \"one\";\n            // No break - should fall through\n        case 2:\n            result = result + \"two\";\n            // No break - should fall through\n        case 3:\n            result = result + \"three\";\n            break;\n        case 4:\n            result = result + \"four\";\n            break;\n        default:\n            result = result + \"default\";\n            break;\n    }\n    return result;\n}\n\n// Test case 1: Should fall through 1 -> 2 -> 3 then break\nprint(test_fallthrough(1));  // Should print: onetwothree\n\n// Test case 2: Should fall through 2 -> 3 then break\nprint(test_fallthrough(2));  // Should print: twothree\n\n// Test case 3: Should just print three then break\nprint(test_fallthrough(3));  // Should print: three\n\n// Test case 4: Should just print four then break\nprint(test_fallthrough(4));  // Should print: four\n\n// Test case 5 (no match): Should print default\nprint(test_fallthrough(5));  // Should print: default\n\n// Test default fallthrough\nfn test_default_fallthrough(x) {\n    let result = \"\";\n    switch (x) {\n        case 1:\n            result = result + \"A\";\n            break;\n        default:\n            result = result + \"D\";\n            // No break - should fall through to case 2\n        case 2:\n            result = result + \"B\";\n            break;\n    }\n    return result;\n}\n\n// Default with fall-through to case 2\nprint(test_default_fallthrough(99));  // Should print: DB\n\n// Case 2 directly\nprint(test_default_fallthrough(2));   // Should print: B\n\n// Case 1 with break\nprint(test_default_fallthrough(1));   // Should print: A\n```", "category": "tests/parity", "source": "tests/parity/language/switch_fallthrough.hml"}
{"instruction": "Show me Hemlock code that test Queue collection.", "output": "```hemlock\n// Test Queue collection\n\nimport { Queue } from \"@stdlib/collections\";\n\nlet q = Queue();\n\n// Test initial state\nassert(q.size == 0, \"Initial size should be 0\");\nassert(q.is_empty() == true, \"Queue should be empty initially\");\nassert(q.peek() == null, \"Peek should return null for empty queue\");\n\n// Test enqueue\nq.enqueue(10);\nassert(q.size == 1, \"Size should be 1 after enqueue\");\nassert(q.is_empty() == false, \"Queue should not be empty\");\nassert(q.peek() == 10, \"Peek should return first element\");\n\nq.enqueue(20);\nq.enqueue(30);\nassert(q.size == 3, \"Size should be 3\");\nassert(q.peek() == 10, \"Peek should still return first element\");\n\n// Test dequeue (FIFO behavior)\nlet val = q.dequeue();\nassert(val == 10, \"First dequeue should return 10\");\nassert(q.size == 2, \"Size should be 2 after dequeue\");\nassert(q.peek() == 20, \"Peek should now return 20\");\n\nlet val2 = q.dequeue();\nassert(val2 == 20, \"Second dequeue should return 20\");\nassert(q.size == 1, \"Size should be 1\");\n\nlet val3 = q.dequeue();\nassert(val3 == 30, \"Third dequeue should return 30\");\nassert(q.size == 0, \"Size should be 0\");\nassert(q.is_empty() == true, \"Queue should be empty\");\n\n// Test dequeue on empty queue (should throw)\nlet caught = false;\ntry {\n    q.dequeue();\n} catch (e) {\n    caught = true;\n}\nassert(caught == true, \"Dequeue on empty queue should throw\");\n\n// Test with different types\nq.enqueue(\"first\");\nq.enqueue(\"second\");\nq.enqueue(42);\nq.enqueue(true);\nq.enqueue(null);\n\nassert(q.size == 5, \"Should handle mixed types\");\nassert(q.dequeue() == \"first\", \"Should dequeue string\");\nassert(q.dequeue() == \"second\", \"Should dequeue string\");\nassert(q.dequeue() == 42, \"Should dequeue number\");\nassert(q.dequeue() == true, \"Should dequeue boolean\");\nassert(q.dequeue() == null, \"Should dequeue null\");\n\n// Test clear\nq.enqueue(1);\nq.enqueue(2);\nq.enqueue(3);\nassert(q.size == 3, \"Size should be 3\");\n\nq.clear();\nassert(q.size == 0, \"Size should be 0 after clear\");\nassert(q.is_empty() == true, \"Queue should be empty after clear\");\n\n// Test to_array\nq.enqueue(\"a\");\nq.enqueue(\"b\");\nq.enqueue(\"c\");\n\nlet arr = q.to_array();\nassert(arr.length == 3, \"Array length should be 3\");\nassert(arr[0] == \"a\", \"Array should have correct order\");\nassert(arr[1] == \"b\", \"Array should have correct order\");\nassert(arr[2] == \"c\", \"Array should have correct order\");\n\n// Ensure to_array doesn't mutate queue\nassert(q.size == 3, \"to_array should not mutate queue\");\n\n// Test large queue\nq.clear();\nlet i = 0;\nwhile (i < 1000) {\n    q.enqueue(i);\n    i = i + 1;\n}\n\nassert(q.size == 1000, \"Should handle large queue\");\n\ni = 0;\nwhile (i < 1000) {\n    let val = q.dequeue();\n    assert(val == i, \"Should dequeue in FIFO order\");\n    i = i + 1;\n}\n\nassert(q.is_empty() == true, \"Queue should be empty after dequeueing all\");\n\nprint(\"All Queue tests passed!\");\n```", "category": "tests/stdlib_collections", "source": "tests/stdlib_collections/test_queue.hml"}
{"instruction": "How does case conversion work in Hemlock?", "output": "to_lower()* - Convert to lowercase:\n\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does use appropriate modes work in Hemlock?", "output": "```hemlock\n// Reading only? Use \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// Completely replacing? Use \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// Adding to end? Use \"a\"\nlet f = open(\"log.txt\", \"a\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Create a Hemlock program that tests else if basic.", "output": "```hemlock\nlet x = 7;\nif (x > 10) {\n    print(1);\n} else if (x > 5) {\n    print(2);\n} else {\n    print(3);\n}\n```", "category": "tests/control", "source": "tests/control/else_if_basic.hml"}
{"instruction": "How does error handling work in Hemlock?", "output": "All WebSocket operations can throw exceptions:\n\n```hemlock\ntry {\n    let ws = WebSocket(\"ws://invalid-host:9999\");\n    ws.send_text(\"test\");\n} catch (e) {\n    print(\"Connection failed: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Provide a Hemlock example of calculates Fibonacci numbers recursively.", "output": "```hemlock\nlet a = 0;\nlet b = 1;\nlet i = 0;\n\nwhile (i < 10) {\n    print(a);\n    let temp = a + b;\n    a = b;\n    b = temp;\n    i = i + 1;\n}\n```", "category": "examples", "source": "examples/fibonacci.hml"}
{"instruction": "Show me Hemlock code that tests mixed.", "output": "```hemlock\nlet tiny: u8 = 5;\nlet small: i16 = -10;\nlet big: i32 = 100;\nlet precise: f64 = 3.14;\nlet result = tiny + small + big + precise;\nprint(result);\n```", "category": "tests/conversions", "source": "tests/conversions/mixed.hml"}
{"instruction": "How does checking argument count work in Hemlock?", "output": "```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <argument>\");\n    // exit or return\n} else {\n    let arg = args[1];\n    // process arg\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Write Hemlock code that test while and for loops.", "output": "```hemlock\n// Test while and for loops\n\n// While loop\nlet i = 0;\nwhile (i < 3) {\n    print(i);\n    i = i + 1;\n}\n\n// For loop\nfor (let j = 0; j < 3; j = j + 1) {\n    print(j);\n}\n\n// Break\nlet k = 0;\nwhile (true) {\n    if (k >= 2) {\n        break;\n    }\n    print(k);\n    k = k + 1;\n}\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/loops.hml"}
{"instruction": "How does processing all arguments except script name work in Hemlock?", "output": "```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Processing: \" + arg);\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Write a Hemlock program that tests waiting on multiple channels simultaneously.", "output": "```hemlock\n// Test: channel select() for multiplexing\n// Tests waiting on multiple channels simultaneously\n\n// Test select with one channel that has data\nasync fn test_select_single() {\n    let ch = channel(10);\n    ch.send(42);\n\n    let result = select([ch]);\n    assert(result != null);\n    assert(result.value == 42);\n\n    ch.close();\n    return \"ok\";\n}\n\nlet r1 = join(spawn(test_select_single));\nassert(r1 == \"ok\");\nprint(\"PASS: select with single channel\");\n\n// Test select with multiple channels - returns first with data\nasync fn test_select_multiple() {\n    let ch1 = channel(10);\n    let ch2 = channel(10);\n    let ch3 = channel(10);\n\n    // Send to ch2 only\n    ch2.send(\"from_ch2\");\n\n    let result = select([ch1, ch2, ch3]);\n    assert(result != null);\n    assert(result.value == \"from_ch2\");\n\n    ch1.close();\n    ch2.close();\n    ch3.close();\n    return \"ok\";\n}\n\nlet r2 = join(spawn(test_select_multiple));\nassert(r2 == \"ok\");\nprint(\"PASS: select returns first channel with data\");\n\n// Test select timeout\nasync fn test_select_timeout() {\n    let ch = channel(10);\n    // Don't send anything\n\n    let start = __time_ms();\n    let result = select([ch], 50);  // 50ms timeout\n    let elapsed = __time_ms() - start;\n\n    // Should timeout (return null)\n    let timed_out = (result == null);\n    // Should have waited approximately 50ms\n    let waited = (elapsed >= 40);\n\n    ch.close();\n    return { timed_out: timed_out, waited: waited };\n}\n\nlet r3 = join(spawn(test_select_timeout));\nassert(r3.timed_out == true);\nassert(r3.waited == true);\nprint(\"PASS: select timeout works\");\n\n// Test select with closed channel\nasync fn test_select_closed() {\n    let ch = channel(10);\n    ch.close();\n\n    let result = select([ch]);\n    // Closed channel should return { channel, value: null }\n    assert(result != null);\n    assert(result.value == null);\n\n    return \"ok\";\n}\n\nlet r4 = join(spawn(test_select_closed));\nassert(r4 == \"ok\");\nprint(\"PASS: select handles closed channel\");\n\n// Test select with producer sending data\nasync fn test_select_with_producer() {\n    let ch1 = channel(10);\n    let ch2 = channel(10);\n\n    // Spawn producer that sends to ch2 after delay\n    let producer = spawn(async fn(ch) {\n        __sleep(0.02);\n        ch.send(\"delayed_message\");\n        return null;\n    }, ch2);\n\n    // Select should wait and receive from ch2\n    let result = select([ch1, ch2], 1000);\n\n    assert(result != null);\n    assert(result.value == \"delayed_message\");\n\n    join(producer);\n    ch1.close();\n    ch2.close();\n    return \"ok\";\n}\n\nlet r5 = join(spawn(test_select_with_producer));\nassert(r5 == \"ok\");\nprint(\"PASS: select waits for producer\");\n\n// Test select with multiple producers\nasync fn test_select_multi_producer() {\n    let ch1 = channel(10);\n    let ch2 = channel(10);\n\n    // First producer (slower - 500ms delay)\n    let p1 = spawn(async fn(ch) {\n        __sleep(0.5);\n        ch.send(\"from_p1\");\n        return null;\n    }, ch1);\n\n    // Second producer (faster - sends immediately)\n    let p2 = spawn(async fn(ch) {\n        __sleep(0.01);\n        ch.send(\"from_p2\");\n        return null;\n    }, ch2);\n\n    // Select should get message from faster producer (ch2)\n    let result = select([ch1, ch2], 1000);\n\n    assert(result != null);\n    assert(result.value == \"from_p2\");\n\n    join(p1);\n    join(p2);\n    ch1.close();\n    ch2.close();\n    return \"ok\";\n}\n\nlet r6 = join(spawn(test_select_multi_producer));\nassert(r6 == \"ok\");\nprint(\"PASS: select with multiple producers\");\n\nprint(\"All channel select tests passed!\");\n```", "category": "tests/async_io", "source": "tests/async_io/channel_select.hml"}
{"instruction": "Write a Hemlock program that test try/catch/finally.", "output": "```hemlock\n// Test try/catch/finally\n\n// Basic try/catch\ntry {\n    print(\"try block\");\n    throw \"error!\";\n    print(\"never reached\");\n} catch (e) {\n    print(\"caught\");\n    print(e);\n}\n\nprint(\"---\");\n\n// Try/finally without throw\ntry {\n    print(\"try 2\");\n} finally {\n    print(\"finally 2\");\n}\n\nprint(\"---\");\n\n// Try/catch/finally with throw\ntry {\n    print(\"try 3\");\n    throw \"boom\";\n} catch (e) {\n    print(\"caught 3\");\n} finally {\n    print(\"finally 3\");\n}\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/exceptions.hml"}
{"instruction": "How does tcp client work in Hemlock?", "output": "```hemlock\nimport { TcpStream } from \"@stdlib/net\";\n\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();\n\nstream.write(\"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\");\nlet response = stream.read(4096);\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Create a Hemlock program that test continue in loop.", "output": "```hemlock\n// Test continue in loop\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 3) {\n        continue;\n    }\n    if (i == 7) {\n        continue;\n    }\n    print(i);\n}\n```", "category": "tests/loops", "source": "tests/loops/continue.hml"}
{"instruction": "Show an example of example 1: file processor in Hemlock.", "output": "```hemlock\n// Usage: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Processing \" + input + \" -> \" + output);\n\n    // Process files\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // Example processing\n        f_out.write(processed);\n\n        print(\"Done!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Show me Hemlock code that tests args index.", "output": "```hemlock\n// Test: Access arguments by index\nif (args.length > 0) {\n    print(args[0]);\n}\nif (args.length > 1) {\n    print(args[1]);\n}\nif (args.length > 2) {\n    print(args[2]);\n}\n```", "category": "tests/args", "source": "tests/args/args_index.hml"}
{"instruction": "Show an example of example: array flattening in Hemlock.", "output": "```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // Nested array - flatten it\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does performance tips work in Hemlock?", "output": "Stat caching:* Cache file_stat() results if checking multiple attributes\n\n```hemlock\nimport { file_stat } from \"@stdlib/fs\";\n\n// Good: Single stat call\nlet info = file_stat(\"large_file.dat\");\nif (info.size > 1000000 && info.is_file) {\n    // Process large file\n}\n\n// Bad: Multiple stat calls\nif (is_file(\"large_file.dat\")) {\n    let info = file_stat(\"large_file.dat\");\n    if (info.size > 1000000) {\n        // Stat called twice\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Implement a Hemlock program that test talloc builtin - typed allocation.", "output": "```hemlock\n// Test talloc builtin - typed allocation\n\n// Allocate space for 10 i32 values (40 bytes)\nlet p1 = talloc(\"i32\", 10);\nprint(\"allocated i32 array\");\n\n// Allocate space for 5 i64 values (40 bytes)\nlet p2 = talloc(\"i64\", 5);\nprint(\"allocated i64 array\");\n\n// Allocate space for 100 bytes\nlet p3 = talloc(\"u8\", 100);\nprint(\"allocated u8 array\");\n\n// Allocate space for 8 pointers (64 bytes)\nlet p4 = talloc(\"ptr\", 8);\nprint(\"allocated ptr array\");\n\n// Free all allocated memory\nfree(p1);\nfree(p2);\nfree(p3);\nfree(p4);\n\nprint(\"freed all\");\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/talloc.hml"}
{"instruction": "Implement a Hemlock program that test string indexing with negative index Tests that negative indices throw catchable exceptions.", "output": "```hemlock\n// Test string indexing with negative index\n// Tests that negative indices throw catchable exceptions\n\nlet s = \"hello\";\n\n// Test negative indexing - this should throw an error\ntry {\n    let ch = s[-1];\n    print(\"ERROR: Should have thrown on negative index\");\n} catch (e) {\n    print(\"PASS: Caught negative index error: \" + e);\n}\n```", "category": "tests/strings", "source": "tests/strings/edge_index_below_zero.hml"}
{"instruction": "How does throw work in Hemlock?", "output": "```hemlock\nif (x < 0) {\n    throw \"x must be positive\";\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does udpsocket work in Hemlock?", "output": "Sets receive timeout in seconds.\n\n```hemlock\nsock.set_timeout(2.0);  // 2 second timeout\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Write Hemlock code that test switch with only default case.", "output": "```hemlock\n// Test switch with only default case\n\nlet x = 42;\n\nswitch (x) {\n    default:\n        print(\"always executes\");\n        break;\n}\n\n// Test that it works with any value\nswitch (\"hello\") {\n    default:\n        print(\"works with strings too\");\n        break;\n}\n\nswitch (null) {\n    default:\n        print(\"works with null\");\n        break;\n}\n\n// Expected output:\n// always executes\n// works with strings too\n// works with null\n```", "category": "tests/switch", "source": "tests/switch/only_default.hml"}
{"instruction": "How does indexing work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "Show me Hemlock code that tests literals.", "output": "```hemlock\nlet a = true;\nlet b = false;\nprint(a);\nprint(b);\n```", "category": "tests/bools", "source": "tests/bools/literals.hml"}
{"instruction": "Write a Hemlock program that test map() - transform each element.", "output": "```hemlock\n// Test map() - transform each element\n\n// Basic map - double each number\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) {\n    return x * 2;\n});\nprint(doubled[0]);  // 2\nprint(doubled[1]);  // 4\nprint(doubled[2]);  // 6\nprint(doubled[3]);  // 8\nprint(doubled[4]);  // 10\nprint(doubled.length);  // 5\n\n// Map to different type - numbers to strings\nlet strs = nums.map(fn(x) {\n    return \"num_\" + typeof(x);\n});\nprint(strs[0]);  // num_1\nprint(strs[1]);  // num_2\nprint(strs[2]);  // num_3\n\n// Map with empty array\nlet empty = [];\nlet empty_result = empty.map(fn(x) {\n    return x * 2;\n});\nprint(empty_result.length);  // 0\n\n// Map with strings\nlet words = [\"hello\", \"world\"];\nlet upper = words.map(fn(s) {\n    return s.to_upper();\n});\nprint(upper[0]);  // HELLO\nprint(upper[1]);  // WORLD\n\n// Map preserves original array\nlet original = [10, 20, 30];\nlet transformed = original.map(fn(x) {\n    return x + 1;\n});\nprint(original[0]);  // 10 (unchanged)\nprint(original[1]);  // 20 (unchanged)\nprint(transformed[0]);  // 11\nprint(transformed[1]);  // 21\n\n// Map with closure\nlet multiplier = 3;\nlet tripled = [1, 2, 3].map(fn(x) {\n    return x * multiplier;\n});\nprint(tripled[0]);  // 3\nprint(tripled[1]);  // 6\nprint(tripled[2]);  // 9\n\n// Complex transformation\nlet objects = [1, 2, 3].map(fn(n) {\n    return n * n;\n});\nprint(objects[0]);  // 1\nprint(objects[1]);  // 4\nprint(objects[2]);  // 9\n```", "category": "tests/arrays", "source": "tests/arrays/map.hml"}
{"instruction": "How does while loops work in Hemlock?", "output": "Infinite loops:*\n\n```hemlock\nwhile (true) {\n    // ... do work\n    if (should_exit) {\n        break;\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Implement a Hemlock program that test enum with mixed auto and explicit values.", "output": "```hemlock\n// Test enum with mixed auto and explicit values\n\nenum Code {\n    A,\n    B = 10,\n    C,\n    D = 20,\n    E\n}\n\nprint(Code.A);\nprint(Code.B);\nprint(Code.C);\nprint(Code.D);\nprint(Code.E);\n```", "category": "tests/enums", "source": "tests/enums/mixed_values.hml"}
{"instruction": "Implement a Hemlock program that test UTF-8 string methods.", "output": "```hemlock\n// Test UTF-8 string methods\n\nlet s = \"Hi üöÄ!\";\n\nprint(\"String: \");\nprint(s);\nprint(\"Length: \");\nprint(s.length);\n\n// Test substr (codepoint-based)\nprint(\"\\nsubstr(0, 3): \");\nprint(s.substr(0, 3));  // Should be \"Hi \"\n\nprint(\"substr(3, 1): \");\nprint(s.substr(3, 1));  // Should be \"üöÄ\"\n\n// Test slice (codepoint-based)\nprint(\"\\nslice(3, 4): \");\nprint(s.slice(3, 4));  // Should be \"üöÄ\"\n\n// Test char_at (returns rune)\nprint(\"\\nchar_at(3): \");\nprint(s.char_at(3));  // Should be 'üöÄ' as rune\n\n// Test byte_at (returns u8)\nprint(\"\\nbyte_at(3): \");\nprint(s.byte_at(3));  // Should be first byte of emoji\n\n// Test chars() (returns array of runes)\nprint(\"\\nchars(): \");\nlet chars = s.chars();\nprint(chars);\n\n// Test bytes() (returns array of u8)\nprint(\"\\nbytes(): \");\nlet bytes = s.bytes();\nprint(bytes);\n\nprint(\"\\nAll methods work!\");\n```", "category": "tests/strings", "source": "tests/strings/utf8_methods.hml"}
{"instruction": "Implement a Hemlock program that tests concat.", "output": "```hemlock\nlet a = \"hello\";\nlet b = \" world\";\nlet c = a + b;\nprint(c);\n```", "category": "tests/strings", "source": "tests/strings/concat.hml"}
{"instruction": "How does reading lines work in Hemlock?", "output": "```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does utf-8 behavior work in Hemlock?", "output": "Multi-byte characters count as one:*\n\n```hemlock\n\"Hello\".length;      // 5\n\"üöÄ\".length;         // 1 (one emoji)\n\"‰Ω†Â•Ω\".length;       // 2 (two Chinese characters)\n\"caf√©\".length;       // 4 (√© is one codepoint)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does memset work in Hemlock?", "output": "```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does basic closures work in Hemlock?", "output": "```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Show me Hemlock code that test logical operators.", "output": "```hemlock\n// Test logical operators\nprint(true && true);\nprint(true && false);\nprint(false && true);\nprint(false && false);\n\nprint(true || true);\nprint(true || false);\nprint(false || true);\nprint(false || false);\n\nprint(!true);\nprint(!false);\n\n// Combined\nlet x = 10;\nlet y = 5;\nprint(x > 5 && y < 10);\nprint(x < 5 || y < 10);\n```", "category": "tests/compiler", "source": "tests/compiler/logical.hml"}
{"instruction": "Implement a Hemlock program that test string to_bytes() method Converts string to a raw buffer.", "output": "```hemlock\n// Test string to_bytes() method\n// Converts string to a raw buffer\n\nlet s = \"Hi\";\nlet b = s.to_bytes();\n\nprint(typeof(b));\nprint(b.length);\nprint(b[0]);  // 'H' = 72\nprint(b[1]);  // 'i' = 105\n\n// Test with emoji (UTF-8 multibyte)\nlet emoji = \"A\";\nlet eb = emoji.to_bytes();\nprint(eb.length);\nprint(eb[0]);  // 'A' = 65\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/methods/string_to_bytes.hml"}
{"instruction": "How does if statements work in Hemlock?", "output": "```hemlock\nif (condition) {\n    // body\n}\n\nif (condition) {\n    // then branch\n} else {\n    // else branch\n}\n\nif (condition1) {\n    // branch 1\n} else if (condition2) {\n    // branch 2\n} else {\n    // default branch\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does recursive data processing work in Hemlock?", "output": "```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Create a Hemlock program that test modulo with negative numbers (C-style modulo).", "output": "```hemlock\n// Test modulo with negative numbers (C-style modulo)\n\n// Negative dividend\nlet a = -10 % 3;\nprint(a);  // -1 (C-style: sign follows dividend)\n\nlet b = -15 % 4;\nprint(b);  // -3\n\n// Negative divisor\nlet c = 10 % -3;\nprint(c);  // 1\n\nlet d = 15 % -4;\nprint(d);  // 3\n\n// Both negative\nlet e = -10 % -3;\nprint(e);  // -1\n\nlet f = -15 % -4;\nprint(f);  // -3\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_signed.hml"}
{"instruction": "Show me how to tests range error in Hemlock.", "output": "```hemlock\nlet x: u8 = 256;\n```", "category": "examples", "source": "examples/range_error.hml"}
{"instruction": "How does null type work in Hemlock?", "output": "```hemlock\nlet x = null;\nlet y: i32 = null;  // ERROR: type mismatch\n\nif (x == null) {\n    print(\"x is null\");\n}\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does now() work in Hemlock?", "output": "Timestamping events\n\n```hemlock\nimport { now } from \"@stdlib/time\";\n\nlet timestamp = now();\nprint(\"Current timestamp: \" + typeof(timestamp));  // e.g., 1700000000\n\n// Measure elapsed time\nlet start = now();\n// ... do work ...\nlet end = now();\nlet seconds_elapsed = end - start;\nprint(\"Took \" + typeof(seconds_elapsed) + \" seconds\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does serialize to json work in Hemlock?", "output": "Convert objects to JSON strings:\n\n```hemlock\n// obj.serialize() - Convert object to JSON string\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Nested objects\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does signal(signum, handler_fn) work in Hemlock?", "output": "Resetting to default:*\n\n```hemlock\nsignal(SIGINT, null);  // Reset SIGINT to default behavior\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Show me how to creates a WebSocket server in Hemlock.", "output": "```hemlock\n// WebSocket Echo Server Example (libwebsockets version)\n// Demonstrates @stdlib/websocket server with async handling\n// Requires: libwebsockets-dev and compiled lws_wrapper.so (make stdlib)\n\nimport { WebSocketServer } from \"@stdlib/websocket\";\n\nprint(\"=== Hemlock WebSocket Echo Server (libwebsockets) ===\");\nprint(\"\");\n\n// Handler for each client connection\nasync fn handle_client(conn, client_id) {\n    defer conn.close();\n\n    print(\"[Client \" + typeof(client_id) + \"] Connected\");\n\n    let message_count = 0;\n\n    while (true) {\n        // Wait for message (10 second timeout)\n        let msg = conn.recv(10000);\n\n        if (msg == null) {\n            print(\"[Client \" + typeof(client_id) + \"] Timeout or connection closed\");\n            break;\n        }\n\n        if (msg.type == \"close\") {\n            print(\"[Client \" + typeof(client_id) + \"] Close frame received\");\n            break;\n        }\n\n        if (msg.type == \"text\") {\n            message_count = message_count + 1;\n            print(\"[Client \" + typeof(client_id) + \"] Message #\" + typeof(message_count) + \": \" + msg.data);\n\n            // Echo back\n            let echo = \"Echo: \" + msg.data;\n            conn.send_text(echo);\n            print(\"[Client \" + typeof(client_id) + \"] Sent: \" + echo);\n        }\n    }\n\n    print(\"[Client \" + typeof(client_id) + \"] Disconnected (handled \" + typeof(message_count) + \" messages)\");\n}\n\n// Main server\ntry {\n    let host = \"0.0.0.0\";\n    let port = 8080;\n\n    print(\"Starting WebSocket server on \" + host + \":\" + typeof(port));\n    print(\"\");\n\n    let server = WebSocketServer(host, port);\n    defer server.close();\n\n    print(\"‚úì Server listening!\");\n    print(\"  Connect with: ws://localhost:8080\");\n    print(\"  Press Ctrl+C to stop\");\n    print(\"\");\n\n    let client_id = 0;\n\n    while (true) {\n        print(\"Waiting for client connection...\");\n\n        // Accept new client (blocking)\n        let conn = server.accept(-1);\n\n        if (conn != null) {\n            client_id = client_id + 1;\n            print(\"New client connected! Spawning handler...\");\n\n            // Handle client in separate task\n            spawn(handle_client, conn, client_id);\n        }\n    }\n\n} catch (e) {\n    print(\"\");\n    print(\"ERROR: \" + e);\n    print(\"\");\n    print(\"Common issues:\");\n    print(\"  - Port 8080 already in use\");\n    print(\"  - lws_wrapper.so not found: Run 'make stdlib'\");\n    print(\"  - libwebsockets not installed: Run 'sudo apt-get install libwebsockets-dev'\");\n    print(\"  - Permission denied (use port > 1024)\");\n}\n\nprint(\"\");\nprint(\"Server stopped\");\n```", "category": "examples", "source": "examples/websocket_server_lws.hml"}
{"instruction": "How does planned features work in Hemlock?", "output": "5. Error Handling*\n\n```hemlock\n// Future: Better error reporting\ntry {\n    let result = risky_c_function();\n} catch (e) {\n    print(\"FFI error: \" + e);\n}\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does capacity management work in Hemlock?", "output": "```hemlock\nlet arr = [];  // Initial capacity: 0\n\narr.push(1);   // Grows to capacity 1\narr.push(2);   // Grows to capacity 2\narr.push(3);   // Grows to capacity 4 (doubles)\narr.push(4);   // Still capacity 4\narr.push(5);   // Grows to capacity 8 (doubles)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does pattern: character filter work in Hemlock?", "output": "```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does message types work in Hemlock?", "output": "Messages have the following structure:\n\n```hemlock\n{\n    type: string,      // \"text\", \"binary\", \"ping\", \"pong\", \"close\"\n    data: string,      // Text content (or null)\n    binary: buffer,    // Binary content (or null)\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Show me Hemlock code that tests that detach works without returning a handle.", "output": "```hemlock\n// Test: detach() fire-and-forget\n// Tests that detach works without returning a handle\n\nimport { sleep } from \"@stdlib/time\";\n\nasync fn log_message(msg: string) {\n    // This would normally do something like write to a log file\n    // For this test, we'll just verify it doesn't crash\n    return null;\n}\n\n// Detach some tasks (fire and forget)\ndetach(log_message, \"Event 1\");\ndetach(log_message, \"Event 2\");\ndetach(log_message, \"Event 3\");\n\n// Give detached tasks time to complete before program exits\n// In a real program, you'd have other work to do here\nsleep(0.05);  // 50ms\n\nprint(\"Detached tasks completed\");\n```", "category": "tests/async", "source": "tests/async/test_detach.hml"}
{"instruction": "How does raw pointers (advanced) work in Hemlock?", "output": "```hemlock\n// Allocate raw memory\nlet ptr = alloc(100);\n\n// Fill with zeros\nmemset(ptr, 0, 100);\n\n// Copy data\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// Free both\nfree(src);\nfree(ptr);\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does reset styles work in Hemlock?", "output": "```hemlock\nimport { BOLD, RESET_BOLD, UNDERLINE, RESET_UNDERLINE, RESET } from \"@stdlib/terminal\";\n\nprint(BOLD + \"Bold \" + RESET_BOLD + \"not bold anymore\");\nprint(UNDERLINE + \"Underlined \" + RESET_UNDERLINE + \"not underlined\");\nprint(BOLD + UNDERLINE + \"Both \" + RESET + \"neither\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does filechecksum(path: string, hashfn): string work in Hemlock?", "output": "Generic file checksum using any hash function.\n\n```hemlock\nimport { sha256, djb2, file_checksum } from \"@stdlib/hash\";\n\n// SHA-256 checksum of a file\nlet checksum = file_checksum(\"data.txt\", sha256);\nprint(checksum);  // Hex string (64 chars for SHA-256)\n\n// Fast non-crypto checksum\nlet fast_checksum = file_checksum(\"data.txt\", djb2);\nprint(fast_checksum);  // String representation of i32\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "Show me Hemlock code that tests open read.", "output": "```hemlock\n// Test: Open file and read in chunks\nlet fw = open(\"tests/temp/test_chunks.txt\", \"w\");\nfw.write(\"Hello, World!\");\nfw.close();\n\nlet f = open(\"tests/temp/test_chunks.txt\", \"r\");\nprint(f);\nprint(\"Mode:\");\nprint(f.mode);\nprint(\"Closed:\");\nprint(f.closed);\nlet chunk1 = f.read(5);\nprint(chunk1);\nlet chunk2 = f.read(8);\nprint(chunk2);\nf.close();\nprint(\"After close:\");\nprint(f.closed);\n```", "category": "tests/io", "source": "tests/io/open_read.hml"}
{"instruction": "How does print work in Hemlock?", "output": "```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// Multiple values\nprint(\"x =\", 10, \"y =\", 20);\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "Implement a Hemlock program that test 1: Generate random bytes.", "output": "```hemlock\n// Test: @stdlib/crypto - Secure random bytes generation\n\nimport { random_bytes } from \"@stdlib/crypto\";\n\nprint(\"Testing random_bytes()...\");\n\n// Test 1: Generate random bytes\nlet bytes = random_bytes(32);\nif (bytes.length != 32) {\n    throw \"Expected 32 bytes, got \" + typeof(bytes.length);\n}\nprint(\"‚úì Generated 32 random bytes\");\n\n// Test 2: Different calls produce different results\nlet bytes1 = random_bytes(16);\nlet bytes2 = random_bytes(16);\n\nlet same = true;\nlet i = 0;\nwhile (i < 16) {\n    if (bytes1[i] != bytes2[i]) {\n        same = false;\n    }\n    i = i + 1;\n}\n\nif (same) {\n    throw \"Random bytes are identical (probability: 1 in 2^128)\";\n}\nprint(\"‚úì Random bytes are different across calls\");\n\n// Test 3: Various sizes\nlet sizes = [1, 8, 16, 32, 64, 128, 256];\ni = 0;\nwhile (i < sizes.length) {\n    let size = sizes[i];\n    let buf = random_bytes(size);\n    if (buf.length != size) {\n        throw \"Expected \" + typeof(size) + \" bytes, got \" + typeof(buf.length);\n    }\n    i = i + 1;\n}\nprint(\"‚úì Various sizes work correctly\");\n\n// Test 4: Error handling - zero size\ntry {\n    random_bytes(0);\n    throw \"Should have thrown error for size 0\";\n} catch (e) {\n    if (e != \"random_bytes() requires positive size\") {\n        throw \"Wrong error message: \" + e;\n    }\n}\nprint(\"‚úì Error handling for zero size\");\n\n// Test 5: Error handling - negative size\ntry {\n    random_bytes(-10);\n    throw \"Should have thrown error for negative size\";\n} catch (e) {\n    if (e != \"random_bytes() requires positive size\") {\n        throw \"Wrong error message: \" + e;\n    }\n}\nprint(\"‚úì Error handling for negative size\");\n\nprint(\"All random_bytes tests passed!\");\n```", "category": "tests/stdlib_crypto", "source": "tests/stdlib_crypto/test_random.hml"}
{"instruction": "How does api work in Hemlock?", "output": "```hemlock\nlet list = LinkedList();\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "Show me Hemlock code that test 1: buffer_to_hex.", "output": "```hemlock\n// Test: @stdlib/crypto - Utility functions (hex encoding/decoding)\n\nimport { buffer_to_hex, hex_to_buffer, random_bytes } from \"@stdlib/crypto\";\n\nprint(\"Testing utility functions...\");\n\n// Test 1: buffer_to_hex\nlet bytes = random_bytes(16);\nlet hex = buffer_to_hex(bytes);\n\nif (typeof(hex) != \"string\") {\n    throw \"Expected string from buffer_to_hex, got \" + typeof(hex);\n}\n\nif (hex.length != 32) {\n    throw \"Expected 32 hex characters for 16 bytes, got \" + typeof(hex.length);\n}\nprint(\"‚úì buffer_to_hex (16 bytes -> 32 hex chars)\");\n\n// Test 2: hex_to_buffer - known values\nlet test_hex = \"48656c6c6f\";  // \"Hello\" in hex\nlet decoded = hex_to_buffer(test_hex);\n\nif (decoded.length != 5) {\n    throw \"Expected 5 bytes, got \" + typeof(decoded.length);\n}\n\n// Check bytes match \"Hello\"\nif (decoded[0] != 72 || decoded[1] != 101 || decoded[2] != 108 || decoded[3] != 108 || decoded[4] != 111) {\n    throw \"Decoded bytes don't match 'Hello'\";\n}\nprint(\"‚úì hex_to_buffer (known value)\");\n\n// Test 3: Round-trip conversion\nlet original = random_bytes(32);\nlet hex2 = buffer_to_hex(original);\nlet restored = hex_to_buffer(hex2);\n\nif (restored.length != original.length) {\n    throw \"Round-trip length mismatch\";\n}\n\nlet i = 0;\nwhile (i < original.length) {\n    if (original[i] != restored[i]) {\n        throw \"Round-trip byte mismatch at index \" + typeof(i);\n    }\n    i = i + 1;\n}\nprint(\"‚úì Round-trip conversion (buffer -> hex -> buffer)\");\n\n// Test 4: Empty buffer (skip - buffer(0) not allowed)\n// Buffers must have positive size in Hemlock\nprint(\"‚úì Empty buffer conversion (skipped - buffer must have positive size)\");\n\n// Test 5: Various sizes\nlet sizes = [1, 2, 8, 16, 32, 64, 100];\ni = 0;\nwhile (i < sizes.length) {\n    let size = sizes[i];\n    let buf = random_bytes(size);\n    let h = buffer_to_hex(buf);\n\n    if (h.length != size * 2) {\n        throw \"Expected \" + typeof(size * 2) + \" hex chars, got \" + typeof(h.length);\n    }\n\n    let back = hex_to_buffer(h);\n    if (back.length != size) {\n        throw \"Round-trip size mismatch for size \" + typeof(size);\n    }\n\n    i = i + 1;\n}\nprint(\"‚úì Various buffer sizes\");\n\n// Test 6: Lowercase hex\nlet lowercase = \"deadbeef\";\nlet lower_buf = hex_to_buffer(lowercase);\n\nif (lower_buf.length != 4) {\n    throw \"Expected 4 bytes from lowercase hex\";\n}\n\nif (lower_buf[0] != 222 || lower_buf[1] != 173 || lower_buf[2] != 190 || lower_buf[3] != 239) {\n    throw \"Lowercase hex decoding failed\";\n}\nprint(\"‚úì Lowercase hex decoding\");\n\n// Test 7: Uppercase hex\nlet uppercase = \"DEADBEEF\";\nlet upper_buf = hex_to_buffer(uppercase);\n\nif (upper_buf.length != 4) {\n    throw \"Expected 4 bytes from uppercase hex\";\n}\n\nif (upper_buf[0] != 222 || upper_buf[1] != 173 || upper_buf[2] != 190 || upper_buf[3] != 239) {\n    throw \"Uppercase hex decoding failed\";\n}\nprint(\"‚úì Uppercase hex decoding\");\n\n// Test 8: Mixed case hex\nlet mixed = \"DeAdBeEf\";\nlet mixed_buf = hex_to_buffer(mixed);\n\nif (mixed_buf.length != 4) {\n    throw \"Expected 4 bytes from mixed case hex\";\n}\nprint(\"‚úì Mixed case hex decoding\");\n\n// Test 9: Error handling - odd length hex string\ntry {\n    hex_to_buffer(\"abc\");  // Odd length\n    throw \"Should have thrown error for odd-length hex string\";\n} catch (e) {\n    if (e != \"hex_to_buffer() requires even-length hex string\") {\n        throw \"Wrong error message: \" + e;\n    }\n}\nprint(\"‚úì Error handling for odd-length hex string\");\n\n// Test 10: All byte values (0-255)\nlet all_bytes = buffer(256);\ni = 0;\nwhile (i < 256) {\n    let val: u8 = i;\n    all_bytes[i] = val;\n    i = i + 1;\n}\n\nlet all_hex = buffer_to_hex(all_bytes);\nlet all_restored = hex_to_buffer(all_hex);\n\nif (all_restored.length != 256) {\n    throw \"All bytes round-trip length mismatch\";\n}\n\ni = 0;\nwhile (i < 256) {\n    if (all_bytes[i] != all_restored[i]) {\n        throw \"All bytes round-trip mismatch at \" + typeof(i);\n    }\n    i = i + 1;\n}\nprint(\"‚úì All byte values (0-255) round-trip\");\n\nprint(\"All utility function tests passed!\");\n```", "category": "tests/stdlib_crypto", "source": "tests/stdlib_crypto/test_utils.hml"}
{"instruction": "How does asyncappendfile work in Hemlock?", "output": "```hemlock\nimport { async_append_file } from \"@stdlib/async_fs\";\n\nlet future = async_append_file(\"log.txt\", \"New log entry\\n\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does try block work in Hemlock?", "output": "The try block executes statements sequentially:\n\n```hemlock\ntry {\n    print(\"Starting...\");\n    risky_operation();\n    print(\"Success!\");  // Only if no exception\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Show me Hemlock code that test sizeof builtin.", "output": "```hemlock\n// Test sizeof builtin\n\n// Integer types\nprint(sizeof(\"i8\"));\nprint(sizeof(\"i16\"));\nprint(sizeof(\"i32\"));\nprint(sizeof(\"i64\"));\n\n// Unsigned types\nprint(sizeof(\"u8\"));\nprint(sizeof(\"u16\"));\nprint(sizeof(\"u32\"));\nprint(sizeof(\"u64\"));\n\n// Float types\nprint(sizeof(\"f32\"));\nprint(sizeof(\"f64\"));\n\n// Other types\nprint(sizeof(\"bool\"));\nprint(sizeof(\"ptr\"));\nprint(sizeof(\"rune\"));\n\n// Aliases\nprint(sizeof(\"integer\"));\nprint(sizeof(\"number\"));\nprint(sizeof(\"byte\"));\n\n// Unknown type returns 0\nprint(sizeof(\"unknown\"));\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/sizeof_builtin.hml"}
{"instruction": "Write a Hemlock program that practical example - resource cleanup with defer.", "output": "```hemlock\n// Practical example - resource cleanup with defer\nfn process_file(filename: string) {\n    print(\"Opening file: \" + filename);\n    let file = open(filename, \"r\");\n    defer file.close();\n    defer print(\"File closed: \" + filename);\n\n    print(\"Processing file...\");\n    let content = file.read();\n    print(\"Content length: \" + typeof(content.length));\n\n    // File automatically closed when function returns\n}\n\n// Create a test file in tests/temp/\nlet test_file = open(\"tests/temp/test_defer.txt\", \"w\");\ntest_file.write(\"Hello, defer!\");\ntest_file.close();\n\n// Process it\nprocess_file(\"tests/temp/test_defer.txt\");\nprint(\"Done!\");\n```", "category": "tests/defer", "source": "tests/defer/defer_resource_cleanup.hml"}
{"instruction": "How does third-party libraries work in Hemlock?", "output": "Example: Cryptography*\n\n```hemlock\n// Use OpenSSL or libsodium\n// Encryption/decryption via FFI\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does panic work in Hemlock?", "output": "```hemlock\npanic(\"unrecoverable error\");\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Create a Hemlock program that test file I/O operations.", "output": "```hemlock\n// Test file I/O operations\n\n// Write a test file\nlet f = open(\"/tmp/hemlock_test.txt\", \"w\");\nf.write(\"Hello, World!\\n\");\nf.write(\"Line 2\\n\");\nf.close();\n\n// Read the file back\nlet f2 = open(\"/tmp/hemlock_test.txt\", \"r\");\nlet content = f2.read();\nprint(content);\nf2.close();\n\n// Test seek and tell\nlet f3 = open(\"/tmp/hemlock_test.txt\", \"r\");\nlet pos1 = f3.tell();\nprint(pos1);\nf3.seek(7);\nlet pos2 = f3.tell();\nprint(pos2);\nlet rest = f3.read();\nprint(rest);\nf3.close();\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/file_io.hml"}
{"instruction": "Show an example of example 1: system information gatherer in Hemlock.", "output": "```hemlock\nfn get_system_info() {\n    print(\"=== System Information ===\");\n\n    // Hostname\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // Uptime\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // Disk usage\n    let r3 = exec(\"df -h /\");\n    print(\"\\nDisk Usage:\");\n    print(r3.output);\n\n    // Memory usage\n    let r4 = exec(\"free -h\");\n    print(\"Memory Usage:\");\n    print(r4.output);\n}\n\nget_system_info();\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does multiple closures work in Hemlock?", "output": "```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "No exceptions are thrown for domain errors\n\n```hemlock\nimport { sqrt, log, NAN, INF } from \"@stdlib/math\";\n\nlet result1 = sqrt(-1.0);  // NAN\nlet result2 = log(0.0);    // -INF\nlet result3 = log(-1.0);   // NAN\n\n// Check for invalid results\nif (result1 != result1) {  // NAN != NAN is true\n    print(\"Result is NaN\");\n}\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Write Hemlock code that empty object.", "output": "```hemlock\n// Empty object\nlet obj = {};\nprint(obj);\n```", "category": "tests/objects", "source": "tests/objects/anonymous_empty.hml"}
{"instruction": "How does uptime() work in Hemlock?", "output": "Performance logging\n\n```hemlock\nimport { uptime } from \"@stdlib/os\";\n\nlet up = uptime();\nlet days = up / 86400;\nlet hours = (up % 86400) / 3600;\nlet minutes = (up % 3600) / 60;\n\nprint(\"System uptime: \" + typeof(days) + \" days, \" + typeof(hours) + \" hours, \" + typeof(minutes) + \" minutes\");\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Write a Hemlock program that tests u8 valid.", "output": "```hemlock\nlet a: u8 = 0;\nlet b: u8 = 255;\nlet c: u8 = 128;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/primitives", "source": "tests/primitives/u8_valid.hml"}
{"instruction": "Create a Hemlock program that tests u32 valid.", "output": "```hemlock\nlet a: u32 = 0;\nlet b: u32 = 2147483647;\nlet c: u32 = 1000000;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/primitives", "source": "tests/primitives/u32_valid.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { ThreadPool, parallel_map } from \"@stdlib/async\";\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does assert_ne(actual, expected) work in Hemlock?", "output": "Assert inequality.\n\n```hemlock\ntest(\"simple inequality\", fn() {\n    assert_ne(5, 10);\n    assert_ne(\"foo\", \"bar\");\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does logger.info(message, data?) work in Hemlock?", "output": "```hemlock\nlogger.info(\"Server started\", { port: 8080, pid: 12345 });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Write Hemlock code that test socket builtins for compiler.", "output": "```hemlock\n// Test socket builtins for compiler\n\n// Test socket constants are available\nprint(AF_INET);\nprint(SOCK_STREAM);\nprint(SOCK_DGRAM);\nprint(SOL_SOCKET);\nprint(SO_REUSEADDR);\n\n// Test socket creation (TCP)\nlet tcp_sock = socket_create(AF_INET, SOCK_STREAM, 0);\nprint(typeof(tcp_sock));\n\n// Test socket properties\nlet fd = tcp_sock.fd;\nprint(fd > 0);\nprint(tcp_sock.closed);\n\n// Test socket close\ntcp_sock.close();\nprint(tcp_sock.closed);\n\n// Test UDP socket creation\nlet udp_sock = socket_create(AF_INET, SOCK_DGRAM, 0);\nprint(typeof(udp_sock));\nudp_sock.close();\nprint(udp_sock.closed);\n\n// Test DNS resolve\nlet ip = dns_resolve(\"localhost\");\nprint(ip);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/sockets.hml"}
{"instruction": "Write Hemlock code that test defer in loop (multiple deferrals) Expected: PASS.", "output": "```hemlock\n// Test defer in loop (multiple deferrals)\n// Expected: PASS\n\nlet counter = 0;\n\nfn increment() {\n    counter = counter + 1;\n}\n\nfn test_defer_loop() {\n    let i = 0;\n    while (i < 3) {\n        defer increment();\n        i = i + 1;\n    }\n}\n\ntest_defer_loop();\n\n// All 3 defers should execute when function returns\nassert(counter == 3, \"all defers from loop should execute\");\n\nprint(\"PASS\");\n```", "category": "tests/defer", "source": "tests/defer/edge_defer_in_loop.hml"}
{"instruction": "Show an example of example: vector math in Hemlock.", "output": "```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "Functions without names, assigned to variables:\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does utf-8 behavior work in Hemlock?", "output": "All string operations work with codepoints (characters), not bytes:\n\n```hemlock\nlet text = \"HelloüöÄWorld\";\nprint(text.length);        // 11 (codepoints)\nprint(text.byte_length);   // 15 (bytes, emoji is 4 bytes)\n\n// Indexing uses codepoints\nlet h = text[0];           // 'H' (rune)\nlet rocket = text[5];      // 'üöÄ' (rune)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Write Hemlock code that basic UTF-8 string test.", "output": "```hemlock\n// Basic UTF-8 string test\n\n// ASCII string\nlet ascii = \"Hello\";\nprint(\"ASCII string: \");\nprint(ascii);\nprint(\"Length (codepoints): \");\nprint(ascii.length);\nprint(\"Byte length: \");\nprint(ascii.byte_length);\n\n// Emoji string\nlet emoji = \"üöÄ\";\nprint(\"\\nEmoji string: \");\nprint(emoji);\nprint(\"Length (codepoints): \");\nprint(emoji.length);\nprint(\"Byte length: \");\nprint(emoji.byte_length);\n\n// Mixed content\nprint(\"\\nMixed string: \");\nlet mixed = \"Hi üöÄ!\";\nprint(mixed);\nprint(\"Length (codepoints): \");\nprint(mixed.length);\nprint(\"Byte length: \");\nprint(mixed.byte_length);\n\nprint(\"\\nUTF-8 strings working!\");\n```", "category": "tests/strings", "source": "tests/strings/utf8_basic.hml"}
{"instruction": "Write a Hemlock program that simple test for memory leak analysis.", "output": "```hemlock\n// Simple test for memory leak analysis\nlet x = 42;\nlet s = \"hello\";\nlet arr = [1, 2, 3];\nprint(\"done\");\n```", "category": "tests/manual", "source": "tests/manual/test_leak.hml"}
{"instruction": "How does type queries work in Hemlock?", "output": "Use typeof() to check value types:\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hello\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Implement a Hemlock program that test continue in switch when inside loop - should skip to next iteration.", "output": "```hemlock\n// Test continue in switch when inside loop - should skip to next iteration\n\nfor (let i = 0; i < 5; i = i + 1) {\n    switch (i) {\n        case 1:\n            print(\"skipping 1\");\n            continue;  // Skip to next loop iteration\n        case 3:\n            print(\"skipping 3\");\n            continue;  // Skip to next loop iteration\n        default:\n            print(\"processing: \" + typeof(i));\n            break;\n    }\n    print(\"  after switch for: \" + typeof(i));\n}\n\n// Expected output:\n// processing: 0\n//   after switch for: 0\n// skipping 1\n// processing: 2\n//   after switch for: 2\n// skipping 3\n// processing: 4\n//   after switch for: 4\n```", "category": "tests/switch", "source": "tests/switch/continue_in_loop.hml"}
{"instruction": "How does assertthrows(fn, expectedmsg?) work in Hemlock?", "output": "Assert function throws exception.\n\n```hemlock\ntest(\"throw assertion\", fn() {\n    assert_throws(fn() {\n        throw \"error!\";\n    });\n\n    assert_throws(fn() {\n        throw \"specific error\";\n    }, \"specific error\");\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "Write a Hemlock example that demonstrates handles command-line arguments.", "output": "```hemlock\n// Example: Command-line argument handling in Hemlock\n//\n// Usage: ./hemlock examples/cli_args.hml [arguments...]\n//\n// This demonstrates accessing command-line arguments via the 'args' array.\n// args[0] is always the script name, args[1+] are the actual arguments.\n\nprint(\"Hemlock Command-Line Arguments Demo\");\nprint(\"====================================\");\nprint(\"\");\n\n// Convert length to string for concatenation\nlet len_str = \"\";\nif (args.length == 0) { len_str = \"0\"; }\nif (args.length == 1) { len_str = \"1\"; }\nif (args.length == 2) { len_str = \"2\"; }\nif (args.length == 3) { len_str = \"3\"; }\nif (args.length == 4) { len_str = \"4\"; }\nif (args.length == 5) { len_str = \"5\"; }\nif (args.length >= 6) { len_str = \"6+\"; }\nprint(\"Total arguments: \" + len_str);\nprint(\"Script name: \" + args[0]);\nprint(\"\");\n\nif (args.length == 1) {\n    print(\"No command-line arguments provided.\");\n    print(\"Try running: ./hemlock examples/cli_args.hml arg1 arg2 arg3\");\n} else {\n    print(\"Arguments provided:\");\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        i = i + 1;\n    }\n}\n```", "category": "examples", "source": "examples/cli_args.hml"}
{"instruction": "Show me Hemlock code that tests that tasks can be spawned and joined.", "output": "```hemlock\n// Test: spawn() and join() basic functionality\n// Tests that tasks can be spawned and joined\n\nasync fn square(x: i32): i32 {\n    return x * x;\n}\n\nlet task = spawn(square, 7);\nlet result = join(task);\n\nprint(result);  // Should print 49\n```", "category": "tests/async", "source": "tests/async/test_spawn_join.hml"}
{"instruction": "How does what reference counting handles work in Hemlock?", "output": "Variables are reassigned* - the old value is released:\n\n```hemlock\nlet x = \"first\";   // ref_count = 1\n   x = \"second\";      // \"first\" released internally, \"second\" ref_count = 1\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does tau work in Hemlock?", "output": "The mathematical constant œÑ (tau) = 2œÄ ‚âà 6.28318530717958647692\n\n```hemlock\nimport { TAU } from \"@stdlib/math\";\nlet full_circle = TAU;  // One complete rotation in radians\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does always check argument count work in Hemlock?", "output": "```hemlock\n// Good\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// Bad - may crash if no arguments\nprocess_file(args[1]);  // Error if args.length == 1\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Write a Hemlock program that test ternary conditional operator.", "output": "```hemlock\n// Test ternary conditional operator\n\n// Basic ternary\nprint(true ? \"yes\" : \"no\");\nprint(false ? \"yes\" : \"no\");\n\n// With variables\nlet a = 10;\nlet b = 5;\nprint(a > b ? \"a is bigger\" : \"b is bigger\");\nprint(a < b ? \"a is smaller\" : \"b is smaller or equal\");\n\n// Nested ternary\nlet x = 5;\nprint(x > 10 ? \"big\" : x > 5 ? \"medium\" : \"small\");\n\nlet y = 15;\nprint(y > 10 ? \"big\" : y > 5 ? \"medium\" : \"small\");\n\n// Ternary with expressions\nlet c = 3;\nlet d = 4;\nprint(c + d > 5 ? c * d : c + d);\n\n// Ternary returning different types\nlet flag = true;\nprint(flag ? 42 : \"not a number\");\n\nlet flag2 = false;\nprint(flag2 ? 42 : \"not a number\");\n\n// Ternary in assignment\nlet result = a > b ? a : b;\nprint(result);\n\n// Ternary with function calls\nfn double(n) { return n * 2; }\nfn triple(n) { return n * 3; }\n\nlet val = 5;\nprint((val > 3 ? double : triple)(val));\n\n// Ternary with null\nlet obj = null;\nprint(obj == null ? \"is null\" : \"not null\");\n\nlet obj2 = { name: \"test\" };\nprint(obj2 == null ? \"is null\" : \"not null\");\n\n// Chained comparisons in ternary\nlet score = 85;\nprint(score >= 90 ? \"A\" : score >= 80 ? \"B\" : score >= 70 ? \"C\" : \"F\");\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/ternary.hml"}
{"instruction": "How does unicode escapes work in Hemlock?", "output": "Use \\u{XXXXXX} syntax for Unicode codepoints (up to 6 hex digits):\n\n```hemlock\nlet rocket = '\\u{1F680}';   // üöÄ Emoji via Unicode escape\nlet heart = '\\u{2764}';     // ‚ù§ Heart\nlet ascii = '\\u{41}';       // 'A' via escape\nlet max = '\\u{10FFFF}';     // Maximum Unicode codepoint\n\n// Leading zeros optional\nlet a = '\\u{41}';           // Same as '\\u{0041}'\nlet b = '\\u{0041}';\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Implement a Hemlock program that test variable scoping and shadowing.", "output": "```hemlock\n// Test variable scoping and shadowing\n\n// Basic shadowing in block\nlet x = 10;\nprint(x);\n{\n    let y = 20;\n    print(y);\n}\nprint(x);\n\n// Shadowing in nested blocks\nlet a = 1;\n{\n    let b = 2;\n    {\n        let c = 3;\n        print(c);\n    }\n    print(b);\n}\nprint(a);\n\n// Shadowing in loops\nlet outer_i = 100;\nfor (let i = 0; i < 3; i = i + 1) {\n    print(i);\n}\nprint(outer_i);\n\n// Shadowing in functions\nlet outer = \"outer\";\nfn test() {\n    let inner = \"inner\";\n    print(inner);\n}\ntest();\nprint(outer);\n\n// Function parameters (with different name to avoid shadowing issue)\nfn doubler(val) {\n    print(val);\n    let result = val * 2;\n    print(result);\n}\ndoubler(5);\n\n// Shadowing in if blocks\nlet cond = true;\nlet val2 = \"original\";\nif (cond) {\n    let inner_val = \"shadowed\";\n    print(inner_val);\n}\nprint(val2);\n\n// Shadowing in catch block\nlet err = \"outer error\";\ntry {\n    throw \"inner error\";\n} catch (e) {\n    print(e);\n}\nprint(err);\n\n// Closure captures outer scope\nlet captured = \"before\";\nlet capturer = fn() { return captured; };\n{\n    let different = \"after\";\n    print(capturer());\n}\n\n// Multiple levels with closures\nlet level = 0;\nfn makeGetter() {\n    let inner_level = 1;\n    return fn() {\n        let deepest = 2;\n        return deepest;\n    };\n}\nprint(makeGetter()());\nprint(level);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/scope_shadowing.hml"}
{"instruction": "How does abort() work in Hemlock?", "output": "Abort the current process, generating a core dump.\n\n```hemlock\nif (critical_error) {\n    abort();  // Terminates immediately with core dump\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Write a Hemlock program that tests contains.", "output": "```hemlock\nlet s = \"hello world\";\nprint(s.contains(\"world\"));\nprint(s.contains(\"foo\"));\nprint(s.contains(\"\"));\nprint(s.contains(\"hello\"));\n```", "category": "tests/strings", "source": "tests/strings/contains.hml"}
{"instruction": "Show an example of complete example in Hemlock.", "output": "```hemlock\nimport { ThreadPool } from \"@stdlib/async\";\n\n// CPU-bound work function\nfn fibonacci(n) {\n    if (n <= 1) { return n; }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Create thread pool\nlet pool = ThreadPool(4);\n\n// Submit multiple tasks\nlet futures = [];\nlet i = 30;\nwhile (i <= 35) {\n    futures.push(pool.submit1(fibonacci, i));\n    i = i + 1;\n}\n\n// Collect results\nprint(\"Computing fibonacci numbers...\");\ni = 0;\nlet n = 30;\nwhile (i < futures.length) {\n    let result = futures[i].get();\n    print(\"fib(\" + n + \") = \" + result);\n    i = i + 1;\n    n = n + 1;\n}\n\n// Cleanup\npool.shutdown();\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "How does named arguments (flags) work in Hemlock?", "output": "Simple pattern for named arguments:\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Verbose mode enabled\");\n}\nprint(\"Input: \" + input_file);\nprint(\"Output: \" + output_file);\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Write Hemlock code that test enums.", "output": "```hemlock\n// Test enums\n\n// Simple enum (auto values: 0, 1, 2)\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nprint(Color.RED);    // 0\nprint(Color.GREEN);  // 1\nprint(Color.BLUE);   // 2\n\n// Enum with explicit values\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 100\n}\n\nprint(Status.OK);       // 0\nprint(Status.ERROR);    // 1\nprint(Status.PENDING);  // 100\n\n// Using enum in switch\nlet color = Color.GREEN;\nswitch (color) {\n    case Color.RED:\n        print(\"red\");\n        break;\n    case Color.GREEN:\n        print(\"green\");\n        break;\n    case Color.BLUE:\n        print(\"blue\");\n        break;\n}\n\n// Comparison\nif (color == Color.GREEN) {\n    print(\"is green\");\n}\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/enums.hml"}
{"instruction": "How does async/await work in Hemlock?", "output": "Hemlock has built-in structured concurrency with pthread-based parallelism:\n\n```hemlock\n// Define async function\nasync fn compute(n: i32): i32 {\n    return n * n;\n}\n\n// Spawn a task\nlet task = spawn(compute, 42);\n\n// Wait for result\nlet result = await task;  // or join(task)\nprint(result);  // 1764\n\n// Fire and forget\ndetach(spawn(background_work));\n\n// Channels for communication\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```", "category": "concepts/async", "source": "CLAUDE.md"}
{"instruction": "How does validate before executing work in Hemlock?", "output": "```hemlock\nfn is_valid_command(cmd: string): bool {\n    // Validate command is safe\n    return true;  // Your validation logic\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Write Hemlock code that tests while.", "output": "```hemlock\nlet i = 5;\nwhile (i >= 0) {\n    print(i);\n    i = i - 1;\n}\n```", "category": "tests/control", "source": "tests/control/while.hml"}
{"instruction": "How does string basics work in Hemlock?", "output": "Strings are mutable and UTF-8:\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5 (character count)\nprint(s.byte_length); // 5 (byte count)\n\n// Mutation\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does named functions work in Hemlock?", "output": "```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // body\n    return value;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does basic iteration work in Hemlock?", "output": "Skip args[0] (script name) and process actual arguments:\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does object type work in Hemlock?", "output": "```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does functions as variables work in Hemlock?", "output": "```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// Reassign\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does type annotations work in Hemlock?", "output": "While types are inferred by default, you can be explicit:\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does i/o work in Hemlock?", "output": "```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interrupt detected\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Termination requested\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does range checking work in Hemlock?", "output": "Type annotations enforce range checks at assignment:\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // ERROR: out of range for u8\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // ERROR: out of range for i8\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // ERROR: u64 cannot be negative\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does benchmarking cpu vs wall time work in Hemlock?", "output": "```hemlock\nimport { clock, time_ms, sleep } from \"@stdlib/time\";\n\nfn benchmark(): null {\n    let wall_start = time_ms();\n    let cpu_start = clock();\n\n    // CPU-intensive work\n    let sum = 0;\n    let i = 0;\n    while (i < 10000000) {\n        sum = sum + i;\n        i = i + 1;\n    }\n\n    // I/O wait (doesn't use CPU)\n    sleep(1.0);\n\n    let wall_elapsed = time_ms() - wall_start;\n    let cpu_elapsed = clock() - cpu_start;\n\n    print(\"Wall time: \" + typeof(wall_elapsed) + \"ms\");\n    print(\"CPU time: \" + typeof(cpu_elapsed * 1000.0) + \"ms\");\n    print(\"Efficiency: \" + typeof(cpu_elapsed * 1000.0 / wall_elapsed * 100.0) + \"%\");\n\n    return null;\n}\n\nbenchmark();\n// Output might be:\n// Wall time: 1245ms\n// CPU time: 234ms\n// Efficiency: 18.8%\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "How does graceful server shutdown work in Hemlock?", "output": "```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown signal received\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Server main loop\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server stopped\");\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does for-in loops work in Hemlock?", "output": "With index and value:*\n\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(\"Index: \" + typeof(i) + \", Value: \" + arr[i]);\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How do you using try/catch in Hemlock?", "output": "```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"File error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Show an example of example usage in Hemlock.", "output": "```hemlock\nprint(\"Script name: \" + args[0]);     // \"script.hml\"\nprint(\"Total args: \" + typeof(args.length));  // \"4\"\nprint(\"First arg: \" + args[1]);       // \"hello\"\nprint(\"Second arg: \" + args[2]);      // \"world\"\nprint(\"Third arg: \" + args[3]);       // \"test 123\"\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does queue operations work in Hemlock?", "output": "shift()* - Remove and return first element:\n\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // Returns 1, arr is now [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Show me Hemlock code that test edge cases for map, filter, reduce.", "output": "```hemlock\n// Test edge cases for map, filter, reduce\n\n// Test 1: map with non-function argument\ntry {\n    let arr = [1, 2, 3];\n    arr.map(42);  // Not a function\n} catch (e) {\n    print(\"Caught: map() argument must be a function\");\n}\n\n// Test 2: filter with non-function argument\ntry {\n    let arr = [1, 2, 3];\n    arr.filter(\"not a function\");\n} catch (e) {\n    print(\"Caught: filter() argument must be a function\");\n}\n\n// Test 3: reduce with non-function argument\ntry {\n    let arr = [1, 2, 3];\n    arr.reduce(null, 0);\n} catch (e) {\n    print(\"Caught: reduce() first argument must be a function\");\n}\n\n// Test 4: reduce on empty array without initial value\ntry {\n    let empty = [];\n    empty.reduce(fn(acc, x) { return acc + x; });\n} catch (e) {\n    print(\"Caught: reduce() on empty array with no initial value\");\n}\n\n// Test 5: map with wrong number of arguments\ntry {\n    let arr = [1, 2, 3];\n    arr.map(fn(x) { return x; }, 42);  // Too many args\n} catch (e) {\n    print(\"Caught: map() expects 1 argument\");\n}\n\n// Test 6: filter with no arguments\ntry {\n    let arr = [1, 2, 3];\n    arr.filter();\n} catch (e) {\n    print(\"Caught: filter() expects 1 argument\");\n}\n\n// Test 7: reduce with too many arguments\ntry {\n    let arr = [1, 2, 3];\n    arr.reduce(fn(acc, x) { return acc; }, 0, 100);\n} catch (e) {\n    print(\"Caught: reduce() expects 1 or 2 arguments\");\n}\n\n// Test 8: callback with wrong arity in map\ntry {\n    let arr = [1, 2, 3];\n    arr.map(fn(x, y, z) { return x; });  // Expects 3 args, gets 1\n} catch (e) {\n    print(\"Caught: Callback expects 3 arguments, got 1\");\n}\n\n// Test 9: callback with wrong arity in filter\ntry {\n    let arr = [1, 2, 3];\n    arr.filter(fn() { return true; });  // Expects 0 args, gets 1\n} catch (e) {\n    print(\"Caught: Callback expects 0 arguments, got 1\");\n}\n\n// Test 10: callback with wrong arity in reduce\ntry {\n    let arr = [1, 2, 3];\n    arr.reduce(fn(x) { return x; }, 0);  // Expects 1 arg, gets 2\n} catch (e) {\n    print(\"Caught: Callback expects 1 arguments, got 2\");\n}\n\n// Test 11: Exception in map callback\ntry {\n    let arr = [1, 2, 3];\n    arr.map(fn(x) {\n        if (x == 2) {\n            throw \"error in map\";\n        }\n        return x;\n    });\n} catch (e) {\n    print(\"Caught: error in map\");\n}\n\n// Test 12: Exception in filter callback\ntry {\n    let arr = [1, 2, 3];\n    arr.filter(fn(x) {\n        if (x == 2) {\n            throw \"error in filter\";\n        }\n        return true;\n    });\n} catch (e) {\n    print(\"Caught: error in filter\");\n}\n\n// Test 13: Exception in reduce callback\ntry {\n    let arr = [1, 2, 3];\n    arr.reduce(fn(acc, x) {\n        if (x == 2) {\n            throw \"error in reduce\";\n        }\n        return acc + x;\n    }, 0);\n} catch (e) {\n    print(\"Caught: error in reduce\");\n}\n\nprint(\"All edge cases passed\");\n```", "category": "tests/arrays", "source": "tests/arrays/edge_map_filter_reduce.hml"}
{"instruction": "How does concurrency work in Hemlock?", "output": "WebSocket integrates with Hemlock's async system:\n\n```hemlock\nasync fn process_messages(ws) {\n    while (true) {\n        let msg = ws.recv(1000);\n        if (msg != null) {\n            // Process message...\n        }\n    }\n}\n\nlet ws = WebSocket(\"ws://example.com\");\ndefer ws.close();\n\nspawn(process_messages, ws);\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does log10(x) work in Hemlock?", "output": "Returns:* f64 - log‚ÇÅ‚ÇÄ(x)\n\n```hemlock\nimport { log10 } from \"@stdlib/math\";\n\nlet result = log10(1.0);    // 0.0\nlet result2 = log10(10.0);  // 1.0\nlet result3 = log10(100.0); // 2.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Create a Hemlock program that test optional parameters with complex default expressions.", "output": "```hemlock\n// Test optional parameters with complex default expressions\n\n// Default expression with arithmetic\nfn power(base: i32, exp?: 2 + 1) {\n    let result = 1;\n    let i = 0;\n    while (i < exp) {\n        result = result * base;\n        i = i + 1;\n    }\n    return result;\n}\n\nprint(power(2));      // 8 (2^3)\nprint(power(2, 4));   // 16 (2^4)\n\n// Default expression with string concatenation\nfn make_url(path: string, protocol?: \"https\" + \"://\") {\n    return protocol + \"example.com\" + path;\n}\n\nprint(make_url(\"/api\"));           // https://example.com/api\nprint(make_url(\"/api\", \"http://\")); // http://example.com/api\n\n// Default expression with array literal\nfn process_items(items?: [1, 2, 3]) {\n    let sum = 0;\n    let i = 0;\n    while (i < items.length) {\n        sum = sum + items[i];\n        i = i + 1;\n    }\n    return sum;\n}\n\nprint(process_items());           // 6\nprint(process_items([10, 20]));   // 30\n\n// Default expression with object literal\nfn configure(opts?: {debug: false, max: 100}) {\n    print(\"Debug: \" + typeof(opts.debug));\n    print(\"Max: \" + typeof(opts.max));\n}\n\nconfigure();                            // Debug: false, Max: 100\nconfigure({debug: true, max: 50});      // Debug: true, Max: 50\n```", "category": "tests/functions", "source": "tests/functions/optional_params_expressions.hml"}
{"instruction": "How does count signal calls work in Hemlock?", "output": "```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler call #\" + typeof(handler_calls));\n\n    // Your handler logic...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Show an example of bitwise examples in Hemlock.", "output": "Common patterns:*\n\n```hemlock\n// Check if bit is set\nif (flags & 0x04) {\n    print(\"bit 2 is set\");\n}\n\n// Set a bit\nflags = flags | 0x08;\n\n// Clear a bit\nflags = flags & ~0x02;\n\n// Toggle a bit\nflags = flags ^ 0x01;\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Implement a Hemlock program that basic defer test - single defer.", "output": "```hemlock\n// Basic defer test - single defer\nfn test_basic() {\n    print(\"start\");\n    defer print(\"deferred\");\n    print(\"end\");\n}\n\ntest_basic();\n```", "category": "tests/defer", "source": "tests/defer/basic_defer.hml"}
{"instruction": "Create a Hemlock program that test seeking to negative position Tests that negative seek throws catchable exception.", "output": "```hemlock\n// Test seeking to negative position\n// Tests that negative seek throws catchable exception\n\nlet f = open(\"/tmp/test_seek_negative.txt\", \"w\");\nf.write(\"test data\");\n\ntry {\n    f.seek(-10);\n    print(\"ERROR: seek to negative position should fail\");\n} catch (e) {\n    print(\"PASS: Caught seek to negative: \" + e);\n}\n\nf.close();\n```", "category": "tests/io", "source": "tests/io/edge_seek_bounds.hml"}
{"instruction": "How does unsetenv(name) work in Hemlock?", "output": "Resetting configuration\n\n```hemlock\nimport { setenv, unsetenv, getenv } from \"@stdlib/env\";\n\n// Set a temporary variable\nsetenv(\"TEMP_VAR\", \"temporary\");\nprint(\"Before: \" + getenv(\"TEMP_VAR\"));  // \"temporary\"\n\n// Remove it\nunsetenv(\"TEMP_VAR\");\nprint(\"After: \" + getenv(\"TEMP_VAR\"));   // null\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does types work in Hemlock?", "output": "Hemlock has a rich type system:\n\n```hemlock\n// Integers\nlet small: i8 = 127;          // 8-bit signed\nlet byte: u8 = 255;           // 8-bit unsigned\nlet num: i32 = 2147483647;    // 32-bit signed (default)\nlet big: i64 = 9223372036854775807;  // 64-bit signed\n\n// Floats\nlet f: f32 = 3.14;            // 32-bit float\nlet d: f64 = 2.71828;         // 64-bit float (default)\n\n// Strings and characters\nlet text: string = \"Hello\";   // UTF-8 string\nlet emoji: rune = 'üöÄ';       // Unicode codepoint\n\n// Boolean and null\nlet flag: bool = true;\nlet empty = null;\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "Write a Hemlock program that comprehensive comparison operations test Tests: ==, !=, <, >, <=, >=.", "output": "```hemlock\n// Comprehensive comparison operations test\n// Tests: ==, !=, <, >, <=, >=\n\n// Numeric equality\nprint(5 == 5);   // true\nprint(5 == 6);   // false\nprint(5 != 6);   // true\nprint(5 != 5);   // false\n\n// Numeric relational\nprint(3 < 5);    // true\nprint(5 < 3);    // false\nprint(5 > 3);    // true\nprint(3 > 5);    // false\n\nprint(5 <= 5);   // true\nprint(5 <= 6);   // true\nprint(6 <= 5);   // false\nprint(5 >= 5);   // true\nprint(6 >= 5);   // true\nprint(5 >= 6);   // false\n\n// Float comparisons\nprint(3.14 < 3.15);  // true\nprint(3.14 > 3.13);  // true\nprint(3.14 == 3.14); // true\n\n// String equality\nprint(\"abc\" == \"abc\");   // true\nprint(\"abc\" == \"def\");   // false\nprint(\"abc\" != \"def\");   // true\n\n// String ordering\nprint(\"abc\" < \"def\");    // true\nprint(\"def\" > \"abc\");    // true\nprint(\"abc\" <= \"abc\");   // true\nprint(\"abc\" >= \"abc\");   // true\nprint(\"xyz\" > \"abc\");    // true\n\n// Boolean comparisons\nprint(true == true);     // true\nprint(true == false);    // false\nprint(true != false);    // true\n\n// Null comparisons\nprint(null == null);     // true\nlet x = null;\nprint(x == null);        // true\n```", "category": "tests/parity", "source": "tests/parity/language/comparisons.hml"}
{"instruction": "Show an example of example: case conversion in Hemlock.", "output": "```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // Convert to uppercase (subtract 32)\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // Convert to lowercase (add 32)\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does writefilesparallel work in Hemlock?", "output": "```hemlock\nwrite_files_parallel(files: array<object>): null\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does when to use type annotations work in Hemlock?", "output": "Unnecessary ceremony\n\n```hemlock\n// Unnecessary\nlet x: i32 = 42;\n\n// Better\nlet x = 42;\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does closures in callbacks work in Hemlock?", "output": "Callbacks capture their closure environment, so they can access outer scope variables:\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // Can access 'multiplier' from outer scope\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does integer literals work in Hemlock?", "output": "```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // Auto i64\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does asynccopyfile work in Hemlock?", "output": "```hemlock\nasync_copy_file(src: string, dst: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does loading spinner work in Hemlock?", "output": "```hemlock\nimport { Spinner, SPINNER_DOTS } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nfn load_data(): null {\n    let spinner = Spinner(SPINNER_DOTS());\n\n    let i = 0;\n    while (i < 100) {\n        spinner.spin();\n        sleep(0.05);\n        // ... actual loading work ...\n        i = i + 1;\n    }\n\n    spinner.finish(\"Data loaded successfully!\");\n    return null;\n}\n\nload_data();\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does hide cursor during animations work in Hemlock?", "output": "```hemlock\nimport { HIDE_CURSOR, SHOW_CURSOR, Spinner } from \"@stdlib/terminal\";\n\nexec(\"printf '\" + HIDE_CURSOR + \"'\");\nlet spinner = Spinner();\n\n// ... animation loop ...\n\nspinner.finish();\nexec(\"printf '\" + SHOW_CURSOR + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Create a Hemlock program that assign function to variable.", "output": "```hemlock\n// Assign function to variable\nlet adder = fn(a, b) {\n    return a + b;\n};\n\nprint(adder(10, 20));\n```", "category": "tests/functions", "source": "tests/functions/assign.hml"}
{"instruction": "Show an example of example 1: interrupt handler with cleanup in Hemlock.", "output": "```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// Register handlers\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// Simulate some work\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // Trigger SIGUSR1 every 10 iterations\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does logger.close() work in Hemlock?", "output": "```hemlock\nlet logger = Logger({ output: \"app.log\" });\n\n// ... use logger ...\n\nlogger.close();  // Close file when done\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does reduce pattern work in Hemlock?", "output": "```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does functions as return values work in Hemlock?", "output": "```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does building path dynamically work in Hemlock?", "output": "```hemlock\nimport { getenv, setenv } from \"@stdlib/env\";\n\nfn add_to_path(directory: string): null {\n    let current_path = getenv(\"PATH\");\n\n    if (current_path == null) {\n        setenv(\"PATH\", directory);\n    } else {\n        // Check if already in PATH\n        if (!current_path.contains(directory)) {\n            setenv(\"PATH\", current_path + \":\" + directory);\n        }\n    }\n\n    return null;\n}\n\n// Add custom directories to PATH\nadd_to_path(\"/usr/local/myapp/bin\");\nadd_to_path(\"/opt/tools/bin\");\n\nprint(\"Updated PATH: \" + getenv(\"PATH\"));\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does pitfall: finally override work in Hemlock?", "output": "```hemlock\n// BAD: Finally overrides return\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // ‚ö†Ô∏è Returns 0, not 42!\n    }\n}\n\n// GOOD: Don't return in finally\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // Just cleanup, no return\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does file type work in Hemlock?", "output": "```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Write a Hemlock program that test terminal text styles.", "output": "```hemlock\n// Test terminal text styles\nimport {\n    BOLD, DIM, ITALIC, UNDERLINE, BLINK, REVERSE, STRIKETHROUGH,\n    RESET, RESET_BOLD, RESET_UNDERLINE, RED, GREEN\n} from \"@stdlib/terminal\";\n\nprint(\"=== Terminal Style Tests ===\");\nprint(\"\");\n\n// Test individual styles\nprint(\"Individual Styles:\");\nprint(BOLD + \"Bold text\" + RESET);\nprint(DIM + \"Dim text\" + RESET);\nprint(ITALIC + \"Italic text (not all terminals)\" + RESET);\nprint(UNDERLINE + \"Underlined text\" + RESET);\nprint(BLINK + \"Blinking text (rarely supported)\" + RESET);\nprint(REVERSE + \"Reversed text\" + RESET);\nprint(STRIKETHROUGH + \"Strikethrough text\" + RESET);\n\nprint(\"\");\n\n// Test combining styles\nprint(\"Combined Styles:\");\nprint(BOLD + UNDERLINE + \"Bold and underlined\" + RESET);\nprint(BOLD + RED + \"Bold red\" + RESET);\nprint(UNDERLINE + GREEN + \"Underlined green\" + RESET);\n\nprint(\"\");\n\n// Test style resets\nprint(\"Style Resets:\");\nprint(BOLD + \"Bold \" + RESET_BOLD + \"not bold anymore\");\nprint(UNDERLINE + \"Underlined \" + RESET_UNDERLINE + \"not underlined\");\nprint(BOLD + UNDERLINE + \"Both \" + RESET + \"neither\");\n\nprint(\"\");\nprint(\"‚úì All style tests completed\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/test_styles.hml"}
{"instruction": "How does operator precedence (complete) work in Hemlock?", "output": "Use parentheses for clarity:*\n\n```hemlock\n// Unclear\nif (a || b && c) { }\n\n// Clear\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\n\nlet angle = PI / 4;\nlet x = cos(angle);\nlet y = sin(angle);\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does lexical scoping work in Hemlock?", "output": "Functions can read (not write) outer scope variables:\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // Can read global and outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does with error handling (recommended) work in Hemlock?", "output": "Use finally to ensure files are closed even on errors:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Always close, even on error\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Write Hemlock code that test task_debug_info builtin.", "output": "```hemlock\n// Test task_debug_info builtin\n\nasync fn work(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn a task\nlet t = spawn(work, 10);\n\n// Wait for result first (makes state deterministic)\nlet result = join(t);\nprint(result);\n\n// Print debug info after join (state is now guaranteed COMPLETED+JOINED)\nprint(\"After join:\");\ntask_debug_info(t);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/task_debug_info.hml"}
{"instruction": "How does asynccopyfile work in Hemlock?", "output": "```hemlock\nimport { async_copy_file } from \"@stdlib/async_fs\";\n\nlet future = async_copy_file(\"original.txt\", \"backup.txt\");\nfuture.get();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Implement a Hemlock program that test nested loops.", "output": "```hemlock\n// Test nested loops\nfor (let i = 0; i < 2; i = i + 1) {\n    for (let j = 0; j < 2; j = j + 1) {\n        print(i);\n        print(j);\n    }\n}\n```", "category": "tests/loops", "source": "tests/loops/nested.hml"}
{"instruction": "How does variable annotations work in Hemlock?", "output": "```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does double-free work in Hemlock?", "output": "```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // Set to null after freeing\n\nif (p != null) {\n    free(p);  // Won't execute\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does pass-by-value work in Hemlock?", "output": "Note:* Objects and arrays are passed by reference (the reference is copied), so their contents can be modified:\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // Modifies original array\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99 (modified)\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does array methods work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30];\n\n// Add/remove at end\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40, arr is now [10, 20, 30]\n\n// Add/remove at beginning\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5, arr is now [10, 20, 30]\n\n// Insert/remove at index\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// Search\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// Slice\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// Join to string\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does log2(x) work in Hemlock?", "output": "Returns:* f64 - log‚ÇÇ(x)\n\n```hemlock\nimport { log2 } from \"@stdlib/math\";\n\nlet result = log2(1.0);  // 0.0\nlet result2 = log2(2.0); // 1.0\nlet result3 = log2(8.0); // 3.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does type safety patterns work in Hemlock?", "output": "Check before use:*\n\n```hemlock\nif (typeof(value) == \"i32\") {\n    // Safe to use as i32\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does method chaining work in Hemlock?", "output": "Methods that return arrays or values enable chaining:\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\nimport {\n    describe, test, expect,\n    assert_eq, assert_ne, assert_true, assert_false, assert_throws,\n    before_each, after_each, run\n} from \"@stdlib/testing\";\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does named functions work in Hemlock?", "output": "```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Hello, Alice!\"\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does when you need free() vs when it's automatic work in Hemlock?", "output": "Long-lived data* - globals or data stored in persistent structures:\n\n```hemlock\nlet cache = {};  // Module-level, lives until program exit unless freed\n\n   fn cleanup() {\n       free(cache);  // Manual cleanup for long-lived data\n   }\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Implement a Hemlock program that test optional parameters with closures and higher-order functions.", "output": "```hemlock\n// Test optional parameters with closures and higher-order functions\n\n// Optional function parameter with default\nfn apply_operation(x: i32, operation?: fn(n) { return n * 2; }) {\n    return operation(x);\n}\n\nprint(apply_operation(5));  // 10 (default: n * 2)\n\nfn triple(n) {\n    return n * 3;\n}\n\nprint(apply_operation(5, triple));  // 15\n\n// Optional parameter in returned closure\nfn make_multiplier(factor?: 10) {\n    return fn(n) {\n        return n * factor;\n    };\n}\n\nlet mult = make_multiplier();\nprint(mult(5));  // 50\n\nlet mult3 = make_multiplier(3);\nprint(mult3(5));  // 15\n\n// Anonymous function with optional params\nlet greet = fn(name: string, prefix?: \"Mr.\") {\n    return prefix + \" \" + name;\n};\n\nprint(greet(\"Smith\"));        // Mr. Smith\nprint(greet(\"Smith\", \"Dr.\"));  // Dr. Smith\n```", "category": "tests/functions", "source": "tests/functions/optional_params_closures.hml"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does dot operator work in Hemlock?", "output": "```hemlock\n// Object field access\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Array property\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// String property\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Method call\nlet result = s.to_upper(); // \"HELLO\"\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does handle errors gracefully work in Hemlock?", "output": "```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warning: Could not read \" + path + \": \" + e);\n        return \"\";\n    }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does cross-platform configuration paths work in Hemlock?", "output": "```hemlock\nimport { platform, homedir } from \"@stdlib/os\";\n\nfn get_config_dir(app_name: string): string {\n    let p = platform();\n    let home = homedir();\n\n    if (p == \"linux\") {\n        // Follow XDG Base Directory spec\n        return home + \"/.config/\" + app_name;\n    } else if (p == \"macos\") {\n        return home + \"/Library/Application Support/\" + app_name;\n    } else if (p == \"windows\") {\n        // On Windows, use APPDATA\n        return home + \"/AppData/Roaming/\" + app_name;\n    }\n\n    // Fallback\n    return home + \"/.\" + app_name;\n}\n\nfn get_data_dir(app_name: string): string {\n    let p = platform();\n    let home = homedir();\n\n    if (p == \"linux\") {\n        return home + \"/.local/share/\" + app_name;\n    } else if (p == \"macos\") {\n        return home + \"/Library/\" + app_name;\n    } else if (p == \"windows\") {\n        return home + \"/AppData/Local/\" + app_name;\n    }\n\n    return home + \"/.\" + app_name + \"/data\";\n}\n\nprint(\"Config: \" + get_config_dir(\"myapp\"));\nprint(\"Data: \" + get_data_dir(\"myapp\"));\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Give me Hemlock code that shows demonstrates function definitions and closures.", "output": "```hemlock\n// Hemlock Functions Demo\n// Showcases first-class functions, closures, and recursion\n\nprint(\"=== Hemlock Functions Demo ===\");\nprint(\"\");\n\n// 1. Basic named function\nprint(\"1. Basic function:\");\nfn add(a, b) {\n    return a + b;\n}\nprint(add(5, 3));\nprint(\"\");\n\n// 2. Function with type annotations\nprint(\"2. Typed function:\");\nfn multiply(x: i32, y: i32): i32 {\n    return x * y;\n}\nprint(multiply(7, 6));\nprint(\"\");\n\n// 3. Recursive function - factorial\nprint(\"3. Recursion (factorial):\");\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\nprint(factorial(6));\nprint(\"\");\n\n// 4. Closures - function that returns a function\nprint(\"4. Closures:\");\nfn makeMultiplier(factor) {\n    return fn(x) {\n        return x * factor;\n    };\n}\nlet double = makeMultiplier(2);\nlet triple = makeMultiplier(3);\nprint(double(5));\nprint(triple(5));\nprint(\"\");\n\n// 5. Anonymous functions as first-class values\nprint(\"5. Anonymous functions:\");\nlet square = fn(n) {\n    return n * n;\n};\nprint(square(8));\nprint(\"\");\n\n// 6. Higher-order functions - passing functions as arguments\nprint(\"6. Higher-order functions:\");\nfn apply(func, value) {\n    return func(value);\n}\nprint(apply(square, 9));\nprint(\"\");\n\n// 7. Lexical scoping\nprint(\"7. Lexical scoping:\");\nlet message = 100;\nfn getMessage() {\n    return message + 23;\n}\nprint(getMessage());\nprint(\"\");\n\n// 8. Counter closure (stateful closure)\nprint(\"8. Counter closure:\");\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\nlet counter = makeCounter();\nprint(counter());\nprint(counter());\nprint(counter());\nprint(\"\");\n\n// 9. Fibonacci with recursion\nprint(\"9. Fibonacci sequence:\");\nfn fib(n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\nlet i = 0;\nwhile (i < 10) {\n    print(fib(i));\n    i = i + 1;\n}\n\nprint(\"\");\nprint(\"=== Demo Complete ===\");\n```", "category": "examples", "source": "examples/functions_demo.hml"}
{"instruction": "How does inf work in Hemlock?", "output": "Positive infinity (IEEE 754 floating point infinity)\n\n```hemlock\nimport { INF } from \"@stdlib/math\";\nlet max_value = INF;\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All hash functions validate input types and throw exceptions on errors:\n\n```hemlock\nimport { sha256, file_sha256 } from \"@stdlib/hash\";\n\n// Type validation\ntry {\n    sha256(123);  // Error: requires string\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// File not found\ntry {\n    file_sha256(\"/nonexistent/file.txt\");\n} catch (e) {\n    print(\"File error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "Show me Hemlock code that test array shift method.", "output": "```hemlock\n// Test array shift method\nlet arr = [1, 2, 3, 4, 5];\nlet first = arr.shift();\nprint(first);\nprint(arr);\nprint(typeof(arr.length));\n\nlet empty = [];\nlet result = empty.shift();\nprint(result);\n```", "category": "tests/arrays", "source": "tests/arrays/shift.hml"}
{"instruction": "How does type checking strategy work in Hemlock?", "output": "Hemlock uses runtime type checking with optional type annotations:\n\n```hemlock\nlet x = 42;           // No type check, infers i32\nlet y: u8 = 255;      // Runtime check: value must fit in u8\nlet z: i32 = x + y;   // Runtime check + type promotion\n```", "category": "docs", "source": "docs/design/implementation.md"}
{"instruction": "How does insertion and removal work in Hemlock?", "output": "remove(index)* - Remove and return element at index:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // Returns 3, arr is now [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does pitfall: loop variable scope work in Hemlock?", "output": "```hemlock\n// i is scoped to the loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // ERROR: i not defined here\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does url protocol extraction work in Hemlock?", "output": "```hemlock\nimport { test, REG_ICASE } from \"@stdlib/regex\";\n\nfn has_https(url: string): bool {\n    return test(\"^https://\", url, REG_ICASE);\n}\n\nprint(has_https(\"https://example.com\"));  // true\nprint(has_https(\"http://example.com\"));   // false\nprint(has_https(\"HTTPS://Example.com\"));  // true (case-insensitive)\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Show me Hemlock code that object type with optional fields.", "output": "```hemlock\n// Object type with optional fields\ndefine User {\n    name: string,\n    email?: string,\n    age?: i32,\n}\n\n// Just test that parsing works\nprint(42);\n```", "category": "tests/objects", "source": "tests/objects/define_optional.hml"}
{"instruction": "Create a Hemlock program that tests AF_INET6 socket creation, bind, listen, connect, accept.", "output": "```hemlock\n// Test: IPv6 socket support\n// Tests AF_INET6 socket creation, bind, listen, connect, accept\n\n// Test 1: AF_INET6 constant available\nprint(\"Test: AF_INET6 constant\");\nassert(AF_INET6 != null);\nassert(AF_INET6 != AF_INET);\nprint(\"PASS: AF_INET6 constant defined\");\n\n// Test 2: Create IPv6 TCP socket\nprint(\"Test: create IPv6 TCP socket\");\nlet server = socket_create(AF_INET6, SOCK_STREAM, 0);\nassert(server != null);\nprint(\"PASS: IPv6 TCP socket created\");\n\n// Test 3: Bind to localhost IPv6\nprint(\"Test: bind to IPv6 localhost\");\nserver.bind(\"::1\", 39186);\nprint(\"PASS: bound to [::1]:29086\");\n\n// Test 4: Listen on IPv6 socket\nprint(\"Test: listen on IPv6 socket\");\nserver.listen(5);\nprint(\"PASS: listening on IPv6 socket\");\n\n// Test 5: Connect and accept with IPv6\nprint(\"Test: IPv6 TCP connect/accept\");\n\nlet accept_task = spawn(async fn(s) {\n    let conn = s.accept();\n    if (conn != null) {\n        // Just accept and close - don't try to exchange data\n        // (bidirectional data exchange has edge case issues)\n        let addr = conn.address;\n        conn.close();\n        return addr;\n    }\n    return null;\n}, server);\n\n__sleep(0.05);\n\nlet client = socket_create(AF_INET6, SOCK_STREAM, 0);\nclient.connect(\"::1\", 39186);\nclient.close();\n\nlet client_addr = join(accept_task);\nprint(\"  Accepted client from: \" + client_addr);\nassert(client_addr == \"::1\");\nprint(\"PASS: IPv6 TCP connect/accept works\");\n\nserver.close();\n\n// Test 6: IPv6 UDP sendto/recvfrom\nprint(\"Test: IPv6 UDP socket\");\nlet udp_server = socket_create(AF_INET6, SOCK_DGRAM, 0);\nudp_server.bind(\"::1\", 39187);\n\nlet udp_client = socket_create(AF_INET6, SOCK_DGRAM, 0);\nudp_client.sendto(\"::1\", 39187, \"hello ipv6 udp\");\n\nlet result = udp_server.recvfrom(100);\n// result.data is a buffer - just check it exists and has correct size\nprint(\"  UDP received \" + result.data.length + \" bytes\");\nprint(\"  From address: \" + result.address);\nassert(result.data.length == 14);  // \"hello ipv6 udp\" is 14 bytes\nassert(result.address == \"::1\");\n\nudp_server.close();\nudp_client.close();\nprint(\"PASS: IPv6 UDP works\");\n\n// Test 7: Bind to all interfaces (::)\nprint(\"Test: IPv6 dual-stack bind\");\nlet dual_server = socket_create(AF_INET6, SOCK_STREAM, 0);\ndual_server.bind(\"::\", 39188);\ndual_server.listen(5);\nprint(\"PASS: bound to [::]:29088 (all interfaces)\");\ndual_server.close();\n\nprint(\"All IPv6 socket tests passed!\");\n```", "category": "tests/async_io", "source": "tests/async_io/ipv6_socket.hml"}
{"instruction": "How does explicit over implicit work in Hemlock?", "output": "Bad (implicit):*\n\n```hemlock\nlet x = 5  // Missing semicolon - should error\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "How does command chaining work in Hemlock?", "output": "```hemlock\nlet r = exec(\"command1 || command2\");\n// Runs command2 only if command1 fails\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Create a Hemlock program that test C-style for loop.", "output": "```hemlock\n// Test C-style for loop\nfor (let i = 0; i < 5; i = i + 1) {\n    print(i);\n}\n```", "category": "tests/loops", "source": "tests/loops/for_basic.hml"}
{"instruction": "How does basic recursion work in Hemlock?", "output": "```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "Write a Hemlock program that defer with return - defers should execute before return.", "output": "```hemlock\n// Defer with return - defers should execute before return\nfn test_return(): i32 {\n    defer print(\"cleanup\");\n    print(\"before return\");\n    return 42;\n}\n\nlet result = test_return();\nprint(\"Result: \" + typeof(result));\n```", "category": "tests/defer", "source": "tests/defer/defer_with_return.hml"}
{"instruction": "How does low-level builtins work in Hemlock?", "output": "Convert time components to Unix timestamp.\n\n```hemlock\nimport { mktime } from \"@stdlib/datetime\";\n\nlet components = {\n    year: 2025,\n    month: 1,\n    day: 15,\n    hour: 12,\n    minute: 30,\n    second: 45\n};\n\nlet timestamp = mktime(components);\nprint(\"Timestamp: \" + typeof(timestamp));\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does memory leaks work in Hemlock?", "output": "Prevention:* Always pair alloc() with free():\n\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... use p\n    } finally {\n        free(p);  // Always freed\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does words(str) work in Hemlock?", "output": "Returns empty array for empty string or whitespace-only string\n\n```hemlock\nimport { words } from \"@stdlib/strings\";\n\n// Basic word splitting\nlet w1 = words(\"hello world\");\nprint(w1.length);   // 2\nprint(w1[0]);       // \"hello\"\nprint(w1[1]);       // \"world\"\n\n// Multiple words\nlet w2 = words(\"the quick brown fox\");\nprint(w2.length);   // 4\n\n// Extra spaces (filtered out)\nlet w3 = words(\"hello  world\");\nprint(w3.length);   // 2 (not 3)\n\n// Leading/trailing spaces\nlet w4 = words(\"  hello world  \");\nprint(w4.length);   // 2\n\n// Single word\nlet w5 = words(\"hello\");\nprint(w5.length);   // 1\n\n// Empty string\nlet w6 = words(\"\");\nprint(w6.length);   // 0\n\n// Only spaces\nlet w7 = words(\"   \");\nprint(w7.length);   // 0\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does pitfall: swallowing errors work in Hemlock?", "output": "```hemlock\n// BAD: Silent failure\ntry {\n    risky_operation();\n} catch (e) {\n    // Error ignored - silent failure\n}\n\n// GOOD: Log or handle\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation failed: \" + e);\n    // Handle appropriately\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does operator precedence work in Hemlock?", "output": "```hemlock\nlet x = 2 + 3 * 4;      // 14 (not 20)\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show an example of example: fizzbuzz in Hemlock.", "output": "```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write Hemlock code that test array insert() at boundary positions Expected: PASS.", "output": "```hemlock\n// Test array insert() at boundary positions\n// Expected: PASS\n\nlet arr = [1, 2, 3];\n\n// Insert at beginning\narr.insert(0, 0);\nassert(arr.length == 4, \"insert should increase length\");\nassert(arr[0] == 0, \"insert at 0 should place at beginning\");\n\n// Insert at end\narr.insert(4, 4);\nassert(arr.length == 5, \"insert at end should work\");\nassert(arr[4] == 4, \"insert at end should place element correctly\");\n\n// Insert beyond end - should this error or extend?\n// Testing current behavior\ntry {\n    let arr2 = [1, 2, 3];\n    arr2.insert(10, 99);\n    print(\"insert beyond end did not error, value inserted\");\n} catch (e) {\n    print(\"insert beyond end threw error: \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/arrays", "source": "tests/arrays/edge_insert_bounds.hml"}
{"instruction": "How does typeof(value) work in Hemlock?", "output": "```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does dynamic by default, typed by choice work in Hemlock?", "output": "Explicit typing when needed:*\n\n```hemlock\nlet x = 42;              // i32 inferred (small value)\nlet y: u8 = 255;         // explicit u8\nlet z = x + y;           // promotes to i32\nlet big = 5000000000;    // i64 inferred (> i32 max)\n```", "category": "docs", "source": "docs/design/philosophy.md"}
{"instruction": "Show me Hemlock code that tests repeat.", "output": "```hemlock\nlet s = \"ha\";\nprint(s.repeat(3));\n\nlet s2 = \"abc\";\nprint(s2.repeat(2));\n\nlet s3 = \"x\";\nprint(s3.repeat(0));\n```", "category": "tests/strings", "source": "tests/strings/repeat.hml"}
{"instruction": "How does .capacity work in Hemlock?", "output": "```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How do you read and write files in Hemlock?", "output": "Use the `open()` function with mode strings:\n\n```hemlock\n// Read file\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Write file\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, World!\");\nf.close();\n\n// Append to file\nlet f = open(\"log.txt\", \"a\");\nf.write(\"New entry\\n\");\nf.close();\n```\n\nModes: r, w, a, r+, w+, a+\n\nOr use the fs stdlib:\n```hemlock\nimport { read_file, write_file } from \"@stdlib/fs\";\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n```", "category": "concepts/io", "source": "CLAUDE.md"}
{"instruction": "Write Hemlock code that function with type annotations.", "output": "```hemlock\n// Function with type annotations\nfn multiply(x: i32, y: i32): i32 {\n    return x * y;\n}\n\nprint(multiply(6, 7));\n```", "category": "tests/functions", "source": "tests/functions/typed.hml"}
{"instruction": "How does error handling work in Hemlock?", "output": "All crypto functions validate inputs and throw exceptions on errors:\n\n```hemlock\nimport { aes_encrypt, generate_aes_key, generate_iv } from \"@stdlib/crypto\";\n\n// Wrong key size\ntry {\n    let bad_key = random_bytes(16);  // Too small\n    aes_encrypt(\"data\", bad_key, generate_iv());\n} catch (e) {\n    print(\"Error: \" + e);  // \"aes_encrypt() requires 32-byte (256-bit) key\"\n}\n\n// Wrong IV size\ntry {\n    aes_encrypt(\"data\", generate_aes_key(), random_bytes(8));  // Too small\n} catch (e) {\n    print(\"Error: \" + e);  // \"aes_encrypt() requires 16-byte (128-bit) iv\"\n}\n\n// Decryption failure (wrong key or corrupted data)\ntry {\n    let ciphertext = aes_encrypt(\"data\", key1, iv);\n    aes_decrypt(ciphertext, key2, iv);  // Different key\n} catch (e) {\n    print(\"Error: \" + e);  // \"EVP_DecryptFinal_ex() failed...\"\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "Implement a Hemlock program that test array builtin functions.", "output": "```hemlock\n// Test array builtin functions\n\n// Length\nprint([1, 2, 3].length);\nprint([].length);\n\n// Array creation and access\nlet arr = [10, 20, 30, 40, 50];\nprint(arr[0]);\nprint(arr[4]);\nprint(arr.length);\n\n// Array modification\narr[2] = 300;\nprint(arr[2]);\n\n// Push and pop\narr.push(60);\nprint(arr.length);\nprint(arr.pop());\nprint(arr.length);\n\n// Shift and unshift\narr.unshift(0);\nprint(arr[0]);\nprint(arr.shift());\nprint(arr[0]);\n\n// Slice\nlet sliced = arr.slice(1, 3);\nprint(sliced.length);\nprint(sliced[0]);\nprint(sliced[1]);\n\n// Join\nlet strs = [\"a\", \"b\", \"c\"];\nprint(strs.join(\"-\"));\nprint(strs.join(\"\"));\n\n// Concat\nlet a1 = [1, 2];\nlet a2 = [3, 4];\nlet combined = a1.concat(a2);\nprint(combined.length);\nprint(combined[2]);\n\n// Reverse\nlet rev = [1, 2, 3];\nrev.reverse();\nprint(rev[0]);\nprint(rev[2]);\n\n// First and last\nlet fl = [10, 20, 30];\nprint(fl.first());\nprint(fl.last());\n\n// Contains\nprint([1, 2, 3].contains(2));\nprint([1, 2, 3].contains(5));\n\n// Find index\nprint([10, 20, 30].find(20));\nprint([10, 20, 30].find(99));\n\n// Insert and remove\nlet mod = [1, 2, 3];\nmod.insert(1, 99);\nprint(mod[1]);\nprint(mod.length);\nmod.remove(1);\nprint(mod[1]);\nprint(mod.length);\n\n// Clear\nlet toclear = [1, 2, 3];\ntoclear.clear();\nprint(toclear.length);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/array_builtins.hml"}
{"instruction": "How does catch block work in Hemlock?", "output": "The catch block receives the thrown value:\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Caught: \" + error);  // error = \"oops\"\n    // error only accessible here\n}\n// error not accessible here\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Create a Hemlock program that test FFI callbacks in compiled Hemlock This test verifies that callback(), callback_free(), and ptr helpers work.", "output": "```hemlock\n// Test FFI callbacks in compiled Hemlock\n// This test verifies that callback(), callback_free(), and ptr helpers work\n\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Comparison function for integers (ascending order)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) {\n        return -1;\n    }\n    if (va > vb) {\n        return 1;\n    }\n    return 0;\n}\n\n// Test qsort with callback\nfn test_qsort() {\n    print(\"Testing qsort with FFI callback (compiled)...\");\n\n    // Allocate array of 5 integers (4 bytes each)\n    let arr = alloc(20);  // 5 * 4 bytes\n\n    // Initialize array: [5, 2, 8, 1, 9]\n    ptr_write_i32(arr, 5);\n    ptr_write_i32(ptr_offset(arr, 1, 4), 2);\n    ptr_write_i32(ptr_offset(arr, 2, 4), 8);\n    ptr_write_i32(ptr_offset(arr, 3, 4), 1);\n    ptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n    // Create callback from comparison function\n    let cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\n\n    // Sort the array\n    qsort(arr, 5, 4, cmp);\n\n    // Verify sorted order: [1, 2, 5, 8, 9]\n    let sorted = true;\n    let i = 0;\n    while (i < 4) {\n        let current = ptr_deref_i32(ptr_offset(arr, i, 4));\n        let next = ptr_deref_i32(ptr_offset(arr, i + 1, 4));\n        if (current > next) {\n            sorted = false;\n        }\n        i = i + 1;\n    }\n\n    if (sorted) {\n        print(\"PASS: Array is sorted correctly\");\n    } else {\n        print(\"FAIL: Array is not sorted correctly\");\n        // Print the array for debugging\n        i = 0;\n        while (i < 5) {\n            let val = ptr_deref_i32(ptr_offset(arr, i, 4));\n            print(`  arr[${i}] = ${val}`);\n            i = i + 1;\n        }\n    }\n\n    // Clean up\n    callback_free(cmp);\n    free(arr);\n\n    return sorted;\n}\n\n// Run test\nlet result = test_qsort();\nif (result) {\n    print(\"All FFI callback tests passed!\");\n} else {\n    print(\"FFI callback tests FAILED\");\n}\n```", "category": "tests/parity", "source": "tests/parity/builtins/ffi_callback.hml"}
{"instruction": "How does import work in Hemlock?", "output": "```hemlock\nimport { get, post, fetch } from \"@stdlib/http\";\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "Show an example of example 1: basic console logging in Hemlock.", "output": "```hemlock\nimport { Logger, INFO } from \"@stdlib/logging\";\n\nlet logger = Logger();\n\nlogger.info(\"Application starting...\");\nlogger.info(\"Loading configuration\");\nlogger.info(\"Server ready on port 8080\");\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "Right Shift (>>)*\n\n```hemlock\nprint(a >> 1);  // 6 (110) - shift right by 1\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Show an example of example: direct call vs spawn in Hemlock.", "output": "```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Direct call - runs synchronously\nlet result1 = factorial(5);  // 120\n\n// Spawned task - runs on separate thread\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does asynclistdir work in Hemlock?", "output": "```hemlock\nasync_list_dir(path: string): Future<array<string>>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does file properties work in Hemlock?", "output": "```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does basic types work in Hemlock?", "output": "```hemlock\nlet x: i32 = 42;           // 32-bit signed integer\nlet y: u8 = 255;           // 8-bit unsigned integer\nlet pi: f64 = 3.14159;     // 64-bit float\nlet name: string = \"Alice\"; // UTF-8 string\nlet flag: bool = true;     // Boolean\nlet ch: rune = 'üöÄ';       // Unicode codepoint\n```", "category": "docs", "source": "docs/README.md"}
{"instruction": "Write a Hemlock program that tests that detached tasks properly clean up their memory when they complete.", "output": "```hemlock\n// Test: detach() cleanup verification\n// Tests that detached tasks properly clean up their memory when they complete\n\n// Create channel for thread-safe communication\nlet ch = channel(100);\n\nasync fn increment_task(id: i32, ch) {\n    // Simulate some work\n    let i = 0;\n    let sum = 0;\n    while (i < 100) {\n        sum = sum + i;\n        i = i + 1;\n    }\n\n    // Signal completion via channel (thread-safe)\n    ch.send(1);\n\n    return null;\n}\n\n// Detach many tasks to exercise cleanup mechanism\nlet num_tasks = 50;\nlet i = 0;\nwhile (i < num_tasks) {\n    detach(increment_task, i, ch);\n    i = i + 1;\n}\n\nprint(\"Detached tasks:\");\nprint(num_tasks);\n\n// Wait for all tasks to complete by receiving from channel\nlet completed = 0;\nlet j = 0;\nwhile (j < num_tasks) {\n    let val = ch.recv();\n    completed = completed + val;\n    j = j + 1;\n}\n\nprint(\"Tasks completed:\");\nprint(completed);\nprint(\"Test completed without crashes\");\n```", "category": "tests/async", "source": "tests/async/test_detach_cleanup.hml"}
{"instruction": "How does buffer work in Hemlock?", "output": "```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Access with bounds checking\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // ERROR: out of bounds\n\nfree(buf);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Implement a Hemlock program that test higher-order array functions.", "output": "```hemlock\n// Test higher-order array functions\n\n// Map - double each number\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) {\n    return x * 2;\n});\nprint(doubled[0]);\nprint(doubled[2]);\nprint(doubled[4]);\n\nprint(\"---\");\n\n// Filter - keep even numbers\nlet evens = nums.filter(fn(x) {\n    return x % 2 == 0;\n});\nprint(evens.length);\nprint(evens[0]);\nprint(evens[1]);\n\nprint(\"---\");\n\n// Reduce - sum\nlet sum = nums.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(sum);\n\n// Reduce - without initial value\nlet product = [1, 2, 3, 4].reduce(fn(acc, x) {\n    return acc * x;\n});\nprint(product);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/higher_order.hml"}
{"instruction": "How does no streaming work in Hemlock?", "output": "Must wait for command completion:\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// Blocks until command finishes\n// Cannot process output incrementally\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does help message work in Hemlock?", "output": "```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show this help message\");\n    print(\"  -v, --verbose  Enable verbose output\");\n} else {\n    // Process normally\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Write a Hemlock program that attempting to use freed regex should throw.", "output": "```hemlock\n// Test: Using freed regex (should throw exception)\nimport { compile } from \"@stdlib/regex\";\n\nlet pattern = compile(\"test\", null);\npattern.free();\n\n// Attempting to use freed regex should throw\ntry {\n    pattern.test(\"testing\");\n    print(\"ERROR: Should have thrown exception\");\n} catch (e) {\n    print(\"Caught expected error: Regex has been freed\");\n}\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/freed_regex_exception.hml"}
{"instruction": "Write a Hemlock program that test Hexadecimal encoding and decoding.", "output": "```hemlock\n// Test Hexadecimal encoding and decoding\n\nimport { hex_encode, hex_decode } from \"@stdlib/encoding\";\n\n// Test 1: Empty string\nlet encoded1 = hex_encode(\"\");\nif (encoded1 != \"\") {\n    throw \"Empty string should encode to empty string\";\n}\nlet decoded1 = hex_decode(\"\");\nif (decoded1 != \"\") {\n    throw \"Empty string should decode to empty string\";\n}\nprint(\"‚úì Test 1: Empty string\");\n\n// Test 2: Single character\nlet encoded2 = hex_encode(\"A\");\nif (encoded2 != \"41\") {\n    throw \"Failed to encode 'A', got: \" + encoded2;\n}\nlet decoded2 = hex_decode(\"41\");\nif (decoded2 != \"A\") {\n    throw \"Failed to decode '41', got: \" + decoded2;\n}\nprint(\"‚úì Test 2: Single character\");\n\n// Test 3: Multiple characters\nlet encoded3 = hex_encode(\"ABC\");\nif (encoded3 != \"414243\") {\n    throw \"Failed to encode 'ABC', got: \" + encoded3;\n}\nlet decoded3 = hex_decode(\"414243\");\nif (decoded3 != \"ABC\") {\n    throw \"Failed to decode '414243', got: \" + decoded3;\n}\nprint(\"‚úì Test 3: Multiple characters\");\n\n// Test 4: Hello World\nlet text4 = \"Hello, World!\";\nlet encoded4 = hex_encode(text4);\nif (encoded4 != \"48656c6c6f2c20576f726c6421\") {\n    throw \"Failed to encode 'Hello, World!', got: \" + encoded4;\n}\nlet decoded4 = hex_decode(\"48656c6c6f2c20576f726c6421\");\nif (decoded4 != text4) {\n    throw \"Failed to decode hex, got: \" + decoded4;\n}\nprint(\"‚úì Test 4: Hello, World!\");\n\n// Test 5: Case insensitive decoding\nlet decoded5a = hex_decode(\"48656c6c6f\");\nlet decoded5b = hex_decode(\"48656C6C6F\");\nlet decoded5c = hex_decode(\"48656C6c6f\");\nif (decoded5a != \"Hello\" || decoded5b != \"Hello\" || decoded5c != \"Hello\") {\n    throw \"Hex decode should be case-insensitive\";\n}\nprint(\"‚úì Test 5: Case insensitive decoding\");\n\n// Test 6: Numbers\nlet text6 = \"0123456789\";\nlet encoded6 = hex_encode(text6);\nlet decoded6 = hex_decode(encoded6);\nif (decoded6 != text6) {\n    throw \"Failed round-trip for numbers\";\n}\nprint(\"‚úì Test 6: Numbers round-trip\");\n\n// Test 7: Special characters\nlet text7 = \"!@#$%^&*()\";\nlet encoded7 = hex_encode(text7);\nlet decoded7 = hex_decode(encoded7);\nif (decoded7 != text7) {\n    throw \"Failed round-trip for special characters\";\n}\nprint(\"‚úì Test 7: Special characters\");\n\n// Test 8: Whitespace characters\nlet text8 = \" \\t\\n\\r\";\nlet encoded8 = hex_encode(text8);\nlet decoded8 = hex_decode(encoded8);\nif (decoded8 != text8) {\n    throw \"Failed round-trip for whitespace\";\n}\nprint(\"‚úì Test 8: Whitespace characters\");\n\n// Test 9: ASCII characters (bytes 1-127)\n// Note: byte 0 (null) cannot be stored in strings due to C string termination\n// Note: bytes 128-255 alone are not valid UTF-8 and cause multi-byte expansion\nlet binary9 = \"\";\nlet i = 1;\nwhile (i < 128) {\n    let byte_char: rune = i;\n    binary9 = binary9 + byte_char;\n    i = i + 1;\n}\nlet encoded9 = hex_encode(binary9);\nlet decoded9 = hex_decode(encoded9);\nif (decoded9.length != binary9.length) {\n    throw \"Binary data length mismatch\";\n}\nprint(\"‚úì Test 9: ASCII characters (bytes 1-127)\");\n\n// Test 10: Printable ASCII byte\n// Note: Null bytes (0x00) cannot be stored in strings due to C string termination\nlet byte10: rune = 65;  // 'A'\nlet text10 = \"\" + byte10;\nlet encoded10 = hex_encode(text10);\nif (encoded10 != \"41\") {\n    throw \"Failed to encode 'A', got: \" + encoded10;\n}\nlet decoded10 = hex_decode(\"41\");\nif (decoded10 != \"A\") {\n    throw \"Failed to decode 0x41\";\n}\nprint(\"‚úì Test 10: Printable ASCII byte\");\n\n// Test 11: DEL character (127)\n// Note: Bytes 128-255 are not valid standalone UTF-8 and cause issues\nlet byte11: rune = 127;  // DEL\nlet text11 = \"\" + byte11;\nlet encoded11 = hex_encode(text11);\nif (encoded11 != \"7f\") {\n    throw \"Failed to encode 0x7F, got: \" + encoded11;\n}\nlet decoded11 = hex_decode(\"7F\");\nif (decoded11.length != 1) {\n    throw \"Failed to decode 0x7F\";\n}\nprint(\"‚úì Test 11: DEL character (0x7F)\");\n\n// Test 12: Longer text\nlet text12 = \"The quick brown fox jumps over the lazy dog\";\nlet encoded12 = hex_encode(text12);\nlet decoded12 = hex_decode(encoded12);\nif (decoded12 != text12) {\n    throw \"Failed round-trip for longer text\";\n}\nprint(\"‚úì Test 12: Longer text round-trip\");\n\n// Test 13: Decode with whitespace (should be removed)\nlet decoded13 = hex_decode(\"48 65 6c 6c 6f\");\nif (decoded13 != \"Hello\") {\n    throw \"Failed to decode hex with spaces, got: \" + decoded13;\n}\nprint(\"‚úì Test 13: Decode with whitespace\");\n\nprint(\"\\n‚úÖ All Hex tests passed!\");\n```", "category": "tests/stdlib_encoding", "source": "tests/stdlib_encoding/test_hex.hml"}
{"instruction": "How does for loops work in Hemlock?", "output": "```hemlock\nfor (initializer; condition; increment) {\n    // body\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does migration from old api work in Hemlock?", "output": "Migration Example:*\n\n```hemlock\n// Old (v0.0)\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// New (v0.1)\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does comparison work in Hemlock?", "output": "<, >, <=, >= - Codepoint order\n\n```hemlock\nprint('A' < 'B');               // true (65 < 66)\nprint('a' > 'Z');               // true (97 > 90)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Show me Hemlock code that tests find.", "output": "```hemlock\nlet s = \"hello world\";\nprint(s.find(\"world\"));\nprint(s.find(\"hello\"));\nprint(s.find(\"foo\"));\nprint(s.find(\"o\"));\n```", "category": "tests/strings", "source": "tests/strings/find.hml"}
{"instruction": "Implement a Hemlock program that test HashMap collection.", "output": "```hemlock\n// Test HashMap collection\n\nimport { HashMap } from \"@stdlib/collections\";\n\nlet map = HashMap();\n\n// Test initial state\nassert(map.size == 0, \"Initial size should be 0\");\nassert(map.keys().length == 0, \"Initial keys should be empty\");\n\n// Test set and get with strings\nmap.set(\"name\", \"Alice\");\nmap.set(\"age\", 30);\nmap.set(\"city\", \"NYC\");\n\nassert(map.size == 3, \"Size should be 3 after adding 3 items\");\nassert(map.get(\"name\") == \"Alice\", \"Should get correct value for 'name'\");\nassert(map.get(\"age\") == 30, \"Should get correct value for 'age'\");\nassert(map.get(\"city\") == \"NYC\", \"Should get correct value for 'city'\");\n\n// Test has\nassert(map.has(\"name\") == true, \"Should have 'name' key\");\nassert(map.has(\"country\") == false, \"Should not have 'country' key\");\n\n// Test update existing key\nmap.set(\"age\", 31);\nassert(map.get(\"age\") == 31, \"Should update existing value\");\nassert(map.size == 3, \"Size should remain 3 after update\");\n\n// Test integer keys\nmap.set(1, \"one\");\nmap.set(2, \"two\");\nmap.set(100, \"hundred\");\n\nassert(map.get(1) == \"one\", \"Should get value for integer key 1\");\nassert(map.get(100) == \"hundred\", \"Should get value for integer key 100\");\nassert(map.size == 6, \"Size should be 6\");\n\n// Test keys, values, entries\nlet keys = map.keys();\nassert(keys.length == 6, \"keys() should return 6 keys\");\nassert(keys.contains(\"name\"), \"keys should contain 'name'\");\nassert(keys.contains(1), \"keys should contain 1\");\n\nlet values = map.values();\nassert(values.length == 6, \"values() should return 6 values\");\nassert(values.contains(\"Alice\"), \"values should contain 'Alice'\");\nassert(values.contains(\"one\"), \"values should contain 'one'\");\n\nlet entries = map.entries();\nassert(entries.length == 6, \"entries() should return 6 entries\");\n\n// Test delete\nlet deleted = map.delete(\"city\");\nassert(deleted == true, \"delete should return true for existing key\");\nassert(map.has(\"city\") == false, \"Should not have 'city' after delete\");\nassert(map.size == 5, \"Size should be 5 after delete\");\n\nlet deleted2 = map.delete(\"missing\");\nassert(deleted2 == false, \"delete should return false for non-existent key\");\n\n// Test null key\nmap.set(null, \"null value\");\nassert(map.get(null) == \"null value\", \"Should handle null key\");\n\n// Test boolean keys\nmap.set(true, \"truthy\");\nmap.set(false, \"falsy\");\nassert(map.get(true) == \"truthy\", \"Should handle boolean true key\");\nassert(map.get(false) == \"falsy\", \"Should handle boolean false key\");\n\n// Test float keys\nmap.set(3.14, \"pi\");\nassert(map.get(3.14) == \"pi\", \"Should handle float key\");\n\n// Test clear\nmap.clear();\nassert(map.size == 0, \"Size should be 0 after clear\");\nassert(map.keys().length == 0, \"Should have no keys after clear\");\nassert(map.get(\"name\") == null, \"Should return null for cleared key\");\n\n// Test large dataset (trigger resize)\nlet i = 0;\nwhile (i < 100) {\n    map.set(i, i * 10);\n    i = i + 1;\n}\n\nassert(map.size == 100, \"Should handle 100 items\");\n\ni = 0;\nwhile (i < 100) {\n    assert(map.get(i) == i * 10, \"Should retrieve correct value for key \" + typeof(i));\n    i = i + 1;\n}\n\n// Test collision handling with string keys\nmap.clear();\nmap.set(\"abc\", 1);\nmap.set(\"bca\", 2);\nmap.set(\"cab\", 3);\n\nassert(map.get(\"abc\") == 1, \"Should handle potential collisions\");\nassert(map.get(\"bca\") == 2, \"Should handle potential collisions\");\nassert(map.get(\"cab\") == 3, \"Should handle potential collisions\");\n\nprint(\"All HashMap tests passed!\");\n```", "category": "tests/stdlib_collections", "source": "tests/stdlib_collections/test_hashmap.hml"}
{"instruction": "How does panic (unrecoverable errors) work in Hemlock?", "output": "```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x must be non-negative\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // Program exits with: panic: x must be non-negative\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Show me Hemlock code that test array find method.", "output": "```hemlock\n// Test array find method\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.find(3));\nprint(arr.find(1));\nprint(arr.find(5));\nprint(arr.find(10));\n\nlet strings = [\"hello\", \"world\", \"foo\"];\nprint(strings.find(\"world\"));\nprint(strings.find(\"bar\"));\n```", "category": "tests/arrays", "source": "tests/arrays/find.hml"}
{"instruction": "Write Hemlock code that tests format.", "output": "```hemlock\n// Test: Custom log formatting\nimport { Logger, INFO, WARN, ERROR } from \"@stdlib/logging\";\n\nprint(\"=== Test 1: Default format ===\");\nlet logger1 = Logger();\nlogger1.info(\"Default format message\");\n\nprint(\"\\n=== Test 2: Custom format (no timestamp) ===\");\nlet logger2 = Logger({\n    format: \"[{level}] {message}\",\n    include_timestamp: false\n});\nlogger2.info(\"No timestamp message\");\nlogger2.warn(\"Warning without timestamp\");\n\nprint(\"\\n=== Test 3: Custom format (level first) ===\");\nlet logger3 = Logger({\n    format: \"{level}: {message}\"\n});\nlogger3.error(\"Error with custom separator\");\n\nprint(\"\\n=== Test 4: Minimal format ===\");\nlet logger4 = Logger({\n    format: \"{message}\",\n    include_timestamp: false\n});\nlogger4.info(\"Just the message\");\n\nprint(\"\\n=== Test 5: Format with structured data ===\");\nlet logger5 = Logger({\n    format: \"[{level}] {message}\",\n    include_timestamp: false\n});\nlogger5.info(\"Structured message\", {\n    key1: \"value1\",\n    key2: 42\n});\n\nprint(\"\\nPASS: Custom format test completed\");\n```", "category": "tests/stdlib_logging", "source": "tests/stdlib_logging/format.hml"}
{"instruction": "How does websocketmessage work in Hemlock?", "output": "```hemlock\n{\n    type: string,      // Message type\n    data: string,      // Text data (or null)\n    binary: buffer,    // Binary data (or null)\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does hostname() work in Hemlock?", "output": "Network configuration\n\n```hemlock\nimport { hostname } from \"@stdlib/os\";\n\nlet host = hostname();\nprint(\"Running on: \" + host);  // e.g., \"myserver.example.com\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does multiple requests work in Hemlock?", "output": "```hemlock\nimport { get_json } from \"@stdlib/http\";\n\n// Fetch multiple users\nlet i = 1;\nwhile (i <= 3) {\n    let user = get_json(\"https://jsonplaceholder.typicode.com/users/\" + typeof(i));\n    print(typeof(i) + \". \" + user.name + \" (\" + user.email + \")\");\n    i = i + 1;\n}\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does export statements work in Hemlock?", "output": "```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does basic structure work in Hemlock?", "output": "```hemlock\n// args[0] is always the script filename\n// args[1] through args[n-1] are the actual arguments\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Total number of arguments (including script name)\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does substring & slicing work in Hemlock?", "output": "substr(start, length)* - Extract substring by position and length:\n\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\" (start at 6, length 5)\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 example\nlet text = \"HiüöÄ!\";\nlet emoji = text.substr(2, 1);  // \"üöÄ\" (position 2, length 1)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does expected output methods work in Hemlock?", "output": "Method 1: Inline comments (recommended for simple tests)*\n\n```hemlock\nprint(\"hello\");  // Expect: hello\nprint(42);       // Expect: 42\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Show me Hemlock code that tests reassignment.", "output": "```hemlock\nlet x = 10;\nprint(x);\nx = 20;\nprint(x);\nx = 30;\nprint(x);\n```", "category": "tests/variables", "source": "tests/variables/reassignment.hml"}
{"instruction": "How does async_rename work in Hemlock?", "output": "```hemlock\nasync_rename(old_path: string, new_path: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does pattern: early exit work in Hemlock?", "output": "```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Early exit\n        }\n    }\n    return -1;  // Not found\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does catch block work in Hemlock?", "output": "What you can do in catch:*\n\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // Log the error\n    print(\"Error: \" + e);\n\n    // Re-throw same error\n    throw e;\n\n    // Throw different error\n    throw \"different error\";\n\n    // Return a default value\n    return null;\n\n    // Handle and continue\n    // (no re-throw)\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does array basics work in Hemlock?", "output": "```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Modify elements\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does binary bitwise work in Hemlock?", "output": "```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Create a Hemlock program that test exec functionality.", "output": "```hemlock\n// Test exec functionality\n\n// Test 1: Simple command output\nlet r1 = exec(\"echo 'test123'\");\nprint(\"Test 1: Basic echo\");\nprint(\"  Output: [\" + r1.output + \"]\");\nprint(\"  Exit code: \" + typeof(r1.exit_code));\nassert(r1.exit_code == 0, \"exit code should be 0\");\nprint(\"  PASSED\");\n\n// Test 2: Command with non-zero exit code\nlet r2 = exec(\"exit 5\");\nprint(\"Test 2: Exit code\");\nassert(r2.exit_code == 5, \"exit code should be 5\");\nprint(\"  PASSED\");\n\n// Test 3: Command that fails\nlet r3 = exec(\"ls /nonexistent_12345_test\");\nprint(\"Test 3: Failed command\");\nassert(r3.exit_code != 0, \"failed command should have non-zero exit code\");\nprint(\"  PASSED\");\n\n// Test 4: Empty output\nlet r4 = exec(\"true\");\nprint(\"Test 4: Empty output\");\nassert(r4.output == \"\", \"true should produce no output\");\nassert(r4.exit_code == 0, \"true should succeed\");\nprint(\"  PASSED\");\n\n// Test 5: Command with pipe\nlet r5 = exec(\"echo hello | cat\");\nprint(\"Test 5: Piped command\");\nassert(r5.exit_code == 0, \"piped command should succeed\");\nprint(\"  PASSED\");\n\n// Test 6: Multi-line output\nlet r6 = exec(\"echo line1 && echo line2\");\nprint(\"Test 6: Multi-line output\");\nassert(r6.exit_code == 0, \"should succeed\");\nlet lines = r6.output.split(\"\\n\");\nprint(\"  Line count: \" + typeof(lines.length));\nprint(\"  PASSED\");\n\nprint(\"\\nAll exec tests passed!\");\n```", "category": "tests/exec", "source": "tests/exec/test_exec_final.hml"}
{"instruction": "How does ‚ùå discouraged contributions work in Hemlock?", "output": "1. Automatic semicolon insertion*\n\n```hemlock\n// BAD: This would be rejected\nlet x = 5  // No semicolon\nlet y = 10 // No semicolon\n```", "category": "docs", "source": "docs/contributing/guidelines.md"}
{"instruction": "How does equality work in Hemlock?", "output": "```hemlock\nif (x == 10) { }    // Equal\nif (x != 10) { }    // Not equal\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Show me Hemlock code that test file I/O operations.", "output": "```hemlock\n// Test file I/O operations\n\n// Write to file\nlet f = open(\"/tmp/hemlock_parity_test.txt\", \"w\");\nf.write(\"Hello, World!\\n\");\nf.write(\"Line 2\\n\");\nf.close();\n\n// Read from file\nlet f2 = open(\"/tmp/hemlock_parity_test.txt\", \"r\");\nlet content = f2.read();\nprint(content);\nf2.close();\n\n// Append mode\nlet f3 = open(\"/tmp/hemlock_parity_test.txt\", \"a\");\nf3.write(\"Line 3\\n\");\nf3.close();\n\n// Read appended content\nlet f4 = open(\"/tmp/hemlock_parity_test.txt\", \"r\");\nlet full = f4.read();\nf4.close();\n\n// Check line count\nlet lines = full.split(\"\\n\");\nprint(lines.length);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/file_io.hml"}
{"instruction": "How does object type annotations (duck typing) work in Hemlock?", "output": "```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show me Hemlock code that test closures - capturing variables from enclosing scope.", "output": "```hemlock\n// Test closures - capturing variables from enclosing scope\n\n// Test 1: Closure factory (makeAdder pattern)\nfn makeAdder(n) {\n    return fn(x) {\n        return n + x;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\nprint(add5(3));\nprint(add10(3));\n\n// Test 2: Multiple captures from function parameter\nfn makeMultiplier(a, b) {\n    return fn(x) {\n        return a * x + b;\n    };\n}\n\nlet mult = makeMultiplier(2, 3);\nprint(mult(5));\n```", "category": "tests/compiler", "source": "tests/compiler/closures.hml"}
{"instruction": "How does string type work in Hemlock?", "output": "```hemlock\nlet text: string = \"Hello, World!\";\nlet empty: string = \"\";\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show me Hemlock code that test optional chaining operator (?.).", "output": "```hemlock\n// Test optional chaining operator (?.)\n\n// Basic property access\nlet obj = { name: \"Alice\", age: 30 };\nprint(obj?.name);\nprint(obj?.age);\n\n// Null/undefined object\nlet empty = null;\nprint(empty?.name);\n\n// Nested optional chaining\nlet nested = { inner: { value: 42 } };\nprint(nested?.inner?.value);\n\n// Optional indexing\nlet arr = [1, 2, 3];\nprint(arr?.[0]);\nprint(arr?.[1]);\n\n// Null array\nlet nullArr = null;\nprint(nullArr?.[0]);\n\n// String indexing with optional\nlet str = \"hello\";\nprint(str?.[0]);\n\n// Object with method-like property (function stored as property)\nlet calculator = {\n    value: 10,\n    double: fn() { return 20; }\n};\nprint(calculator?.value);\n\n// Chained property access\nlet deep = { a: { b: { c: 100 } } };\nprint(deep?.a?.b?.c);\n\n// Mixed null in chain\nlet partial = { a: null };\nprint(partial?.a?.b);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/optional_chaining.hml"}
{"instruction": "How does double-free work in Hemlock?", "output": "Allowed but will crash:*\n\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: Double-free detected\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "Write Hemlock code that tests else if nested.", "output": "```hemlock\nlet x = 7;\nlet y = 12;\n\nif (x > 10) {\n    print(1);\n} else if (x > 5) {\n    if (y > 15) {\n        print(2);\n    } else if (y > 10) {\n        print(3);\n    } else {\n        print(4);\n    }\n} else {\n    print(5);\n}\n```", "category": "tests/control", "source": "tests/control/else_if_nested.hml"}
{"instruction": "How does writing files work in Hemlock?", "output": "```hemlock\n// Write text\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, File!\\n\");\nf.write(\"Second line\\n\");\nf.close();\n\n// Append to file\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"Appended line\\n\");\nf2.close();\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Show an example of complete client example in Hemlock.", "output": "```hemlock\nimport { WebSocket } from \"@stdlib/websocket\";\n\ntry {\n    let ws = WebSocket(\"wss://secure.example.com/socket\");\n    defer ws.close();\n\n    // Send message\n    ws.send_text(\"Hello!\");\n\n    // Receive response\n    let msg = ws.recv(5000);\n    if (msg != null && msg.type == \"text\") {\n        print(\"Server said: \" + msg.data);\n    }\n\n} catch (e) {\n    print(\"Error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Show an example of example 3: logical operators in Hemlock.", "output": "```hemlock\nlet result = true || false && false;\n// Evaluated as: true || (false && false) = true\n// && has higher precedence than ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// Evaluated as: (5 < 10) && (10 < 20) = true\n// Comparison has higher precedence than &&\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does sin(x) work in Hemlock?", "output": "Returns:* f64 - Sine of x in range [-1, 1]\n\n```hemlock\nimport { sin, PI } from \"@stdlib/math\";\n\nlet result = sin(0.0);        // 0.0\nlet result2 = sin(PI / 2.0);  // 1.0\nlet result3 = sin(PI);        // ~0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does try/finally work in Hemlock?", "output": "```hemlock\ntry {\n    // risky code\n} finally {\n    // always runs\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does with error handling work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Always close, even on error\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does pattern: range checking work in Hemlock?", "output": "```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"valid score\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does complex expressions work in Hemlock?", "output": "```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// Evaluation: b * c ‚Üí f64(60.0)\n//             a + f64(60.0) ‚Üí f64(70.0)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Create a Hemlock program that test await on non-task values Expected: PASS (await should return the value unchanged).", "output": "```hemlock\n// Test await on non-task values\n// Expected: PASS (await should return the value unchanged)\n\nlet x = await 42;\nassert(x == 42, \"await on integer should return the integer\");\n\nlet s = await \"hello\";\nassert(s == \"hello\", \"await on string should return the string\");\n\nlet arr = await [1, 2, 3];\nassert(arr.length == 3, \"await on array should return the array\");\n\nprint(\"PASS\");\n```", "category": "tests/async", "source": "tests/async/edge_await_non_task.hml"}
{"instruction": "Show me Hemlock code that test closures - capturing variables from enclosing scope.", "output": "```hemlock\n// Test closures - capturing variables from enclosing scope\n\n// Closure factory (makeAdder pattern)\nfn makeAdder(n) {\n    return fn(x) {\n        return n + x;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\nprint(add5(3));\nprint(add10(3));\n\n// Multiple captures from function parameter\nfn makeMultiplier(a, b) {\n    return fn(x) {\n        return a * x + b;\n    };\n}\n\nlet mult = makeMultiplier(2, 3);\nprint(mult(5));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/closures.hml"}
{"instruction": "How does throw work in Hemlock?", "output": "```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does scientific notation work in Hemlock?", "output": "Hemlock supports scientific notation for numeric literals:\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // Case insensitive\nlet f = 1e+5;        // Explicit positive exponent\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does type safety patterns work in Hemlock?", "output": "Use duck typing for flexibility:*\n\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does pow(base, exponent) work in Hemlock?", "output": "Returns:* f64 - base^exponent\n\n```hemlock\nimport { pow } from \"@stdlib/math\";\n\nlet result = pow(2.0, 3.0);   // 8.0\nlet result2 = pow(10.0, 2.0); // 100.0\nlet result3 = pow(4.0, 0.5);  // 2.0 (square root)\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does pattern: array as stack work in Hemlock?", "output": "```hemlock\nlet stack = [];\n\n// Push onto stack\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop from stack\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does acos(x) work in Hemlock?", "output": "Returns:* f64 - Arc cosine in range [0, œÄ]\n\n```hemlock\nimport { acos, PI } from \"@stdlib/math\";\n\nlet angle = acos(0.0);   // œÄ/2\nlet angle2 = acos(1.0);  // 0.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Show me Hemlock code that test UTF-8 string iteration in for-in loops Should iterate over Unicode codepoints (runes), not bytes.", "output": "```hemlock\n// Test UTF-8 string iteration in for-in loops\n// Should iterate over Unicode codepoints (runes), not bytes\n\n// ASCII string\nlet ascii = \"Hello\";\nlet count = 0;\nfor (let ch in ascii) {\n    print(ch);\n    count = count + 1;\n}\nprint(\"ASCII count: \" + count);\n\n// UTF-8 with emojis (rocket is 4 bytes)\nlet emoji = \"Hi!\";\ncount = 0;\nfor (let ch in emoji) {\n    print(ch);\n    count = count + 1;\n}\nprint(\"Emoji count: \" + count);\n\n// Mixed UTF-8\nlet mixed = \"cafe\";\ncount = 0;\nfor (let ch in mixed) {\n    print(ch);\n    count = count + 1;\n}\nprint(\"Mixed count: \" + count);\n\n// Chinese characters (3 bytes each)\nlet chinese = \"abc\";\ncount = 0;\nfor (let ch in chinese) {\n    print(ch);\n    count = count + 1;\n}\nprint(\"CJK count: \" + count);\n```", "category": "tests/parity", "source": "tests/parity/language/string_utf8_iteration.hml"}
{"instruction": "How does center(str, width, fill?) work in Hemlock?", "output": "Useful for creating headers, banners, and aligned text\n\n```hemlock\nimport { center } from \"@stdlib/strings\";\n\nlet s1 = center(\"Title\", 10);\nprint(s1);  // \"  Title   \" (2 left, 3 right)\n\nlet s2 = center(\"X\", 5, \"*\");\nprint(s2);  // \"**X**\"\n\n// Create banner\nlet banner = center(\"IMPORTANT\", 40, \"=\");\nprint(banner);  // \"===============IMPORTANT================\"\n\n// Unicode fill\nlet s3 = center(\"test\", 10, \"‚îÄ\");\nprint(s3);  // \"‚îÄ‚îÄ‚îÄtest‚îÄ‚îÄ‚îÄ\"\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does use descriptive variable names work in Hemlock?", "output": "```hemlock\n// Good\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// Bad\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does md5(input: string): string work in Hemlock?", "output": "‚ö†Ô∏è WARNING: MD5 is cryptographically broken. Use only for legacy compatibility, NOT for security.\n\n```hemlock\nlet hash = md5(\"hello\");\nprint(hash);\n// \"5d41402abc4b2a76b9719d911017c592\"\n\nassert(hash.length == 32, \"MD5 produces 32 hex characters\");\n\n// Known MD5 hash\nlet test_hash = md5(\"The quick brown fox jumps over the lazy dog\");\nassert(test_hash == \"9e107d9d372bb6826bd81d3542a419d6\");\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does legacy code integration work in Hemlock?", "output": "Reuse existing C codebases:\n\n```hemlock\n// Call functions from legacy C applications\n// Gradually migrate to Hemlock\n// Preserve working C code\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Write Hemlock code that test math module exponential and logarithmic functions.", "output": "```hemlock\n// Test math module exponential and logarithmic functions\n\nimport * as math from \"@stdlib/math\";\n\n// Test sqrt\nassert(math.sqrt(4.0) == 4.0 / 2.0, \"sqrt(4) should be 2\");\nassert(math.sqrt(9.0) == 9.0 / 3.0, \"sqrt(9) should be 3\");\nassert(math.sqrt(0.0) == 0.0, \"sqrt(0) should be 0\");\n\nlet s = math.sqrt(2.0);\nassert(s >= 1.41 && s <= 1.42, \"sqrt(2) should be approximately 1.414\");\n\n// Test pow\nassert(math.pow(2.0, 3.0) == 8.0, \"pow(2, 3) should be 8\");\nassert(math.pow(5.0, 2.0) == 25.0, \"pow(5, 2) should be 25\");\nassert(math.pow(10.0, 0.0) == 1.0, \"pow(10, 0) should be 1\");\n\n// Test exp\nlet e = math.exp(0.0);\nassert(e == 1.0, \"exp(0) should be 1\");\n\ne = math.exp(1.0);\nassert(e >= 2.71 && e <= 2.72, \"exp(1) should be approximately E\");\n\n// Test log (natural logarithm)\nlet l = math.log(1.0);\nassert(l >= -0.01 && l <= 0.01, \"log(1) should be approximately 0\");\n\nl = math.log(math.E);\nassert(l >= 0.99 && l <= 1.01, \"log(E) should be approximately 1\");\n\n// Test log10\nlet l10 = math.log10(1.0);\nassert(l10 >= -0.01 && l10 <= 0.01, \"log10(1) should be approximately 0\");\n\nl10 = math.log10(10.0);\nassert(l10 >= 0.99 && l10 <= 1.01, \"log10(10) should be approximately 1\");\n\nl10 = math.log10(100.0);\nassert(l10 >= 1.99 && l10 <= 2.01, \"log10(100) should be approximately 2\");\n\n// Test log2\nlet l2 = math.log2(1.0);\nassert(l2 >= -0.01 && l2 <= 0.01, \"log2(1) should be approximately 0\");\n\nl2 = math.log2(2.0);\nassert(l2 >= 0.99 && l2 <= 1.01, \"log2(2) should be approximately 1\");\n\nl2 = math.log2(8.0);\nassert(l2 >= 2.99 && l2 <= 3.01, \"log2(8) should be approximately 3\");\n\nprint(\"All exponential and logarithmic function tests passed!\");\n```", "category": "tests/stdlib_math", "source": "tests/stdlib_math/test_exp_log.hml"}
{"instruction": "Write a Hemlock program that test array remove method.", "output": "```hemlock\n// Test array remove method\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);\nprint(removed);\nprint(arr);\n\nlet first = arr.remove(0);\nprint(first);\nprint(arr);\n\nlet last = arr.remove(2);\nprint(last);\nprint(arr);\n```", "category": "tests/arrays", "source": "tests/arrays/remove.hml"}
{"instruction": "How does pattern: character counting work in Hemlock?", "output": "```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "What is the difference between ptr and buffer in Hemlock?", "output": "`ptr` is a raw pointer with no safety checks - you're responsible for bounds.\n\n`buffer` is a safe wrapper that provides bounds checking:\n\n```hemlock\n// Raw pointer - no bounds checking\nlet p = alloc(10);\np[100] = 1;  // undefined behavior, no error\n\n// Buffer - bounds checked\nlet b = buffer(10);\nb[100] = 1;  // runtime error: index out of bounds\n```\n\nUse `ptr` for performance-critical code, `buffer` for safety.", "category": "concepts/memory", "source": "CLAUDE.md"}
{"instruction": "How does expected output methods work in Hemlock?", "output": "```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "What is the difference between / and div() in Hemlock?", "output": "The `/` operator always returns a float, while `div()` performs floor division:\n\n```hemlock\nprint(7 / 2);      // 3.5 (float division)\nprint(div(7, 2));  // 3 (floor division)\nprint(7 % 2);      // 1 (remainder)\n```\n\nThis differs from C where `/` on integers gives integer division.", "category": "concepts/operators", "source": "CLAUDE.md"}
{"instruction": "Create a Hemlock program that tests u16 valid.", "output": "```hemlock\nlet a: u16 = 0;\nlet b: u16 = 65535;\nlet c: u16 = 1000;\nprint(a);\nprint(b);\nprint(c);\n```", "category": "tests/primitives", "source": "tests/primitives/u16_valid.hml"}
{"instruction": "How does print_at(row, col, text) work in Hemlock?", "output": "```hemlock\nimport { print_at } from \"@stdlib/terminal\";\n\nprint_at(10, 20, \"Hello at position (10, 20)\");\nprint_at(15, 30, \"Another line here\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does randrange(minval, max_val) work in Hemlock?", "output": "Returns:* f64 - Random value in [min, max)\n\n```hemlock\nimport { rand_range } from \"@stdlib/math\";\n\nlet dice = rand_range(1.0, 7.0);       // Random 1.0 to 6.999...\nlet temperature = rand_range(20.0, 30.0); // Random 20-30¬∞C\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How do you allocate memory in Hemlock?", "output": "Hemlock provides manual memory management:\n\n```hemlock\n// Raw pointer allocation\nlet p = alloc(64);       // allocate 64 bytes\nmemset(p, 0, 64);        // initialize to zero\nfree(p);                 // must free manually\n\n// Safe buffer (bounds checked)\nlet b = buffer(64);\nb[0] = 42;               // bounds checked access\nfree(b);\n\n// Typed allocation\nlet nums = talloc(i32, 10);  // 10 i32 values\nfree(nums);\n```", "category": "concepts/memory", "source": "CLAUDE.md"}
{"instruction": "How does file truncation work in Hemlock?", "output": "```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // \"w\" mode truncates\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Write Hemlock code that test array operations on empty arrays Expected: PASS (testing that operations handle empty arrays gracefully).", "output": "```hemlock\n// Test array operations on empty arrays\n// Expected: PASS (testing that operations handle empty arrays gracefully)\n\nlet arr = [];\n\n// Test length\nassert(arr.length == 0, \"Empty array should have length 0\");\n\n// Test first() on empty array - should return null\nlet f = arr.first();\nassert(f == null, \"first() on empty array should return null\");\n\n// Test last() on empty array - should return null\nlet l = arr.last();\nassert(l == null, \"last() on empty array should return null\");\n\n// Test find on empty array\nlet idx = arr.find(5);\nassert(idx == -1, \"find on empty array should return -1\");\n\n// Test contains on empty array\nassert(arr.contains(5) == false, \"contains on empty array should return false\");\n\n// Test join on empty array\nlet joined = arr.join(\",\");\nassert(joined == \"\", \"join on empty array should return empty string\");\n\n// Test reverse on empty array (should not crash)\narr.reverse();\nassert(arr.length == 0, \"reverse on empty array should keep it empty\");\n\n// Test slice on empty array\nlet sliced = arr.slice(0, 5);\nassert(sliced.length == 0, \"slice on empty array should return empty array\");\n\n// Test concat empty with empty\nlet arr2: array = [];\nlet combined = arr.concat(arr2);\nassert(combined.length == 0, \"concat empty with empty should return empty\");\n\n// Test concat empty with non-empty\nlet arr3 = [1, 2, 3];\nlet combined2 = arr.concat(arr3);\nassert(combined2.length == 3, \"concat empty with non-empty should return non-empty\");\n\n// Test concat non-empty with empty\nlet combined3 = arr3.concat(arr);\nassert(combined3.length == 3, \"concat non-empty with empty should return non-empty\");\n\nprint(\"PASS\");\n```", "category": "tests/arrays", "source": "tests/arrays/edge_empty_operations.hml"}
{"instruction": "How does signal work in Hemlock?", "output": "```hemlock\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Reset to default\nsignal(SIGINT, null);\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All JSON operations use Hemlock's exception system:\n\n```hemlock\nimport { parse, stringify, get, set } from \"@stdlib/json\";\n\n// Parse errors\ntry {\n    let obj = parse('{\"malformed}');\n} catch (e) {\n    print(\"Parse error: \" + e);\n}\n\n// Serialization errors (circular references)\ntry {\n    let obj = {};\n    obj.self = obj;\n    stringify(obj);\n} catch (e) {\n    print(\"Stringify error: \" + e);\n}\n\n// Path errors\ntry {\n    let obj = { user: { name: \"Alice\" } };\n    set(obj, \"nonexistent.path\", \"value\");\n} catch (e) {\n    print(\"Path error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "Create a Hemlock program that test enum comparison.", "output": "```hemlock\n// Test enum comparison\n\nenum Status {\n    OK,\n    ERROR,\n    PENDING\n}\n\nlet status = Status.OK;\n\nif (status == Status.OK) {\n    print(\"Status is OK\");\n}\n\nif (status != Status.ERROR) {\n    print(\"Status is not ERROR\");\n}\n\nlet error = Status.ERROR;\nif (error == Status.ERROR) {\n    print(\"Error status\");\n}\n```", "category": "tests/enums", "source": "tests/enums/comparison.hml"}
{"instruction": "How does planned features work in Hemlock?", "output": "4. String Marshaling*\n\n```hemlock\n// Future: Automatic string conversion\nlet s = \"hello\";\nc_string_function(s);  // Auto-convert to C string\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does processing large files in chunks work in Hemlock?", "output": "```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // 4KB chunks\n            if (chunk == \"\") { break; }\n\n            // Process chunk\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does args work in Hemlock?", "output": "# Command: ./hemlock script.hml hello world\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// Iterate arguments\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument\", i, \":\", args[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "Create a Hemlock program that test namespace import.", "output": "```hemlock\n// Test namespace import\nimport * as math from \"./math.hml\";\n\nlet result1 = math.add(5, 7);\nlet result2 = math.subtract(20, 8);\n\nprint(\"math.add(5, 7) = \" + typeof(result1));  // Should print 12\nprint(\"math.subtract(20, 8) = \" + typeof(result2));  // Should print 12\nprint(\"math.PI = \" + typeof(math.PI));  // Should print 3.14159\n```", "category": "tests/modules", "source": "tests/modules/test_import_namespace.hml"}
{"instruction": "Implement a Hemlock program that test optional parameters with default values.", "output": "```hemlock\n// Test optional parameters with default values\n\nfn greet(name, greeting?: \"Hello\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));\nprint(greet(\"Bob\", \"Hi\"));\n\n// Multiple optional parameters\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));\nprint(add(1, 2));\nprint(add(1, 2, 3));\n\n// All optional\nfn test(x?: 1, y?: 2) {\n    return x + y;\n}\n\nprint(test());\nprint(test(10));\nprint(test(10, 20));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/optional_params.hml"}
{"instruction": "How does directory tree listing work in Hemlock?", "output": "```hemlock\nimport { list_dir, is_dir } from \"@stdlib/fs\";\n\nfn list_recursive(path: string, indent: string): null {\n    try {\n        let entries = list_dir(path);\n\n        let i = 0;\n        while (i < entries.length) {\n            let name = entries[i];\n            let full_path = path + \"/\" + name;\n\n            print(indent + name);\n\n            if (is_dir(full_path)) {\n                list_recursive(full_path, indent + \"  \");\n            }\n\n            i = i + 1;\n        }\n    } catch (e) {\n        print(indent + \"Error: \" + e);\n    }\n\n    return null;\n}\n\nprint(\"Directory tree:\");\nlist_recursive(\".\", \"\");\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Write a Hemlock program that test basic FFI functionality with strlen.", "output": "```hemlock\n// Test basic FFI functionality with strlen\n\n// Import libc\nimport \"libc.so.6\";\n\n// Declare external function\nextern fn strlen(s: string): i32;\n\n// Test strlen\nlet len = strlen(\"hello\");\nprint(\"strlen test:\");\nprint(len);\n\n// Test with longer string\nlet len2 = strlen(\"hello world\");\nprint(len2);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/ffi_basic.hml"}
{"instruction": "How does when exec() does not throw work in Hemlock?", "output": "```hemlock\n// Command runs but returns non-zero exit code\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1 (not an exception)\n\n// Command produces no output\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\" (not an exception)\n\n// Command not found by shell\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127 (not an exception)\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does djb2(input: string): i32 work in Hemlock?", "output": "DJB2 hash algorithm - fast, simple, with good distribution. Commonly used in hash tables.\n\n```hemlock\nlet h = djb2(\"hello world\");\nprint(h);  // -862545276 (i32 hash value)\n\n// Empty string\nlet h2 = djb2(\"\");\nprint(h2);  // 5381 (djb2 initial value)\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does sensitive data work in Hemlock?", "output": "Best practices:*\n\n```hemlock\nimport { getenv, unsetenv } from \"@stdlib/env\";\n\n// Get sensitive value\nlet api_key = getenv(\"API_KEY\");\n\n// Use it...\nauthenticate(api_key);\n\n// Clear it from environment\nunsetenv(\"API_KEY\");\n\n// api_key variable still in memory, but not in environment\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "Show an example of example: event emitter in Hemlock.", "output": "```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Received: \" + data);\n});\n\nemitter.emit(\"message\", \"Hello!\");\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Write Hemlock code that test basic HTTP functionality (requires libwebsockets).", "output": "```hemlock\n// Test basic HTTP functionality (requires libwebsockets)\n\nimport * as http from \"@stdlib/http\";\n\nprint(\"Testing @stdlib/http basic functionality...\");\n\n// Test 1: Module loads\nprint(\"‚úì HTTP module loads\");\n\n// Test 2: Status code helpers\nassert(http.is_success(200) == true, \"is_success(200) should be true\");\nassert(http.is_success(299) == true, \"is_success(299) should be true\");\nassert(http.is_success(300) == false, \"is_success(300) should be false\");\nassert(http.is_success(404) == false, \"is_success(404) should be false\");\n\nassert(http.is_redirect(301) == true, \"is_redirect(301) should be true\");\nassert(http.is_redirect(302) == true, \"is_redirect(302) should be true\");\nassert(http.is_redirect(200) == false, \"is_redirect(200) should be false\");\n\nassert(http.is_client_error(400) == true, \"is_client_error(400) should be true\");\nassert(http.is_client_error(404) == true, \"is_client_error(404) should be true\");\nassert(http.is_client_error(500) == false, \"is_client_error(500) should be false\");\n\nassert(http.is_server_error(500) == true, \"is_server_error(500) should be true\");\nassert(http.is_server_error(503) == true, \"is_server_error(503) should be true\");\nassert(http.is_server_error(400) == false, \"is_server_error(400) should be false\");\n\nprint(\"‚úì Status code helpers work correctly\");\n\n// Test 3: URL encoding\nlet encoded = http.url_encode(\"hello world\");\nassert(encoded == \"hello%20world\", \"url_encode should encode spaces\");\n\nlet encoded2 = http.url_encode(\"test&key=value\");\nassert(encoded2.contains(\"%26\"), \"url_encode should encode ampersands\");\n\nprint(\"‚úì URL encoding works\");\n\nprint(\"\");\nprint(\"All HTTP basic tests passed!\");\nprint(\"\");\nprint(\"Note: Network tests require libwebsockets-dev and 'make stdlib'\");\nprint(\"Run tests/stdlib_http/test_http_requests.hml for network tests\");\n```", "category": "tests/stdlib_http", "source": "tests/stdlib_http/test_http_basic.hml"}
{"instruction": "How does handling failures work in Hemlock?", "output": "```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // Note: stderr not captured\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show me Hemlock code that basic field access.", "output": "```hemlock\n// Basic field access\nlet obj = { x: 10, y: 20 };\nprint(obj.x);\nprint(obj.y);\n```", "category": "tests/objects", "source": "tests/objects/field_access_basic.hml"}
{"instruction": "How does comparison work in Hemlock?", "output": "Runes can be compared for equality:\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Case sensitive\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Runes can be compared with integers (codepoint values)\nprint(a == 65);                 // true (implicit conversion)\nprint('üöÄ' == 128640);          // true\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does array literals work in Hemlock?", "output": "```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];\nlet empty = [];\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does recursion work in Hemlock?", "output": "```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does channels work in Hemlock?", "output": "```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Show me Hemlock code that test mixed type arrays.", "output": "```hemlock\n// Test mixed type arrays\nlet mixed = [1, \"hello\", true, null];\nprint(mixed);\n```", "category": "tests/arrays", "source": "tests/arrays/mixed.hml"}
{"instruction": "How does logical or (||) work in Hemlock?", "output": "At least one condition must be true:\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"out of range\");\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does string type work in Hemlock?", "output": "```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate (now \"Hello\")\nprint(s.length);        // 5 (codepoint count)\nprint(s.byte_length);   // 5 (UTF-8 bytes)\n\nlet emoji = \"üöÄ\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does timeout handling work in Hemlock?", "output": "```hemlock\nimport { TcpStream } from \"@stdlib/net\";\n\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();\n\nstream.set_timeout(5.0);  // 5 second timeout\n\ntry {\n    let data = stream.read(1024);\n    print(\"Received data\");\n} catch (e) {\n    print(\"Timeout or error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does open work in Hemlock?", "output": "```hemlock\n// Read mode (default)\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// Write mode (truncate)\nlet f_write = open(\"output.txt\", \"w\");\n\n// Append mode\nlet f_append = open(\"log.txt\", \"a\");\n\n// Read/write mode\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// Read/write (truncate)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Read/append\nlet f_ra = open(\"log.txt\", \"a+\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does return inside try/catch/finally work in Hemlock?", "output": "```hemlock\nfn example() {\n    try {\n        return 1;  // ‚úÖ Returns 1 after finally runs\n    } finally {\n        print(\"cleanup\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // ‚ö†Ô∏è Finally return overrides try return - returns 2\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Write Hemlock code that should not cause stack overflow when freed.", "output": "```hemlock\n// Test: Array containing itself\n// Should not cause stack overflow when freed\n\nlet arr = [1, 2, 3];\narr.push(arr);\n\n// Free should work without crashing\nfree(arr);\n\nprint(\"PASS: Array self-reference handled correctly\");\n```", "category": "tests/circular_refs", "source": "tests/circular_refs/test_array_self_reference.hml"}
{"instruction": "How does working with string indexing work in Hemlock?", "output": "Important:* String indexing uses codepoint positions, not byte offsets:\n\n```hemlock\nlet text = \"HiüöÄ!\";\n// Codepoint positions: 0='H', 1='i', 2='üöÄ', 3='!'\n// Byte positions:      0='H', 1='i', 2-5='üöÄ', 6='!'\n\nlet r = text[2];                // 'üöÄ' (codepoint 2)\nprint(typeof(r));               // \"rune\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Implement a Hemlock program that test edge cases for string operations on empty strings Expected: PASS.", "output": "```hemlock\n// Test edge cases for string operations on empty strings\n// Expected: PASS\n\n// Empty string operations\nlet empty = \"\";\nassert(empty.length == 0, \"Empty string should have length 0\");\n\n// find on empty string\nassert(empty.find(\"x\") == -1, \"find on empty string should return -1\");\n\n// contains on empty string\nassert(empty.contains(\"x\") == false, \"contains on empty string should return false\");\n\n// split on empty string\nlet parts = empty.split(\",\");\nassert(parts.length == 1, \"split empty string should return array with 1 element\");\nassert(parts[0] == \"\", \"split empty string should contain empty string\");\n\n// split with empty delimiter\nlet str = \"hello\";\nlet chars_split = str.split(\"\");\nassert(chars_split.length == 5, \"split with empty delimiter should split into characters\");\n\n// trim on whitespace-only string\nlet whitespace = \"   \\t\\n  \";\nlet trimmed = whitespace.trim();\nassert(trimmed == \"\", \"trim on whitespace-only should return empty string\");\n\n// substr on empty string\nlet sub = empty.substr(0, 5);\nassert(sub == \"\", \"substr on empty string should return empty string\");\n\n// slice on empty string\nlet sliced = empty.slice(0, 5);\nassert(sliced == \"\", \"slice on empty string should return empty string\");\n\n// repeat with 0 count\nlet repeated = \"test\".repeat(0);\nassert(repeated == \"\", \"repeat with 0 should return empty string\");\n\n// join empty array\nlet arr = [];\nlet joined = arr.join(\",\");\nassert(joined == \"\", \"join empty array should return empty string\");\n\n// replace on empty string\nlet replaced = empty.replace(\"x\", \"y\");\nassert(replaced == \"\", \"replace on empty string should return empty string\");\n\n// to_upper/to_lower on empty\nassert(empty.to_upper() == \"\", \"to_upper on empty string should return empty\");\nassert(empty.to_lower() == \"\", \"to_lower on empty string should return empty\");\n\n// starts_with/ends_with on empty\nassert(empty.starts_with(\"\") == true, \"empty string should start with empty string\");\nassert(empty.ends_with(\"\") == true, \"empty string should end with empty string\");\nassert(empty.starts_with(\"x\") == false, \"empty string should not start with non-empty\");\nassert(empty.ends_with(\"x\") == false, \"empty string should not end with non-empty\");\n\n// chars() and bytes() on empty string\nlet chars = empty.chars();\nassert(chars.length == 0, \"chars() on empty string should return empty array\");\n\nlet bytes = empty.bytes();\nassert(bytes.length == 0, \"bytes() on empty string should return empty array\");\n\nprint(\"PASS\");\n```", "category": "tests/strings", "source": "tests/strings/edge_empty_operations.hml"}
{"instruction": "How does common errors work in Hemlock?", "output": "File not found:*\n\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does bgcolor256(n) work in Hemlock?", "output": "Returns:* string - 256-color background code\n\n```hemlock\nimport { bg_color_256, color_256, RESET } from \"@stdlib/terminal\";\n\nprint(color_256(16) + bg_color_256(226) + \" Black on yellow \" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does exit_code field work in Hemlock?", "output": "```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0 (success)\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1 (failure)\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2 (file not found, varies by command)\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Give me Hemlock code that shows demonstrates string operations.", "output": "```hemlock\nlet name = \"Alice\";\nlet greeting = \"Hello, \";\nlet message = greeting + name;\n\nprint(name);\nprint(greeting);\nprint(message);\n```", "category": "examples", "source": "examples/strings.hml"}
{"instruction": "Create a Hemlock program that some tasks throw exceptions, verify they're properly caught.", "output": "```hemlock\n// Test: Exception handling with many concurrent tasks\n// Some tasks throw exceptions, verify they're properly caught\n\nasync fn maybe_fail(id: i32): i32 {\n    // Tasks with even IDs throw exceptions\n    if (id == 2 || id == 4 || id == 6 || id == 8) {\n        throw \"Task failed\";\n    }\n    return id * 10;\n}\n\n// Spawn 10 tasks (half will fail)\nlet tasks = [];\nlet i = 0;\nwhile (i < 10) {\n    tasks.push(spawn(maybe_fail, i));\n    i = i + 1;\n}\n\n// Join tasks and handle exceptions\nlet successful = 0;\nlet failed = 0;\nlet sum = 0;\n\ni = 0;\nwhile (i < tasks.length) {\n    try {\n        let result = join(tasks[i]);\n        sum = sum + result;\n        successful = successful + 1;\n    } catch (e) {\n        failed = failed + 1;\n    }\n    i = i + 1;\n}\n\nprint(\"Successful:\");\nprint(successful);\nprint(\"Failed:\");\nprint(failed);\nprint(\"Sum:\");\nprint(sum);\n```", "category": "tests/async", "source": "tests/async/stress_exception_handling.hml"}
{"instruction": "Implement a Hemlock program that tests switch statements.", "output": "```hemlock\nlet x = 85;\nswitch (x) {\n    case 100:\n    case 90:\n    case 85:\n        print(\"matched\");\n        break;\n}\nprint(\"done\");\n```", "category": "tests/manual", "source": "tests/manual/test_switch2.hml"}
{"instruction": "Show me Hemlock code that tests round trip.", "output": "```hemlock\n// Test: Round-trip serialization/deserialization\nlet original = { x: 10, y: 20, name: \"test\", active: true };\nlet json = original.serialize();\nprint(json);\nlet restored = json.deserialize();\nprint(restored.x);\nprint(restored.y);\nprint(restored.name);\nprint(restored.active);\n```", "category": "tests/objects", "source": "tests/objects/round_trip.hml"}
{"instruction": "Write a Hemlock program that nested functions with defer - each function should have its own defer stack.", "output": "```hemlock\n// Nested functions with defer - each function should have its own defer stack\nfn inner() {\n    defer print(\"inner defer 1\");\n    defer print(\"inner defer 2\");\n    print(\"inner body\");\n}\n\nfn outer() {\n    defer print(\"outer defer 1\");\n    print(\"outer before inner\");\n    inner();\n    print(\"outer after inner\");\n    defer print(\"outer defer 2\");\n}\n\nouter();\n```", "category": "tests/defer", "source": "tests/defer/defer_nested.hml"}
{"instruction": "Create a Hemlock program that test array remove() with invalid indices Tests that invalid indices throw catchable exceptions.", "output": "```hemlock\n// Test array remove() with invalid indices\n// Tests that invalid indices throw catchable exceptions\n\nlet arr = [1, 2, 3];\n\n// Test remove at negative index\ntry {\n    arr.remove(-1);\n    print(\"ERROR: Should have thrown on negative index\");\n} catch (e) {\n    print(\"Caught negative index: \" + e);\n}\n\n// Test remove beyond bounds\ntry {\n    arr.remove(10);\n    print(\"ERROR: Should have thrown on out of bounds index\");\n} catch (e) {\n    print(\"Caught out of bounds: \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/arrays", "source": "tests/arrays/edge_remove_bounds.hml"}
{"instruction": "How does error handling work in Hemlock?", "output": "All networking operations can throw exceptions:\n\n```hemlock\ntry {\n    let listener = TcpListener(\"0.0.0.0\", 8080);\n    defer listener.close();\n    // ... server code\n} catch (e) {\n    print(\"Failed to start server: \" + e);\n}\n\ntry {\n    let stream = TcpStream(\"example.com\", 80);\n    defer stream.close();\n    stream.write(\"data\");\n} catch (e) {\n    print(\"Connection failed: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does waitpid(pid: i32, options: i32): object work in Hemlock?", "output": "Returns:* Same as wait()\n\n```hemlock\nlet child_pid = fork();\n\nif (child_pid == 0) {\n    // Child work\n    exit(0);\n} else {\n    // Wait for specific child\n    let result = waitpid(child_pid, 0);\n    print(\"Child exited: \" + typeof(result.status));\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Write Hemlock code that test bitwise shifts by large amounts Expected: Testing behavior (undefined in many languages).", "output": "```hemlock\n// Test bitwise shifts by large amounts\n// Expected: Testing behavior (undefined in many languages)\n\nlet x: i32 = 1;\n\n// Shift by 32 (bit width of i32)\nlet result1 = x << 32;\nprint(\"1 << 32 = \" + typeof(result1));\n\n// Shift by more than bit width\nlet result2 = x << 40;\nprint(\"1 << 40 = \" + typeof(result2));\n\n// Negative shift (if allowed)\ntry {\n    let result3 = x << -1;\n    print(\"Shift by negative did not error: \" + typeof(result3));\n} catch (e) {\n    print(\"Caught negative shift: \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/bitwise", "source": "tests/bitwise/edge_shift_large.hml"}
{"instruction": "How does methods and self work in Hemlock?", "output": "```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "Write Hemlock code that test socket.set_nonblocking method.", "output": "```hemlock\n// Test socket.set_nonblocking method\nprint(\"=== Socket Non-blocking Test ===\");\n\n// Create a TCP socket\nlet sock = socket_create(2, 1, 0);  // AF_INET, SOCK_STREAM, 0\nprint(\"Socket created\");\nprint(sock.fd >= 0);\n\n// Set to non-blocking mode\nsock.set_nonblocking(true);\nprint(\"Set to non-blocking\");\n\n// Set back to blocking mode\nsock.set_nonblocking(false);\nprint(\"Set to blocking\");\n\n// Close socket\nsock.close();\nprint(\"Socket closed\");\n\nprint(\"=== Done ===\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/socket_nonblocking.hml"}
{"instruction": "How does cycle detection work in Hemlock?", "output": "Circular references are detected and cause errors:\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Create circular reference\n\nobj.serialize();  // ERROR: serialize() detected circular reference\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "Write a Hemlock program that test modulo in complex expressions.", "output": "```hemlock\n// Test modulo in complex expressions\n\n// Modulo with addition/subtraction\nlet a = 10 % 3 + 5;\nprint(a);  // 6 (1 + 5)\n\nlet b = 20 - 15 % 4;\nprint(b);  // 17 (20 - 3)\n\n// Modulo with multiplication (same precedence, left-to-right)\nlet c = 10 * 3 % 7;\nprint(c);  // 2 (30 % 7)\n\nlet d = 20 % 3 * 4;\nprint(d);  // 8 (2 * 4)\n\n// Modulo with division (same precedence, left-to-right)\nlet e = 20 / 3 % 5;\nprint(e);  // 1 (6 % 5)\n\nlet f = 20 % 7 / 2;\nprint(f);  // 3 (6 / 2)\n\n// Parentheses\nlet g = 20 % (3 + 2);\nprint(g);  // 0 (20 % 5)\n\nlet h = (20 + 5) % 7;\nprint(h);  // 4 (25 % 7)\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_expressions.hml"}
{"instruction": "How does get all process info work in Hemlock?", "output": "```hemlock\nfn get_process_info() {\n    let info = {};\n    info.pid = get_pid();\n    info.ppid = getppid();\n    info.uid = getuid();\n    info.euid = geteuid();\n    info.gid = getgid();\n    info.egid = getegid();\n    return info;\n}\n\nlet info = get_process_info();\nprint(\"PID: \" + typeof(info.pid));\nprint(\"UID: \" + typeof(info.uid));\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "How does shutdownasyncfs work in Hemlock?", "output": "```hemlock\nimport { async_read_file, shutdown_async_fs } from \"@stdlib/async_fs\";\n\n// Use async file operations...\nlet content = async_read_file(\"data.txt\").get();\n\n// Cleanup when done\nshutdown_async_fs();\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does minimum length work in Hemlock?", "output": "Always at least 1 (the script name):\n\n```hemlock\nprint(args.length);  // Minimum: 1\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does ecdsa_sign(data: string, keypair: ecdsakeypair): buffer work in Hemlock?", "output": "Sign data with ECDSA private key using SHA-256 digest.\n\n```hemlock\nimport { ecdsa_sign } from \"@stdlib/crypto\";\n\nlet data = \"Important message\";\nlet signature = ecdsa_sign(data, keypair);\n\nprint(\"Signature length: \" + typeof(signature.length));  // ~70-72 bytes (DER-encoded)\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "Show an example of complete aes example in Hemlock.", "output": "```hemlock\nimport {\n    generate_aes_key,\n    generate_iv,\n    aes_encrypt,\n    aes_decrypt,\n    buffer_to_hex\n} from \"@stdlib/crypto\";\n\n// Generate key and IV\nlet key = generate_aes_key();\nlet iv = generate_iv();\n\nprint(\"Key: \" + buffer_to_hex(key));\nprint(\"IV:  \" + buffer_to_hex(iv));\n\n// Encrypt\nlet message = \"This is a secret message!\";\nlet encrypted = aes_encrypt(message, key, iv);\n\nprint(\"Encrypted (\" + typeof(encrypted.length) + \" bytes): \" + buffer_to_hex(encrypted));\n\n// Decrypt\nlet decrypted = aes_decrypt(encrypted, key, iv);\nprint(\"Decrypted: \" + decrypted);\n\n// Verify\nif (decrypted == message) {\n    print(\"‚úì Encryption/decryption successful!\");\n}\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does min(a, b) work in Hemlock?", "output": "Returns:* f64 - Minimum of a and b\n\n```hemlock\nimport { min } from \"@stdlib/math\";\n\nlet result = min(5.0, 10.0);  // 5.0\nlet result2 = min(-3.0, 2.0); // -3.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Implement a Hemlock program that test optional chaining.", "output": "```hemlock\n// Test optional chaining\n\n// Test with null object\nlet obj = null;\nlet result = obj?.name;\nprint(result);\n\n// Test with non-null object\nlet person = { name: \"Alice\", age: 30 };\nlet name = person?.name;\nprint(name);\n\n// Test chained optional access\nlet data = { user: { profile: { email: \"test@example.com\" } } };\nlet email = data?.user?.profile?.email;\nprint(email);\n\n// Test optional chaining returning null for missing property\nlet empty = {};\nlet missing = empty?.nonexistent;\nprint(missing);\n\n// Test optional indexing with array\nlet arr = [1, 2, 3];\nlet first = arr?.[0];\nprint(first);\n\n// Test optional indexing with null\nlet nullArr = null;\nlet nullResult = nullArr?.[0];\nprint(nullResult);\n\n// Test null coalesce with optional chaining\nlet user = null;\nlet defaultName = user?.name ?? \"default\";\nprint(defaultName);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/optional_chaining.hml"}
{"instruction": "How does handling multiple tasks work in Hemlock?", "output": "```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task \" + typeof(id) + \" failed\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // Will fail\nlet t3 = spawn(work, 3, 0);\n\n// Join with error handling\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Task 1:\", r1);\n\n    let r2 = join(t2);  // Throws\n    print(\"Task 2:\", r2);  // Never reached\n} catch (e) {\n    print(\"Error:\", e);  // \"Error: Task 2 failed\"\n}\n\n// Can still join remaining task\nlet r3 = join(t3);\nprint(\"Task 3:\", r3);\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "Show me Hemlock code that tests serialize basic.", "output": "```hemlock\n// Test: Basic object serialization\nlet obj = { x: 10, y: 20, name: \"test\" };\nprint(obj.serialize());\n```", "category": "tests/objects", "source": "tests/objects/serialize_basic.hml"}
{"instruction": "How does test-driven development (tdd) work in Hemlock?", "output": "Write the test first:\n\n```hemlock\ntest(\"parses JSON string\", fn() {\n    let obj = parse_json('{\"x\": 10}');\n    expect(obj.x).to_equal(10);\n});\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How does testing exceptions work in Hemlock?", "output": "Always wrap risky calls in functions:\n\n```hemlock\n// ‚úì Correct\nexpect(fn() {\n    let result = divide(10, 0);\n}).to_throw();\n\n// ‚úó Wrong - throws immediately, test fails\nexpect(divide(10, 0)).to_throw();\n```", "category": "docs", "source": "stdlib/docs/testing.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as hash from \"@stdlib/hash\";\nlet checksum = hash.sha256(\"data\");\n```", "category": "docs", "source": "stdlib/docs/hash.md"}
{"instruction": "How does type aliases work in Hemlock?", "output": "```hemlock\nlet count: integer = 100;       // Same as i32\nlet price: number = 19.99;      // Same as f64\nlet b: byte = 255;              // Same as u8\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Implement a Hemlock program that tests chaining.", "output": "```hemlock\nlet s = \"  Hello World  \";\nlet result = s.trim().to_lower().replace(\"world\", \"hemlock\");\nprint(result);\n\nlet s2 = \"foo\";\nlet result2 = s2.repeat(3).to_upper();\nprint(result2);\n```", "category": "tests/strings", "source": "tests/strings/chaining.hml"}
{"instruction": "Create a Hemlock program that test switch statements.", "output": "```hemlock\n// Test switch statements\n\n// Test 1: Basic switch with integers\nlet x = 2;\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n    default:\n        print(\"other\");\n        break;\n}\n\n// Test 2: Switch with strings\nlet color = \"green\";\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown\");\n        break;\n}\n\n// Test 3: Switch with default only\nlet y = 100;\nswitch (y) {\n    case 1:\n        print(\"one\");\n        break;\n    default:\n        print(\"default\");\n        break;\n}\n\n// Test 4: No matching case, no default\nlet z = 99;\nswitch (z) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n}\n\n// Test 5: Switch with expressions\nlet a = 5;\nlet b = 3;\nswitch (a + b) {\n    case 7:\n        print(\"seven\");\n        break;\n    case 8:\n        print(\"eight\");\n        break;\n    case 9:\n        print(\"nine\");\n        break;\n}\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/switch.hml"}
{"instruction": "Write Hemlock code that basic ternary operator tests.", "output": "```hemlock\n// Basic ternary operator tests\n\n// Test 1: Simple true condition\nlet a = true ? 1 : 2;\nprint(typeof(a));\n\n// Test 2: Simple false condition\nlet b = false ? 1 : 2;\nprint(typeof(b));\n\n// Test 3: With comparison\nlet c = 10 > 5 ? \"big\" : \"small\";\nprint(c);\n\n// Test 4: With comparison (false)\nlet d = 3 > 5 ? \"big\" : \"small\";\nprint(d);\n\n// Test 5: With variables\nlet x = 7;\nlet result = x > 5 ? \"yes\" : \"no\";\nprint(result);\n\n// Test 6: Different types in branches\nlet type_test = true ? 42 : \"string\";\nprint(typeof(type_test));\n\nlet type_test2 = false ? 42 : \"string\";\nprint(type_test2);\n```", "category": "tests/control", "source": "tests/control/ternary_basic.hml"}
{"instruction": "Implement a Hemlock program that tests replace.", "output": "```hemlock\nlet s = \"hello world\";\nprint(s.replace(\"world\", \"there\"));\nprint(s.replace(\"foo\", \"bar\"));\n\nlet s2 = \"foo foo foo\";\nprint(s2.replace(\"foo\", \"bar\"));\nprint(s2.replace_all(\"foo\", \"bar\"));\n```", "category": "tests/strings", "source": "tests/strings/replace.hml"}
{"instruction": "How does pattern: resource cleanup work in Hemlock?", "output": "Always use finally for cleanup:\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Error processing file: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // Always closes, even on error\n        }\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does result object work in Hemlock?", "output": "The object returned by exec() has the following structure:\n\n```hemlock\n{\n    output: string,      // Command stdout (captured output)\n    exit_code: i32       // Process exit status (0 = success)\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does open work in Hemlock?", "output": "Error Handling:*\n\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"Failed to open:\", e);\n    // Error: Failed to open 'missing.txt': No such file or directory\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Useful for reading complete messages\n\n```hemlock\nlet all_data = stream.read_all();\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does unary bitwise operator work in Hemlock?", "output": "Bitwise NOT (~)*\n\n```hemlock\nlet a = 12;\nprint(~a);      // -13 (two's complement)\n\nlet c: u8 = 15;   // 00001111 in binary\nprint(~c);        // 240 (11110000) in u8\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write Hemlock code that tests before_each and after_each functionality.", "output": "```hemlock\n// Test: @stdlib/testing - Test hooks\n// Tests before_each and after_each functionality\n\nimport {\n    describe, test, expect,\n    before_each, after_each, run\n} from \"@stdlib/testing\";\nimport { exit } from \"@stdlib/env\";\n\ndescribe(\"before_each hook\", fn() {\n    let counter = 0;\n\n    before_each(fn() {\n        counter = 100;\n    });\n\n    test(\"runs before first test\", fn() {\n        expect(counter).to_equal(100);\n        counter = 200;\n    });\n\n    test(\"runs before second test\", fn() {\n        expect(counter).to_equal(100);  // Reset by before_each\n        counter = 300;\n    });\n\n    test(\"runs before third test\", fn() {\n        expect(counter).to_equal(100);  // Reset again\n    });\n});\n\ndescribe(\"after_each hook\", fn() {\n    let log = [];\n\n    after_each(fn() {\n        log.push(\"cleanup\");\n    });\n\n    test(\"first test\", fn() {\n        log.push(\"test1\");\n        expect(log.length).to_equal(1);\n    });\n\n    test(\"second test\", fn() {\n        log.push(\"test2\");\n        // after_each from first test ran\n        expect(log).to_contain(\"cleanup\");\n    });\n});\n\ndescribe(\"before_each and after_each together\", fn() {\n    let data = null;\n\n    before_each(fn() {\n        data = [1, 2, 3];\n    });\n\n    after_each(fn() {\n        data = null;\n    });\n\n    test(\"data is initialized\", fn() {\n        expect(data).not_to_be_null();\n        expect(data.length).to_equal(3);\n    });\n\n    test(\"data is fresh each time\", fn() {\n        expect(data).to_equal([1, 2, 3]);\n        data.push(4);\n        expect(data.length).to_equal(4);\n    });\n\n    test(\"modifications don't persist\", fn() {\n        // Previous test modified data, but before_each reset it\n        expect(data.length).to_equal(3);\n    });\n});\n\ndescribe(\"hooks with array operations\", fn() {\n    let arr = null;\n\n    before_each(fn() {\n        arr = [];\n    });\n\n    test(\"push operation\", fn() {\n        arr.push(10);\n        expect(arr.length).to_equal(1);\n    });\n\n    test(\"array starts empty\", fn() {\n        expect(arr.length).to_equal(0);\n    });\n\n    test(\"multiple pushes\", fn() {\n        arr.push(1);\n        arr.push(2);\n        arr.push(3);\n        expect(arr.length).to_equal(3);\n    });\n});\n\n// Run tests\nlet results = run();\n\nif (!results.success) {\n    exit(1);\n}\n```", "category": "tests/stdlib_testing", "source": "tests/stdlib_testing/test_hooks.hml"}
{"instruction": "Write a Hemlock program that this tests that await syntax is parsed and executed correctly.", "output": "```hemlock\n// Test: Basic await expression\n// This tests that await syntax is parsed and executed correctly\n\nasync fn compute(x: i32): i32 {\n    return x * 2;\n}\n\nasync fn main() {\n    let result = await compute(21);\n    print(result);\n}\n\nmain();\n```", "category": "tests/async", "source": "tests/async/basic_await.hml"}
{"instruction": "Write a Hemlock program that tests the typeof operator.", "output": "```hemlock\n// Test: typeof() returns basic type names\nprint(typeof(42));\nprint(typeof(3.14));\nprint(typeof(true));\nprint(typeof(\"hello\"));\n```", "category": "tests/objects", "source": "tests/objects/typeof_basic.hml"}
{"instruction": "How does async functions work in Hemlock?", "output": "Functions can be declared as async to indicate they're designed for concurrent execution:\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Write Hemlock code that tests null.", "output": "```hemlock\n// Test: null keyword\nlet x = null;\nprint(x);\nprint(typeof(null));\n```", "category": "tests/primitives", "source": "tests/primitives/null.hml"}
{"instruction": "Show me Hemlock code that test user-defined functions.", "output": "```hemlock\n// Test user-defined functions\nfn add(a, b) {\n    return a + b;\n}\n\nfn multiply(x, y) {\n    return x * y;\n}\n\nfn greet(name) {\n    print(\"Hello, \" + name + \"!\");\n    return null;\n}\n\n// Test function calls\nprint(add(10, 20));\nprint(multiply(6, 7));\ngreet(\"World\");\n\n// Test function with local variables\nfn compute(x) {\n    let doubled = x * 2;\n    let tripled = x * 3;\n    return doubled + tripled;\n}\n\nprint(compute(5));\n```", "category": "tests/compiler", "source": "tests/compiler/functions.hml"}
{"instruction": "Implement a Hemlock program that tests that await can be used with spawned tasks.", "output": "```hemlock\n// Test: Combining await with spawn/join\n// Tests that await can be used with spawned tasks\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * await factorial(n - 1);\n}\n\nasync fn main() {\n    // Spawn factorial computations\n    let t1 = spawn(factorial, 5);\n    let t2 = spawn(factorial, 6);\n    let t3 = spawn(factorial, 7);\n\n    // Join and get results\n    let f5 = join(t1);\n    let f6 = join(t2);\n    let f7 = join(t3);\n\n    print(f5);  // 120\n    print(f6);  // 720\n    print(f7);  // 5040\n}\n\nmain();\n```", "category": "tests/async", "source": "tests/async/test_await_with_spawn.hml"}
{"instruction": "Write a Hemlock program that tests define duck typing basic.", "output": "```hemlock\n// Test: Basic duck typing - object matches type definition\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.name);\nprint(typed_p.age);\n```", "category": "tests/objects", "source": "tests/objects/define_duck_typing_basic.hml"}
{"instruction": "How does index operator work in Hemlock?", "output": "```hemlock\n// Array indexing\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// String indexing (returns rune)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Buffer indexing\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Show me Hemlock code that test array slice method.", "output": "```hemlock\n// Test array slice method\nlet arr = [1, 2, 3, 4, 5];\nlet sub1 = arr.slice(1, 4);\nprint(sub1);\n\nlet sub2 = arr.slice(0, 2);\nprint(sub2);\n\nlet sub3 = arr.slice(3, 5);\nprint(sub3);\n\nlet empty = arr.slice(2, 2);\nprint(empty);\n```", "category": "tests/arrays", "source": "tests/arrays/slice.hml"}
{"instruction": "Implement a Hemlock program that test throwing null Expected: PASS.", "output": "```hemlock\n// Test throwing null\n// Expected: PASS\n\ntry {\n    throw null;\n} catch (e) {\n    assert(e == null, \"caught value should be null\");\n    print(\"PASS: Caught null exception\");\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/edge_throw_null.hml"}
{"instruction": "How does minimum length work in Hemlock?", "output": "./hemlock script.hml\n\n```hemlock\n// In script.hml:\nprint(args.length);  // 1 (just script name)\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "Implement a Hemlock program that tests rethrow.", "output": "```hemlock\n// Test: Re-throwing exceptions\ntry {\n    try {\n        throw \"inner error\";\n    } catch (e) {\n        print(\"Inner caught: \" + e);\n        throw e;\n    }\n} catch (e) {\n    print(\"Outer caught: \" + e);\n}\n```", "category": "tests/exceptions", "source": "tests/exceptions/rethrow.hml"}
{"instruction": "How does configuration management work in Hemlock?", "output": "```hemlock\nimport { parse_file, pretty_file, get, set } from \"@stdlib/json\";\n\n// Load configuration\nlet config = parse_file(\"config.json\");\n\n// Read settings with defaults\nlet port = get(config, \"server.port\", 8080);\nlet host = get(config, \"server.host\", \"localhost\");\nlet db_pool = get(config, \"database.pool_size\", 10);\n\nprint(\"Server: \" + host + \":\" + typeof(port));\n\n// Update settings\nset(config, \"server.port\", 9000);\nset(config, \"database.pool_size\", 20);\n\n// Save with formatting\npretty_file(\"config.json\", config, 2);\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "Write a Hemlock program that constants test Tests: const declarations, immutability.", "output": "```hemlock\n// Constants test\n// Tests: const declarations, immutability\n\nconst PI = 3.14159;\nconst NAME = \"Hemlock\";\nconst MAX_SIZE = 100;\nconst IS_DEBUG = false;\n\nprint(PI);\nprint(NAME);\nprint(MAX_SIZE);\nprint(IS_DEBUG);\n\n// Constants in expressions\nlet area = PI * 5 * 5;\nprint(area);\n\n// Const arrays and objects\nconst COLORS = [\"red\", \"green\", \"blue\"];\nprint(COLORS[0]);\nprint(COLORS[1]);\nprint(COLORS[2]);\n\nconst CONFIG = { version: 1, name: \"test\" };\nprint(CONFIG.version);\nprint(CONFIG.name);\n```", "category": "tests/parity", "source": "tests/parity/language/constants.hml"}
{"instruction": "How does low-level builtins work in Hemlock?", "output": "Format time components using strftime format string.\n\n```hemlock\nimport { strftime } from \"@stdlib/datetime\";\n\nlet components = {\n    year: 2025,\n    month: 12,\n    day: 25,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    weekday: 0,\n    yearday: 1\n};\n\nlet formatted = strftime(\"%B %d, %Y\", components);\nprint(formatted);  // \"December 25, 2025\"\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "How does no timeout work in Hemlock?", "output": "Workaround - use timeout command:*\n\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// Will timeout after 5 seconds\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show me Hemlock code that tests test string.", "output": "```hemlock\nlet x = \"hello\";\nlet y = \"world\";\nlet z = x == y;\nprint(z);\n```", "category": "tests/manual", "source": "tests/manual/test_string.hml"}
{"instruction": "Show an example of example 3: git helper in Hemlock.", "output": "```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Error: Not a git repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Working directory clean\");\n    } else {\n        print(\"Changes:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Adding all changes...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Error adding files\");\n        return;\n    }\n\n    print(\"Committing...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Error committing\");\n        return;\n    }\n\n    print(\"Committed successfully\");\n    print(r2.output);\n}\n\n// Usage\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does closed: bool work in Hemlock?", "output": "Example - Checking if file is open:*\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... process content\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"File is now closed\");\n}\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Show me how to demonstrates file I/O operations in Hemlock.", "output": "```hemlock\n// Hemlock I/O System Demo\n// Demonstrates all I/O features in v0.1\n\nprint(\"=== Hemlock I/O System Demo ===\");\nprint(\"\");\n\n// 1. High-level convenience functions\nprint(\"1. High-level file operations:\");\nwrite_file(\"demo.txt\", \"Hello, Hemlock!\\nThis is a test.\\n\");\nprint(\"  Written to demo.txt\");\n\nlet content = read_file(\"demo.txt\");\nprint(\"  Read from demo.txt:\");\nprint(\"  \" + content);\n\nappend_file(\"demo.txt\", \"Appended line.\\n\");\nprint(\"  Appended to demo.txt\");\n\nif (file_exists(\"demo.txt\")) {\n    print(\"  File exists: true\");\n}\n\nprint(\"\");\n\n// 2. Binary operations\nprint(\"2. Binary file operations:\");\nlet buf = buffer(5);\nbuf[0] = 72;   // 'H'\nbuf[1] = 101;  // 'e'\nbuf[2] = 108;  // 'l'\nbuf[3] = 108;  // 'l'\nbuf[4] = 111;  // 'o'\nwrite_bytes(\"demo.bin\", buf);\nprint(\"  Written binary data\");\n\nlet data = read_bytes(\"demo.bin\");\nprint(\"  Read binary data, length:\");\nprint(data.length);\nfree(buf);\nfree(data);\n\nprint(\"\");\n\n// 3. Low-level file operations\nprint(\"3. Low-level file operations:\");\nlet f = open(\"demo.txt\", \"r\");\nprint(\"  Opened file:\");\nprint(f);\nprint(\"  Mode:\");\nprint(f.mode);\nprint(\"  Closed:\");\nprint(f.closed);\n\nlet pos = f.tell();\nprint(\"  Current position:\");\nprint(pos);\n\nlet chunk = f.read_text(10);\nprint(\"  Read chunk: \" + chunk);\n\nf.seek(0);\nprint(\"  Seeked to beginning\");\n\nlet line = f.read_text(100);\nprint(\"  Read full content: \" + line);\n\nf.close();\nprint(\"  File closed:\");\nprint(f.closed);\n\nprint(\"\");\n\n// 4. Standard streams\nprint(\"4. Standard streams:\");\neprint(\"This message goes to stderr\");\nprint(\"This message goes to stdout\");\n\nprint(\"\");\nprint(\"=== Demo Complete ===\");\nprint(\"(Temporary files: demo.txt, demo.bin)\");\n```", "category": "examples", "source": "examples/io_demo.hml"}
{"instruction": "How does pitfall: reference vs. value work in Hemlock?", "output": "```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Shallow copy\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (surprise! both changed)\n\n// To avoid: Create new object\nlet obj3 = { x: obj1.x };  // Deep copy (manual)\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does creating callbacks work in Hemlock?", "output": "Use callback() to create a C-callable function pointer from a Hemlock function:\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Create a Hemlock program that test substr edge cases with boundary conditions Expected: PASS.", "output": "```hemlock\n// Test substr edge cases with boundary conditions\n// Expected: PASS\n\nlet s = \"hello\";\n\n// substr with length exceeding string length\nlet sub1 = s.substr(0, 100);\nassert(sub1.length == 5, \"substr with excessive length should return available characters\");\n\n// substr starting beyond string length\nlet sub2 = s.substr(10, 5);\nassert(sub2 == \"\", \"substr starting beyond length should return empty string\");\n\n// substr with 0 length\nlet sub3 = s.substr(2, 0);\nassert(sub3 == \"\", \"substr with 0 length should return empty string\");\n\n// substr at exact end\nlet sub4 = s.substr(5, 1);\nassert(sub4 == \"\", \"substr at exact end should return empty string\");\n\n// substr near end\nlet sub5 = s.substr(3, 10);\nassert(sub5 == \"lo\", \"substr near end should return remaining characters\");\n\nprint(\"PASS\");\n```", "category": "tests/strings", "source": "tests/strings/edge_substr_bounds.hml"}
{"instruction": "How does pitfall: rune vs. byte confusion work in Hemlock?", "output": "```hemlock\n// DON'T: Treat runes as bytes\nlet r: rune = 'üöÄ';\nlet b: u8 = r;              // ERROR: Rune codepoint 128640 doesn't fit in u8\n\n// DO: Use appropriate conversions\nlet r: rune = 'üöÄ';\nlet code: i32 = r;          // OK: 128640\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does core allocation work in Hemlock?", "output": "free(ptr) - Free memory*\n\n```hemlock\nlet p = alloc(100);\nfree(p);  // Must free to avoid memory leak\n\nlet buf = buffer(100);\nfree(buf);  // Works on both ptr and buffer\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does functions as arguments work in Hemlock?", "output": "```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does do's work in Hemlock?", "output": "‚úÖ Test both success and failure\n\n```hemlock\n// Success: tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Expect: expected value\n\n// Failure: tests/feature/failure.hml\ndo_invalid_thing();  // Should error\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does format_bytes(bytes) work in Hemlock?", "output": "Returns:* string - Human-readable string (e.g., \"1024 KB\", \"2 GB\")\n\n```hemlock\nimport { format_bytes } from \"@stdlib/os\";\n\nprint(format_bytes(1024));           // \"1 KB\"\nprint(format_bytes(1048576));        // \"1 MB\"\nprint(format_bytes(1073741824));     // \"1 GB\"\nprint(format_bytes(1099511627776));  // \"1 TB\"\nprint(format_bytes(500));            // \"500 B\"\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Implement a Hemlock program that expect: 8 Expect: 2 Expect: 64 Expect: 1 Expect: 0 Expect: 128.", "output": "```hemlock\n// Test: Shift operations\n// Expect: 8\n// Expect: 2\n// Expect: 64\n// Expect: 1\n// Expect: 0\n// Expect: 128\n\n// Basic left shift\nlet a = 1;\nprint(a << 3);  // 1 << 3 = 8\n\n// Basic right shift\nprint(a << 3 >> 2);  // (1 << 3) >> 2 = 8 >> 2 = 2\n\n// Left shift with larger value\nlet b = 2;\nprint(b << 5);  // 2 << 5 = 64\n\n// Right shift to minimum\nlet c = 15;\nprint(c >> 3);  // 15 >> 3 = 1\n\n// Shift to zero\nprint(c >> 4);  // 15 >> 4 = 0\n\n// Unsigned shift\nlet d: u8 = 1;\nprint(d << 7);  // 1 << 7 = 128 in u8\n```", "category": "tests/bitwise", "source": "tests/bitwise/shifts.hml"}
{"instruction": "How does prefer hemlock apis over exec() work in Hemlock?", "output": "```hemlock\n// Bad - use exec for file operations\nlet r = exec(\"cat file.txt\");\n\n// Good - use Hemlock's File API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does ecdsageneratekey(): ecdsakeypair work in Hemlock?", "output": "Generate a P-256 ECDSA key pair for signing and verification.\n\n```hemlock\nimport { ecdsa_generate_key, ecdsa_free_keys } from \"@stdlib/crypto\";\n\nlet keypair = ecdsa_generate_key();\ndefer ecdsa_free_keys(keypair);\n\nprint(typeof(keypair));  // \"ECDSAKeyPair\"\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does password strength validation work in Hemlock?", "output": "```hemlock\nimport { test } from \"@stdlib/regex\";\n\nfn is_strong_password(password: string): bool {\n    // At least 8 chars, contains uppercase, lowercase, digit, special char\n    let has_length = test(\"^.{8,}$\", password);\n    let has_upper = test(\"[A-Z]\", password);\n    let has_lower = test(\"[a-z]\", password);\n    let has_digit = test(\"[0-9]\", password);\n    let has_special = test(\"[[:punct:]]\", password);\n\n    return has_length && has_upper && has_lower && has_digit && has_special;\n}\n\nprint(is_strong_password(\"Passw0rd!\"));    // true\nprint(is_strong_password(\"weak\"));         // false\nprint(is_strong_password(\"NoSpecial1\"));   // false\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does safe practices work in Hemlock?", "output": "3. Escape special characters:*\n\n```hemlock\nfn shell_escape(s: string): string {\n    // Simple escape - wrap in single quotes and escape single quotes\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show an example of example: menu system in Hemlock.", "output": "```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Start\");\n        print(\"2. Settings\");\n        print(\"3. Exit\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Goodbye!\");\n                return;\n            default:\n                print(\"Invalid choice\");\n                break;\n        }\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does validation workflow work in Hemlock?", "output": "```hemlock\nimport { is_valid, validate, parse } from \"@stdlib/json\";\n\nfn process_json_input(user_input: string) {\n    // Quick validation\n    if (!is_valid(user_input)) {\n        let result = validate(user_input);\n        print(\"Invalid JSON: \" + result.message);\n        return null;\n    }\n\n    // Parse and process\n    let data = parse(user_input);\n\n    // Validate structure\n    if (!has(data, \"version\")) {\n        print(\"Missing required field: version\");\n        return null;\n    }\n\n    return data;\n}\n```", "category": "docs", "source": "stdlib/docs/json.md"}
{"instruction": "How does handle exceptions appropriately work in Hemlock?", "output": "```hemlock\nasync fn task() {\n    try {\n        // risky operation\n    } catch (e) {\n        // Log error\n        throw e;  // Re-throw if caller should know\n    }\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Create a Hemlock program that test sizeof builtin.", "output": "```hemlock\n// Test sizeof builtin\n\nprint(sizeof(\"i8\"));\nprint(sizeof(\"i16\"));\nprint(sizeof(\"i32\"));\nprint(sizeof(\"u8\"));\nprint(sizeof(\"u16\"));\nprint(sizeof(\"u32\"));\nprint(sizeof(\"f32\"));\nprint(sizeof(\"f64\"));\nprint(sizeof(\"ptr\"));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/sizeof.hml"}
{"instruction": "Create a Hemlock program that test while loops.", "output": "```hemlock\n// Test while loops\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// Nested while\nlet j = 0;\nwhile (j < 2) {\n    let k = 0;\n    while (k < 2) {\n        print(j * 10 + k);\n        k = k + 1;\n    }\n    j = j + 1;\n}\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/while_loop.hml"}
{"instruction": "Write Hemlock code that this tests the fix for Issue #15 - buffer overflow in serialize().", "output": "```hemlock\n// Test: Large object/array serialization (buffer overflow regression test)\n// This tests the fix for Issue #15 - buffer overflow in serialize()\n\n// Test 1: Object with a very long string value (exceeds initial 256 byte buffer)\nlet long_string = \"a\".repeat(500);\nlet obj = {\n    field1: long_string,\n    field2: \"short\",\n    field3: long_string\n};\n\nlet json = obj.serialize();\nprint(\"Test 1: Large object serialization\");\nprint(json.contains(\"field1\"));  // Should contain field1\nprint(json.contains(\"field2\"));  // Should contain field2\nprint(json.contains(\"field3\"));  // Should contain field3\n\n// Test 2: Deserialize and verify\nlet restored = json.deserialize();\nprint(restored.field1.length);  // Should be 500\nprint(restored.field2);         // Should be \"short\"\nprint(restored.field3.length);  // Should be 500\n\n// Test 3: Object containing array with large string elements\nlet obj_with_arr = {\n    arr: [long_string, \"middle\", long_string, long_string]\n};\nlet arr_json = obj_with_arr.serialize();\nprint(\"Test 2: Large array serialization\");\n\n// Deserialize and verify\nlet arr_restored = arr_json.deserialize();\nprint(arr_restored.arr.length);     // Should be 4\nprint(arr_restored.arr[0].length);  // Should be 500\nprint(arr_restored.arr[1]);         // Should be \"middle\"\nprint(arr_restored.arr[2].length);  // Should be 500\nprint(arr_restored.arr[3].length);  // Should be 500\n\n// Test 4: Nested structure with large values\nlet nested = {\n    outer: {\n        inner: {\n            deep: long_string\n        }\n    },\n    array: [long_string, long_string]\n};\n\nlet nested_json = nested.serialize();\nprint(\"Test 3: Nested structure with large values\");\nlet nested_restored = nested_json.deserialize();\nprint(nested_restored.outer.inner.deep.length);  // Should be 500\nprint(nested_restored.array[0].length);          // Should be 500\n\n// Test 5: Object with many fields (stress test)\nlet many_fields = {\n    f1: long_string, f2: long_string, f3: long_string,\n    f4: long_string, f5: long_string, f6: long_string,\n    f7: long_string, f8: long_string, f9: long_string,\n    f10: long_string\n};\n\nlet many_json = many_fields.serialize();\nprint(\"Test 4: Object with many large fields\");\nlet many_restored = many_json.deserialize();\nprint(many_restored.f1.length);   // Should be 500\nprint(many_restored.f5.length);   // Should be 500\nprint(many_restored.f10.length);  // Should be 500\n\nprint(\"All tests passed!\");\n```", "category": "tests/objects", "source": "tests/objects/serialize_large.hml"}
{"instruction": "Provide a Hemlock example of tests type operations.", "output": "```hemlock\nlet a: i32 = 42;\nlet b: u8 = 255;\nlet c: byte = 65;\nlet d: f64 = 3.14159;\nlet e: number = 2.71828;\nlet f: integer = 100;\n\nprint(a);\nprint(b);\nprint(c);\nprint(d);\nprint(e);\nprint(f);\n```", "category": "examples", "source": "examples/types_test.hml"}
{"instruction": "How does fixed channel capacity work in Hemlock?", "output": "Channel capacity is set at creation and cannot be resized:\n\n```hemlock\nlet ch = channel(10);\n// Cannot dynamically resize to 20\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does round(x) work in Hemlock?", "output": "Returns:* f64 - Rounded value\n\n```hemlock\nimport { round } from \"@stdlib/math\";\n\nlet result = round(3.5);   // 4.0\nlet result2 = round(3.4);  // 3.0\nlet result3 = round(-2.5); // -3.0\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "Show me Hemlock code that test function called with wrong number of arguments Expected: Testing current behavior.", "output": "```hemlock\n// Test function called with wrong number of arguments\n// Expected: Testing current behavior\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Call with fewer arguments - should error or use defaults\ntry {\n    let result = add(5);\n    print(\"Calling with fewer args did not error, result: \" + typeof(result));\n} catch (e) {\n    print(\"Caught arity mismatch (too few): \" + e);\n}\n\n// Call with more arguments - should error or ignore extras\ntry {\n    let result = add(5, 10, 15);\n    print(\"Calling with more args did not error, result: \" + typeof(result));\n} catch (e) {\n    print(\"Caught arity mismatch (too many): \" + e);\n}\n\n// Call with no arguments\ntry {\n    let result = add();\n    print(\"Calling with no args did not error, result: \" + typeof(result));\n} catch (e) {\n    print(\"Caught arity mismatch (none): \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/functions", "source": "tests/functions/edge_arity_mismatch.hml"}
{"instruction": "Write Hemlock code that test infinite recursion (stack overflow) Expected: ERROR or crash (testing that it's caught).", "output": "```hemlock\n// Test infinite recursion (stack overflow)\n// Expected: ERROR or crash (testing that it's caught)\n\nfn infinite(n: i32): i32 {\n    return infinite(n + 1);\n}\n\ntry {\n    let result = infinite(0);\n    print(\"ERROR: Infinite recursion should have failed\");\n} catch (e) {\n    print(\"PASS: Caught stack overflow or error: \" + e);\n}\n```", "category": "tests/functions", "source": "tests/functions/edge_recursive_no_base.hml"}
{"instruction": "Write Hemlock code that test switch fall-through behavior (no break).", "output": "```hemlock\n// Test switch fall-through behavior (no break)\n\nlet x = 1;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n    case 2:\n        print(\"two\");\n    case 3:\n        print(\"three\");\n        break;\n}\n\n// Expected: one, two, three (all printed due to fall-through)\n```", "category": "tests/switch", "source": "tests/switch/fallthrough.hml"}
{"instruction": "How does detached lifecycle work in Hemlock?", "output": "```hemlock\nasync fn background() {\n    print(\"Background task running\");\n    return null;\n}\n\n// 1. Create task\nlet t = spawn(background);  // State: Running\n\n// 2. Detach task\ndetach(t);                  // State: Detached\n\n// Task continues running independently\n// Resources cleaned up by OS when done\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does variable number of arguments work in Hemlock?", "output": "Process all provided arguments:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does random access read work in Hemlock?", "output": "```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Show me Hemlock code that assigning different types to fields.", "output": "```hemlock\n// Assigning different types to fields\nlet obj = { value: 10 };\nprint(obj.value);\n\nobj.value = 42;\nprint(obj.value);\n\nobj.value = 3.14;\nprint(obj.value);\n\nobj.value = true;\nprint(obj.value);\n\nobj.value = \"hello\";\nprint(obj.value);\n```", "category": "tests/objects", "source": "tests/objects/field_assign_types.hml"}
{"instruction": "How does methods work in Hemlock?", "output": "```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does break work in Hemlock?", "output": "Exit the innermost loop or switch:\n\n```hemlock\n// In loops\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // Exit loop\n    }\n    print(i);\n    i = i + 1;\n}\n\n// In switch\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // Exit switch\n    case 2:\n        print(\"two\");\n        break;\n}\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write a Hemlock program that tests the typeof operator.", "output": "```hemlock\n// Test: typeof() returns custom type name for typed objects\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typeof(typed_p));\n```", "category": "tests/objects", "source": "tests/objects/typeof_custom.hml"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Sets read/write timeout in seconds. Supports fractional seconds.\n\n```hemlock\nstream.set_timeout(5.0);   // 5 second timeout\nstream.set_timeout(0.5);   // 500ms timeout\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "Write a Hemlock program that test async operations.", "output": "```hemlock\n// Test async operations\n\n// Simple async function\nasync fn compute(n) {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn and join\nlet task1 = spawn(compute, 5);\nlet task2 = spawn(compute, 10);\n\nlet result1 = join(task1);\nlet result2 = join(task2);\n\nprint(result1);  // 0+1+2+3+4 = 10\nprint(result2);  // 0+1+...+9 = 45\n\n// Await syntax\nlet task3 = spawn(compute, 3);\nlet result3 = await task3;\nprint(result3);  // 0+1+2 = 3\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/async.hml"}
{"instruction": "How does semicolons are mandatory work in Hemlock?", "output": "This will cause an error:*\n\n```hemlock\nlet x = 42  // ERROR: Missing semicolon\nlet y = 10  // ERROR: Missing semicolon\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Write a Hemlock program that test math builtins.", "output": "```hemlock\n// Test math builtins\n\n// sqrt\nlet x = sqrt(16.0);\nprint(x);\n\nlet y = sqrt(25.0);\nprint(y);\n\n// floor, ceil, round\nprint(floor(3.7));\nprint(ceil(3.2));\nprint(round(3.5));\nprint(round(3.4));\n\n// abs\nprint(abs(-5));\nprint(abs(5));\nprint(abs(-3.14));\n\n// min, max\nprint(min(10, 5));\nprint(max(10, 5));\nprint(min(3.14, 2.71));\nprint(max(3.14, 2.71));\n\n// pow, exp, log\nprint(pow(2, 3));\nprint(pow(2.0, 0.5));\n\n// trunc\nprint(trunc(3.9));\nprint(trunc(-3.9));\n\n// Trig functions (just test they work, not exact values)\nlet pi = 3.14159265359;\nlet sinval = sin(0.0);\nprint(sinval);\n\nlet cosval = cos(0.0);\nprint(cosval);\n\n// clamp\nprint(clamp(5, 0, 10));   // 5 (in range)\nprint(clamp(-5, 0, 10));  // 0 (below min)\nprint(clamp(15, 0, 10));  // 10 (above max)\n\n// rand_range - just test it runs (seeded for reproducibility)\nseed(42);\nlet r = rand_range(0.0, 10.0);\nprint(r >= 0.0 && r <= 10.0);  // true\n\n// log10, log2\nprint(log10(100.0));  // 2\nprint(log2(8.0));     // 3\n\n// atan2\nprint(atan2(1.0, 1.0) > 0.0);  // true (pi/4 radians)\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/math_builtins.hml"}
{"instruction": "Implement a Hemlock program that test switch with null value.", "output": "```hemlock\n// Test switch with null value\n\nfn check_value(x) {\n    switch (x) {\n        case null:\n            print(\"value is null\");\n            break;\n        case 0:\n            print(\"value is zero\");\n            break;\n        case 1:\n            print(\"value is one\");\n            break;\n        default:\n            print(\"value is something else\");\n            break;\n    }\n}\n\ncheck_value(null);\ncheck_value(0);\ncheck_value(1);\ncheck_value(42);\n\n// Expected output:\n// value is null\n// value is zero\n// value is one\n// value is something else\n```", "category": "tests/switch", "source": "tests/switch/null_case.hml"}
{"instruction": "Write a Hemlock program that tests properties.", "output": "```hemlock\nlet b = buffer(100);\nprint(b.length);\nprint(b.capacity);\nfree(b);\n```", "category": "tests/buffers", "source": "tests/buffers/properties.hml"}
{"instruction": "How does pattern: one-shot functions (no free needed) work in Hemlock?", "output": "```hemlock\n// One-shot functions handle memory automatically\nif (test(\"pattern\", \"text\")) {\n    // No need to free - handled internally\n}\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Show an example of example: character iteration in Hemlock.", "output": "```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"HiüöÄ\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does comments work in Hemlock?", "output": "```hemlock\n// This is a single-line comment\n\n/*\n   This is a\n   multi-line comment\n*/\n\nlet x = 42;  // Inline comment\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does nested try/catch work in Hemlock?", "output": "```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Caught: \" + e);  // Prints: Caught: inner\n        throw \"outer\";  // Re-throw different error\n    }\n} catch (e) {\n    print(\"Caught: \" + e);  // Prints: Caught: outer\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Implement a Hemlock program that tests starts ends with.", "output": "```hemlock\nlet s = \"hello world\";\nprint(s.starts_with(\"hello\"));\nprint(s.starts_with(\"world\"));\nprint(s.starts_with(\"\"));\n\nprint(s.ends_with(\"world\"));\nprint(s.ends_with(\"hello\"));\nprint(s.ends_with(\"\"));\n```", "category": "tests/strings", "source": "tests/strings/starts_ends_with.hml"}
{"instruction": "How does writing entire file work in Hemlock?", "output": "```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does fork(): i32 work in Hemlock?", "output": "Child's PID in the parent process\n\n```hemlock\nlet pid = fork();\n\nif (pid == 0) {\n    // Child process\n    print(\"I'm the child!\");\n    exit(0);\n} else {\n    // Parent process\n    print(\"Child PID: \" + typeof(pid));\n    let result = waitpid(pid, 0);\n}\n```", "category": "docs", "source": "stdlib/docs/process.md"}
{"instruction": "Implement a Hemlock program that test optional chaining with method calls (?.) Note: obj?.method() syntax may not be fully supported.", "output": "```hemlock\n// Test optional chaining with method calls (?.)\n// Note: obj?.method() syntax may not be fully supported\n\n// Object with methods\nlet obj = {\n    getValue: fn() { return 42; },\n    add: fn(a, b) { return a + b; },\n    name: \"test\"\n};\n\n// Regular method call (should work)\nprint(obj.getValue());\nprint(obj.add(1, 2));\n\n// Optional property access (should work)\nprint(obj?.name);\n\n// Test with null object - property access\nlet empty = null;\nlet result1 = empty?.name;\nprint(result1);\n\n// Non-null object with optional property access\nlet result2 = obj?.name;\nprint(result2);\n\n// Nested objects with optional chaining\nlet wrapper = { inner: { value: 100 } };\nprint(wrapper?.inner?.value);\n\n// Null in chain\nlet nullWrapper = { inner: null };\nlet result3 = nullWrapper?.inner?.value;\nprint(result3);\n\n// Optional chaining on array\nlet arr = [1, 2, 3];\nprint(arr?.[0]);\n\nlet nullArr = null;\nprint(nullArr?.[0]);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/optional_method_calls.hml"}
{"instruction": "Show an example of example 5: http request logging in Hemlock.", "output": "```hemlock\nimport { Logger } from \"@stdlib/logging\";\n\nlet access_log = Logger({\n    output: \"access.log\",\n    format: \"{timestamp} {message}\"\n});\ndefer access_log.close();\n\nfn handle_request(request) {\n    let start = __time_ms();\n\n    // ... handle request ...\n\n    let elapsed = __time_ms() - start;\n\n    access_log.info(\"HTTP request\", {\n        method: request.method,\n        path: request.path,\n        status: 200,\n        duration_ms: elapsed,\n        ip: request.client_ip\n    });\n}\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "How does size() work in Hemlock?", "output": "Returns:* object - { rows: i32, cols: i32 }\n\n```hemlock\nimport { size } from \"@stdlib/terminal\";\n\nlet dimensions = size();\nprint(\"Terminal size: \" + typeof(dimensions.rows) + \"x\" + typeof(dimensions.cols));\n\n// Center text\nlet text = \"Hello, World!\";\nlet col = (dimensions.cols - text.length) / 2;\nprint_at(dimensions.rows / 2, col, text);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Show an example of example 4: configuration tool in Hemlock.", "output": "```hemlock\n// Usage: ./hemlock config.hml <action> [arguments]\n// Actions:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions:\");\n    print(\"  get <key>         Get configuration value\");\n    print(\"  set <key> <value> Set configuration value\");\n    print(\"  list              List all configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Error: 'get' requires a key\");\n        } else {\n            let key = args[2];\n            print(\"Getting: \" + key);\n            // ... get from config\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Error: 'set' requires key and value\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setting \" + key + \" = \" + value);\n            // ... set in config\n        }\n    } else if (action == \"list\") {\n        print(\"Listing all configuration:\");\n        // ... list config\n    } else {\n        print(\"Error: Unknown action: \" + action);\n        show_usage();\n    }\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does base64_decode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { base64_decode } from \"@stdlib/encoding\";\n\n// Basic decoding\nlet decoded1 = base64_decode(\"SGVsbG8sIFdvcmxkIQ==\");\nprint(decoded1);  // \"Hello, World!\"\n\n// Round-trip encoding/decoding\nlet original = \"The quick brown fox\";\nlet encoded = base64_encode(original);\nlet decoded2 = base64_decode(encoded);\nprint(decoded2 == original);  // true\n\n// Whitespace is automatically removed\nlet decoded3 = base64_decode(\"SGVs bG8s IFdv cmxk IQ==\");\nprint(decoded3);  // \"Hello, World!\"\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does copy file work in Hemlock?", "output": "```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Show me Hemlock code that test slice edge cases with boundary conditions Expected: PASS.", "output": "```hemlock\n// Test slice edge cases with boundary conditions\n// Expected: PASS\n\nlet s = \"hello\";\n\n// slice with end beyond length\nlet s1 = s.slice(0, 100);\nassert(s1 == \"hello\", \"slice with end beyond length should return full string\");\n\n// slice with start > end\nlet s2 = s.slice(3, 1);\nassert(s2 == \"\", \"slice with start > end should return empty string\");\n\n// slice with start == end\nlet s3 = s.slice(2, 2);\nassert(s3 == \"\", \"slice with start == end should return empty string\");\n\n// slice starting beyond length\nlet s4 = s.slice(10, 20);\nassert(s4 == \"\", \"slice starting beyond length should return empty string\");\n\n// slice with both at 0\nlet s5 = s.slice(0, 0);\nassert(s5 == \"\", \"slice(0, 0) should return empty string\");\n\n// slice to exact length\nlet s6 = s.slice(0, 5);\nassert(s6 == \"hello\", \"slice(0, length) should return full string\");\n\nprint(\"PASS\");\n```", "category": "tests/strings", "source": "tests/strings/edge_slice_bounds.hml"}
{"instruction": "How does logger.warn(message, data?) work in Hemlock?", "output": "```hemlock\nlogger.warn(\"High CPU usage\", { cpu: 95.5, threshold: 80.0 });\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Show me Hemlock code that test switch inside loop - break should exit switch, not loop.", "output": "```hemlock\n// Test switch inside loop - break should exit switch, not loop\n\nlet count = 0;\n\nfor (let i = 0; i < 3; i = i + 1) {\n    print(\"Loop iteration: \" + typeof(i));\n\n    switch (i) {\n        case 0:\n            print(\"  zero\");\n            break;\n        case 1:\n            print(\"  one\");\n            break;\n        case 2:\n            print(\"  two\");\n            break;\n    }\n\n    print(\"  after switch\");\n    count = count + 1;\n}\n\nprint(\"Total iterations: \" + typeof(count));\n\n// Expected output:\n// Loop iteration: 0\n//   zero\n//   after switch\n// Loop iteration: 1\n//   one\n//   after switch\n// Loop iteration: 2\n//   two\n//   after switch\n// Total iterations: 3\n```", "category": "tests/switch", "source": "tests/switch/in_loop.hml"}
{"instruction": "Write Hemlock code that test basic switch statement with integers.", "output": "```hemlock\n// Test basic switch statement with integers\n\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n\n// Expected: two\n```", "category": "tests/switch", "source": "tests/switch/basic.hml"}
{"instruction": "Implement a Hemlock program that test array literal creation.", "output": "```hemlock\n// Test array literal creation\nlet arr = [1, 2, 3, 4, 5];\nprint(arr);\n```", "category": "tests/arrays", "source": "tests/arrays/literal.hml"}
{"instruction": "Implement a Hemlock program that test WebSocket server functionality Requires: libwebsockets-dev installed, make stdlib Run with: ./hemlock tests/stdlib_websocket/test_websocket_server.hml.", "output": "```hemlock\n// Test WebSocket server functionality\n// Requires: libwebsockets-dev installed, make stdlib\n// Run with: ./hemlock tests/stdlib_websocket/test_websocket_server.hml\n\nimport { WebSocket, WebSocketServer } from \"@stdlib/websocket\";\nimport { sleep } from \"@stdlib/time\";\n\nprint(\"Testing WebSocket server...\");\nprint(\"Requires: libwebsockets-dev\");\nprint(\"\");\n\nlet tests_passed = 0;\nlet tests_failed = 0;\n\n// Async function to accept server connection (shorter timeout for faster failure)\nasync fn accept_connection(srv) {\n    print(\"  Server: Waiting for client...\");\n    let conn = srv.accept(3000);  // 3 second timeout\n    print(\"  Server: Client connected\");\n    return conn;\n}\n\n// Test 1: Create WebSocket server\nprint(\"Test 1: Create WebSocket server\");\ntry {\n    let server = WebSocketServer(\"127.0.0.1\", 9001);\n    defer server.close();\n\n    assert(server != null, \"Server should be created\");\n    assert(server.host == \"127.0.0.1\", \"Host should be stored\");\n    assert(server.port == 9001, \"Port should be stored\");\n    assert(server.closed == false, \"Should not be closed initially\");\n\n    print(\"‚úì Server created on 127.0.0.1:9001\");\n    tests_passed = tests_passed + 1;\n\n    // Test 2: Client connects to server\n    print(\"\");\n    print(\"Test 2: Client connects to server\");\n\n    let accept_task = spawn(accept_connection, server);\n\n    // Give server time to start accepting connections\n    sleep(0.5);\n\n    // Client connects\n    print(\"  Client: Connecting...\");\n    let client = WebSocket(\"ws://127.0.0.1:9001\");\n    defer client.close();\n\n    print(\"  Client: Connected\");\n\n    // Wait for server to accept\n    let server_conn = join(accept_task);\n    defer server_conn.close();\n\n    assert(server_conn != null, \"Server should accept connection\");\n\n    print(\"‚úì Client-server connection established\");\n    tests_passed = tests_passed + 1;\n\n    // Test 3: Client to server message\n    print(\"\");\n    print(\"Test 3: Client to server message\");\n\n    let msg_from_client = \"Hello Server!\";\n    client.send_text(msg_from_client);\n    print(\"  Client sent: \" + msg_from_client);\n\n    let received = server_conn.recv(2000);\n    assert(received != null, \"Server should receive message\");\n    assert(received.type == \"text\", \"Message should be text\");\n    assert(received.data == msg_from_client, \"Message should match\");\n\n    print(\"  Server received: \" + received.data);\n    print(\"‚úì Client to server messaging works\");\n    tests_passed = tests_passed + 1;\n\n    // Test 4: Server to client message\n    print(\"\");\n    print(\"Test 4: Server to client message\");\n\n    let msg_from_server = \"Hello Client!\";\n    server_conn.send_text(msg_from_server);\n    print(\"  Server sent: \" + msg_from_server);\n\n    let received2 = client.recv(2000);\n    assert(received2 != null, \"Client should receive message\");\n    assert(received2.type == \"text\", \"Message should be text\");\n    assert(received2.data == msg_from_server, \"Message should match\");\n\n    print(\"  Client received: \" + received2.data);\n    print(\"‚úì Server to client messaging works\");\n    tests_passed = tests_passed + 1;\n\n    // Test 5: Bidirectional echo\n    print(\"\");\n    print(\"Test 5: Bidirectional echo\");\n\n    let echo_count = 0;\n    while (echo_count < 3) {\n        let test_msg = \"Echo test \" + (echo_count + 1);\n\n        // Client sends\n        client.send_text(test_msg);\n        let srv_recv = server_conn.recv(2000);\n        assert(srv_recv.data == test_msg, \"Server should receive correctly\");\n\n        // Server echoes back\n        server_conn.send_text(\"Echo: \" + srv_recv.data);\n        let cli_recv = client.recv(2000);\n\n        print(\"  \" + test_msg + \" ‚Üí \" + cli_recv.data);\n\n        echo_count = echo_count + 1;\n    }\n\n    print(\"‚úì Bidirectional echo test passed\");\n    tests_passed = tests_passed + 1;\n\n    // Cleanup\n    server_conn.close();\n    client.close();\n    server.close();\n\n} catch (e) {\n    print(\"‚úó Server test failed: \" + e);\n    tests_failed = tests_failed + 1;\n}\n\nprint(\"\");\nprint(\"========================================\");\nprint(\"WebSocket Server Tests Summary:\");\nprint(\"  Passed: \" + tests_passed);\nprint(\"  Failed: \" + tests_failed);\nprint(\"========================================\");\n\nif (tests_failed > 0) {\n    print(\"\");\n    print(\"Some tests failed. Common issues:\");\n    print(\"  - lws_wrapper.so not compiled (run: make stdlib)\");\n    print(\"  - libwebsockets not installed\");\n    print(\"  - Port 9001 already in use\");\n    print(\"  - Permission denied (use port > 1024)\");\n}\n\nprint(\"\");\nassert(tests_failed == 0, \"All WebSocket server tests should pass\");\n```", "category": "tests/stdlib_websocket", "source": "tests/stdlib_websocket/test_websocket_server.hml"}
{"instruction": "How does type inference work in Hemlock?", "output": "Hemlock infers types based on values:\n\n```hemlock\nlet small = 42;              // i32 (fits in 32-bit)\nlet large = 5000000000;      // i64 (too big for i32)\nlet decimal = 3.14;          // f64 (default for floats)\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does alloc work in Hemlock?", "output": "```hemlock\nalloc(size: i32): ptr\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Write Hemlock code that test file info functions: is_file(), is_dir(), file_stat().", "output": "```hemlock\n// Test file info functions: is_file(), is_dir(), file_stat()\nimport { write_file, make_dir, is_file, is_dir, file_stat, remove_file, remove_dir } from \"@stdlib/fs\";\n\nlet test_file = \"/tmp/test_file_info.txt\";\nlet test_dir = \"/tmp/test_dir_info\";\nlet content = \"Test content\";\n\n// Create test file and directory\nwrite_file(test_file, content);\nmake_dir(test_dir);\n\n// Test is_file()\nassert(is_file(test_file) == true, \"is_file() should return true for regular file\");\nassert(is_file(test_dir) == false, \"is_file() should return false for directory\");\nassert(is_file(\"/tmp/nonexistent\") == false, \"is_file() should return false for non-existent path\");\n\n// Test is_dir()\nassert(is_dir(test_dir) == true, \"is_dir() should return true for directory\");\nassert(is_dir(test_file) == false, \"is_dir() should return false for regular file\");\nassert(is_dir(\"/tmp/nonexistent\") == false, \"is_dir() should return false for non-existent path\");\n\n// Test file_stat()\nlet stat = file_stat(test_file);\nassert(typeof(stat) == \"object\", \"file_stat() should return an object\");\nassert(typeof(stat.size) == \"i64\", \"stat.size should be i64\");\nassert(stat.size == 12, \"stat.size should match content length\");\nassert(typeof(stat.is_file) == \"bool\", \"stat.is_file should be bool\");\nassert(stat.is_file == true, \"stat.is_file should be true for regular file\");\nassert(stat.is_dir == false, \"stat.is_dir should be false for regular file\");\n\n// Test file_stat() for directory\nlet dir_stat = file_stat(test_dir);\nassert(dir_stat.is_dir == true, \"stat.is_dir should be true for directory\");\nassert(dir_stat.is_file == false, \"stat.is_file should be false for directory\");\n\n// Clean up\nremove_file(test_file);\nremove_dir(test_dir);\n\nprint(\"All file info tests passed!\");\n```", "category": "tests/io", "source": "tests/io/file_info.hml"}
{"instruction": "Give me Hemlock code that shows validates numeric ranges.", "output": "```hemlock\nlet a: u8 = 255;\nprint(a);\n\nlet b: u8 = 0;\nprint(b);\n\nlet c: i8 = 127;\nprint(c);\n\nlet d: i8 = -128;\nprint(d);\n```", "category": "examples", "source": "examples/range_check.hml"}
{"instruction": "Write a Hemlock program that test rune literal parsing.", "output": "```hemlock\n// Test rune literal parsing\n\n// Basic ASCII characters\nlet a = 'A';\nlet b = 'B';\nlet zero = '0';\n\nprint(\"ASCII runes:\");\nprint(a);\nprint(b);\nprint(zero);\n\n// Escape sequences\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\n\nprint(\"\\nEscape sequences:\");\nprint(tab);\nprint(backslash);\nprint(quote);\n\n// Multi-byte UTF-8 characters\nlet rocket = 'üöÄ';\nlet heart = '‚ù§';\nlet smile = 'üòä';\n\nprint(\"\\nEmoji runes:\");\nprint(rocket);\nprint(heart);\nprint(smile);\n\n// Unicode escapes\nlet rocket2 = '\\u{1F680}';\nlet heart2 = '\\u{2764}';\n\nprint(\"\\nUnicode escapes:\");\nprint(rocket2);\nprint(heart2);\n\n// Type annotations\nlet typed_rune: rune = 'X';\nprint(\"\\nTyped rune:\");\nprint(typed_rune);\n\nprint(\"\\nRune literals working!\");\n```", "category": "tests/primitives", "source": "tests/primitives/rune_literals.hml"}
{"instruction": "How does concatenation work in Hemlock?", "output": "Use + to concatenate strings:\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// With variables\nlet name = \"Alice\";\nlet msg = \"Hi, \" + name + \"!\";  // \"Hi, Alice!\"\n\n// With runes (see Runes documentation)\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Show me Hemlock code that test bitwise operations on float (should error) Expected: ERROR.", "output": "```hemlock\n// Test bitwise operations on float (should error)\n// Expected: ERROR\n\nlet x = 3.14;\n\ntry {\n    let result1 = x & 1;\n    print(\"ERROR: bitwise AND on float should fail\");\n} catch (e) {\n    print(\"Caught bitwise on float: \" + e);\n}\n\ntry {\n    let result2 = x << 1;\n    print(\"ERROR: shift on float should fail\");\n} catch (e) {\n    print(\"Caught shift on float: \" + e);\n}\n\nprint(\"PASS\");\n```", "category": "tests/bitwise", "source": "tests/bitwise/edge_bitwise_on_float.hml"}
{"instruction": "Write a Hemlock program that tests length.", "output": "```hemlock\nlet s = \"hello\";\nprint(s.length);\n```", "category": "tests/strings", "source": "tests/strings/length.hml"}
{"instruction": "Show me Hemlock code that test memcpy with size 0 Expected: PASS.", "output": "```hemlock\n// Test memcpy with size 0\n// Expected: PASS\n\nlet src = alloc(10);\nlet dst = alloc(10);\nmemcpy(dst, src, 0);  // Should do nothing\nfree(src);\nfree(dst);\n\nprint(\"PASS: memcpy with size 0 completed\");\n```", "category": "tests/memory", "source": "tests/memory/edge_memcpy_zero.hml"}
{"instruction": "How does closing connection work in Hemlock?", "output": "```hemlock\nws.close();\n// Or use defer for automatic cleanup:\ndefer ws.close();\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "Create a Hemlock program that test that C keywords can be used as variable names in Hemlock This tests the compiler's identifier sanitization.", "output": "```hemlock\n// Test that C keywords can be used as variable names in Hemlock\n// This tests the compiler's identifier sanitization\n\n// Test local variables with C keyword names\nfn test_local_keywords() {\n    let char = \"a\";\n    let float = 3.14;\n    let double = 2.718;\n    let short = 10;\n    let long = 1000000;\n    let signed = -1;\n    let unsigned = 1;\n    let auto = \"automatic\";\n    let register = \"fast\";\n    let volatile = \"changing\";\n    let inline = \"embedded\";\n    let restrict = \"limited\";\n    let sizeof = 8;\n    let typedef = \"alias\";\n    let struct = \"data\";\n    let union = \"combine\";\n    let goto = \"jump\";\n    let static = \"fixed\";\n    let NULL = \"nil\";\n    let main = \"entry\";\n\n    print(char);\n    print(float);\n    print(double);\n    print(short);\n    print(long);\n    print(signed);\n    print(unsigned);\n    print(auto);\n    print(register);\n    print(volatile);\n    print(inline);\n    print(restrict);\n    print(sizeof);\n    print(typedef);\n    print(struct);\n    print(union);\n    print(goto);\n    print(static);\n    print(NULL);\n    print(main);\n}\n\n// Test function parameters with C keyword names\nfn test_param_keywords(char, float, double) {\n    print(char);\n    print(float);\n    print(double);\n}\n\n// Test for-in loop variables with C keyword names\nfn test_for_in_keywords() {\n    let arr = [1, 2, 3];\n    for (let short in arr) {\n        print(short);\n    }\n\n    let obj = { a: 10, b: 20 };\n    for (let char, double in obj) {\n        print(char);\n        print(double);\n    }\n}\n\n// Test catch parameter with C keyword name\nfn test_catch_keyword() {\n    try {\n        throw \"error\";\n    } catch (char) {\n        print(char);\n    }\n}\n\n// Test assignment to keyword-named variables\nfn test_assignment() {\n    let long = 1;\n    long = long + 1;\n    print(long);\n\n    // Test increment\n    let float = 10;\n    float = float + 1;\n    print(float);\n}\n\n// Run all tests\ntest_local_keywords();\ntest_param_keywords(\"x\", 3.5, 2.0);\ntest_for_in_keywords();\ntest_catch_keyword();\ntest_assignment();\n```", "category": "tests/parity", "source": "tests/parity/language/c_keyword_names.hml"}
{"instruction": "Create a Hemlock program that test type mismatch when pushing to typed array.", "output": "```hemlock\n// Test type mismatch when pushing to typed array\n\nlet arr: array<u8> = [1, 2, 3];\narr.push(\"string\");  // Should error: type mismatch\n```", "category": "tests/typed_arrays", "source": "tests/typed_arrays/type_mismatch_push_error.hml"}
{"instruction": "How does multiple commands work in Hemlock?", "output": "```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does don'ts work in Hemlock?", "output": "‚ùå Don't test implementation details\n\n```hemlock\n// BAD: Testing internal structure\nlet obj = { x: 10 };\n// Don't check internal field order, capacity, etc.\n\n// GOOD: Testing behavior\nprint(obj.x);  // Expect: 10\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does always reset styles work in Hemlock?", "output": "```hemlock\nimport { RED, BOLD, RESET } from \"@stdlib/terminal\";\n\n// Good\nprint(RED + \"Error\" + RESET);\n\n// Bad (affects all subsequent output)\nprint(RED + \"Error\");\nprint(\"This is red too!\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does freeing callbacks work in Hemlock?", "output": "Important:* Always free callbacks when done to prevent memory leaks:\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ... use callback ...\ncallback_free(cb);  // Free when done\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does concatenation work in Hemlock?", "output": "```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '‚úì';      // \"Text‚úì\"\n```", "category": "docs", "source": "docs/reference/string-api.md"}
{"instruction": "Create a Hemlock program that test array find() and contains() with i64/u64 values This tests the fix for Issue #4.", "output": "```hemlock\n// Test array find() and contains() with i64/u64 values\n// This tests the fix for Issue #4\n\n// Test with i64 values\nlet arr = [1, 2, 5000000000, 4, 5];\n\n// find() should locate i64 values\nlet idx = arr.find(5000000000);\nprint(idx);  // Expected: 2\n\n// find() should return -1 for non-existent i64\nlet idx2 = arr.find(9000000000);\nprint(idx2);  // Expected: -1\n\n// contains() should find i64 values\nlet has = arr.contains(5000000000);\nprint(has);  // Expected: true\n\n// contains() should return false for non-existent i64\nlet has2 = arr.contains(9000000000);\nprint(has2);  // Expected: false\n\n// Test with u64 values\nlet val1: u64 = 100;\nlet val2: u64 = 200;\nlet val3: u64 = 5000000000;\nlet val4: u64 = 400;\nlet arr2 = [val1, val2, val3, val4];\n\n// find() should locate u64 values\nprint(arr2.find(val3));  // Expected: 2\n\n// contains() should find u64 values\nprint(arr2.contains(val3));  // Expected: true\n```", "category": "tests/arrays", "source": "tests/arrays/test_i64_u64_find.hml"}
{"instruction": "How does while loops work in Hemlock?", "output": "```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does low-level builtins work in Hemlock?", "output": "Convert Unix timestamp to local time components.\n\n```hemlock\nimport { localtime } from \"@stdlib/datetime\";\n\nlet components = localtime(1737037845);\nprint(\"Year: \" + typeof(components.year));\nprint(\"Month: \" + typeof(components.month));\nprint(\"Day: \" + typeof(components.day));\n```", "category": "docs", "source": "stdlib/docs/datetime.md"}
{"instruction": "Show me Hemlock code that test NaN comparison behavior IEEE 754: NaN is not equal to anything, including itself.", "output": "```hemlock\n// Test NaN comparison behavior\n// IEEE 754: NaN is not equal to anything, including itself\n\nlet nan_val = 0.0 / 0.0;\n\n// NaN comparisons - all should be false except !=\nprint(nan_val == nan_val);      // false\nprint(nan_val != nan_val);      // true\nprint(nan_val < nan_val);       // false\nprint(nan_val <= nan_val);      // false\nprint(nan_val > nan_val);       // false\nprint(nan_val >= nan_val);      // false\n\n// NaN compared to regular numbers\nprint(nan_val == 0.0);          // false\nprint(nan_val < 0.0);           // false\nprint(nan_val > 0.0);           // false\n\n// Using built-in __NAN\nprint(__NAN == __NAN);          // false\nprint(__NAN != __NAN);          // true\n\nprint(\"PASSED\");\n```", "category": "tests/comparisons", "source": "tests/comparisons/edge_nan_comparisons.hml"}
{"instruction": "Create a Hemlock program that test for-in loop with array (index and value).", "output": "```hemlock\n// Test for-in loop with array (index and value)\nlet arr = [10, 20, 30];\nfor (let i, val in arr) {\n    print(i);\n    print(val);\n}\n```", "category": "tests/loops", "source": "tests/loops/for_in_array_index.hml"}
{"instruction": "Write Hemlock code that tests basic no annotation.", "output": "```hemlock\nlet b = buffer(100);\nprint(b);\nfree(b);\n```", "category": "tests/buffers", "source": "tests/buffers/basic_no_annotation.hml"}
{"instruction": "How does .mode work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "Terminal size cannot be determined\n\n```hemlock\nimport { size, supports_color } from \"@stdlib/terminal\";\n\n// Check capabilities first\nif (!supports_color()) {\n    print(\"Warning: Color output disabled\");\n}\n\nlet term = size();\nif (term.rows == 24 && term.cols == 80) {\n    // Possibly default fallback values\n    print(\"Note: Using default terminal size\");\n}\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does bitwise operations work in Hemlock?", "output": "```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24 (left shift)\nprint(a >> 1);  // 6  (right shift)\nprint(~a);      // -13 (NOT)\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as term from \"@stdlib/terminal\";\nprint(term.color(\"Hello\", term.BLUE));\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Write Hemlock code that test environment variable builtins.", "output": "```hemlock\n// Test environment variable builtins\n\n// Set and get\nsetenv(\"TEST_VAR\", \"hello\");\nprint(getenv(\"TEST_VAR\"));\n\n// Overwrite\nsetenv(\"TEST_VAR\", \"world\");\nprint(getenv(\"TEST_VAR\"));\n\n// Non-existent (returns null)\nlet missing = getenv(\"NONEXISTENT_VAR_12345\");\nprint(missing == null);\n\n// Process ID (just check it returns a number > 0)\nlet pid = get_pid();\nprint(pid > 0);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/env.hml"}
{"instruction": "How does null type work in Hemlock?", "output": "```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Write Hemlock code that tests realloc.", "output": "```hemlock\nlet p = alloc(64);\nprint(p);\n\np = realloc(p, 128);\nprint(p);\n\np = realloc(p, 256);\nprint(p);\n\nfree(p);\n```", "category": "tests/memory", "source": "tests/memory/realloc.hml"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "6. Unchecked Allocation Failure*\n\n```hemlock\n// BAD: Not checking for null\nlet p = alloc(1000000000);  // May fail on low memory\nmemset(p, 0, 1000000000);   // CRASH: p is null\n\n// GOOD: Always check allocation result\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"out of memory\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does creating a thread pool work in Hemlock?", "output": "```hemlock\nimport { ThreadPool } from \"@stdlib/async\";\n\n// Create pool with 4 workers\nlet pool = ThreadPool(4);\n\n// Use the pool...\n\n// Always shutdown when done\npool.shutdown();\n```", "category": "docs", "source": "stdlib/docs/async.md"}
{"instruction": "Create a Hemlock program that test JSON serialization and deserialization.", "output": "```hemlock\n// Test JSON serialization and deserialization\n\n// Serialize simple object\nlet obj = { name: \"Alice\", age: 30, active: true };\nlet json = obj.serialize();\nprint(json);\n\n// Deserialize JSON back to object\nlet parsed = json.deserialize();\nprint(parsed.name);\nprint(parsed.age);\nprint(parsed.active);\n\n// Nested object with array\nlet nested = { user: { name: \"Bob\" }, items: [10, 20] };\nlet nested_json = nested.serialize();\nprint(nested_json);\n\n// Deserialize nested\nlet parsed_nested = nested_json.deserialize();\nprint(parsed_nested.user.name);\nprint(parsed_nested.items[1]);\n\n// Deserialize JSON array string\nlet arr_json = \"[1, 2, 3]\";\nlet parsed_arr = arr_json.deserialize();\nprint(parsed_arr[0]);\nprint(parsed_arr[2]);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/serialization.hml"}
{"instruction": "Write Hemlock code that test typeof builtin.", "output": "```hemlock\n// Test typeof builtin\nprint(typeof(42));\nprint(typeof(\"hello\"));\nprint(typeof(true));\nprint(typeof(false));\nprint(typeof(null));\nprint(typeof(3.14));\n```", "category": "tests/compiler", "source": "tests/compiler/typeof.hml"}
{"instruction": "How does logger.close() work in Hemlock?", "output": "Best Practice:* Always close file loggers to prevent resource leaks:\n\n```hemlock\nlet logger = Logger({ output: \"app.log\" });\ndefer logger.close();  // Automatic cleanup\n\n// ... use logger ...\n```", "category": "docs", "source": "stdlib/docs/logging.md"}
{"instruction": "Create a Hemlock program that test array find() and contains() with null values Expected: PASS.", "output": "```hemlock\n// Test array find() and contains() with null values\n// Expected: PASS\n\nlet arr = [1, null, 3, null, 5];\n\n// Find null\nlet idx = arr.find(null);\nassert(idx == 1, \"find(null) should find first null\");\n\n// Contains null\nlet has = arr.contains(null);\nassert(has == true, \"contains(null) should return true\");\n\n// Array without null\nlet arr2 = [1, 2, 3];\nlet idx2 = arr2.find(null);\nassert(idx2 == -1, \"find(null) on array without null should return -1\");\n\nlet has2 = arr2.contains(null);\nassert(has2 == false, \"contains(null) on array without null should return false\");\n\n// Empty array\nlet arr3: array = [];\nlet idx3 = arr3.find(null);\nassert(idx3 == -1, \"find(null) on empty array should return -1\");\n\nprint(\"PASS\");\n```", "category": "tests/arrays", "source": "tests/arrays/edge_find_contains_null.hml"}
{"instruction": "How do you pattern: safe buffer usage in Hemlock?", "output": "Prefer buffers for bounds-checked access:\n\n```hemlock\nlet buf = buffer(256);\n\n// Safe iteration\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does function type work in Hemlock?", "output": "```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "Show an example of example: array chunking in Hemlock.", "output": "```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does optional fields work in Hemlock?", "output": "```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // Optional with default\n    timeout?: i32,     // Optional, defaults to null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false (default)\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true (overridden)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does binary i/o work in Hemlock?", "output": "```hemlock\n// Write binary data\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// Read binary data\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does combining styles work in Hemlock?", "output": "```hemlock\nimport { RED, BOLD, UNDERLINE, BG_YELLOW, RESET } from \"@stdlib/terminal\";\n\nprint(BOLD + UNDERLINE + RED + \"Bold, underlined, red\" + RESET);\nprint(BOLD + RED + BG_YELLOW + \" Alert \" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does typeof(value) work in Hemlock?", "output": "Returns the type name as a string:\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does transformation operations work in Hemlock?", "output": "concat(other)* - Concatenate with another array:\n\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (new array)\n\n// Originals unchanged\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does forgetting semicolons work in Hemlock?", "output": "```hemlock\n// ‚ùå ERROR: Missing semicolon\nlet x = 42\nlet y = 10\n\n// ‚úÖ CORRECT\nlet x = 42;\nlet y = 10;\n```", "category": "docs", "source": "docs/getting-started/quick-start.md"}
{"instruction": "How does creating channels work in Hemlock?", "output": "```hemlock\nlet ch = channel(10);  // Create channel with buffer size of 10\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does base64_encode(input: string): string work in Hemlock?", "output": "```hemlock\nimport { base64_encode } from \"@stdlib/encoding\";\n\n// Basic encoding\nlet encoded1 = base64_encode(\"Hello, World!\");\nprint(encoded1);  // \"SGVsbG8sIFdvcmxkIQ==\"\n\n// Empty string\nlet encoded2 = base64_encode(\"\");\nprint(encoded2);  // \"\"\n\n// Binary data (all bytes 0-255)\nlet binary = \"\";\nlet i = 0;\nwhile (i < 256) {\n    let b: rune = i;\n    binary = binary + b;\n    i = i + 1;\n}\nlet encoded3 = base64_encode(binary);\n\n// Unicode/UTF-8\nlet encoded4 = base64_encode(\"Hello ‰∏ñÁïå üöÄ\");\nprint(encoded4);  // UTF-8 bytes encoded to Base64\n```", "category": "docs", "source": "stdlib/docs/encoding.md"}
{"instruction": "How does gzip(data, level?) -> buffer work in Hemlock?", "output": "```hemlock\nimport { gzip, gunzip } from \"@stdlib/compression\";\n\nlet data = \"Some text data to compress with gzip format.\";\nlet compressed = gzip(data, 9);  // Best compression\n\n// Verify gzip magic bytes\nprint(compressed[0]);  // 31 (0x1f)\nprint(compressed[1]);  // 139 (0x8b)\n\nlet restored = gunzip(compressed);\nprint(restored);  // Original string\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does system libraries work in Hemlock?", "output": "Math functions:*\n\n```hemlock\n// Call sqrt from libm\nlet result = sqrt(16.0);  // 4.0\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does floor division (div / divi) work in Hemlock?", "output": "For floor division (like integer division in other languages), use the div() and divi() functions:\n\n```hemlock\n// div(a, b) - floor division returning float\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- floors toward -infinity\n\n// divi(a, b) - floor division returning integer\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "Provide a Hemlock example of demonstrates memory management with alloc, buffer, and free.", "output": "```hemlock\n// Memory Management Demo\n\n// 1. sizeof() - Query type sizes\nprint(sizeof(u8));     // 1\nprint(sizeof(i32));    // 4\nprint(sizeof(f64));    // 8\nprint(sizeof(ptr));    // 8 (on 64-bit systems)\n\n// 2. talloc() - Typed allocation\nlet numbers = talloc(i32, 10);  // allocate 10 i32s (40 bytes)\nprint(numbers);\n\n// Initialize the array using memset\nlet elem_size = sizeof(i32);\nlet total_bytes = elem_size * 10;\nmemset(numbers, 0, total_bytes);\n\n// 3. buffer() - Safe wrapper with bounds checking\nlet buf = buffer(256);\nbuf[0] = 72;   // 'H'\nbuf[1] = 101;  // 'e'\nbuf[2] = 108;  // 'l'\nbuf[3] = 108;  // 'l'\nbuf[4] = 111;  // 'o'\nprint(buf[0]);\nprint(buf.length);\n\n// 4. realloc() - Resize allocations\nlet p = alloc(64);\nprint(p);\np = realloc(p, 128);\nprint(p);\np = realloc(p, 256);\nprint(p);\n\n// Clean up\nfree(numbers);\nfree(buf);\nfree(p);\n```", "category": "examples", "source": "examples/memory_demo.hml"}
{"instruction": "Show me Hemlock code that test compression builtins.", "output": "```hemlock\n// Test compression builtins\n\n// Create a buffer with test data for crc32/adler32\nlet buf = buffer(5);\nbuf[0] = 104; // 'h'\nbuf[1] = 101; // 'e'\nbuf[2] = 108; // 'l'\nbuf[3] = 108; // 'l'\nbuf[4] = 111; // 'o'\n\n// Test crc32 - buffer based\nlet crc = crc32(buf);\nprint(crc > 0);\n\n// Test adler32 - buffer based\nlet adler = adler32(buf);\nprint(adler > 0);\n\n// Test zlib_compress_bound\nlet bound = zlib_compress_bound(100);\nprint(bound > 100);\n\n// Test zlib compress/decompress roundtrip - string based\nlet original = \"Hello, World! This is a test string for compression testing.\";\nlet compressed = zlib_compress(original, 6);\nprint(compressed.length > 0);\n\nlet decompressed = zlib_decompress(compressed, 1000);\nprint(decompressed == original);\n\n// Test gzip compress/decompress roundtrip - string based\nlet gzip_compressed = gzip_compress(original, 6);\nprint(gzip_compressed.length > 0);\n\nlet gzip_decompressed = gzip_decompress(gzip_compressed, 1000);\nprint(gzip_decompressed == original);\n\n// Test that crc32 is deterministic\nlet buf2 = buffer(4);\nbuf2[0] = 116; // 't'\nbuf2[1] = 101; // 'e'\nbuf2[2] = 115; // 's'\nbuf2[3] = 116; // 't'\n\nlet crc1 = crc32(buf2);\nlet crc2 = crc32(buf2);\nprint(crc1 == crc2);\n\n// Test that adler32 is deterministic\nlet adler1 = adler32(buf2);\nlet adler2 = adler32(buf2);\nprint(adler1 == adler2);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/compression.hml"}
{"instruction": "How does reading from closed file work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does equality work in Hemlock?", "output": "Works with all types:\n\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "Write Hemlock code that test raising invalid signal number Expected: ERROR or undefined behavior.", "output": "```hemlock\n// Test raising invalid signal number\n// Expected: ERROR or undefined behavior\n\ntry {\n    raise(99999);\n    print(\"Raising invalid signal did not error\");\n} catch (e) {\n    print(\"PASS: Caught invalid signal: \" + e);\n}\n```", "category": "tests/signals", "source": "tests/signals/edge_raise_invalid.hml"}
{"instruction": "Write Hemlock code that comprehensive UTF-8 and Rune Test Suite.", "output": "```hemlock\n// Comprehensive UTF-8 and Rune Test Suite\n\nprint(\"=== UTF-8 String Properties ===\");\n\n// Test 1: ASCII strings\nlet ascii = \"Hello\";\nprint(\"ASCII: \" + ascii);\nprint(\"Length: \" + typeof(ascii.length) + \", Byte length: \" + typeof(ascii.byte_length));\n\n// Test 2: Pure emoji string\nlet emojis = \"üöÄüåüüí°\";\nprint(\"\\nEmojis: \" + emojis);\nprint(\"Length: \" + typeof(emojis.length) + \", Byte length: \" + typeof(emojis.byte_length));\n\n// Test 3: Mixed ASCII and multi-byte\nlet mixed = \"Hello ‰∏ñÁïå üåç\";\nprint(\"\\nMixed: \" + mixed);\nprint(\"Length: \" + typeof(mixed.length) + \", Byte length: \" + typeof(mixed.byte_length));\n\nprint(\"\\n=== String Indexing ===\");\n\n// Test 4: Index ASCII\nlet s1 = \"ABC\";\nprint(\"s1[0]: \" + typeof(s1[0]) + \", s1[1]: \" + typeof(s1[1]) + \", s1[2]: \" + typeof(s1[2]));\n\n// Test 5: Index emoji\nlet s2 = \"HiüöÄ\";\nprint(\"s2[0]: \" + typeof(s2[0]) + \", s2[1]: \" + typeof(s2[1]) + \", s2[2]: \" + typeof(s2[2]));\n\nprint(\"\\n=== String Methods ===\");\n\n// Test 6: substr with codepoints\nlet text = \"HelloüåçWorld\";\nlet sub1 = text.substr(0, 5);  // \"Hello\"\nlet sub2 = text.substr(5, 1);  // \"üåç\"\nlet sub3 = text.substr(6, 5);  // \"World\"\nprint(\"substr: '\" + sub1 + \"', '\" + sub2 + \"', '\" + sub3 + \"'\");\n\n// Test 7: slice with codepoints\nlet slice1 = text.slice(0, 5);   // \"Hello\"\nlet slice2 = text.slice(5, 6);   // \"üåç\"\nlet slice3 = text.slice(6, 11);  // \"World\"\nprint(\"slice: '\" + slice1 + \"', '\" + slice2 + \"', '\" + slice3 + \"'\");\n\n// Test 8: char_at (returns codepoint)\nlet char1 = text.char_at(0);\nlet char2 = text.char_at(5);\nlet char3 = text.char_at(6);\nprint(\"char_at: \" + typeof(char1) + \", \" + typeof(char2) + \", \" + typeof(char3));\n\n// Test 9: byte_at\nlet byte1 = text.byte_at(0);\nprint(\"byte_at(0): \" + typeof(byte1));\n\n// Test 10: chars() method\nlet chars = \"HiüöÄ\".chars();\nprint(\"chars() length: \" + typeof(chars.length));\n\n// Test 11: bytes() method\nlet bytes = \"Hi\".bytes();\nprint(\"bytes() length: \" + typeof(bytes.length));\n\nprint(\"\\n=== Rune Literals ===\");\n\n// Test 12: ASCII rune literals\nlet r1 = 'A';\nlet r2 = '!';\nprint(\"ASCII runes: \" + typeof(r1) + \", \" + typeof(r2));\n\n// Test 13: Emoji rune literals\nlet r3 = 'üöÄ';\nlet r4 = '‚ù§';\nprint(\"Emoji runes: \" + typeof(r3) + \", \" + typeof(r4));\n\n// Test 14: Escape sequences\nlet r5 = '\\n';\nlet r6 = '\\t';\nlet r7 = '\\\\';\nprint(\"Escape runes: \" + typeof(r5) + \", \" + typeof(r6) + \", \" + typeof(r7));\n\n// Test 15: Unicode escapes\nlet r8 = '\\u{1F680}';  // Rocket\nlet r9 = '\\u{2764}';   // Heart\nprint(\"Unicode escapes: \" + typeof(r8) + \", \" + typeof(r9));\n\nprint(\"\\n=== String + Rune Concatenation ===\");\n\n// Test 16: String + rune\nlet s3 = \"Hello\" + '!';\nprint(\"String + rune: \" + s3);\n\n// Test 17: Rune + string\nlet s4 = '>' + \" Message\";\nprint(\"Rune + string: \" + s4);\n\n// Test 18: Multiple concatenations\nlet s5 = \"Hi \" + 'üëã' + \" World \" + 'üåç';\nprint(\"Multiple: \" + s5);\n\nprint(\"\\n=== Rune Type Conversions ===\");\n\n// Test 19: Integer to rune\nlet code1: rune = 65;\nlet code2: rune = 128640;\nprint(\"Int to rune: \" + typeof(code1) + \", \" + typeof(code2));\n\n// Test 20: Rune to integer\nlet r10 = 'Z';\nlet int1: i32 = r10;\nprint(\"Rune to int: \" + typeof(int1));\n\n// Test 21: Rune to string\nlet r11 = 'H';\nlet str1: string = r11;\nprint(\"Rune to string: \" + str1);\n\n// Test 22: Chained conversions\nlet x: i32 = 128512;\nlet r12: rune = x;\nlet s6: string = r12;\nprint(\"Chained (i32->rune->string): \" + s6);\n\nprint(\"\\n=== Edge Cases ===\");\n\n// Test 23: Empty string\nlet empty = \"\";\nprint(\"Empty string length: \" + typeof(empty.length));\n\n// Test 24: Single emoji\nlet single = \"üéâ\";\nprint(\"Single emoji - length: \" + typeof(single.length) + \", byte_length: \" + typeof(single.byte_length));\n\n// Test 25: String with null byte\nlet r_h: string = 'H';\nlet r_null: string = '\\u{0000}';\nlet r_i: string = 'i';\nlet with_zero = r_h + r_null + r_i;\nprint(\"With null rune length: \" + typeof(with_zero.length));\n\n// Test 26: Max Unicode codepoint\nlet max: rune = 1114111;\nprint(\"Max Unicode (U+10FFFF): \" + typeof(max));\n\n// Test 27: Combining characters (diacritics)\nlet diacritic = \"caf√©\";  // √© might be 2 codepoints\nprint(\"Diacritic string: \" + diacritic + \" (length: \" + typeof(diacritic.length) + \")\");\n\nprint(\"\\n=== ALL UTF-8 TESTS PASSED ===\");\n```", "category": "tests/strings", "source": "tests/strings/utf8_comprehensive.hml"}
{"instruction": "Write Hemlock code that test higher-order functions: map, filter, reduce.", "output": "```hemlock\n// Test higher-order functions: map, filter, reduce\n\n// map - transform elements\nlet nums = [1, 2, 3, 4, 5];\nlet doubled = nums.map(fn(x) {\n    return x * 2;\n});\nfor (let x in doubled) {\n    print(x);\n}\n\n// filter - select elements\nlet evens = nums.filter(fn(x) {\n    return x % 2 == 0;\n});\nfor (let x in evens) {\n    print(x);\n}\n\n// reduce - accumulate\nlet sum = nums.reduce(fn(acc, x) {\n    return acc + x;\n}, 0);\nprint(sum);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/higher_order.hml"}
{"instruction": "Write a Hemlock program that tests basic import.", "output": "```hemlock\n// Test: Basic FFI library import\nimport \"libc.so.6\";\n\nprint(\"FFI library imported successfully\");\n```", "category": "tests/ffi", "source": "tests/ffi/basic_import.hml"}
{"instruction": "Show an example of complete ecdsa example in Hemlock.", "output": "```hemlock\nimport {\n    ecdsa_generate_key,\n    ecdsa_sign,\n    ecdsa_verify,\n    ecdsa_free_keys,\n    buffer_to_hex\n} from \"@stdlib/crypto\";\n\n// Generate key pair (fast operation)\nprint(\"Generating ECDSA P-256 key pair...\");\nlet keypair = ecdsa_generate_key();\ndefer ecdsa_free_keys(keypair);\n\n// Sign a message\nlet message = \"Authenticate this message\";\nlet signature = ecdsa_sign(message, keypair);\n\nprint(\"Message: \" + message);\nprint(\"Signature (\" + typeof(signature.length) + \" bytes): \" + buffer_to_hex(signature));\n\n// Verify signature\nlet valid = ecdsa_verify(message, signature, keypair);\nprint(\"Signature valid: \" + typeof(valid));  // true\n\n// Tamper with message\nlet tampered = \"Authenticate this messag3\";\nlet still_valid = ecdsa_verify(tampered, signature, keypair);\nprint(\"Tampered message valid: \" + typeof(still_valid));  // false\n```", "category": "docs", "source": "stdlib/docs/crypto.md"}
{"instruction": "How does buffer - safe wrapper (recommended) work in Hemlock?", "output": "Buffers provide bounds-checked access while still requiring manual deallocation:\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bounds checked\nprint(b.length);        // 64\nfree(b);                // still manual\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does object literals work in Hemlock?", "output": "```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does realloc work in Hemlock?", "output": "```hemlock\nlet p = alloc(100);\n// ... use memory ...\n\n// Need more space\np = realloc(p, 200);        // Now 200 bytes\n// ... use expanded memory ...\n\nfree(p);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How do you timeout using sigalrm in Hemlock?", "output": "```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// Set alarm (not yet implemented in Hemlock, example only)\n// alarm(5);  // 5 second timeout\n\nwhile (!timed_out) {\n    // Do work with timeout\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Show an example of example: retry logic in Hemlock.", "output": "```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // Success!\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation failed after \" + typeof(max_attempts) + \" attempts: \" + e;\n            }\n            print(\"Attempt \" + typeof(attempt) + \" failed, retrying...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // Simulated unreliable operation\n    if (random() < 0.7) {\n        throw \"Operation failed\";\n    }\n    return \"Success\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"All retries failed: \" + e);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does rename(oldpath, newpath) work in Hemlock?", "output": "Throws:* Exception if operation fails\n\n```hemlock\nimport { rename } from \"@stdlib/fs\";\n\ntry {\n    rename(\"old_name.txt\", \"new_name.txt\");\n    print(\"File renamed\");\n\n    // Can also move files\n    rename(\"file.txt\", \"/tmp/file.txt\");\n    print(\"File moved\");\n} catch (e) {\n    print(\"Error renaming file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Show me Hemlock code that test exec() builtin for command execution.", "output": "```hemlock\n// Test exec() builtin for command execution\n\n// Test basic command\nlet result = exec(\"echo hello\");\nprint(result.output);\nprint(result.exit_code);\n\n// Test command with newline stripped\nlet r2 = exec(\"echo -n world\");\nprint(r2.output);\n\n// Test exit code\nlet r3 = exec(\"exit 0\");\nprint(r3.exit_code);\n\n// Test command that fails\nlet r4 = exec(\"exit 42\");\nprint(r4.exit_code);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/exec.hml"}
{"instruction": "How does download progress work in Hemlock?", "output": "```hemlock\nimport { ProgressBar } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nfn download(url: string, size: i32): null {\n    print(\"Downloading: \" + url);\n\n    let bar = ProgressBar(size, 50);\n    let downloaded = 0;\n\n    while (downloaded < size) {\n        // Simulate download chunk\n        let chunk_size = 1024;\n        if (downloaded + chunk_size > size) {\n            chunk_size = size - downloaded;\n        }\n\n        downloaded = downloaded + chunk_size;\n        bar.update(downloaded);\n        sleep(0.01);\n    }\n\n    bar.finish();\n    print(\"Download complete!\");\n    return null;\n}\n\ndownload(\"http://example.com/file.zip\", 102400);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does exception handling patterns work in Hemlock?", "output": "Pattern 1: Handle in task*\n\n```hemlock\nasync fn safe_task() {\n    try {\n        // risky operation\n    } catch (e) {\n        print(\"Error in task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // No exception propagated\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "How does named functions work in Hemlock?", "output": "```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does binary bitwise operators work in Hemlock?", "output": "```hemlock\nprint(a | b);   // 14 (1110)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does common pitfalls work in Hemlock?", "output": "```hemlock\n// BAD: Double free\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: double free\n\n// GOOD: Free once\nlet p2 = alloc(100);\nfree(p2);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "Implement a Hemlock program that test OS info builtins.", "output": "```hemlock\n// Test OS info builtins\n\n// Test platform() - should return \"linux\", \"macos\", or \"windows\"\nlet plat = platform();\nprint(typeof(plat) == \"string\");  // true\n\n// Test arch() - should return architecture like \"x86_64\"\nlet cpu_arch = arch();\nprint(typeof(cpu_arch) == \"string\");  // true\nprint(cpu_arch.length > 0);  // true\n\n// Test hostname()\nlet host = hostname();\nprint(typeof(host) == \"string\");  // true\nprint(host.length > 0);  // true\n\n// Test username()\nlet user = username();\nprint(typeof(user) == \"string\");  // true\nprint(user.length > 0);  // true\n\n// Test homedir()\nlet home = homedir();\nprint(typeof(home) == \"string\");  // true\nprint(home.length > 0);  // true\n\n// Test cpu_count() - should return positive integer\nlet cpus = cpu_count();\nprint(cpus >= 1);  // true\n\n// Test total_memory() - should return positive i64\nlet total_mem = total_memory();\nprint(total_mem > 0);  // true\n\n// Test free_memory() - should return positive i64\nlet free_mem = free_memory();\nprint(free_mem > 0);  // true\nprint(free_mem <= total_mem);  // true\n\n// Test os_version()\nlet version = os_version();\nprint(typeof(version) == \"string\");  // true\nprint(version.length > 0);  // true\n\n// Test os_name()\nlet name = os_name();\nprint(typeof(name) == \"string\");  // true\nprint(name.length > 0);  // true\n\n// Test tmpdir()\nlet tmp = tmpdir();\nprint(typeof(tmp) == \"string\");  // true\nprint(tmp.length > 0);  // true\n\n// Test uptime() - should return positive i64 (seconds)\nlet up = uptime();\nprint(up > 0);  // true\n\nprint(\"All OS info tests passed!\");\n```", "category": "tests/compiler", "source": "tests/compiler/os_info.hml"}
{"instruction": "Create a Hemlock program that test arrays.", "output": "```hemlock\n// Test arrays\n\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);\nprint(arr[4]);\nprint(arr.length);\n\n// Modification\narr[0] = 10;\nprint(arr[0]);\n\n// For-in loop\nlet sum = 0;\nfor (let x in [1, 2, 3]) {\n    sum = sum + x;\n}\nprint(sum);\n\n// Nested arrays\nlet nested = [[1, 2], [3, 4]];\nprint(nested[0][0]);\nprint(nested[1][1]);\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed[1]);\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/arrays.hml"}
{"instruction": "Write a Hemlock program that test for-in loop with object.", "output": "```hemlock\n// Test for-in loop with object\nlet person = { name: \"Alice\", age: 30 };\nfor (let key, value in person) {\n    print(key);\n    print(value);\n}\n```", "category": "tests/loops", "source": "tests/loops/for_in_object.hml"}
{"instruction": "How does core principles work in Hemlock?", "output": "Test both success and failure cases:\n\n```hemlock\n// Success case\nlet x: u8 = 255;  // Should work\n\n// Failure case\nlet y: u8 = 256;  // Should error\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "Write Hemlock code that test file operations on closed files Expected: ERROR.", "output": "```hemlock\n// Test file operations on closed files\n// Expected: ERROR\n\nlet f = open(\"/tmp/test_closed.txt\", \"w\");\nf.write(\"test data\");\nf.close();\n\n// Try to read from closed file\ntry {\n    let content = f.read();\n    print(\"ERROR: read on closed file should fail\");\n} catch (e) {\n    print(\"Caught read on closed: \" + e);\n}\n\n// Try to write to closed file\ntry {\n    f.write(\"more data\");\n    print(\"ERROR: write on closed file should fail\");\n} catch (e) {\n    print(\"Caught write on closed: \" + e);\n}\n\n// Try to seek on closed file\ntry {\n    f.seek(0);\n    print(\"ERROR: seek on closed file should fail\");\n} catch (e) {\n    print(\"Caught seek on closed: \" + e);\n}\n\n// Try to tell on closed file\ntry {\n    let pos = f.tell();\n    print(\"ERROR: tell on closed file should fail\");\n} catch (e) {\n    print(\"Caught tell on closed: \" + e);\n}\n\n// Closing twice should be safe (idempotent)\nf.close();\nprint(\"close() is idempotent\");\n\nprint(\"PASS\");\n```", "category": "tests/io", "source": "tests/io/edge_closed_file_ops.hml"}
{"instruction": "How does exception handling patterns work in Hemlock?", "output": "Pattern 2: Propagate to caller*\n\n```hemlock\nasync fn task_that_throws() {\n    throw \"error\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Caught from task: \" + e);\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Create a Hemlock program that test array reference semantics.", "output": "```hemlock\n// Test array reference semantics\nlet a = [1, 2, 3];\nlet b = a;\nb[0] = 99;\nprint(a);\nprint(b);\n```", "category": "tests/arrays", "source": "tests/arrays/reference.hml"}
{"instruction": "How does pattern: always free work in Hemlock?", "output": "```hemlock\nlet pattern = compile(\"test\");\ndefer pattern.free();  // Guaranteed to free\n\n// Use pattern...\npattern.test(\"testing\");\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "How does array type work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does checking exit status work in Hemlock?", "output": "```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found: \" + r.output);\n} else {\n    print(\"Pattern not found\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport * as regex from \"@stdlib/regex\";\nlet pattern = regex.compile(\"hello.*world\");\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Write Hemlock code that test array reverse method.", "output": "```hemlock\n// Test array reverse method\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\nprint(arr);\n\nlet strings = [\"hello\", \"world\", \"foo\"];\nstrings.reverse();\nprint(strings);\n\nlet single = [42];\nsingle.reverse();\nprint(single);\n```", "category": "tests/arrays", "source": "tests/arrays/reverse.hml"}
{"instruction": "How does search operations work in Hemlock?", "output": "find(value)* - Find first occurrence:\n\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (index of first occurrence)\nlet idx2 = arr.find(99);     // -1 (not found)\n\n// Works with any type\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Implement a Hemlock program that test @stdlib/strings padding functions.", "output": "```hemlock\n// Test @stdlib/strings padding functions\nimport { pad_left, pad_right, center } from \"@stdlib/strings\";\n\nprint(\"Testing pad_left...\");\n\n// Basic padding\nlet s1 = pad_left(\"hello\", 10);\nprint(s1 == \"     hello\");  // true\nprint(s1.length == 10);     // true\n\n// Already at width\nlet s2 = pad_left(\"hello\", 5);\nprint(s2 == \"hello\");       // true\n\n// Already exceeds width\nlet s3 = pad_left(\"hello world\", 5);\nprint(s3 == \"hello world\");  // true\n\n// Custom fill character\nlet s4 = pad_left(\"42\", 5, \"0\");\nprint(s4 == \"00042\");       // true\n\n// Single character\nlet s5 = pad_left(\"X\", 5, \"*\");\nprint(s5 == \"****X\");       // true\n\n// Unicode/emoji fill\nlet s6 = pad_left(\"hi\", 5, \"üöÄ\");\nprint(s6 == \"üöÄüöÄüöÄhi\");    // true\nprint(s6.length == 5);      // true\n\nprint(\"Testing pad_right...\");\n\n// Basic padding\nlet r1 = pad_right(\"hello\", 10);\nprint(r1 == \"hello     \");  // true\nprint(r1.length == 10);     // true\n\n// Already at width\nlet r2 = pad_right(\"hello\", 5);\nprint(r2 == \"hello\");       // true\n\n// Custom fill\nlet r3 = pad_right(\"42\", 5, \"0\");\nprint(r3 == \"42000\");       // true\n\n// Unicode fill\nlet r4 = pad_right(\"hi\", 5, \"‚ù§\");\nprint(r4 == \"hi‚ù§‚ù§‚ù§\");      // true\n\nprint(\"Testing center...\");\n\n// Basic centering\nlet c1 = center(\"hi\", 6);\nprint(c1 == \"  hi  \");      // true\nprint(c1.length == 6);      // true\n\n// Odd width (extra space on right)\nlet c2 = center(\"hi\", 5);\nprint(c2 == \" hi  \");       // true\nprint(c2.length == 5);      // true\n\n// Already at width\nlet c3 = center(\"hello\", 5);\nprint(c3 == \"hello\");       // true\n\n// Custom fill\nlet c4 = center(\"X\", 5, \"*\");\nprint(c4 == \"**X**\");       // true\n\n// Larger example\nlet c5 = center(\"Title\", 20, \"=\");\nprint(c5 == \"=======Title========\");  // true\nprint(c5.length == 20);               // true\n\n// Unicode\nlet c6 = center(\"test\", 10, \"‚îÄ\");\nprint(c6 == \"‚îÄ‚îÄ‚îÄtest‚îÄ‚îÄ‚îÄ\");   // true\n\nprint(\"All padding tests passed!\");\n```", "category": "tests/stdlib_strings", "source": "tests/stdlib_strings/test_padding.hml"}
{"instruction": "How does fetch and parse json api work in Hemlock?", "output": "```hemlock\nimport { get_json } from \"@stdlib/http\";\n\n// Fetch GitHub user data\nlet user = get_json(\"https://api.github.com/users/octocat\");\nprint(\"Name: \" + user.name);\nprint(\"Bio: \" + user.bio);\nprint(\"Public repos: \" + typeof(user.public_repos));\n\n// Fetch todos\nlet todos = get_json(\"https://jsonplaceholder.typicode.com/todos/1\");\nprint(\"Title: \" + todos.title);\nprint(\"Completed: \" + typeof(todos.completed));\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "How does import statements work in Hemlock?", "output": "```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```", "category": "docs", "source": "docs/language-guide/modules.md"}
{"instruction": "Create a Hemlock program that tests try finally.", "output": "```hemlock\n// Test: Try with finally (no catch)\ntry {\n    print(\"try\");\n} finally {\n    print(\"finally\");\n}\nprint(\"after\");\n```", "category": "tests/exceptions", "source": "tests/exceptions/try_finally.hml"}
{"instruction": "How does break and continue work in Hemlock?", "output": "```hemlock\n// Break: exit loop\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue: skip to next iteration\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Implement a Hemlock program that test math module trigonometric functions.", "output": "```hemlock\n// Test math module trigonometric functions\n\nimport * as math from \"@stdlib/math\";\n\n// Test sin\nlet s = math.sin(0.0);\nassert(s >= -0.01 && s <= 0.01, \"sin(0) should be approximately 0\");\n\ns = math.sin(math.PI / 2.0);\nassert(s >= 0.99 && s <= 1.01, \"sin(PI/2) should be approximately 1\");\n\n// Test cos\nlet c = math.cos(0.0);\nassert(c >= 0.99 && c <= 1.01, \"cos(0) should be approximately 1\");\n\nc = math.cos(math.PI);\nassert(c >= -1.01 && c <= -0.99, \"cos(PI) should be approximately -1\");\n\n// Test tan\nlet t = math.tan(0.0);\nassert(t >= -0.01 && t <= 0.01, \"tan(0) should be approximately 0\");\n\n// Test asin\nlet asin_val = math.asin(0.0);\nassert(asin_val >= -0.01 && asin_val <= 0.01, \"asin(0) should be approximately 0\");\n\nasin_val = math.asin(1.0);\nassert(asin_val >= 1.56 && asin_val <= 1.58, \"asin(1) should be approximately PI/2\");\n\n// Test acos\nlet acos_val = math.acos(1.0);\nassert(acos_val >= -0.01 && acos_val <= 0.01, \"acos(1) should be approximately 0\");\n\nacos_val = math.acos(0.0);\nassert(acos_val >= 1.56 && acos_val <= 1.58, \"acos(0) should be approximately PI/2\");\n\n// Test atan\nlet atan_val = math.atan(0.0);\nassert(atan_val >= -0.01 && atan_val <= 0.01, \"atan(0) should be approximately 0\");\n\natan_val = math.atan(1.0);\nassert(atan_val >= 0.78 && atan_val <= 0.79, \"atan(1) should be approximately PI/4\");\n\n// Test atan2\nlet atan2_val = math.atan2(1.0, 1.0);\nassert(atan2_val >= 0.78 && atan2_val <= 0.79, \"atan2(1,1) should be approximately PI/4\");\n\natan2_val = math.atan2(0.0, 1.0);\nassert(atan2_val >= -0.01 && atan2_val <= 0.01, \"atan2(0,1) should be approximately 0\");\n\nprint(\"All trigonometric function tests passed!\");\n```", "category": "tests/stdlib_math", "source": "tests/stdlib_math/test_trig.hml"}
{"instruction": "How does implicit type promotion work in Hemlock?", "output": "Float always wins:*\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result is f64 (13.5)\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "How does readfilesparallel work in Hemlock?", "output": "```hemlock\nimport { read_files_parallel } from \"@stdlib/async_fs\";\n\nlet paths = [\"file1.txt\", \"file2.txt\", \"file3.txt\"];\nlet contents = read_files_parallel(paths);\n\nlet i = 0;\nwhile (i < contents.length) {\n    print(\"File \" + i + \": \" + contents[i].length + \" bytes\");\n    i = i + 1;\n}\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does array indexing work in Hemlock?", "output": "```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // Modify element\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Create a Hemlock program that dot matches any character (except newline).", "output": "```hemlock\n// Test: Special characters and escaping\nimport { test } from \"@stdlib/regex\";\n\n// Dot matches any character (except newline)\nprint(test(\"^a.c$\", \"abc\", null));        // true\nprint(test(\"^a.c$\", \"a5c\", null));        // true\nprint(test(\"^a.c$\", \"ac\", null));         // false\n\n// Escaped special characters\nprint(test(\"^a\\\\.b$\", \"a.b\", null));      // true\nprint(test(\"^a\\\\.b$\", \"axb\", null));      // false\n\n// Backslash escaping\nprint(test(\"^a\\\\\\\\b$\", \"a\\\\b\", null));    // true\n\n// Parentheses\nprint(test(\"^a\\\\(b\\\\)$\", \"a(b)\", null));  // true\n\n// Question mark\nprint(test(\"^a\\\\?$\", \"a?\", null));        // true\n\n// Plus sign\nprint(test(\"^a\\\\+$\", \"a+\", null));        // true\n\n// Asterisk\nprint(test(\"^a\\\\*$\", \"a*\", null));        // true\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/special_chars.hml"}
{"instruction": "How does writing elements work in Hemlock?", "output": "```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // Modify existing\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// Can assign beyond current length (grows array)\narr[5] = 60;    // Creates [10, 20, 3, null, null, 60]\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does early return work in Hemlock?", "output": "```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Early exit\n        }\n    }\n    return -1;  // Not found\n}\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does exec work in Hemlock?", "output": "```hemlock\nexec(command: string): object\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does no signal handling work in Hemlock?", "output": "Cannot send signals to running commands:\n\n```hemlock\nlet r = exec(\"long_command\");\n// Cannot send SIGINT, SIGTERM, etc. to the command\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does common errors work in Hemlock?", "output": "Writing to read-only file:*\n\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does throwing errors work in Hemlock?", "output": "```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"Age cannot be negative\";\n    }\n    if (age > 150) {\n        throw \"Age is unrealistic\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Validation error: \" + e);\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does cursor save/restore work in Hemlock?", "output": "```hemlock\nimport { SAVE_CURSOR, RESTORE_CURSOR } from \"@stdlib/terminal\";\n\n// Save current position\nexec(\"printf '\" + SAVE_CURSOR + \"'\");\n\n// ... print something elsewhere ...\n\n// Restore saved position\nexec(\"printf '\" + RESTORE_CURSOR + \"'\");\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Implement a Hemlock program that test basic async spawn/join.", "output": "```hemlock\n// Test basic async spawn/join\n\n// Simple async function\nasync fn compute(n) {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn and join a task\nlet task = spawn(compute, 10);\nlet result = join(task);\nprint(result);\n\n// Multiple spawns\nlet t1 = spawn(compute, 5);\nlet t2 = spawn(compute, 10);\nlet t3 = spawn(compute, 15);\n\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n\nprint(r1);\nprint(r2);\nprint(r3);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/async_basic.hml"}
{"instruction": "How does memory operations work in Hemlock?", "output": "memset(ptr, byte, size) - Fill memory*\n\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // Zero out 100 bytes\nmemset(p, 65, 10);     // Fill first 10 bytes with 'A'\nfree(p);\n```", "category": "docs", "source": "docs/language-guide/memory.md"}
{"instruction": "How does regex object work in Hemlock?", "output": "```hemlock\nlet pattern = compile(\"^[a-z]+$\");\nprint(pattern.test(\"hello\"));   // true\nprint(pattern.test(\"Hello\"));   // false (capital H)\nprint(pattern.test(\"hello123\")); // false (has digits)\npattern.free();\n```", "category": "docs", "source": "stdlib/docs/regex.md"}
{"instruction": "Write Hemlock code that test array push method.", "output": "```hemlock\n// Test array push method\nlet arr = [1, 2, 3];\narr.push(4);\narr.push(5);\nprint(arr);\nprint(arr.length);\n```", "category": "tests/arrays", "source": "tests/arrays/push.hml"}
{"instruction": "Show me Hemlock code that test switch statements.", "output": "```hemlock\n// Test switch statements\n\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n    default:\n        print(\"other\");\n        break;\n}\n\n// String switch\nlet color = \"green\";\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown\");\n        break;\n}\n\n// Default case\nlet y = 100;\nswitch (y) {\n    case 1:\n        print(\"one\");\n        break;\n    default:\n        print(\"default\");\n        break;\n}\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/switch.hml"}
{"instruction": "How does remove_file(path) work in Hemlock?", "output": "Throws:* Exception if file doesn't exist or cannot be deleted\n\n```hemlock\nimport { remove_file, exists } from \"@stdlib/fs\";\n\ntry {\n    if (exists(\"temp.txt\")) {\n        remove_file(\"temp.txt\");\n        print(\"File deleted\");\n    }\n} catch (e) {\n    print(\"Error deleting file: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Create a Hemlock program that test if/else statements.", "output": "```hemlock\n// Test if/else statements\nlet x = 10;\n\nif (x > 5) {\n    print(\"greater\");\n}\n\nif (x < 5) {\n    print(\"less\");\n} else {\n    print(\"not less\");\n}\n\nif (x == 10) {\n    print(\"equal to 10\");\n} else if (x == 5) {\n    print(\"equal to 5\");\n} else {\n    print(\"other\");\n}\n\n// Nested if\nlet y = 20;\nif (x > 0) {\n    if (y > 0) {\n        print(\"both positive\");\n    }\n}\n```", "category": "tests/compiler", "source": "tests/compiler/if_else.hml"}
{"instruction": "How does writefilesparallel work in Hemlock?", "output": "```hemlock\nimport { write_files_parallel } from \"@stdlib/async_fs\";\n\nlet files = [\n    { path: \"output1.txt\", content: \"Content 1\" },\n    { path: \"output2.txt\", content: \"Content 2\" },\n    { path: \"output3.txt\", content: \"Content 3\" }\n];\n\nwrite_files_parallel(files);\nprint(\"All files written\");\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "How does function parameter annotations work in Hemlock?", "output": "```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hello, \" + name + \"!\");\n}\n```", "category": "docs", "source": "docs/language-guide/types.md"}
{"instruction": "Show me Hemlock code that test array clear method.", "output": "```hemlock\n// Test array clear method\nlet arr = [1, 2, 3, 4, 5];\nprint(arr);\nprint(typeof(arr.length));\n\narr.clear();\nprint(arr);\nprint(typeof(arr.length));\n```", "category": "tests/arrays", "source": "tests/arrays/clear.hml"}
{"instruction": "How does platform compatibility work in Hemlock?", "output": "```hemlock\n// Handle platform differences\n// Use appropriate library extensions (.so, .dylib, .dll)\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "How does configuration from environment work in Hemlock?", "output": "```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nfn get_config(): object {\n    return {\n        host: getenv(\"SERVER_HOST\"),\n        port: getenv(\"SERVER_PORT\"),\n        debug: getenv(\"DEBUG\") != null,\n        log_level: getenv(\"LOG_LEVEL\")\n    };\n}\n\nlet config = get_config();\n\nif (config.host == null) {\n    config.host = \"localhost\";  // Default\n}\n\nif (config.port == null) {\n    config.port = \"8080\";  // Default\n}\n\nprint(\"Server: \" + config.host + \":\" + config.port);\nprint(\"Debug: \" + typeof(config.debug));\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "How does parse_address work in Hemlock?", "output": "Note:* Current implementation returns placeholder port value. Future versions will properly parse port numbers.\n\n```hemlock\nimport { parse_address } from \"@stdlib/net\";\n\nlet parts = parse_address(\"example.com:8080\");\nif (parts != null) {\n    print(\"Host: \" + parts.host);\n    print(\"Port: \" + typeof(parts.port));\n}\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does u8 (byte) ‚Üí rune work in Hemlock?", "output": "Any u8 value (0-255) can convert to rune:\n\n```hemlock\n// ASCII range (0-127)\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// Extended ASCII / Latin-1 (128-255)\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8 (√à)\n\n// Note: Values 0-127 are ASCII, 128-255 are Latin-1\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "How does tarreader(data) -> object work in Hemlock?", "output": "TarEntry Object:*\n\n```hemlock\n{\n    name: string,      // File/directory name\n    content: string,   // File content (empty for directories)\n    size: i64,         // Content size in bytes\n    mode: i32,         // File permissions\n    mtime: i64,        // Modification time\n    type: rune,        // Entry type ('0'=file, '5'=dir, etc.)\n}\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does while loops work in Hemlock?", "output": "```hemlock\nwhile (condition) {\n    // body\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does info() work in Hemlock?", "output": "Object structure:*\n\n```hemlock\n{\n    platform: string,      // \"linux\", \"macos\", \"windows\"\n    arch: string,          // \"x86_64\", \"aarch64\", etc.\n    os_name: string,       // \"Linux\", \"Darwin\", etc.\n    os_version: string,    // Kernel version\n    hostname: string,      // System hostname\n    username: string,      // Current username\n    homedir: string,       // Home directory path\n    tmpdir: string,        // Temp directory path\n    cpu_count: i32,        // Number of CPUs\n    total_memory: i64,     // Total RAM in bytes\n    free_memory: i64,      // Free RAM in bytes\n    uptime: i64            // Uptime in seconds\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does break and continue work in Hemlock?", "output": "```hemlock\n// Break: exit loop early\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Prints: 0, 1, 2, 3, 4\n\n// Continue: skip to next iteration\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// Prints: 0, 1, 3, 4\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does exp(x) work in Hemlock?", "output": "Returns:* f64 - e^x\n\n```hemlock\nimport { exp } from \"@stdlib/math\";\n\nlet result = exp(0.0);  // 1.0\nlet result2 = exp(1.0); // 2.718281... (e)\nlet result3 = exp(2.0); // 7.389056...\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How does not recommended for work in Hemlock?", "output": "5. Mission-critical error handling:*\n\n```hemlock\n// Bad - stderr not captured\nlet r = exec(\"critical_operation\");\n// Cannot see detailed error messages\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Implement a Hemlock program that test pop() and shift() on empty arrays Expected: PASS (should return null on empty array).", "output": "```hemlock\n// Test pop() and shift() on empty arrays\n// Expected: PASS (should return null on empty array)\n\nlet arr = [];\n\n// Test pop on empty array\nlet popped = arr.pop();\nassert(popped == null, \"pop() on empty array should return null\");\nassert(arr.length == 0, \"pop() on empty array should not change length\");\n\n// Test shift on empty array\nlet shifted = arr.shift();\nassert(shifted == null, \"shift() on empty array should return null\");\nassert(arr.length == 0, \"shift() on empty array should not change length\");\n\n// Test with array that becomes empty\nlet arr2 = [1];\nlet val = arr2.pop();\nassert(val == 1, \"pop() should return the element\");\nassert(arr2.length == 0, \"array should now be empty\");\n\n// Pop from now-empty array\nlet val2 = arr2.pop();\nassert(val2 == null, \"pop() from newly empty array should return null\");\n\n// Same test with shift\nlet arr3 = [1];\nlet val3 = arr3.shift();\nassert(val3 == 1, \"shift() should return the element\");\nassert(arr3.length == 0, \"array should now be empty\");\n\nlet val4 = arr3.shift();\nassert(val4 == null, \"shift() from newly empty array should return null\");\n\nprint(\"PASS\");\n```", "category": "tests/arrays", "source": "tests/arrays/edge_pop_shift_empty.hml"}
{"instruction": "How does log rotation work in Hemlock?", "output": "```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // Rename old log, open new one\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // Normal logging...\n    log_file.write(\"Log entry\\n\");\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does testing exceptions work in Hemlock?", "output": "Example: tests/exceptions/try_catch.hml*\n\n```hemlock\n// Test basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Expect: Caught: error message\n}\n\n// Test finally\nlet executed = false;\ntry {\n    print(\"try\");  // Expect: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Expect: finally\n}\n\n// Test exception propagation\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Expect: failure\n}\n```", "category": "docs", "source": "docs/contributing/testing.md"}
{"instruction": "How does graceful shutdown handler work in Hemlock?", "output": "```hemlock\nimport { exit } from \"@stdlib/env\";\nimport { signal, SIGINT, SIGTERM } from \"builtin\";  // Signal handling\n\nlet should_exit = false;\n\nfn handle_shutdown(sig: i32): null {\n    print(\"Received signal \" + typeof(sig) + \", shutting down...\");\n    should_exit = true;\n    return null;\n}\n\n// Register signal handlers\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Main loop\nwhile (!should_exit) {\n    // ... do work ...\n\n    if (should_exit) {\n        print(\"Performing cleanup...\");\n        // ... cleanup code ...\n        exit(0);\n    }\n}\n```", "category": "docs", "source": "stdlib/docs/env.md"}
{"instruction": "Implement a Hemlock program that test invalid hex literal - should fail to parse.", "output": "```hemlock\n// Test invalid hex literal - should fail to parse\nlet x = 0x;\nprint(x);\n```", "category": "tests/primitives", "source": "tests/primitives/hex_invalid.hml"}
{"instruction": "How does rune ‚Üí string work in Hemlock?", "output": "Runes can be explicitly converted to strings:\n\n```hemlock\n// Explicit conversion\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = 'üöÄ';       // \"üöÄ\"\n\n// Automatic during concatenation\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Create a Hemlock program that test optional parameters with recursion.", "output": "```hemlock\n// Test optional parameters with recursion\n\n// Recursive function with optional accumulator\nfn factorial(n: i32, acc?: 1): i32 {\n    if (n <= 1) {\n        return acc;\n    }\n    return factorial(n - 1, n * acc);\n}\n\nprint(factorial(5));      // 120\nprint(factorial(5, 1));   // 120\nprint(factorial(5, 2));   // 240 (factorial * 2)\n\n// Countdown with optional step\nfn countdown(n: i32, step?: 1) {\n    if (n <= 0) {\n        print(\"Done!\");\n        return null;\n    }\n    print(n);\n    return countdown(n - step, step);\n}\n\ncountdown(5);      // 5 4 3 2 1 Done!\ncountdown(10, 2);  // 10 8 6 4 2 Done!\n\n// Fibonacci with optional starting values\nfn fib(n: i32, a?: 0, b?: 1): i32 {\n    if (n == 0) {\n        return a;\n    }\n    if (n == 1) {\n        return b;\n    }\n    return fib(n - 1, b, a + b);\n}\n\nprint(fib(0));   // 0\nprint(fib(1));   // 1\nprint(fib(10));  // 55\n```", "category": "tests/functions", "source": "tests/functions/optional_params_recursion.hml"}
{"instruction": "How does ptr (raw pointer) work in Hemlock?", "output": "```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does syntax work in Hemlock?", "output": "Basic try/catch:*\n\n```hemlock\ntry {\n    // risky code\n} catch (e) {\n    // handle error, e contains the thrown value\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "How does resource management work in Hemlock?", "output": "Exception handling with cleanup:\n\n```hemlock\nlet stream = TcpStream(\"example.com\", 80);\ndefer stream.close();  // Runs even if exception is thrown\n\ntry {\n    stream.write(\"data\");\n    let response = stream.read(1024);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n// stream.close() called automatically here\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does is_alpha(str) work in Hemlock?", "output": "Returns:* bool - True if all characters are alphabetic\n\n```hemlock\nimport { is_alpha } from \"@stdlib/strings\";\n\nprint(is_alpha(\"hello\"));         // true\nprint(is_alpha(\"HELLO\"));         // true\nprint(is_alpha(\"HelloWorld\"));    // true\n\nprint(is_alpha(\"hello123\"));      // false\nprint(is_alpha(\"hello world\"));   // false (space)\nprint(is_alpha(\"hello!\"));        // false\nprint(is_alpha(\"\"));              // false (empty)\n```", "category": "docs", "source": "stdlib/docs/strings.md"}
{"instruction": "How does handle quoted arguments with spaces work in Hemlock?", "output": "./hemlock script.hml \"file with spaces.txt\"\n\n```hemlock\nprint(args[1]);  // \"file with spaces.txt\"\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does substring & slicing work in Hemlock?", "output": "slice(start, end)* - Extract substring by range (end exclusive):\n\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\" (index 0 to 4)\nlet slice2 = s.slice(6, 11);    // \"world\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does escape sequences work in Hemlock?", "output": "Common escape sequences for special characters:\n\n```hemlock\nlet newline = '\\n';     // Newline (U+000A)\nlet tab = '\\t';         // Tab (U+0009)\nlet backslash = '\\\\';   // Backslash (U+005C)\nlet quote = '\\'';       // Single quote (U+0027)\nlet dquote = '\"';       // Double quote (U+0022)\nlet null_char = '\\0';   // Null character (U+0000)\nlet cr = '\\r';          // Carriage return (U+000D)\n```", "category": "docs", "source": "docs/language-guide/runes.md"}
{"instruction": "Implement a Hemlock program that test string methods.", "output": "```hemlock\n// Test string methods\n\nlet s = \"hello world\";\n\n// Length\nprint(s.length);\n\n// Substring and slice\nprint(s.substr(0, 5));\nprint(s.slice(6, 11));\n\n// Find and contains\nprint(s.find(\"world\"));\nprint(s.contains(\"hello\"));\nprint(s.contains(\"xyz\"));\n\n// Case conversion\nprint(s.to_upper());\nprint(s.to_lower());\n\n// Trim\nlet padded = \"  trimmed  \";\nprint(padded.trim());\n\n// Split\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");\nprint(parts[0]);\nprint(parts[1]);\nprint(parts[2]);\nprint(parts.length);\n\n// Starts/ends with\nprint(s.starts_with(\"hello\"));\nprint(s.ends_with(\"world\"));\n\n// Replace\nprint(s.replace(\"world\", \"there\"));\nprint(\"foo foo foo\".replace_all(\"foo\", \"bar\"));\n\n// Repeat\nprint(\"ab\".repeat(3));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/methods/string_methods.hml"}
{"instruction": "How does type annotations (optional) work in Hemlock?", "output": "```hemlock\n// No annotations (types inferred)\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\n// With annotations (checked at runtime)\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "How does tcpstream work in Hemlock?", "output": "Closes the stream. Idempotent.\n\n```hemlock\nstream.close();\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does defining methods work in Hemlock?", "output": "Methods are functions stored in object fields:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does asyncremovedir work in Hemlock?", "output": "```hemlock\nasync_remove_dir(path: string): Future<null>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Show me Hemlock code that test directory operations: make_dir(), remove_dir(), list_dir().", "output": "```hemlock\n// Test directory operations: make_dir(), remove_dir(), list_dir()\nimport { make_dir, exists, is_dir, write_file, list_dir, remove_file, remove_dir } from \"@stdlib/fs\";\n\nlet test_dir = \"/tmp/test_hemlock_dir\";\n\n// Create directory\nmake_dir(test_dir);\nassert(exists(test_dir) == true, \"make_dir() should create directory\");\nassert(is_dir(test_dir) == true, \"is_dir() should return true for directory\");\n\n// Create files in directory\nwrite_file(test_dir + \"/file1.txt\", \"content 1\");\nwrite_file(test_dir + \"/file2.txt\", \"content 2\");\nwrite_file(test_dir + \"/file3.txt\", \"content 3\");\n\n// List directory\nlet entries = list_dir(test_dir);\nassert(entries.length == 3, \"list_dir() should return 3 entries\");\n\n// Verify entries contain expected files\nlet found_file1 = false;\nlet found_file2 = false;\nlet found_file3 = false;\nlet i = 0;\nwhile (i < entries.length) {\n    if (entries[i] == \"file1.txt\") { found_file1 = true; }\n    if (entries[i] == \"file2.txt\") { found_file2 = true; }\n    if (entries[i] == \"file3.txt\") { found_file3 = true; }\n    i = i + 1;\n}\nassert(found_file1 == true, \"list_dir() should find file1.txt\");\nassert(found_file2 == true, \"list_dir() should find file2.txt\");\nassert(found_file3 == true, \"list_dir() should find file3.txt\");\n\n// Clean up files\nremove_file(test_dir + \"/file1.txt\");\nremove_file(test_dir + \"/file2.txt\");\nremove_file(test_dir + \"/file3.txt\");\n\n// Remove directory\nremove_dir(test_dir);\nassert(exists(test_dir) == false, \"remove_dir() should remove directory\");\n\nprint(\"All directory operation tests passed!\");\n```", "category": "tests/io", "source": "tests/io/directory_ops.hml"}
{"instruction": "How does search operations work in Hemlock?", "output": "contains(value)* - Check if array contains value:\n\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How does best practices for safe signal handling work in Hemlock?", "output": "Simple boolean assignments are generally safe:\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // Simple assignment is safe\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // work...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does closure scope work in Hemlock?", "output": "Closures capture variables from enclosing scope:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Captures 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```", "category": "docs", "source": "docs/language-guide/syntax.md"}
{"instruction": "Write Hemlock code that mixing existing and dynamic fields.", "output": "```hemlock\n// Mixing existing and dynamic fields\nlet obj = { a: 1, b: 2 };\nobj.c = 3;\nobj.a = 10;\nobj.d = 4;\nprint(obj.a);\nprint(obj.b);\nprint(obj.c);\nprint(obj.d);\n```", "category": "tests/objects", "source": "tests/objects/dynamic_field_mixed.hml"}
{"instruction": "How does method chaining work in Hemlock?", "output": "All string methods return new strings, enabling chaining:\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "Show an example of example 1: arithmetic and comparison in Hemlock.", "output": "```hemlock\nlet result = 5 + 3 * 2;\n// Evaluated as: 5 + (3 * 2) = 11\n// Multiplication has higher precedence than addition\n\nlet cmp = 10 > 5 + 3;\n// Evaluated as: 10 > (5 + 3) = true\n// Addition has higher precedence than comparison\n```", "category": "docs", "source": "docs/reference/operators.md"}
{"instruction": "How does pattern: configuration object work in Hemlock?", "output": "```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```", "category": "docs", "source": "docs/language-guide/objects.md"}
{"instruction": "How does declaring variables work in Hemlock?", "output": "```hemlock\n// Basic variable declaration\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does pattern: reduce (fold) work in Hemlock?", "output": "```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "Write Hemlock code that test terminal progress bar.", "output": "```hemlock\n// Test terminal progress bar\nimport { ProgressBar } from \"@stdlib/terminal\";\nimport { sleep } from \"@stdlib/time\";\n\nprint(\"=== Terminal Progress Bar Tests ===\");\nprint(\"\");\n\n// Test ProgressBar creation\nprint(\"Testing ProgressBar creation:\");\nlet bar1 = ProgressBar(100);\nprint(\"‚úì Created progress bar with total=100\");\n\nlet bar2 = ProgressBar(50, 30);\nprint(\"‚úì Created progress bar with total=50, width=30\");\n\nprint(\"\");\n\n// Test update method\nprint(\"Testing update method:\");\nbar1.update(0);\nsleep(0.1);\nbar1.update(25);\nsleep(0.1);\nbar1.update(50);\nsleep(0.1);\nbar1.update(75);\nsleep(0.1);\nbar1.update(100);\nbar1.finish();\nprint(\"‚úì Progress bar update works\");\n\nprint(\"\");\n\n// Test increment method\nprint(\"Testing increment method:\");\nlet bar3 = ProgressBar(10, 20);\nlet i = 0;\nwhile (i < 10) {\n    bar3.increment();\n    sleep(0.05);\n    i = i + 1;\n}\nbar3.finish();\nprint(\"‚úì Progress bar increment works\");\n\nprint(\"\");\n\n// Test with different widths\nprint(\"Testing different widths:\");\nlet bar4 = ProgressBar(100, 60);\nbar4.update(30);\nsleep(0.1);\nbar4.update(60);\nsleep(0.1);\nbar4.update(100);\nbar4.finish();\nprint(\"‚úì Wide progress bar works\");\n\nprint(\"\");\nprint(\"‚úì All progress bar tests completed\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/test_progress.hml"}
{"instruction": "How does polling with timeout work in Hemlock?", "output": "```hemlock\nimport { now, sleep } from \"@stdlib/time\";\n\nfn wait_for_condition(check: function, timeout_seconds: i32): bool {\n    let start = now();\n\n    while (true) {\n        if (check()) {\n            return true;  // Condition met\n        }\n\n        let elapsed = now() - start;\n        if (elapsed >= timeout_seconds) {\n            return false;  // Timeout\n        }\n\n        sleep(0.1);  // Poll every 100ms\n    }\n}\n\n// Usage\nlet result = wait_for_condition(fn() {\n    // Check some condition\n    return false;  // Example: not ready yet\n}, 30);\n\nif (result) {\n    print(\"Condition met!\");\n} else {\n    print(\"Timeout!\");\n}\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "Show an example of examples in Hemlock.", "output": "Appending to a file:*\n\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // Creates if doesn't exist\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does post json data work in Hemlock?", "output": "```hemlock\nimport { post_json } from \"@stdlib/http\";\n\nlet data = {\n    title: \"Buy groceries\",\n    completed: false,\n    userId: 1\n};\n\nlet response = post_json(\"https://jsonplaceholder.typicode.com/todos\", data);\nprint(response.body);\n```", "category": "docs", "source": "stdlib/docs/http.md"}
{"instruction": "Show me Hemlock code that basic functionality test for @stdlib/process.", "output": "```hemlock\n// Basic functionality test for @stdlib/process\nimport { get_pid, getppid, getuid, geteuid, getgid, getegid, exec } from \"@stdlib/process\";\n\nprint(\"Testing @stdlib/process basic functionality...\");\n\n// Test process identification\nlet pid = get_pid();\nassert(typeof(pid) == \"i32\", \"get_pid() should return i32\");\nassert(pid > 0, \"PID should be positive\");\n\nlet ppid = getppid();\nassert(typeof(ppid) == \"i32\", \"getppid() should return i32\");\nassert(ppid > 0, \"PPID should be positive\");\n\nlet uid = getuid();\nassert(typeof(uid) == \"i32\", \"getuid() should return i32\");\nassert(uid >= 0, \"UID should be non-negative\");\n\nlet euid = geteuid();\nassert(typeof(euid) == \"i32\", \"geteuid() should return i32\");\nassert(euid >= 0, \"EUID should be non-negative\");\n\nlet gid = getgid();\nassert(typeof(gid) == \"i32\", \"getgid() should return i32\");\nassert(gid >= 0, \"GID should be non-negative\");\n\nlet egid = getegid();\nassert(typeof(egid) == \"i32\", \"getegid() should return i32\");\nassert(egid >= 0, \"EGID should be non-negative\");\n\n// Test exec\nlet result = exec(\"echo 'test output'\");\nassert(typeof(result) == \"object\", \"exec() should return object\");\nassert(result.exit_code == 0, \"exec() exit_code should be 0\");\nassert(result.output.contains(\"test output\"), \"exec() output should contain command output\");\n\n// Test exec with non-zero exit\nlet result2 = exec(\"false\");\nassert(result2.exit_code != 0, \"false command should have non-zero exit code\");\n\nprint(\"‚úÖ All basic tests passed!\");\n```", "category": "tests/stdlib_process", "source": "tests/stdlib_process/basic_test.hml"}
{"instruction": "How does asin(x) work in Hemlock?", "output": "Returns:* f64 - Arc sine in range [-œÄ/2, œÄ/2]\n\n```hemlock\nimport { asin, PI } from \"@stdlib/math\";\n\nlet angle = asin(1.0);   // œÄ/2\nlet angle2 = asin(0.5);  // œÄ/6\n```", "category": "docs", "source": "stdlib/docs/math.md"}
{"instruction": "How do you using pipes in Hemlock?", "output": "```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does channel work in Hemlock?", "output": "```hemlock\nlet ch = channel(10);  // Buffered channel with capacity 10\nlet ch2 = channel(1);  // Minimal buffer (synchronous)\nlet ch3 = channel(100); // Large buffer\n```", "category": "docs", "source": "docs/reference/concurrency-api.md"}
{"instruction": "How does readfilesparallel work in Hemlock?", "output": "```hemlock\nread_files_parallel(paths: array<string>): array<string>\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Give me Hemlock code that shows demonstrates the HTTP client library.", "output": "```hemlock\n// Example: Using @stdlib/http module\n// Demonstrates production-ready HTTP/HTTPS client using curl\n\nimport { get, post_json, fetch, get_json, is_success } from \"@stdlib/http\";\n\nprint(\"=== Hemlock HTTP Client Example ===\\n\");\n\n// Example 1: Simple HTTPS GET request\nprint(\"Example 1: HTTPS GET request\");\nprint(\"-----------------------------\");\ntry {\n    let response = get(\"https://httpbin.org/get\", null);\n\n    if (is_success(response.status_code)) {\n        print(\"Status: \" + typeof(response.status_code));\n        print(\"Body (first 100 chars): \" + response.body.substr(0, 100));\n    } else {\n        print(\"Request failed with status: \" + typeof(response.status_code));\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    print(\"(Requires curl to be installed and network access)\");\n}\n\nprint(\"\\n\");\n\n// Example 2: Fetch JSON API\nprint(\"Example 2: Fetch and Parse JSON\");\nprint(\"--------------------------------\");\ntry {\n    let user = get_json(\"https://jsonplaceholder.typicode.com/users/1\");\n    print(\"Name: \" + user.name);\n    print(\"Email: \" + user.email);\n    print(\"Company: \" + user.company.name);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 3: POST JSON data\nprint(\"Example 3: POST JSON\");\nprint(\"--------------------\");\ntry {\n    let data = {\n        title: \"Buy groceries\",\n        completed: false,\n        userId: 1\n    };\n\n    let response = post_json(\"https://jsonplaceholder.typicode.com/todos\", data);\n    print(\"Response (first 100 chars): \" + response.body.substr(0, 100));\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 4: Custom headers with authentication\nprint(\"Example 4: Custom Headers\");\nprint(\"-------------------------\");\ntry {\n    let headers = [\n        \"User-Agent: Hemlock-HTTP/1.0\",\n        \"Accept: application/json\",\n        \"X-Custom-Header: test-value\"\n    ];\n\n    let response = get(\"https://httpbin.org/headers\", headers);\n    print(\"Response received (check headers were sent)\");\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 5: Error handling\nprint(\"Example 5: Error Handling\");\nprint(\"-------------------------\");\ntry {\n    let response = get(\"https://httpbin.org/status/404\", null);\n    if (is_success(response.status_code)) {\n        print(\"Success!\");\n    } else {\n        print(\"Got error status: \" + typeof(response.status_code));\n    }\n} catch (e) {\n    print(\"Request failed: \" + e);\n}\n\nprint(\"\\n\");\n\n// Example 6: Simple fetch\nprint(\"Example 6: Simple Fetch\");\nprint(\"-----------------------\");\ntry {\n    let html = fetch(\"https://example.com\");\n    print(\"Fetched \" + typeof(html.length) + \" bytes from example.com\");\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\nprint(\"\\n=== Examples Complete ===\");\n\nprint(\"\\nNOTE: This module uses curl for HTTP/HTTPS support.\");\nprint(\"Ensure curl is installed: which curl\");\n```", "category": "examples", "source": "examples/http_example.hml"}
{"instruction": "How does cpu_count() work in Hemlock?", "output": "System resource reporting\n\n```hemlock\nimport { cpu_count } from \"@stdlib/os\";\n\nlet cores = cpu_count();\nprint(\"CPU cores: \" + typeof(cores));  // e.g., 8\n\n// Size thread pool based on available cores\nlet worker_count = cores - 1;  // Leave one for main thread\nif (worker_count < 1) {\n    worker_count = 1;\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does read file line by line work in Hemlock?", "output": "```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "Write Hemlock code that test null coalescing operator (??).", "output": "```hemlock\n// Test null coalescing operator (??)\n\n// Basic null coalescing\nlet a = null;\nprint(a ?? \"default\");\n\n// Non-null value\nlet b = \"hello\";\nprint(b ?? \"default\");\n\n// With numbers\nlet c = null;\nprint(c ?? 42);\n\nlet d = 100;\nprint(d ?? 42);\n\n// Chained null coalescing\nlet e = null;\nlet f = null;\nlet g = \"found\";\nprint(e ?? f ?? g);\n\n// All null\nlet h = null;\nlet i = null;\nprint(h ?? i ?? \"fallback\");\n\n// With zero (should NOT coalesce - zero is not null)\nlet zero = 0;\nprint(zero ?? 100);\n\n// With false (should NOT coalesce - false is not null)\nlet falsy = false;\nprint(falsy ?? true);\n\n// With empty string (should NOT coalesce)\nlet empty = \"\";\nprint(empty ?? \"default\");\nprint(empty == \"\" ?? \"was null\");\n\n// In function return\nfn maybeNull(flag) {\n    if (flag) {\n        return \"value\";\n    }\n    return null;\n}\n\nprint(maybeNull(true) ?? \"was null\");\nprint(maybeNull(false) ?? \"was null\");\n\n// Combined with optional chaining\nlet obj = { name: \"Alice\" };\nlet nullObj = null;\nprint(obj?.name ?? \"unknown\");\nprint(nullObj?.name ?? \"unknown\");\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/language/null_coalesce.hml"}
{"instruction": "Write Hemlock code that test defer statement - LIFO order execution.", "output": "```hemlock\n// Test defer statement - LIFO order execution\n\nfn test_single_defer() {\n    defer print(\"cleanup\");\n    print(\"work\");\n    return null;\n}\n\nfn test_multiple_defers() {\n    defer print(\"first\");\n    defer print(\"second\");\n    defer print(\"third\");\n    print(\"start\");\n    return null;\n}\n\nfn test_early_return() {\n    defer print(\"always runs\");\n    print(\"before return\");\n    return 42;\n    print(\"never prints\");\n}\n\n// Run tests\ntest_single_defer();\nprint(\"---\");\ntest_multiple_defers();\nprint(\"---\");\nlet result = test_early_return();\nprint(result);\n```", "category": "tests/compiler", "source": "tests/compiler/defer.hml"}
{"instruction": "How does for-in iteration (including script name) work in Hemlock?", "output": "```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```", "category": "docs", "source": "docs/advanced/command-line-args.md"}
{"instruction": "How does sending messages work in Hemlock?", "output": "Binary messages:*\n\n```hemlock\nlet data = buffer(10);\ndata[0] = 72;  // 'H'\ndata[1] = 105; // 'i'\n\nlet success = ws.send_binary(data);\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
{"instruction": "How does .closed work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```", "category": "docs", "source": "docs/reference/file-api.md"}
{"instruction": "How does error checking work in Hemlock?", "output": "```hemlock\n// Check return values\nlet result = c_function();\nif (result == null) {\n    print(\"C function failed\");\n}\n```", "category": "docs", "source": "docs/advanced/ffi.md"}
{"instruction": "Create a Hemlock program that multiple method calls on same object.", "output": "```hemlock\n// Multiple method calls on same object\nlet obj = {\n    x: 10,\n    y: 20,\n    getX: fn() {\n        return self.x;\n    },\n    getY: fn() {\n        return self.y;\n    },\n};\n\nprint(obj.getX());\nprint(obj.getY());\n```", "category": "tests/objects", "source": "tests/objects/method_chaining.hml"}
{"instruction": "Write Hemlock code that tests basic.", "output": "```hemlock\nlet a = 10 + 5;\nlet b = 10 - 5;\nlet c = 10 * 5;\nlet d = 10 / 5;\nprint(a);\nprint(b);\nprint(c);\nprint(d);\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/basic.hml"}
{"instruction": "How does talloc work in Hemlock?", "output": "```hemlock\ntalloc(type, count: i32): ptr\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does c-style for work in Hemlock?", "output": "```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i not accessible here (loop-scoped)\n```", "category": "docs", "source": "docs/language-guide/control-flow.md"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "Named vs. Anonymous:*\n\n```hemlock\n// These are equivalent:\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```", "category": "docs", "source": "docs/language-guide/functions.md"}
{"instruction": "How does api work in Hemlock?", "output": "```hemlock\nlet s = Stack();\n```", "category": "docs", "source": "stdlib/docs/collections.md"}
{"instruction": "How do you stack usage in Hemlock?", "output": "```hemlock\nlet stack = [];\n\n// Push elements\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop elements\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```", "category": "docs", "source": "docs/reference/array-api.md"}
{"instruction": "How does binary file copy work in Hemlock?", "output": "```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "How does async/concurrency work in Hemlock?", "output": "```hemlock\nasync fn compute(n: i32): i32 {\n    return n * n;\n}\n\nlet task = spawn(compute, 42);\nlet result = join(task);  // 1764\n```", "category": "docs", "source": "docs/README.md"}
{"instruction": "How does remove_dir(path) work in Hemlock?", "output": "Throws:* Exception if directory doesn't exist, is not empty, or cannot be deleted\n\n```hemlock\nimport { remove_dir } from \"@stdlib/fs\";\n\ntry {\n    remove_dir(\"empty_directory\");\n    print(\"Directory removed\");\n} catch (e) {\n    print(\"Error removing directory: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/fs.md"}
{"instruction": "Create a Hemlock program that character ranges.", "output": "```hemlock\n// Test: Character classes and ranges\nimport { test } from \"@stdlib/regex\";\n\n// Character ranges\nprint(test(\"^[a-z]+$\", \"hello\", null));            // true\nprint(test(\"^[a-z]+$\", \"Hello\", null));            // false\nprint(test(\"^[A-Z]+$\", \"HELLO\", null));            // true\nprint(test(\"^[0-9]+$\", \"12345\", null));            // true\nprint(test(\"^[a-zA-Z]+$\", \"HelloWorld\", null));    // true\n\n// Character classes\nprint(test(\"^[abc]+$\", \"abcabc\", null));           // true\nprint(test(\"^[abc]+$\", \"abcd\", null));             // false\n\n// Negation\nprint(test(\"^[^0-9]+$\", \"hello\", null));           // true\nprint(test(\"^[^0-9]+$\", \"hello123\", null));        // false\n\n// POSIX character classes\nprint(test(\"^[[:digit:]]+$\", \"12345\", null));      // true\nprint(test(\"^[[:alpha:]]+$\", \"Hello\", null));      // true\nprint(test(\"^[[:alnum:]]+$\", \"Hello123\", null));   // true\nprint(test(\"^[[:space:]]+$\", \"   \", null));        // true\n```", "category": "tests/stdlib_regex", "source": "tests/stdlib_regex/character_classes.hml"}
{"instruction": "How does check file state before operations work in Hemlock?", "output": "```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... use content\n}\n\nf.close();\n```", "category": "docs", "source": "docs/advanced/file-io.md"}
{"instruction": "Write a Hemlock program that jSON functions test.", "output": "```hemlock\n// JSON functions test\nimport { parse, stringify } from \"@stdlib/json\";\n\n// Parse simple object\nlet obj = parse(\"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}\");\nprint(obj.name);\nprint(obj.age);\n\n// Parse array\nlet arr = parse(\"[1, 2, 3]\");\nprint(arr[0]);\nprint(arr[1]);\nprint(arr[2]);\n\n// Stringify object\nlet data = { x: 10, y: 20 };\nprint(stringify(data));\n\n// Nested object\nlet nested = parse(\"{\\\"user\\\": {\\\"name\\\": \\\"Bob\\\"}}\");\nprint(nested.user.name);\n\n// Boolean and null\nlet mixed = parse(\"{\\\"flag\\\": true, \\\"empty\\\": null}\");\nprint(mixed.flag);\nprint(mixed.empty);\n```", "category": "tests/parity", "source": "tests/parity/modules/stdlib_json.hml"}
{"instruction": "How does memory management work in Hemlock?", "output": "```hemlock\n// Safe buffer (recommended)\nlet buf = buffer(64);\nbuf[0] = 65;\nfree(buf);\n\n// Raw pointer (for experts)\nlet ptr = alloc(64);\nmemset(ptr, 0, 64);\nfree(ptr);\n```", "category": "docs", "source": "docs/README.md"}
{"instruction": "Create a Hemlock program that test await on null value Expected: PASS (await on non-task should return the value).", "output": "```hemlock\n// Test await on null value\n// Expected: PASS (await on non-task should return the value)\n\nlet result = await null;\nif (result == null) {\n    print(\"PASS: await null returned null\");\n} else {\n    print(\"ERROR: await null should return null\");\n}\n```", "category": "tests/async", "source": "tests/async/edge_await_null.hml"}
{"instruction": "How does tcplistener work in Hemlock?", "output": "Closes the listener socket. Idempotent (safe to call multiple times).\n\n```hemlock\nlistener.close();\n```", "category": "docs", "source": "stdlib/docs/net.md"}
{"instruction": "How does worker pool sizing work in Hemlock?", "output": "```hemlock\nimport { cpu_count, total_memory, format_bytes } from \"@stdlib/os\";\n\nfn calculate_workers(memory_per_worker: i64): i32 {\n    let cores = cpu_count();\n    let total = total_memory();\n\n    // Workers based on CPU (leave 1 core for system)\n    let cpu_workers = cores - 1;\n    if (cpu_workers < 1) {\n        cpu_workers = 1;\n    }\n\n    // Workers based on memory (use 75% of total)\n    let available = (total * 75) / 100;\n    let mem_workers: i32 = available / memory_per_worker;\n    if (mem_workers < 1) {\n        mem_workers = 1;\n    }\n\n    // Use the lower of the two\n    let workers = cpu_workers;\n    if (mem_workers < workers) {\n        workers = mem_workers;\n    }\n\n    print(\"Calculated workers:\");\n    print(\"  CPU-based: \" + typeof(cpu_workers) + \" (from \" + typeof(cores) + \" cores)\");\n    print(\"  Memory-based: \" + typeof(mem_workers) + \" (\" + format_bytes(available) + \" available)\");\n    print(\"  Using: \" + typeof(workers) + \" workers\");\n\n    return workers;\n}\n\n// Assume each worker needs 512 MB\nlet worker_memory: i64 = 536870912;  // 512 MB\nlet num_workers = calculate_workers(worker_memory);\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "How does error handling work in Hemlock?", "output": "All functions throw exceptions on errors:\n\n```hemlock\nimport { compress, decompress, gunzip } from \"@stdlib/compression\";\n\n// Invalid compression level\ntry {\n    compress(\"data\", 15);  // Level must be 0-9\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// Corrupted data\ntry {\n    let bad_data = buffer(10);\n    decompress(bad_data);\n} catch (e) {\n    print(\"Decompression error: \" + e);\n}\n\n// Invalid gzip data\ntry {\n    let not_gzip = buffer(10);\n    not_gzip[0] = 0;  // Wrong magic byte\n    gunzip(not_gzip);\n} catch (e) {\n    print(\"Gunzip error: \" + e);\n}\n```", "category": "docs", "source": "stdlib/docs/compression.md"}
{"instruction": "How does memory copy pattern work in Hemlock?", "output": "```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// Create copy\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```", "category": "docs", "source": "docs/reference/memory-api.md"}
{"instruction": "How does bg_rgb(r, g, b) work in Hemlock?", "output": "Returns:* string - RGB background color code\n\n```hemlock\nimport { bg_rgb, rgb, RESET } from \"@stdlib/terminal\";\n\nprint(rgb(255, 255, 255) + bg_rgb(255, 0, 0) + \" White on red \" + RESET);\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "How does permission considerations work in Hemlock?", "output": "Commands run with the same permissions as the Hemlock process:\n\n```hemlock\n// If Hemlock runs as root, exec() commands also run as root!\nlet r = exec(\"rm -rf /important\");  // DANGEROUS if running as root\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "How does safe practices work in Hemlock?", "output": "2. Use allowlists, not denylists:*\n\n```hemlock\n// Good - strict allowlist\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Invalid command\");\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show me Hemlock code that tests a simulated producer-consumer using channels.", "output": "```hemlock\n// Test: Producer-consumer pattern with channels\n// Tests a simulated producer-consumer using channels\n\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    let val = 0;\n    while (i < count) {\n        val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel\nlet ch = channel(10);\n\n// Run producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for them to complete\njoin(p);\nlet total = join(c);\n\nprint(total);  // 0 + 10 + 20 + 30 + 40 = 100\n```", "category": "tests/async", "source": "tests/async/test_producer_consumer.hml"}
{"instruction": "How does character & byte access work in Hemlock?", "output": "byte_at(index)* - Get byte value at index (returns u8):\n\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII value of 'h')\n\n// UTF-8 example\nlet emoji = \"üöÄ\";\nlet first_byte = emoji.byte_at(0);  // 240 (first UTF-8 byte)\n```", "category": "docs", "source": "docs/language-guide/strings.md"}
{"instruction": "How does arch() work in Hemlock?", "output": "System requirements validation\n\n```hemlock\nimport { arch } from \"@stdlib/os\";\n\nlet a = arch();\nprint(\"CPU architecture: \" + a);  // e.g., \"x86_64\"\n\nif (a == \"x86_64\" || a == \"amd64\") {\n    print(\"64-bit x86 system\");\n} else if (a == \"aarch64\" || a == \"arm64\") {\n    print(\"64-bit ARM system\");\n}\n```", "category": "docs", "source": "stdlib/docs/os.md"}
{"instruction": "Implement a Hemlock program that test 1: Basic encryption/decryption.", "output": "```hemlock\n// Test: @stdlib/crypto - AES-256-CBC encryption/decryption\n\nimport { generate_aes_key, generate_iv, aes_encrypt, aes_decrypt } from \"@stdlib/crypto\";\n\nprint(\"Testing AES-256-CBC...\");\n\n// Test 1: Basic encryption/decryption\nlet key = generate_aes_key();\nlet iv = generate_iv();\n\nif (key.length != 32) {\n    throw \"AES key should be 32 bytes, got \" + typeof(key.length);\n}\nif (iv.length != 16) {\n    throw \"IV should be 16 bytes, got \" + typeof(iv.length);\n}\nprint(\"‚úì Key and IV generation\");\n\n// Test 2: Encrypt and decrypt simple message\nlet plaintext = \"Hello, World!\";\nlet ciphertext = aes_encrypt(plaintext, key, iv);\n\nif (ciphertext.length < plaintext.length) {\n    throw \"Ciphertext should be at least as long as plaintext\";\n}\n\nlet decrypted = aes_decrypt(ciphertext, key, iv);\nif (decrypted != plaintext) {\n    throw \"Decrypted text doesn't match: \" + decrypted;\n}\nprint(\"‚úì Basic encryption/decryption\");\n\n// Test 3: Longer message\nlet long_message = \"This is a much longer message that will span multiple AES blocks. AES has a block size of 16 bytes, so this message will be split across several blocks. The CBC mode will chain the blocks together for security.\";\nlet long_ciphertext = aes_encrypt(long_message, key, iv);\nlet long_decrypted = aes_decrypt(long_ciphertext, key, iv);\n\nif (long_decrypted != long_message) {\n    throw \"Long message decryption failed\";\n}\nprint(\"‚úì Long message encryption/decryption\");\n\n// Test 4: Empty string\nlet empty = \"\";\nlet empty_ciphertext = aes_encrypt(empty, key, iv);\nlet empty_decrypted = aes_decrypt(empty_ciphertext, key, iv);\n\nif (empty_decrypted != empty) {\n    throw \"Empty string decryption failed\";\n}\nprint(\"‚úì Empty string encryption/decryption\");\n\n// Test 5: Unicode/UTF-8 - encryption works, but decryption has UTF-8 reconstruction limitation\n// Note: Hemlock strings use UTF-8, but byte-to-string conversion reconstructs code points\n// individually rather than as multi-byte UTF-8 sequences. Use ASCII text for reliable round-trip.\nlet unicode = \"Hello üåç! Hemlock üöÄ\";\nlet unicode_ciphertext = aes_encrypt(unicode, key, iv);\n// Verify encryption produces output (the bytes are correct, just string comparison fails)\nif (unicode_ciphertext.length < unicode.bytes().length) {\n    throw \"Unicode encryption should produce output\";\n}\nprint(\"‚úì Unicode/UTF-8 encryption (decryption has UTF-8 limitation)\");\n\n// Test 6: Different IV produces different ciphertext\nlet iv2 = generate_iv();\nlet ciphertext1 = aes_encrypt(plaintext, key, iv);\nlet ciphertext2 = aes_encrypt(plaintext, key, iv2);\n\nlet same = true;\nlet i = 0;\nlet min_len = ciphertext1.length;\nif (ciphertext2.length < min_len) {\n    min_len = ciphertext2.length;\n}\n\nwhile (i < min_len) {\n    if (ciphertext1[i] != ciphertext2[i]) {\n        same = false;\n    }\n    i = i + 1;\n}\n\nif (same) {\n    throw \"Different IVs should produce different ciphertexts\";\n}\nprint(\"‚úì Different IVs produce different ciphertexts\");\n\n// Test 7: Wrong key fails decryption\nlet key2 = generate_aes_key();\ntry {\n    aes_decrypt(ciphertext, key2, iv);\n    throw \"Should have failed with wrong key\";\n} catch (e) {\n    // Expected - decryption should fail\n}\nprint(\"‚úì Wrong key fails decryption\");\n\n// Test 8: Wrong IV fails decryption\nlet iv3 = generate_iv();\ntry {\n    aes_decrypt(ciphertext, key, iv3);\n    throw \"Should have failed with wrong IV\";\n} catch (e) {\n    // Expected - decryption should fail\n}\nprint(\"‚úì Wrong IV fails decryption\");\n\n// Test 9: Error handling - wrong key size\ntry {\n    let bad_key = generate_iv();  // 16 bytes instead of 32\n    aes_encrypt(\"data\", bad_key, iv);\n    throw \"Should have thrown error for wrong key size\";\n} catch (e) {\n    if (e != \"aes_encrypt() requires 32-byte (256-bit) key\") {\n        throw \"Wrong error message: \" + e;\n    }\n}\nprint(\"‚úì Error handling for wrong key size\");\n\n// Test 10: Error handling - wrong IV size\ntry {\n    let bad_iv = generate_aes_key();  // 32 bytes instead of 16\n    aes_encrypt(\"data\", key, bad_iv);\n    throw \"Should have thrown error for wrong IV size\";\n} catch (e) {\n    if (e != \"aes_encrypt() requires 16-byte (128-bit) iv\") {\n        throw \"Wrong error message: \" + e;\n    }\n}\nprint(\"‚úì Error handling for wrong IV size\");\n\nprint(\"All AES tests passed!\");\n```", "category": "tests/stdlib_crypto", "source": "tests/stdlib_crypto/test_aes.hml"}
{"instruction": "How does boolean type work in Hemlock?", "output": "```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"working\");\n}\n```", "category": "docs", "source": "docs/reference/type-system.md"}
{"instruction": "How does throwing error objects work in Hemlock?", "output": "Create structured error information:\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"File does not exist\"\n        };\n    }\n    // ... read file\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"File not found: \" + e.path);\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Create a Hemlock program that tests args length.", "output": "```hemlock\n// Test: Print the number of arguments\nprint(args.length);\n```", "category": "tests/args", "source": "tests/args/args_length.hml"}
{"instruction": "How does fan-out, fan-in work in Hemlock?", "output": "```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // Process value\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// Fan-out: Multiple workers\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// Send work\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// Fan-in: Collect all results\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// Wait for all workers\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```", "category": "docs", "source": "docs/advanced/async-concurrency.md"}
{"instruction": "Write Hemlock code that test print and typeof builtins.", "output": "```hemlock\n// Test print and typeof builtins\n\nprint(typeof(42));\nprint(typeof(3.14));\nprint(typeof(\"hello\"));\nprint(typeof(true));\nprint(typeof(null));\nprint(typeof([1, 2, 3]));\nprint(typeof({ x: 1 }));\n\nfn test() {\n    return 1;\n}\nprint(typeof(test));\n\nprint(\"done\");\n```", "category": "tests/parity", "source": "tests/parity/builtins/print_typeof.hml"}
{"instruction": "How does throw work in Hemlock?", "output": "```hemlock\nthrow expression\n```", "category": "docs", "source": "docs/reference/builtins.md"}
{"instruction": "How does pitfall: forgetting cleanup work in Hemlock?", "output": "```hemlock\n// BAD: File may not be closed on error\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // May throw\n    file.close();  // Never reached if error\n}\n\n// GOOD: Use finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Write Hemlock code that test WebSocket module basics (no network required) Tests module loading, constants, utility functions Run with: ./hemlock tests/stdlib_websocket/test_websocket_basic.hml.", "output": "```hemlock\n// Test WebSocket module basics (no network required)\n// Tests module loading, constants, utility functions\n// Run with: ./hemlock tests/stdlib_websocket/test_websocket_basic.hml\n\nprint(\"Testing @stdlib/websocket basic functionality...\");\nprint(\"\");\n\n// Import module at the top\nimport { is_secure_url, parse_ws_url } from \"@stdlib/websocket\";\n\nlet tests_passed = 0;\nlet tests_failed = 0;\n\n// Test 1: Module import\nprint(\"Test 1: Module import\");\ntry {\n    assert(is_secure_url != null, \"is_secure_url should be defined\");\n    assert(parse_ws_url != null, \"parse_ws_url should be defined\");\n    print(\"‚úì Module loaded successfully\");\n    tests_passed = tests_passed + 1;\n} catch (e) {\n    print(\"‚úó Failed to load module: \" + e);\n    tests_failed = tests_failed + 1;\n}\n\nprint(\"\");\n\n// Test 2: is_secure_url() function\nprint(\"Test 2: is_secure_url() function\");\ntry {\n    assert(is_secure_url(\"wss://example.com\") == true, \"wss:// should be secure\");\n    assert(is_secure_url(\"ws://example.com\") == false, \"ws:// should not be secure\");\n    assert(is_secure_url(\"http://example.com\") == false, \"http:// should not be secure\");\n    print(\"‚úì is_secure_url() works correctly\");\n    tests_passed = tests_passed + 1;\n} catch (e) {\n    print(\"‚úó is_secure_url() failed: \" + e);\n    tests_failed = tests_failed + 1;\n}\n\nprint(\"\");\n\n// Test 3: parse_ws_url() for ws:// URLs\nprint(\"Test 3: parse_ws_url() for ws:// URLs\");\ntry {\n    let parts1 = parse_ws_url(\"ws://echo.websocket.org/\");\n\n    assert(parts1.secure == false, \"ws:// should not be secure\");\n    assert(parts1.host == \"echo.websocket.org\", \"Host should be extracted\");\n    assert(parts1.port == 80, \"Default port should be 80\");\n    assert(parts1.path == \"/\", \"Path should be extracted\");\n\n    print(\"‚úì parse_ws_url() parses ws:// correctly\");\n    tests_passed = tests_passed + 1;\n} catch (e) {\n    print(\"‚úó parse_ws_url() failed for ws://: \" + e);\n    tests_failed = tests_failed + 1;\n}\n\nprint(\"\");\n\n// Test 4: parse_ws_url() for wss:// URLs\nprint(\"Test 4: parse_ws_url() for wss:// URLs\");\ntry {\n    let parts2 = parse_ws_url(\"wss://secure.example.com/socket\");\n\n    assert(parts2.secure == true, \"wss:// should be secure\");\n    assert(parts2.host == \"secure.example.com\", \"Host should be extracted\");\n    assert(parts2.port == 443, \"Default port should be 443 for wss://\");\n    assert(parts2.path == \"/socket\", \"Path should be extracted\");\n\n    print(\"‚úì parse_ws_url() parses wss:// correctly\");\n    tests_passed = tests_passed + 1;\n} catch (e) {\n    print(\"‚úó parse_ws_url() failed for wss://: \" + e);\n    tests_failed = tests_failed + 1;\n}\n\nprint(\"\");\n\n// Test 5: parse_ws_url() error handling\nprint(\"Test 5: parse_ws_url() error handling\");\ntry {\n    let caught_error = false;\n    try {\n        parse_ws_url(\"http://example.com\");\n    } catch (e) {\n        caught_error = true;\n        assert(e.contains(\"Invalid WebSocket URL\"), \"Should throw invalid URL error\");\n    }\n\n    assert(caught_error == true, \"Should have thrown error for invalid URL\");\n    print(\"‚úì parse_ws_url() validates URL scheme\");\n    tests_passed = tests_passed + 1;\n} catch (e) {\n    print(\"‚úó parse_ws_url() error handling failed: \" + e);\n    tests_failed = tests_failed + 1;\n}\n\nprint(\"\");\nprint(\"========================================\");\nprint(\"WebSocket Basic Tests Summary:\");\nprint(\"  Passed: \" + tests_passed);\nprint(\"  Failed: \" + tests_failed);\nprint(\"========================================\");\n\nif (tests_failed > 0) {\n    print(\"\");\n    print(\"Some tests failed. This usually means:\");\n    print(\"  - lws_wrapper.so not compiled (run: make stdlib)\");\n    print(\"  - libwebsockets not installed\");\n    print(\"  - Module API has changed\");\n}\n\nprint(\"\");\nassert(tests_failed == 0, \"All WebSocket basic tests should pass\");\n```", "category": "tests/stdlib_websocket", "source": "tests/stdlib_websocket/test_websocket_basic.hml"}
{"instruction": "Create a Hemlock program that test environment builtins.", "output": "```hemlock\n// Test environment builtins\n\n// Test get_pid returns positive number\nlet pid = get_pid();\nprint(pid > 0);\n\n// Test getenv returns null for non-existent variable\nlet missing = getenv(\"__TEST_NONEXISTENT_VAR__\");\nprint(missing == null);\n\n// Test setenv and getenv work together\nsetenv(\"__TEST_VAR__\", \"hello\");\nlet val = getenv(\"__TEST_VAR__\");\nprint(val);\n\n// PATH should exist\nlet path = getenv(\"PATH\");\nprint(path != null);\n\nprint(\"done\");\n```", "category": "tests/compiler", "source": "tests/compiler/env_builtins.hml"}
{"instruction": "Write Hemlock code that function with no parameters.", "output": "```hemlock\n// Function with no parameters\nfn getMessage() {\n    return 42;\n}\n\nprint(getMessage());\n```", "category": "tests/functions", "source": "tests/functions/no_params.hml"}
{"instruction": "Show an example of example 4: backup script in Hemlock.", "output": "```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Backing up \" + source + \" to \" + dest);\n\n    // Create backup directory\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Error creating backup directory\");\n        return false;\n    }\n\n    // Create tarball with timestamp\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creating archive: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Error creating backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completed successfully\");\n\n    // Show backup size\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup size: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```", "category": "docs", "source": "docs/advanced/command-execution.md"}
{"instruction": "Show me Hemlock code that test basic enum declaration and usage.", "output": "```hemlock\n// Test basic enum declaration and usage\n\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nprint(Color.RED);\nprint(Color.GREEN);\nprint(Color.BLUE);\n```", "category": "tests/enums", "source": "tests/enums/basic_enum.hml"}
{"instruction": "How do you usage in Hemlock?", "output": "```hemlock\nimport { async_read_file, async_write_file, read_files_parallel } from \"@stdlib/async_fs\";\n```", "category": "docs", "source": "stdlib/docs/async_fs.md"}
{"instruction": "Implement a Hemlock program that test modulo with different integer types.", "output": "```hemlock\n// Test modulo with different integer types\n\n// i8\nlet a: i8 = 10;\nlet b: i8 = 3;\nprint(a % b);  // 1\n\n// i16\nlet c: i16 = 100;\nlet d: i16 = 7;\nprint(c % d);  // 2\n\n// i32\nlet e: i32 = 1000;\nlet f: i32 = 13;\nprint(e % f);  // 12\n\n// i64\nlet g: i64 = 100000;\nlet h: i64 = 7;\nprint(g % h);  // 5\n\n// u8\nlet i: u8 = 255;\nlet j: u8 = 10;\nprint(i % j);  // 5\n\n// u16\nlet k: u16 = 1000;\nlet l: u16 = 17;\nprint(k % l);  // 13\n\n// u32\nlet m: u32 = 50000;\nlet n: u32 = 19;\nprint(m % n);  // 10\n\n// u64\nlet o: u64 = 100000;\nlet p: u64 = 11;\nprint(o % p);  // 10\n```", "category": "tests/arithmetic", "source": "tests/arithmetic/modulo_types.hml"}
{"instruction": "Write a Hemlock program that test for-in loop - array iteration.", "output": "```hemlock\n// Test for-in loop - array iteration\n\n// Test 1: Simple value iteration\nlet arr = [10, 20, 30];\nfor (let val in arr) {\n    print(val);\n}\n\n// Test 2: Index and value iteration\nprint(\"---\");\nlet names = [\"Alice\", \"Bob\", \"Charlie\"];\nfor (let i, name in names) {\n    print(i);\n    print(name);\n}\n\n// Test 3: Empty array\nprint(\"---\");\nlet empty = [];\nfor (let x in empty) {\n    print(\"should not print\");\n}\nprint(\"done\");\n\n// Test 4: Nested loops\nprint(\"---\");\nlet matrix = [[1, 2], [3, 4]];\nfor (let row in matrix) {\n    for (let val in row) {\n        print(val);\n    }\n}\n```", "category": "tests/compiler", "source": "tests/compiler/for_in.hml"}
{"instruction": "Create a Hemlock program that tests else if no final else.", "output": "```hemlock\nlet x = 3;\nif (x > 10) {\n    print(1);\n} else if (x > 5) {\n    print(2);\n}\nprint(99);\n```", "category": "tests/control", "source": "tests/control/else_if_no_final_else.hml"}
{"instruction": "How does progressbar.increment() work in Hemlock?", "output": "Increment progress by one step.\n\n```hemlock\nimport { ProgressBar } from \"@stdlib/terminal\";\n\nlet bar = ProgressBar(10);\nlet i = 0;\nwhile (i < 10) {\n    // ... process item ...\n    bar.increment();\n    i = i + 1;\n}\nbar.finish();\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Create a Hemlock program that test terminal cursor control.", "output": "```hemlock\n// Test terminal cursor control\nimport {\n    move_to, move_up, move_down, move_left, move_right,\n    SAVE_CURSOR, RESTORE_CURSOR, HIDE_CURSOR, SHOW_CURSOR,\n    print_at, clear\n} from \"@stdlib/terminal\";\n\n// ESC character for testing\nlet ESC: rune = 27;\nlet ESC_STR: string = ESC;\n\nprint(\"=== Terminal Cursor Tests ===\");\nprint(\"\");\n\n// Test move_to function\nprint(\"Testing move_to():\");\nlet code = move_to(5, 10);\nprint(\"move_to(5, 10) returns escape code\");\nif (code.contains(ESC_STR + \"[\")) {\n    print(\"‚úì Contains ANSI escape sequence\");\n}\n\n// Test relative movements\nprint(\"\");\nprint(\"Testing relative movements:\");\nlet up = move_up(3);\nlet down = move_down(2);\nlet left = move_left(5);\nlet right = move_right(4);\n\nif (up.contains(ESC_STR + \"[3A\")) {\n    print(\"‚úì move_up(3) correct\");\n}\nif (down.contains(ESC_STR + \"[2B\")) {\n    print(\"‚úì move_down(2) correct\");\n}\nif (left.contains(ESC_STR + \"[5D\")) {\n    print(\"‚úì move_left(5) correct\");\n}\nif (right.contains(ESC_STR + \"[4C\")) {\n    print(\"‚úì move_right(4) correct\");\n}\n\n// Test cursor save/restore\nprint(\"\");\nprint(\"Testing save/restore:\");\nif (SAVE_CURSOR.contains(ESC_STR + \"[s\")) {\n    print(\"‚úì SAVE_CURSOR correct\");\n}\nif (RESTORE_CURSOR.contains(ESC_STR + \"[u\")) {\n    print(\"‚úì RESTORE_CURSOR correct\");\n}\n\n// Test cursor visibility\nprint(\"\");\nprint(\"Testing cursor visibility:\");\nif (HIDE_CURSOR.contains(ESC_STR + \"[?25l\")) {\n    print(\"‚úì HIDE_CURSOR correct\");\n}\nif (SHOW_CURSOR.contains(ESC_STR + \"[?25h\")) {\n    print(\"‚úì SHOW_CURSOR correct\");\n}\n\nprint(\"\");\nprint(\"‚úì All cursor tests completed\");\n```", "category": "tests/stdlib_terminal", "source": "tests/stdlib_terminal/test_cursor.hml"}
{"instruction": "How does debug mode toggle work in Hemlock?", "output": "```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug mode: ON\");\n    } else {\n        print(\"Debug mode: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// From shell: kill -USR2 <pid> to toggle\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "How does clock() work in Hemlock?", "output": "Distinguishing CPU time from wall-clock time\n\n```hemlock\nimport { clock } from \"@stdlib/time\";\n\nlet cpu_start = clock();\n// ... CPU-intensive work ...\nlet cpu_end = clock();\nlet cpu_time = cpu_end - cpu_start;\nprint(\"CPU time: \" + typeof(cpu_time) + \" seconds\");\n```", "category": "docs", "source": "stdlib/docs/time.md"}
{"instruction": "Show me Hemlock code that tests define duck typing wrong type error.", "output": "```hemlock\n// Test: Duck typing fails when field has wrong type\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p = { name: \"Alice\", age: \"thirty\" };\nlet typed_p: Person = p;  // Should error: age is string not i32\n```", "category": "tests/objects", "source": "tests/objects/define_duck_typing_wrong_type_error.hml"}
{"instruction": "How does configuration reload (without restart) work in Hemlock?", "output": "```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Reloading configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // Use config...\n}\n```", "category": "docs", "source": "docs/advanced/signals.md"}
{"instruction": "Show me Hemlock code that expect: 7 Expect: 15 Expect: 8 Expect: 60 Expect: 3 Expect: 240.", "output": "```hemlock\n// Test: Bitwise operations with unsigned types\n// Expect: 7\n// Expect: 15\n// Expect: 8\n// Expect: 60\n// Expect: 3\n// Expect: 240\n\nlet c: u8 = 15;\nlet d: u8 = 7;\n\n// AND\nprint(c & d);   // 15 & 7 = 7\n\n// OR\nprint(c | d);   // 15 | 7 = 15\n\n// XOR\nprint(c ^ d);   // 15 ^ 7 = 8\n\n// Left shift\nprint(c << 2);  // 15 << 2 = 60\n\n// Right shift\nprint(c >> 2);  // 15 >> 2 = 3\n\n// Bitwise NOT\nprint(~c);      // ~15 = 240 (in u8)\n```", "category": "tests/bitwise", "source": "tests/bitwise/unsigned.hml"}
{"instruction": "How does pitfall: reference equality work in Hemlock?", "output": "```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// Same reference: true\narr.contains(obj);  // true\n\n// Different reference: false\narr.contains({ x: 10 });  // false (different object)\n```", "category": "docs", "source": "docs/language-guide/arrays.md"}
{"instruction": "How do you define an enum in Hemlock?", "output": "Enums define named constants:\n\n```hemlock\n// Auto-numbered (0, 1, 2...)\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\n// Custom values\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 100\n}\n\n// Usage\nlet c = Color.RED;    // 0\nlet s = Status.ERROR; // 1\nprint(c);  // 0\n```", "category": "concepts/enums", "source": "CLAUDE.md"}
{"instruction": "Show me Hemlock code that test switch with string values.", "output": "```hemlock\n// Test switch with string values\n\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"blue\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown\");\n        break;\n}\n\n// Expected: go\n```", "category": "tests/switch", "source": "tests/switch/strings.hml"}
{"instruction": "How does anonymous functions work in Hemlock?", "output": "```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```", "category": "docs", "source": "docs/getting-started/tutorial.md"}
{"instruction": "How does move_to(row, col) work in Hemlock?", "output": "Returns:* string - ANSI escape sequence\n\n```hemlock\nimport { move_to } from \"@stdlib/terminal\";\n\nexec(\"printf '\" + move_to(10, 20) + \"Hello'\");  // Print at row 10, col 20\n```", "category": "docs", "source": "stdlib/docs/terminal.md"}
{"instruction": "Create a Hemlock program that test enum with switch statement.", "output": "```hemlock\n// Test enum with switch statement\n\nenum Color {\n    RED = 1,\n    GREEN = 2,\n    BLUE = 3\n}\n\nlet color = Color.GREEN;\n\nswitch (color) {\n    case Color.RED:\n        print(\"Red\");\n        break;\n    case Color.GREEN:\n        print(\"Green\");\n        break;\n    case Color.BLUE:\n        print(\"Blue\");\n        break;\n    default:\n        print(\"Unknown\");\n        break;\n}\n```", "category": "tests/enums", "source": "tests/enums/switch_statement.hml"}
{"instruction": "How does pattern: error wrapping work in Hemlock?", "output": "Wrap lower-level errors with context:\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Failed to load config from \" + path + \": \" + e;\n    }\n}\n```", "category": "docs", "source": "docs/language-guide/error-handling.md"}
{"instruction": "Implement a Hemlock program that returning objects from functions.", "output": "```hemlock\n// Returning objects from functions\nfn makePoint(x, y) {\n    return { x: x, y: y };\n}\n\nlet p = makePoint(10, 20);\nprint(p.x);\nprint(p.y);\n```", "category": "tests/objects", "source": "tests/objects/object_return.hml"}
{"instruction": "How does accepting connections work in Hemlock?", "output": "Accept with timeout:*\n\n```hemlock\nlet conn = server.accept(10000);  // 10 second timeout\nif (conn == null) {\n    print(\"No client connected\");\n}\n```", "category": "docs", "source": "stdlib/docs/websocket.md"}
